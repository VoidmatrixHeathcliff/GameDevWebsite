{"posts":[{"title":"欢迎来到 VoidGameSpace","text":"VoidGameSpace 游戏开发社区博客","link":"/about/"},{"title":"测试测试测试测试测试测试测试测试测试测试","text":"测试测试测试测试测试title: testdate: 2024-05-28updated: 2024-05-28permalink: articles/Flaaax/test/categories: Flaaaxtags: [test]测试测试测试测试测试 测试，测试，测试，测试, 测试，测试，测试，测试，测试 测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试锟斤拷锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟锟","link":"/articles/Flaaax/test/"},{"title":"你好，世界","text":"群友的一小步，游戏行业的一大步","link":"/articles/Demo/HelloWorld/"},{"title":"游戏设计知识分享笔记-依赖性","text":"飞鱼丸的个人博客建成啦，欢迎大家参观！点击传送原文 前言在构思一个新游戏时常常会有许多想法，诸如不同的挑战、系统以及界面，完整的游戏常常会包含上百种机制及子系统，在已经构思好许多子系统后，紧接着我们要开始游戏的开发，现在我们有以下的选择 最简单的模块 最擅长的模块 最具特色的模块 常常能听到的核心玩法 绝大多数游戏开发者都会建议从核心玩法开始开发，但是为什么要这样做呢？ 游戏开发顺序的影响当我们为某个已经完成的游戏制作几个额外关卡时，开发的顺序无关紧要，关卡之间并不会相互影响，但制作游戏并不一样，不同设计之间常常相互依赖 当我们修改某一个模块时，依赖于该模块的部分必然也会发生变化，例如，假设最初开发时先完成了场景布局，设计了一条玩家无法跳过只能从桥梁通过的河流，完成场景布局后，为了优秀的视觉表现，把桥梁设计的十分精美，河流周围的景色也十分美丽，但是在随后的开发中发现玩家的跳跃能力不够灵活，需要增强玩家跳跃能力，导致了原本设计无法跳过去的河流可以跳过去了，就得再修改场景布局，同时依赖于场景布局的视觉表现也需要再重新制作，若能够再开发前对不同模块的依赖性有更深刻的理解，我们也许会先确立移动体系，随后再去进行场景布局和视觉表现。 如何确定游戏开发顺序我们可以通过画依赖关系图，来分析识别设计中关键的依赖性，从而确定开发顺序 将游戏分解成许多独立的因素，包含机制，操作，界面，子系统等等，每个因素应包含一份详细的设计方案。 识别出各个因素之间关键的依赖，并通过树状图的结构将所有的因素囊括进来，通过连线来描述依赖关系。 TIPS:对A模块进行修改时会影响B模块时，便可称B依赖A，在设计中常常会出现A与B之间互相依赖的情况，事实上任何设计之间都会存在一定的依赖关系，在依赖关系图中会有意忽略依赖性较弱的部分，以便开发时能够更加专注于最重要的元素，时刻记得依赖关系图只是帮助开发进行决策的工具，无止境的拘泥于过于细致的分析只会导致项目难以推动。 额外需要注意的地方原创的不确定性原创度较高的游戏常会出现不按照设计方案来实现，这种不确定性使得依赖性变得非常重要，某个设计中出现的不确定不足以说明问题，然后由于依赖性的存在，不确定性会因为多层依赖的存在逐步积累，因此位于依赖关系图顶层的内容常常重新设计，甚至直接被删除。 应对措施重新梳理最初的依赖关系图，将短期内不会实现的内容以及相互独立的设计灵感放置于设计库中，将底层的内容实现并测试再进行迭代，此时并没有依赖关系的存在，因此并不会产生巨大的不确定性积累，等到底层系统确定性足够高后再将设计库某一内容添加进来。 TIPS：可以将最初版所有内容包含进来的依赖关系图中拿走但不会使游戏毫无意义的内容全部拿走，剩下的就是核心玩法，核心玩法常常可以用于定义某一游戏的类型，尽早完成核心玩法的开发，可以让项目尽快开始进行测试及迭代。","link":"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/"},{"title":"Git使用方法学习","text":"这篇文章既是记录Git的学习过程，同时也是markdown的练习，操作系统为Win11，文章末尾有自我介绍。 Git的安装和初始化配置 安装Git，Git下载连接,根据自己的操作系统进行选择，下载后运行exe文件，我下载选项暂时全部都选择默认 检查是否成功安装Git，下载完成后，打开控制面板（win+R 输入cmd），查看Git版本信息 12// 输入此命令进行查看git --version 配置Git，配置用户名和邮箱，在命令行中输入以下指令 123git config --global user.name &lt;此处替换为你的用户名&gt;git config --global user.email &lt;此处替换成你的邮箱&gt; 检测是否配置成功，在命令行中输入以下指令 12git config user.namegit config user.email Git基础使用中文官方文档链接 获取Git仓库 在已存在目录中初始化仓库 首先，新建一个文件夹，例如testGit，记录该文件夹的路径例如:”D:\\testGit”，接下来点击鼠标右键，选择Git Bash，输入指令 1$ cd D:\\testGit //输入你自己文件夹的路径，该步骤是转到此文件夹下 再输入 1$ git init //该步骤将当前文件夹转化为一个Git仓库 若显示 1Initialized empty Git repository in D:/testGit/.git/ 即为操作成功 接下来可以在文件夹中创建两个文本文档，命名为test1和test2. 通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： $ git add *.txt $ git commit -m 'initial project version' 克隆现有的仓库 使用命令 1git clone &lt;url&gt; 详情参考中文官方文档 记录每次更新到仓库工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 现在开始检查Git仓库的状态 在Git Bash中输入以下指令，便可查看仓库当前状态 1$ git status 若看到以下输出 12On branch masternothing to commit, working tree clean 说明你现在的工作目录相当干净。所有已跟踪文件在上次提交后都未被更改过且当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 然后在testGit中新建一个名为README的文本文档，再次输入$ git status 可以看到以下输出 12345On branch masterUntracked files:(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) README.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 可以看到新建的 README 文件出现在 Untracked files 下面。除非明确表示要跟踪某文件，否则Git不会自动纳入跟踪范围，这样做生成的二进制文件或其它不想被跟踪的文件包含进来。 现在让我们跟踪README文件 使用命令 git add 开始跟踪一个文件 1$ git add README.txt 输入$ git status，会看到 README 文件已被跟踪，并处于暂存状态 12345$ git statusOn branch masterChanges to be committed:(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: README.txt 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 接着，尝试暂存已修改的文件 打开test1，在其中随意写一些文字，例如”Hello World!”并保存修改，输入$ git status，可以看到 123456........ Changes not staged for commit:(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test1.txt test1.txt出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区. 要暂存这次更新，需要运行 git add test1.txt 命令, 接着再运行git status命令 可以看到以下输出 123456$ git statusOn branch masterChanges to be committed:(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: README.txt modified: test1.txt 可以看到现在两个文件都已暂存，下次提交时就会一并记录到仓库。 提交更新，输入 1$ git commit 屏幕显示 1234567891011121314151617181920212223# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## On branch master# Changes to be committed:# new file: README.txt# modified: test1.txt#~~~~~~~~~~~~~.git/COMMIT_EDITMSG [unix] (20:11 29/05/2024) 1,0-1 All&quot;/d/testGit/.git/COMMIT_EDITMSG&quot; [unix] 9L, 235B 按“i”键，插入git commit，再按“esc”键，输入wq,再按回车键，便可以成功提交。 查看提交历史输入git log即可查看该仓库提交历史。详情指令集可查看官方文档。 最后写一丢丢随笔：我是一个普通的大学生，从小就喜欢玩电子游戏，从4399到Steam，玩了许多电子游戏，不过那时也就仅限于玩一下而已，对于怎么制作电子游戏说不上感兴趣，让我想要学习制作电子游戏的契机说起来还挺难过的，或许是长大了，又或许是因为生活中的一些不快，我慢慢的不能像儿时那样，一整天坐在电脑桌前，全身心的投入到游戏缤纷的世界里，但是我仍然热爱电子游戏，我喜欢这些用代码和美术构成的虚拟而又缤纷的世界，所以我决定把自己对游戏的热爱从玩电子游戏到制作电子游戏。 但是万事开头难，回忆自己在大学中一年多的学习，都是像数据结构，软件工程概论这样的理论上的学习，理论学习和技术学习有着巨大的鸿沟，我根本无法从命令行开始去想象如何制作一个游戏，在我为此绞尽脑汁时，意外的在EasyX的社区中看到了大V老师的视频，这才真正开启了我学习技术的道路。 跟着大V老师学习差不多快两个月了，从刚开始跟着敲井字棋，到现在见证了社区的建立，大V老师质量优秀的视频和建立的学习交流群，提供给我游戏制作技术入门的途径，对大V老师的感谢难以言表，祝大V老师的教程越来越好，吸引更多对游戏制作感兴趣的人来观看，也祝社区越办越好，成为中国游戏制作的绿洲，滋养中国游戏界。","link":"/articles/FlyingfishFantasticfan/Git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"保姆级！使用网页版在VoidGameSpace中发表文章与图文。Ciallo​～","text":"保姆级！保姆级！保姆级！Ciallo​～！每一步都有图文混合讲解！ 琪诺兔 关注我的哔哩哔哩走进我的生活 &nbsp;|&nbsp; 关注我的GitHub获得我的代码 第一步，先分叉一个VoidGameSpace的原始库 1: 点击蓝字进入VoidGameSpace。进入后，会看到这样的页面。 2: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。 3: 此刻你的库中就有了一份分叉文件，第一步完成。 第二步，来到自己的库中，并进入GameDevWebsite项目。 1: 点击左上角的，点点点，标志。选择，自己名字加上斜杠的/GameDevWebsite项目，非常重要！ 2: 这样就进入了自己库中的GameDevWebsite克隆项目。这里的头像变成自己的，就正确了。 第三步，来到，_posts，文件夹。点击项目中的，source，文件夹。在点击，_posts，文件夹这里会有一大堆别人的文件夹，不需要管理。 第四步，准备文章！此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。 自己的名字！，不要抄我的名字！进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。编写参阅，VoidGameSpace。下方的说明。 1: 跳过上面的说明我们创建一个。 2: 打开，在头部添加以下内容。permalink: 不太好理解，不用担心，请往下看，它是这样的结构，permalink: articles/QiNuoTu/Demo/ articles: 可以理解为根目录，必须加上。 QiNuoTu: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。 Demo: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，/，斜杠在尾部。这样一来，文章头就准备完毕了。 第五步，编写文章！ 1: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，&lt;!-- More --&gt; 标记下书写 2: 如何添加图片，在文章旁边使用同名创建一个文件夹。 3: 将图片丢进文件夹中，就可以使用，![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)表达式引用图片了。 4: 网页链接同理，[名称](链接)，表达式，即可。 5: 置入代码，只需要使用，```cpp 代码 ```将代码包裹其中即可。 第六步，发表文章。 1: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。 2: 把文件夹拖住丢上去。 3: 点击绿色按钮。 4: 之后就可以看到自己的文件夹了。 5: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。 第七步，提交！ 1: 点击右上角的GameDevWebsite。 2: 找到，Contribote，点击绿色按钮！ 2: 填写标题，点击绿色按钮！ 等待审核即可！ 这是什么？","link":"/articles/QiNuoTu/CorrectlyReleased/"},{"title":"自己设计一个游戏通用的2D摄像机累。Camera2D","text":"在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。 琪诺兔 关注我的哔哩哔哩走进我的生活 &nbsp;|&nbsp; 关注我的GitHub获得我的代码 一个合格的摄像机应该具有以下功能。本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。 视口控制：设置视口大小适应不同的分辨率和屏幕尺寸。123456void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) { ViewportWidth = Viewport_Width; ViewportHeight = Viewport_Height; ViewportCenterX = ViewportWidth * 0.5f; ViewportCenterY = ViewportHeight * 0.5f;} 焦点跟随：视点跟随焦点移动。12345678void SetTarget(float targetX, float targetY) { TargetX = targetX; TargetY = targetY;} void SmoothMoveToPosition(float smoothing = 0.5f) { CameraFocusX += (targetX - CameraFocusX) * smoothing; CameraFocusY += (targetY - CameraFocusY) * smoothing;} 坐标转换：屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。123456789void ScreenToWorld(float screenX, float screenY, float&amp; worldX, float&amp; worldY) const { worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom; worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;}void WorldToScreen(float worldX, float worldY, float&amp; screenX, float&amp; screenY) const { screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom; screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;} 缩放功能：适应不同的游戏场景和提供不同的视觉体验。123456float GetScale() const { return Zoom; }void SetScale(float zoom = 1){ Zoom = zoom;} 边界限制：设置移动边界，防止摄像机移动到游戏世界之外。12345678910111213141516171819202122232425262728293031void SetWorldSize(float Width, float Height) { WorldBoundaryLeft = -Width * 0.5f; WorldBoundaryTop = -Height * 0.5f; WorldBoundaryRight = Width * 0.5f; WorldBoundaryBottom = Height * 0.5f;}bool SetWorldBoundaries(float left, float top, float right, float bottom) { if (left &lt; right &amp;&amp; top &lt; bottom) { WorldBoundaryLeft = left; WorldBoundaryTop = top; WorldBoundaryRight = right; WorldBoundaryBottom = bottom; return true; } return false;}void ViewportCheckBoundaries() { float scaledOffsetX = ViewportCenterX / Zoom; float scaledOffsetY = ViewportCenterY / Zoom; CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX)); CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY)); if (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) { CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f; } if (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) { CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f; }} 平滑过渡：避免视角突变给玩家带来不适。12345678void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) { CameraFocusX += (targetX - CameraFocusX) * smoothing; CameraFocusY += (targetY - CameraFocusY) * smoothing;}void Scale(float zoom = 1){ Zoom += zoom;} 抖动效果：模拟冲击爆炸等效果来增强游戏的氛围和反馈。123456789101112131415void Shake(float intensityX = 5.5f, float intensityY = 5.5f) { std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX); std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY); CameraFocusX += disX(gen); CameraFocusY += disY(gen);}void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) { std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX); std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY); std::uniform_real_distribution&lt;float&gt; angle(-360.0f, 360.0f); float radian = angle(gen) / 360 * m_PI * 2; CameraFocusX += disX(gen) * std::cos(radian); CameraFocusY += disY(gen) * std::sin(radian);} 此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142class Camera2D {public: Camera2D(float Viewport_Width, float Viewport_Height, float World_Width, float World_Height, float FocusX = 0, float FocusY = 0) : ViewportCenterX(Viewport_Width * 0.5f), ViewportCenterY(Viewport_Height * 0.5f), ViewportWidth(Viewport_Width), ViewportHeight(Viewport_Height), WorldBoundaryLeft(-World_Width * 0.5), WorldBoundaryTop(-World_Height * 0.5), WorldBoundaryRight(World_Width * 0.5), WorldBoundaryBottom(World_Height * 0.5), TargetX(0), TargetY(0), CameraFocusX(FocusX), CameraFocusY(FocusY), Zoom(1){} ~Camera2D() = default; void ScreenToWorld(float screenX, float screenY, float&amp; worldX, float&amp; worldY) const { worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom; worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom; } void WorldToScreen(float worldX, float worldY, float&amp; screenX, float&amp; screenY) const { screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom; screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom; } float GetScale() const { return Zoom; } void SetScale(float zoom = 1) { Zoom = zoom; } void Scale(float zoom = 1) { Zoom += zoom; } void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) { CameraFocusX += (targetX - CameraFocusX) * smoothing; CameraFocusY += (targetY - CameraFocusY) * smoothing; } void SetTarget(float targetX, float targetY) { TargetX = targetX; TargetY = targetY; } void SmoothMoveToTarget(float smoothing = 0.5f) { CameraFocusX += (TargetX - CameraFocusX) * smoothing; CameraFocusY += (TargetY - CameraFocusY) * smoothing; } void Shake(float intensityX = 5.5f, float intensityY = 5.5f) { std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX); std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY); CameraFocusX += disX(gen); CameraFocusY += disY(gen); } void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) { std::uniform_real_distribution&lt;float&gt; disX(-intensityX, intensityX); std::uniform_real_distribution&lt;float&gt; disY(-intensityY, intensityY); std::uniform_real_distribution&lt;float&gt; angle(-360.0f, 360.0f); float radian = angle(gen) / 360 * 3.1415926535 * 2; CameraFocusX += disX(gen) * std::cos(radian); CameraFocusY += disY(gen) * std::sin(radian); } void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) { ViewportWidth = Viewport_Width; ViewportHeight = Viewport_Height; ViewportCenterX = ViewportWidth * 0.5f; ViewportCenterY = ViewportHeight * 0.5f; } void SetFocus(float FocusX, float FocusY) { CameraFocusX = FocusX; CameraFocusY = FocusY; } void Move(float deltaX, float deltaY) { CameraFocusX += deltaX; CameraFocusY += deltaY; } float GetFocusX() const { return CameraFocusX; } float GetFocusY() const { return CameraFocusY; } void SetWorldSize(float Width, float Height) { WorldBoundaryLeft = -Width * 0.5f; WorldBoundaryTop = -Height * 0.5f; WorldBoundaryRight = Width * 0.5f; WorldBoundaryBottom = Height * 0.5f; } bool SetWorldBoundaries(float left, float top, float right, float bottom) { if (left &lt; right &amp;&amp; top &lt; bottom) { WorldBoundaryLeft = left; WorldBoundaryTop = top; WorldBoundaryRight = right; WorldBoundaryBottom = bottom; return true; } return false; } void ViewportCheckBoundaries() { float scaledOffsetX = ViewportCenterX / Zoom; float scaledOffsetY = ViewportCenterY / Zoom; CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX)); CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY)); if (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) { CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f; } if (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) { CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f; } } void GetFocusRect(float&amp; left, float&amp; top, float&amp; right, float&amp; bottom) { left = CameraFocusX - ViewportCenterX; top = CameraFocusY - ViewportCenterY; right = CameraFocusX + ViewportCenterX; bottom = CameraFocusY + ViewportCenterY; }private: std::random_device rd; std::mt19937 gen(rd()); float TargetX, TargetY; float CameraFocusX, CameraFocusY; float ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight; float Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;}; 这是什么?","link":"/articles/QiNuoTu/Camera2D/"},{"title":"是琪诺兔啦！(●&#39;◡&#39;●)！","text":"琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o/ 琪诺兔 关注我的哔哩哔哩走进我的生活 &nbsp;|&nbsp; 关注我的GitHub获得我的代码 #这是什么？","link":"/articles/QiNuoTu/Iamme/"},{"title":"一些开箱即用碰撞检测！AABB","text":"听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！ 琪诺兔 关注我的哔哩哔哩走进我的生活 &nbsp;|&nbsp; 关注我的GitHub获得我的代码 在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 定义一个结构体，表示二维空间中的点struct Point_F { double x; // 点的x坐标 double y; // 点的y坐标};// 定义一个结构体，表示矩形区域struct RECT { double left; // 矩形左边缘的x坐标 double top; // 矩形上边缘的y坐标 double right; // 矩形右边缘的x坐标 double bottom; // 矩形下边缘的y坐标};// 判断点是否在矩形区域内bool AABBPointInside(const Point_F&amp; V, const RECT&amp; RECT) { return (V.x &gt; RECT.left &amp;&amp; V.x &lt; RECT.right &amp;&amp; V.y &gt; RECT.top &amp;&amp; V.y &lt; RECT.bottom);}// 判断一个矩形是否完全在另一个矩形内部bool AABBRectInside(const RECT&amp; rect1, const RECT&amp; rect2) { return (rect2.left &gt;= rect1.left &amp;&amp; rect2.right &lt;= rect1.right &amp;&amp; rect2.top &gt;= rect1.top &amp;&amp; rect2.bottom &lt;= rect1.bottom);}// 判断两个矩形是否重叠bool AABBRectOverlap(const RECT&amp; rect1, const RECT&amp; rect2) { return (rect1.right &lt; rect2.left || rect1.left &gt; rect2.right || rect1.bottom &lt; rect2.top || rect1.top &gt; rect2.bottom) ? false : true;}// 判断矩形与圆形是否重叠，考虑矩形旋转的情况bool AABBRectCircleOverlap(double rectCenterX, double rectCenterY, double rectWidth, double rectHeight, double angle, double circleX, double circleY, double circleRadius) { // 计算旋转后的向量坐标 double vectorX = circleX - rectCenterX; double vectorY = circleY - rectCenterY; double radians = angle * M_PI / 180.0; double x = vectorX * cos(radians) + vectorY * sin(radians); double y = vectorY * cos(radians) - vectorX * sin(radians); // 计算矩形的半宽和半高 double halfWidth = rectWidth * 0.5; double halfHeight = rectHeight * 0.5; if (x - circleRadius &lt; halfWidth &amp;&amp; x + circleRadius &gt; -halfWidth) { if (y - circleRadius &lt; halfHeight &amp;&amp; y + circleRadius &gt; -halfHeight) { if (x &lt; -halfWidth &amp;&amp; y &lt; -halfHeight){ if (distance(x, y, -halfWidth, -halfHeight) &gt;= circleRadius) { return true; } } else if (x &lt; halfWidth &amp;&amp; y &lt; -halfHeight){ if (distance(x, y, halfWidth, -halfHeight) &gt;= circleRadius) { return true; } } else if (x &gt; halfWidth &amp;&amp; y &gt; halfHeight){ if (distance(x, y, halfWidth, halfHeight) &gt;= circleRadius) { return true; } } else if (x &lt; -halfWidth &amp;&amp; y &gt; halfHeight) { if (distance(x, y, -halfWidth, halfHeight) &gt;= circleRadius) { return true; } } } return true; } return false;}// 判断点是否在圆内bool AABBPointInCircle(double pointX, double pointY, double circleCenterX, double circleCenterY, double circleRadius) { // 计算点到圆心的距离，判断是否小于等于半径 double dx = pointX - circleCenterX; double dy = pointY - circleCenterY; return sqrt(dx * dx + dy * dy) &lt;= circleRadius;}// 判断两个圆是否相交bool AABBCirclesIntersect(double circleCenterX1, double circleCenterY1, double circleRadius1, double circleCenterX2, double circleCenterY2, double circleRadius2) { // 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和 double dx = circleCenterX1 - circleCenterX2; double dy = circleCenterY1 - circleCenterY2; return sqrt(dx * dx + dy * dy) &lt;= circleRadius1 + circleRadius2;}// 判断点是否在圆环内bool AABBPointInAnnulus(double x, double y, double circleCenterX, double circleCenterY, double circleRadius, double innerThickness, double outerThickness) { // 计算点到圆心的距离 double dx = x - circleCenterX; double dy = y - circleCenterY; double dist = sqrt(dx * dx + dy * dy); // 判断距离是否在内圆半径和外圆半径之间 return (dist &lt;= circleRadius + outerThickness &amp;&amp; dist &gt;= circleRadius - innerThickness);}// 判断点是否在椭圆内bool AABBPointInEllipse(double centerX, double centerY, double radiusA, double radiusB, double x, double y) { // 计算点到椭圆中心的距离，并与椭圆的参数化方程比较 double dx = centerX - x; double dy = centerY - y; return (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) &lt;= 1;}","link":"/articles/QiNuoTu/%E4%B8%80%E4%BA%9B%E5%8C%85%E5%9B%B4%E7%9B%92%E7%B1%BB%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"},{"title":"mytest","text":"这一次一定要可以，啊！！！","link":"/articles/Demo/Touyouta/"},{"title":"开箱即用平滑插值大合集！OpenEasing！","text":"在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。Easing，网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++. 琪诺兔 关注我的哔哩哔哩走进我的生活 &nbsp;|&nbsp; 关注我的GitHub获得我的代码 比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。 begin_: 当前时间&amp;当前是第几段&amp;当前位置，无需担心会被自动计算为比例。 start: 开始值&amp;开始时间&amp;开始位置，等。 end: 结束值&amp;结束时间&amp;结束位置，等。 percent_: 将开始与结束之间分为多少段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306int main() { // 示例 double progress = 0.5; // 进度 double startValue = 0; // 开始数值 double endValue = 100; // 结束数值 double segments = 10; // 分段数 double result = Easing(progress, startValue, endValue, segments); std::cout &lt;&lt; &quot;Easing price: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;}RGBA ColorDifference(const RGBA&amp; start, const RGBA&amp; end, double t) { return RGBA(start.R + (end.R - start.R) * t, start.G + (end.G - start.G) * t, start.B + (end.B - start.B) * t, start.A + (end.A - start.A) * t);}double _getOutBounce(double begin_,double end_,double percent_){ double _st = end_ - begin_; double _ed = percent_; if (_st &lt; 1 ÷ 2.75) return _ed * 7.5625 * _st * _st + begin_; else if (_st &lt; 2 ÷ 2.75) {_st = _st - 1.5 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.75) + begin_;} else if (_st &lt; 2.5 ÷ 2.75) {_st = _st - 2.25 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.9375) + begin_;} _st = _st - 2.625 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.984375) + begin_;}double _getInBounce(double begin_,double end_,double percent_){ double _ed = end_ - begin_; return _ed - _getOutBounce (0, _ed, 1 - percent_) + begin_;}double Linear(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return ((_End - _Start) * percents_ * percents_ + _Start);}double OutQuad(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return -(_End - _Start) * percents_ * (percents_ - 2) + _Start;}double InOutQuad(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ts = percents_ * 2; if (_ts &lt; 1) return (_End - _Start) ÷ 2 * _ts * _ts + _Start; return -(_End - _Start) ÷ 2 * (_ts * (_ts - 2) - 1) + _Start;}double InCubic(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return (_End - _Start) * percents_ * percents_ * percents_ + _Start;}double OutCubic(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ - 1; return (_End - _Start) * (_st * _st * _st + 1) + _Start;}double InOutCubic(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ - 1; double _ed1 = _End - _Start; if(_st &lt; 1)return _ed1 ÷ 2 * _st * _st * _st + _Start; _st = _st - 2; return _ed1 ÷ 2 * (_st * _st * _st + 2) + _Start;}double InQuart(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;}double OutQuart(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ - 1; return -(_End - _Start) * (_st * _st * _st * _st - 1) + _Start;}double InOutQuart(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ * 2; double _ed1 = _End - _Start; if (_st &lt; 1) return _ed1 ÷ 2 * _st * _st * _st * _st + _Start; _st = _st - 2; return -_ed1 ÷ 2 * (_st * _st * _st * _st - 2) + _Start;}double InQuint(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;}double OutQuint(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ - 1; double _ed1 = _End - _Start; return _ed1 * (_st * _st * _st * _st * _st + 1) + _Start;}double InOutQuint(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ * 2; double _ed1 = _End - _Start; if (_st &lt; 1) return _ed1 ÷ 2 * _st * _st * _st * _st * _st + _Start; _st = _st - 2; return _ed1 ÷ 2 * (_st * _st * _st * _st * _st + 2) + _Start;}double InSine(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed1 = _End - _Start; return -_ed1 * cos (percents_ ÷ 1 * M_PI ÷ 2) + _ed1 + _Start;} double OutSine(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed1 = _End - _Start; return _ed1 * sin (percents_ ÷ 1 * M_PI ÷ 2) + _Start;}double InOutSine(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed1 = _End - _Start; return _ed1 * pow (2, 10 * (percents_ ÷ 1 - 1)) + _Start;}double OutExpo(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ * 2; double _ed1 = _End - _Start; if (_st &lt; 1) return _ed1 ÷ 2 * pow (2, 10 * (_st - 1)) + _Start; _st = _st - 1; return _ed1 ÷ 2 * (-pow (2, -10 * _st) + 2) + _Start;}double InCirc(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed1 = _End - _Start; return -_ed1 * (sqrt (1 - percents_ * percents_) - 1) + _Start;}double OutCirc(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ - 1; double _ed1 = _End - _Start; return _ed1 * sqrt (1 - _st * _st) + _Start;}double InOutCirc(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _st = percents_ * 2; double _ed1 = _End - _Start; if (_st &lt; 1) return -_ed1 ÷ 2 * (sqrt (1 - _st * _st) - 1) + _Start; _st = _st - 2; return _ed1 ÷ 2 * (sqrt (1 - _st * _st) + 1) + _Start;}double InBounce(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return _getInBounce(_Start, _End, percents_);}double OutBounce(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; return _getOutBounce(_Start, _End, percents_);}double InOutBounce(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed = _End - _Start; if (percents_ &lt; 0.5) return _getInBounce (0, _ed, percents_ * 2) * 0.5 + _Start; return _getOutBounce (0, _ed, percents_ * 2 - 1) * 0.5 + _ed * 0.5 + _Start;}double InBack(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed = _End - _Start; double _s = 1.70158; return _ed * percents_ * percents_ * ((_s + 1) * percents_ - _s) + _Start;}double OutBack(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed = _End - _Start; double _s = 1.70158; double _st = percents_ - 1; return _ed * (_st * _st * ((_s + 1) * _st + _s) + 1) + _Start;}double InOutBack(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; double _ed = _End - _Start; double _s = 1.70158; double _st = percents_ * 2; if (_st &lt; 1){_s = _s * 1.525; return _ed ÷ 2 * _st * _st * ((_s + 1) * _st - _s) + _Start;} double _st = _st - 2 double _s = _s * 1.525 return _ed ÷ 2 * (_st * _st * ((_s + 1) * _st + _s) + 2) + _Start;}double InElastic(double _Progress,double _Start,double _End,double _segments){ double percents_ = _Progress / _segments; if (percents &lt; 0) percents = 0; else if (percents &gt; 1) percents = 1; if(percents_ == 0) return _Start; if(percents_ == 1) return _End; double _ed = _End - _Start; double _d = 1 double _p = _d * 0.3 double _s = 0 double _a = 0 if (_a = 0 || _a &lt; ads(_ed)){_a = _ed; _s = _p ÷ 4} else {_s = _p / (2 * M_PI) * std::asin(_ed / _a);} double _st = percents - 1; return -(_a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p)) + _Start;}double OutElastic(double _Progress, double _Start, double _end, double _segments) { double percents_ = _Progress / _segments; if (percents_ &lt; 0) percents_ = 0; else if (percents_ &gt; 1) percents_ = 1; double _ed = _end - _Start; double _d = 1; double _p = _d * 0.3; double _s = 0; double _a = 0; if (_a == 0 || _a &lt; abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);} return _a * pow(2, -10 * percents) * sin((percents * _d - _s) * 2 * M_PI / _p) + _end;}double InOutElastic(double _progress, double _start, double _end, double _segments) { double percents_ = _progress / _segments; if (percents_ &lt; 0) percents_ = 0; else if (percents_ &gt; 1) percents_ = 1; double _ed = _end - _start; double _d = 1; double _p = _d * 0.3; double _s = 0; double _a = 0; double _st = percents_ * 2; if (_st == 2) {return _end;} if (_a == 0 || _a &lt; abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);} if (_st &lt; 1) {_st -= 1;return -0.5 * _a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) + _start;} _st -= 1; return _a * pow(2, -10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) * 0.5 + _end;}double Clerp(double _progress, double _start, double _end, double _segments) { double percents_ = _progress / _segments; if (percents_ &lt; 0) percents_ = 0; else if (percents_ &gt; 1) percents_ = 1; double _ed = _end - _start; const double _min = 0; const double _max = 360; const double _half = 180; double _retval = 0; double _diff = 0; if (_ed &lt; -_half) { _diff = (_max - _start + _end) * percents_; _retval = _start + _diff; } else if (_ed &gt; _half) { _diff = -(_max - _end + _start) * percents_; _retval = _start + _diff; } else { _retval = _start + _ed * percents_; } return _retval;}double Spring(double _progress, double _start, double _end, double _segments) { double percents_ = _progress / _segments; if (percents_ &lt; 0) percents_ = 0; else if (percents_ &gt; 1) percents_ = 1; double _st = sin(percents_ * M_PI * (0.2 + 2.5 * percents_ * percents_ * percents_)) * pow(1 - percents_, 2.2) + percents_; _st = _st * (1 + 1.2 * (1 - percents_)); return _start + (_end - _start) * _st;}double Punch(double _progress, double _start, double _end, double _segments) { double percents_ = _progress / _segments; if (percents_ &lt; 0) percents_ = 0; else if (percents_ &gt; 1) percents_ = 1; if (percents_ == 0) return 0; if (percents_ == 1) return 0; const double _p = 0.3; double _s = _p / (2 * M_PI) * asin(0); return _end * pow(2, -10 * percents) * sin((percents - _s) * 2 * M_PI / _p);} 这是什么！","link":"/articles/QiNuoTu/OpenEasing/"},{"title":"Boids集群算法浅析与实践","text":"鸟群算法 Boids是模拟鸟类群集行为的人工生命项目，由克雷格·雷诺兹（Craig Reynolds）于1986年开发。Boids 是涌现行为的典例，其复杂性来自于遵循一系列简单规则个体的相互作用。 Boids 通常用于计算机图形学，提供鸟群和其他生物（如鱼群）的逼真表现： 《史丹利和史黛拉: 破冰》是第一部利用了 Boids 模型的动画片； 《半条命》中，游戏结束时出现的类似鸟类的飞行生物就使用了该模型； 《蝙蝠侠归来》电影中，蝙蝠群和成群的企鹅行进穿过哥谭市的街道时使用了该模型； 《黑客帝国》/《重装前哨》中，章鱼外形的哨兵机器人的集群特效使用了该模型。 Boids 模型由三种规则描述： 分离：个体之间存在排斥趋向，自主移动避开群体拥挤处； 聚集：个体会朝向周围同伴所处的平均位置处移动； 对齐：个体会朝向周围同伴的平均移动方向运动。 下面将使用 EasyX 可视化该算法。 随机个体位置着色1234567std::vector&lt;Boid&gt; boids(500);for (Boid&amp; b : boids){ b.position.x = (float)(rand() % 1280); b.position.y = (float)(rand() % 720); b.color = RGB(rand() % 255, rand() % 255, rand() % 255);} 添加“聚集”规则123456789101112131415161718192021222324Vector2D cohesion(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D center_of_mass(0, 0); int total_neighbors = 0; for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; neighbour_distance) { center_of_mass = center_of_mass + b.position; total_neighbors++; } } if (total_neighbors &gt; 0) { center_of_mass = center_of_mass * (1.0f / total_neighbors); return (center_of_mass - position); } return Vector2D(0, 0);} 添加“分离”规则1234567891011121314151617Vector2D separation(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D separation(0, 0); for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; separation_distance) { Vector2D diff = position - b.position; separation = separation + diff * (1.0f / distance); } } return separation;} 添加“对齐”规则123456789101112131415161718192021222324Vector2D alignment(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D avg_velocity(0, 0); int total_neighbors = 0; for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; neighbour_distance) { avg_velocity = avg_velocity + b.velocity; total_neighbors++; } } if (total_neighbors &gt; 0) { avg_velocity = avg_velocity * (1.0f / total_neighbors); return avg_velocity - velocity; } return Vector2D(0, 0);} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;graphics.h&gt;// 简单的二维向量struct Vector2D { float x, y; Vector2D() = default; Vector2D(float _x, float _y) : x(_x), y(_y) {} Vector2D operator+(const Vector2D&amp; other) const { return Vector2D(x + other.x, y + other.y); } Vector2D operator-(const Vector2D&amp; other) const { return Vector2D(x - other.x, y - other.y); } Vector2D operator*(float scalar) const { return Vector2D(x * scalar, y * scalar); } float length() const { return std::sqrt(x * x + y * y); } void normalize() { float len = length(); x /= len; y /= len; }};// 集群单位struct Boid { COLORREF color; Vector2D position; Vector2D velocity; // 聚集规则 Vector2D cohesion(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D center_of_mass(0, 0); int total_neighbors = 0; for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; neighbour_distance) { center_of_mass = center_of_mass + b.position; total_neighbors++; } } if (total_neighbors &gt; 0) { center_of_mass = center_of_mass * (1.0f / total_neighbors); return (center_of_mass - position); } return Vector2D(0, 0); } // 分离规则 Vector2D separation(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D separation(0, 0); for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; separation_distance) { Vector2D diff = position - b.position; separation = separation + diff * (1.0f / distance); } } return separation; } // 对齐规则 Vector2D alignment(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D avg_velocity(0, 0); int total_neighbors = 0; for (const Boid&amp; b : boids) { float distance = (b.position - position).length(); if (distance &gt; 0 &amp;&amp; distance &lt; neighbour_distance) { avg_velocity = avg_velocity + b.velocity; total_neighbors++; } } if (total_neighbors &gt; 0) { avg_velocity = avg_velocity * (1.0f / total_neighbors); return avg_velocity - velocity; } return Vector2D(0, 0); } // 更新方法 void update(const std::vector&lt;Boid&gt;&amp; boids) { Vector2D v1 = cohesion(boids); Vector2D v2 = separation(boids); Vector2D v3 = alignment(boids); // 根据规则权重调节最终行为 v1 = v1 * cohesion_weight; v2 = v2 * separation_weight; v3 = v3 * align_weight; // 更新速度 velocity = velocity + v1 + v2 + v3; // 限制速度 float speed = velocity.length(); if (speed &gt; max_speed) velocity = velocity * (max_speed / speed); // 更新位置 position = position + velocity; // 限制位置 if (position.x &lt; 0) position.x = 0; if (position.x &gt; 1280) position.x = 1280; if (position.y &lt; 0) position.y = 0; if (position.y &gt; 720) position.y = 720; } float neighbour_distance = 100.0f; // 判定为临近单位的距离 float separation_distance = 50.0f; // 临近单位的分离距离 float cohesion_weight = 1.0f; // &quot;聚集&quot; 规则强度 float separation_weight = 1.0f; // &quot;分离&quot; 规则强度 float align_weight = 1.0f; // &quot;对齐&quot; 规则强度 float max_speed = 5.0f; // 集群最大速度};int main() { initgraph(1280, 720, EW_SHOWCONSOLE); BeginBatchDraw(); // 初始化集群 std::vector&lt;Boid&gt; boids(500); for (Boid&amp; b : boids) { b.position.x = (float)(rand() % 1280); b.position.y = (float)(rand() % 720); b.color = RGB(rand() % 255, rand() % 255, rand() % 255); } // 循环模拟 while (true) { // 更新集群 for (Boid&amp; b : boids) b.update(boids); // 渲染集群 cleardevice(); for (Boid&amp; b : boids) { setfillcolor(b.color); fillcircle((int)b.position.x, (int)b.position.y, 10); } FlushBatchDraw(); Sleep(25); } return 0;} 使用三角形等有指向性的元素，根据当前速度向量绘图模拟效果会更加清晰。 &gt;&gt;&gt; 在 Voidmatrix’s Blog 上查看本文章 &lt;&lt;&lt;","link":"/articles/Voidmatrix/boids-algorithm/"},{"title":"XINDENG123456自我介绍","text":"‘hello everyone! Hello world!! 😝🤪😜’阿巴阿巴啦啦啦👻👻etc.… 自我介绍 本人贪吃贪睡，玩世不恭 本人积懒成疾，无可救药 本人大愚若智，爱好躺平 今天做的事： 吃饭 睡觉 赶作业 ==学习== 找对象 试写代码： 1234 int main(){ return 0;} 试写公式…算了不会，晚点学[^晚点学 ] x^2^ 下面画一个表 不想写，还是抄一个 ASCII HTML Single backticks 'Isn't this fun?' ‘Isn’t this fun?’ Quotes &quot;Isn't this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash 我的GitHub在这里XINDENG123456 [^晚点学]： 指不知道多晚，可以参考自我介绍","link":"/articles/XINDENG123456/self-introduction/"},{"title":"程序化游戏地图生成浅析（一）","text":"使用 程序化内容生成（PCG） 的优势： 无限地图内容：两个维度，一是单次游玩的地图内容趋近于无限，即无限大世界；二是可以生成近似无限多的世界，提升游戏的可重复游玩性； 节省开发成本：开发者只需要定义生成规则来描述世界最底层的机制，而不需要从上到下事无巨细地完成玩家可游玩的全部内容； 挑战与变化：使用程序生成地图可以很好地控制随机性，给玩家创造挑战的机会，更具趣味性； 动态难度调整：使用规则描述世界生成可以站在更高的维度去调控世界资源，更好地平衡游戏难度或创造特殊难度的世界。 在大多数情况下，程序化生成地图的游戏也并不能完全地摆脱传统的手工制作的部分，即便是程序化内容生成主导的世界中，也存在细粒度的部分需要开发者进行人工设计（如 Minecraft 中的村庄等内容），这同样也可以使用更细致的生成规则来描述。 生成思路总览对于程序化生成的游戏世界地图，可以使用分批次地、递归地类似分形的思想逐步进行细化处理，每一层处理都基本满足以下三个步骤： 随机：根据随机数或噪声算法生成最粗略的数据模板； 平滑：根据当前生成内容的维度和粒度对得到的数据进行插值和过渡处理； 修正：根据游戏内容和更上层的设计规则调整平滑后的世界。 一个使用此思想实现的流程可以如下所示： 在前两个步骤中，我们需要确保使用的算法满足下列三个条件： 随机性：这个过程是随机的，或者说在相当大范围内不会出现重复的生成周期； 可哈希：使用相同的随机数输入（种子），得到的随机内容是一致的； 连续性：无论粒度大小，生成的内容都是连续且平滑的。 可哈希的特性给游戏的增量存档提供了可能，存储游戏世界信息的存档不需要在初始化生成时便保存全部数据内容，而是可以随着游戏进行，只增量存储玩家探索过或修改过的内容。 下面我们将分类讨论在随机和平滑的过程中使用的算法思路。 直接使用随机数直接使用rand()等随机函数会存在以下问题： 不连续性：随机数的生成是跳跃的，直接使用时无法起到平滑的效果； 易受影响：虽然我们可以使用srand()等函数设置随机数的种子来确保随机数的哈希性，但是程序的其他部分可能需要使用时间来初始化随机数种子来获取更灵活的随机数，这就导致在全局环境下生成的随机数不稳定。 使用如下代码生成的灰度图，可以很清楚地看出其不连续性： 12345678910111213141516171819202122#include &lt;graphics.h&gt;int main(){ const int width = 1280; const int height = 720; initgraph(width, height, EW_SHOWCONSOLE); for (int x = 0; x &lt; width; x++) { for (int y = 0; y &lt; height; y++) { int val = rand() % 255; putpixel(x, y, RGB(val, val, val)); } } system(&quot;pause&quot;); return 0;} 但是，这并不意味着随机数函数是无用的，我们可以直接使用随机数生成离散的影响点，再根据距离权重进行平滑处理，如《文明6》等游戏中使用的米切尔候选算法（Mitchell’s best-candidate algorithm），在处理初期时可以直接使用随机数进行候选节点的生成的，这将在后续的游戏资源生成章节再进行详细讨论。 在上古项目随机地图高度图生成过程中，也是使用了简单的先随机后平滑的思路： 平滑的噪声函数在《基于EasyX软渲染实现常见故障艺术》一文中，提供了一种可行的随机噪声函数： 123456// 获取随机噪声virtual double GetRandomNoise(double x, double y){ double val = sin(x * 12.9898 + y * 78.233) * 43758.5453; return val - floor(val);} 简单地，我们也可以使用正弦波叠加的思想处理类似的噪声生成： 但是，我们可以很清晰地看出，这种直接使用函数生成的噪声即便可以满足哈希性和连续性，但它们的周期性太强，直接将生成得到的计算结果应用于游戏中会导致整个世界出现大量重复地形，并不能完全满足随机性的要求： 1234567891011121314151617181920212223242526272829double noise(int x, int y){ double val_x = abs((1 * sin(x * 1)) + (0.5 * sin(x * 2)) + (0.25 * sin(x * 4)) + (0.125 * sin(x * 8))); double val_y = abs((1 * sin(y * 1)) + (0.5 * sin(y * 2)) + (0.25 * sin(y * 4)) + (0.125 * sin(y * 8))); // 对得到的结果进行归一化 return (val_x + val_y) / ((1 + 0.5 + 0.25 + 0.125) * 2);}int main(){ const int width = 1280; const int height = 720; initgraph(width, height, EW_SHOWCONSOLE); for (int x = 0; x &lt; width; x++) { for (int y = 0; y &lt; height; y++) { int val = (int)(noise(x / 10, y / 10) * 255); putpixel(x, y, RGB(val, val, val)); } } system(&quot;pause&quot;); return 0;} 即便如此，这些生成噪声的方式，同样可以作为分形噪声等更进阶的噪声生成时的原始数据。 更进阶的噪声生成有许多已经被实践证明满足上述需求的噪声算法，如：Perlin噪声，Simplex噪声，Wavelet噪声，Value噪声和Worley噪声等，下面将以大名鼎鼎的柏林噪声（Perlin）为例讲解实现思路。 柏林噪声本质上可以算是一种非典型的晶格噪声技术，晶格噪声是一种在离散的、规则的网格上生成的噪声，所以晶格噪声通常在规则的格点上有着明确定义的数值，而柏林噪声的特殊之处在于，在使用晶格为单位生成基础噪声后，又通过插值和平滑处理，产生了空间中连续的噪声变化。 柏林噪声的生成可以归纳为三步： 梯度生成：在空间中随机生成梯度向量网格，梯度向量由每个整数坐标点（晶格）上随机确定的。这些梯度向量定义了一个在整个空间内变化的方向； 插值：当需要计算某一点的噪声值时，首先确定其所处的网格单元，然后计算该点到网格单元内各个梯度向量的距离，并将这些距离用于权重插值，在这个过程中噪声得到了平滑的处理； 分形：对生成得到的结果进行不同尺度的缩放和叠加，来生成更具随机性且不同粒度的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cmath&gt;#include &lt;graphics.h&gt;// 生成基础噪声值double noise(int x, int y){ return fmod(sin(x * 12.9898 + y * 78.233) * 43758.5453, 1.0);}// 生成平滑噪声值double smooth_noise(int x, int y) { // 计算角落、边和中心的平均噪声值 double corners = (noise(x - 1, y - 1) + noise(x + 1, y - 1) + noise(x - 1, y + 1) + noise(x + 1, y + 1)) / 16; double sides = (noise(x - 1, y) + noise(x + 1, y) + noise(x, y - 1) + noise(x, y + 1)) / 8; double center = noise(x, y) / 4; // 返回平滑噪声值 return corners + sides + center; }// 线性插值double interpolate(double a, double b, double x) { // 计算插值权重 double ft = x * 3.1415927; double f = (1 - cos(ft)) * 0.5; // 返回插值结果 return a * (1 - f) + b * f; }// 插值计算double interpolated_noise(double x, double y) { // 提取整数部分和小数部分 int integer_X = static_cast&lt;int&gt;(x); double fractional_X = x - integer_X; int integer_Y = static_cast&lt;int&gt;(y); double fractional_Y = y - integer_Y; // 计算插值点的噪声值 double v1 = smooth_noise(integer_X, integer_Y); double v2 = smooth_noise(integer_X + 1, integer_Y); double v3 = smooth_noise(integer_X, integer_Y + 1); double v4 = smooth_noise(integer_X + 1, integer_Y + 1); double i1 = interpolate(v1, v2, fractional_X); double i2 = interpolate(v3, v4, fractional_X); // 返回插值后的噪声值 return interpolate(i1, i2, fractional_Y); }int main() { const int width = 1280; const int height = 720; initgraph(width, height); // 循环生成每个像素点的噪声值并转换为灰度颜色 for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { // 生成插值噪声，并控制噪声的规模 double value = interpolated_noise(x / 50.0, y / 50.0); // 将噪声值转换为灰度颜色 COLORREF color = RGB((int)(value * 255), (int)(value * 255), (int)(value * 255)); // 在指定位置绘制像素 putpixel(x, y, color); } } system(&quot;pause&quot;); return 0;} &gt;&gt;&gt; 在 Voidmatrix’s Blog 上查看本文章 &lt;&lt;&lt;","link":"/articles/Voidmatrix/pcg-game-map-1/"},{"title":"植物明星大乱斗系列视频——勘误","text":"本文收录并校对植物明星大乱斗系列视频中出现的错误 从零开始的植物明星大乱斗系列视频 错误该部分收录已确定的错误 在resources文件夹中“winnner_bar.png”拼写错误，应重命名为”winner_bar.png” 在资源加载和动画类实现01:27中“img_flpipped”拼写错误，应重命名为”img_flipped” 在玩家子弹发射和角色技能实现12:00中“timer_spwan_pea_ex”拼写错误，应重命名为”timer_spawn_pea_ex” 在玩家子弹发射和角色技能实现12:08中SunflowerPlayer构造函数缺少头顶文本动画，左右特殊攻击动画的部分语句，应添加实际上这部分添加内容在08:53中出现过 警告该部分收录的算不算错误我不好说 resources文件夹中sun_explode_ex.mp3和sun_ex_explode系列图片命名不同我把sun_explode_ex.mp3以及main.cpp、sun_bullet_ex.h中使用的别名统一修改为sun_ex_explode","link":"/articles/Ye%20Minglv/video_corrigendum/"},{"title":"hszSoft 向大家问好","text":"各位好，这里是 hszSoft，项目 StardustEngine 的参与者之一。 除了程序以外，本人也爱好编曲，并常年混迹于东方圈。 由于工作原因，StardustEngine 的更新进度非常慢，很长时间看不到一个提交，但这个项目是不会鸽的。 因为比较忙，所以一般也很少看到我发言吧…？ 本人研究与游戏相关的多个方向，并会总结一些自己的心得在我的博客中 &gt;&gt;&gt; hszSoft 的博客 &lt;&lt;&lt; 早期的一些文章因为其内容不够深入，所以没有全部发布上来，对我正在做的事情感兴趣的小伙伴们，欢迎联系我 &gt;&gt;&gt; https://github.com/hszSoft &lt;&lt;&lt; 相信总有一天，hszSoft 的成果能够让你眼前一亮。","link":"/articles/hszSoft/hello/"},{"title":"suang","text":"这里是suang的自我介绍~ 我是谁？ suang！ 我是suang！一个永远都在追求快乐的人!一名很菜但正在学习的大一蒟蒻 非常感谢大v老师建立这样一个平台希望能够在VSpace里和大家一起学习，共同进步啦~ 最后非常非常感谢帮助过我的各位，爱你们~","link":"/articles/suang/Aboutme/"},{"title":"博客第一步：将Hexo部署在GitHub上","text":"Hexo 是一个快速、简单且强大的静态博客框架，与 GitHub 结合使用可轻松搭建个人博客网站。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。其主题，模板也更加丰富多样，更适合创建功能丰富的个人博客或其他类型的静态网站。 Quick Start接下来，我将分享我在GitHub上部署Hexo的过程步骤，并给出其中我遇到的一些困难与解决方法。。 1.安装NodeHexo是一个基于Node.js的静态网站生成器，需要在本地安装Node.js环境，并通过命令行来创建、编译和部署网站。 下载链接: Node 2.安装Sublime text这个算是文本编辑器，但功能更加强大，有许多妙用。 下载链接: Sublime text 3.下载Git下载链接: Git 基本配置Git打开gitbush终端输入一下指令（名字邮箱皆与GitHub相关），这将关系到你是否能将仓库推送到GitHub上 a.配置昵称，邮箱 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;your.email@example.com&quot; b.生成ssh 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; //生成ssh密钥 c.添加 SSH 公钥到GitHub账户 使用Git链接远程仓库（后续会使用到）需要替换url 123$ git init //初始化仓库$ git remote add origin https://github.com/exampleuser/example.git $ git remote -v //查看是否关联成功 4.创建GitHub仓库建立一个公共仓库，仓库名：&lt;你的 GitHub 用户名&gt;.github.ioeg：Dream-verylively.github.io 5.配置并使用Hexoa.配置hexo 这个步骤将生成blog文件夹，接下来的诸多操作将围绕这个文件夹进行 12345$ npm install hexo-cli -g //安装 Hexo CLI（命令行工具）到全局环境$ hexo init blog //始化 Hexo 博客，创建一个名为 &quot;blog&quot; 的目录，并在其中初始化 Hexo（名字可更改）$ cd blog //进入到刚创建的 &quot;blog&quot; 目录中$ npm install //npm install$ hexo server //启动 Hexo 服务器，用于本地预览您的博客 More info: hexo b.编辑你的 _config.yml 第一处第二处 c.在博客文件夹下打开终端执行以下命令 123$ hexo clean //清理 Hexo 生成的静态文件和缓存$ hexo g //使用 Hexo 生成静态文件，将 Markdown 格式的文章转换为 HTML 等静态文件$ hexo deploy //部署生成的静态文件到指定的部署目标（例如 GitHub Pages、FTP 等） GithubPages 404问题1、github 仓库名称不匹配在 github 上面创建的仓库名称没有使用自己的 github 账号名称，例如你的 github 账号名称是 zhanghao，而你创建的仓库名称是 suibian.github.io，这样你是无法访问你的博客网站的。 2、配置文件错误在你的本地博客目录下（我创建的名称是 hexo，注意不是 themes 主题目录下的那个配置文件），有个配置文件 _config.yml，注意观察里边的内容是否符合条件。 3、分支错误注意提交的分支要与GitHub仓库中的默认分支一致 4、hexo 依赖不全检查依赖安装是否有不全的情况，可以使用 npm list 命令 1$ npm list --depth 0 如果检查有问题，会在控制台提示类似 npm ERR! missing xxxxx。 5.版本不匹配问题（node与hexo）12$ node -v //检查两者的版本$ hexo -v 看这个：版本限制 写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。","link":"/articles/shuo-liu16/deploy-hexo/"},{"title":"奥日与萤火意志2","text":"玩奥日有感（真随笔）剧情上 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图解锁了地底下和森林的碎片唤醒了底下的蜘蛛（被腐朽吞噬了心智）夸洛克牺牲了自我换回碎片 剧情就不得不提到npc了莫基——路人角色，大大小小的任务都有承担，森林的原住民算是库克——地图提供者猴子——推动剧情，教会武器方面技能商人——交易升级技能夸洛克——沼泽的庇护神工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器 玩法上在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。在角色系统我会介绍这些对玩法的贡献 主要是——场景，场景关卡设置，物品和玩法剖析 场景的关卡前期的最大关卡就是【1】找到散落的楔石打开石门小的关卡【2】拖拽石头来阻挡机关和帮助跳跃还有类似司机挡位的机关——触发一些机关，打开石门等等【3】还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏 场景物品藤条——帮助跳跃竖直木棒——陷阱悬停水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了羽毛——还有库和奥日的配合玩法—— 补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯 玩法其实有的已经融合在以上或者以下的分析里面主要探索，打斗剧情的玩法——对话打斗boss等boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣 场景第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景 从角色系统上分析主要分为四个部分 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条） 武器+主动技能系统从光剑到弓箭到重锤，技能则有光之箭和回血等评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。光剑——可以打碎一些木板障碍物例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速重锤——可以打碎石板光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）其他目前武器目前没有看到对地图探索的作用，有再补充 不可见的被动技能例如二连跳抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深 课拆卸购买升级的被动技能首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级技能框则是探索地图一步一步的去扩展讲几个印象比较深的技能:攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行三连跳——好吧也是默认了，不仅帅而且探索地图确实方便其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧 （4）美术","link":"/articles/yang12342/%E5%A5%A5%E6%97%A5%E4%B8%8E%E8%90%A4%E7%81%AB%E6%84%8F%E5%BF%972/"},{"title":"测试","text":"这里是一个测试，大佬看看是这样咩？","link":"/articles/YoungFlame/"},{"title":"使用EasyX制作游戏需要读写文件时遇到编码问题的解决方法","text":"痛苦之子suang又遇到了什么问题呢？噢！原来是编码问题！快来帮他解决吧！痛苦之子~~~乔戈亚~~~~~ 一、编码问题例如我们需要从file.txt中读取文字，再使用outtextxy()函数向窗口绘制文字。查找EasyX的官方文档可知，该函数有两个重载，分别为：void outtextxy(int x, int y, LPCTSTR str)和void outtextxy(int x, int y, TCHAR c)。如果我们的file.txt文件使用GBK或者GB2312编码的话，会导致VS编译器混合utf-8编码和GBK编码，导致程序不能正确绘制文字。编码问题一直是令人头痛的问题，这里给出通用的方法论，希望能够带来一些帮助。 二、解决方法1. 重新编码txt文件首先使用vscode打开file.txt文件，确保文件编码为utf-8。 如果不是utf-8编码，点击选择编码，通过编码重新打开，选择utf-8编码，这时原来的内容会变成乱码，将原来的内容删除，重新输入，保存即可。 2. 代码部分首先，我们需要用到std::wstring_convert，这个标准库需要头文件#include&lt;codecvt&gt;，我们定义string str，用static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; converter;定义我们所需要的从utf-8编码的字符串到宽字符串的转换器。 打开文件，读取文件内容到str内，使用from_bytes(str)函数即可实现字符串的转换，又由于outtextxy没有使用wstring的重载，使用wstring的成员函数c_str()即可转换成wchar_t字符串，最终，我们用这样的代码将文字绘制在窗口上outtextxy(10, 10, converter.from_bytes(str).c_str());。 完整代码如下： 12345678910111213141516171819202122232425262728#include&lt;fstream&gt;#include&lt;codecvt&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;graphics.h&gt;std::string str;int main(){ initgraph(500, 500); static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; converter; std::ifstream infile(&quot;file.txt&quot;); if (!infile) { std::cerr &lt;&lt; &quot;无法打开文件&quot; &lt;&lt; std::endl; return 0; } std::getline(infile, str); infile.close(); while (true) { outtextxy(10, 10, converter.from_bytes(str).c_str()); }} 三、问题延伸如果我们需要在程序内使用InputBox对话框输入，并将输入的内容正确保存在文件里，该如何操作呢。首先查看InputBox的参数列表bool InputBox(LPTSTR pString, int nMaxCount, LPCTSTR pPrompt = NULL, LPCTSTR pTitle = NULL, LPCTSTR pDefault = NULL, int width = 0, int height = 0, bool bOnlyOK = true);，我们关注第一个参数，InputBox只接受&amp;wchar_t的参数，因此，假设输入的字符串最大长度为256，我们定义TCHAR buffer[256];数组来接收输入，写下这样的代码来弹出对话框InputBox(buffer, 256, _T(&quot;请输入：&quot;), _T(&quot;输入框&quot;), NULL, 0, 0, TRUE);打开文件，定义std::string str;，仍然使用我们刚才定义的转换器，使用to_bytes()函数，即可将输入的内容转换为utf-8字符串。再进行输入即可。 完整代码如下： 12345678910111213141516171819202122232425#include&lt;fstream&gt;#include&lt;codecvt&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;graphics.h&gt;int main(){ initgraph(500, 500); static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; converter; TCHAR buffer[256]; InputBox(buffer, 256, _T(&quot;请输入：&quot;), _T(&quot;输入框&quot;), NULL, 0, 0, TRUE); std::ofstream outfile(&quot;file.txt&quot;); if (!outfile) { std::cerr &lt;&lt; &quot;无法打开文件&quot; &lt;&lt; std::endl; return 0; } std::string str = converter.to_bytes(buffer); outfile &lt;&lt; str; outfile.close();} 说些题外话，suang心事很重，虽然表面看上去什么都不在乎，但是其实内心很脆弱很敏感。时常会独自emo，我的朋友跟我说啊，要把不开心的事情说出去，不能憋着。其实我是不想憋的，但是我说不出口，或者说我已经不知道怎么去说了，每次难受的时候，就什么都说不出来了，也许发生在我身上的事情真的那么那么复杂，也许只有亲身经历过，才能感同身受，才能知道怎么解开我的心结罢。可我没什么文采，写不来文章，又没那么专业，拍不了电影。所以，我想做游戏，在另一个世界里，说我想说但说不出口的，做我想做却没勇气做的，弥补我曾经的遗憾。也许这样，我就真的释然了。 做游戏的想法埋下了，我却一直都没去做，一是我确实没什么实力，二是我并不知道如何开始，直到我发现了大V老师…… 我真的没想到，大V老师能帮我远程解决问题，当时真的震惊到我了，我跟我的室友炫耀了好久，我真的没想到，在那些卖课的占据b站首页大部分的今天，还有大V老师这样的一股清流。来到群里之后我发现，真的有乐于分享，愿意帮助我的人，suang真的真的很感动。","link":"/articles/suang/EasyX_code/"},{"title":"使用GitHub Desktop在论坛中发表文章的方法及注意事项","text":"suang教你用GitHub Desktop发表文章！超级简单！超级详细！超级耐心！一定要看！一看就会！ 一、提交文章的流程1. 安装以下工具 GitHub Desktop VSCode 2. 将GitHub库中的资源clone到本地进入 VoidGameSpace 论坛的 GitHub 库网站，点击 &lt; &gt; Code ，选择Open with GitHub Desktop将资源克隆到本地。 3. 使用VSCode打开库中资源并进行编辑切换到 GitHub Desktop ，点击 Open in Visual Studio Code 即可在 VSCode 中进行编辑。在左侧资源管理器中打开目录 /GAMEDEVWEBSITE/source/_posts 在这个目录下新建一个独立的、专属于自己的文件夹。在自己的文件夹中新建 markdown 文件，编辑完成保存后返回 GitHub Desktop 。 4. 提交本地代码，将本地所做的更改同步到远程代码库返回 GitHub Desktop 后，会自动跳转到 Changes 界面，确认代码无误后，点击 Commit to main 进行提交，再点击 Push origin 将更改同步到远程代码库。 5. 进入自己的fork，拉取合并更改的请求回到 GitHub 中并刷新网页，此时，一定要在自己fork的文件中！！！按照下图方式点击，进入自己的fork，才能进行之后的操作。 接下来点击 Pull requests ，再点击 New pull request 拉取合并更改的请求。最后点击 Create pull request 生成请求。 6. 等待Vercel部署和大V老师的审核完成了这一步，恭喜你已经成功将你的文章提交了，接下来就是耐心地等待你的文章通过审核了。不过别急着高兴，关于 markdown 文件，还有一些注意事项。 二、关于markdown文件1. markdown文件的写法markdown的语法很简单，可以参考 Markdown 官方教程 来进行查找和学习。 2. 注意事项敲重点！！！！！ 元数据一定不能少！ 元数据一定不能少！ 元数据一定不能少！ 重要的事情说一万遍！ 元数据是用两个---分割线包围的数据，记录你的文章的标题、上传时间，修改时间、永久链接、目录、标签 这些信息，缺少了元数据的文章无法通过审核。写法如下： 12345678---title: 使用GitHub Desktop在论坛中发表文章的方法及注意事项date: 2024-05-28update: 2024-05-29permalink: articles/suang/publish_article/categories: suangtags: [suang, 教程, 发表文章]--- 其中，permalink 项要填写 article/你的专属目录/子目录（可选）/ 虽然子目录是可选项，但是，你也不想把所有的文章都丢在同一个文件夹下吧。真的不要这样做啊！！！ 元数据中有 title 属性不需要写一级标题 最好使用 &lt;!-- More --&gt; 注释添加概述否则主页文章会全部展开显得很长 三、关于图片的插入1. 导入图片资源 首先，将你所需要的图片资源导入到你的专属文件夹中，然后就可以修改markdown文件啦~ 像这样 12345&lt;div style=&quot;text-align:center&quot;&gt;![图片在哪里呀？](articles/suang/publish_article/image_pos.png)&lt;/div&gt; 括号里面写上你的图片的相对路径就可以将图片导入啦！ 真的是保姆级了，正常来说照着我的教程一步一步来应该不会出问题了。如果遇到了问题记得在群里@我 Yeah~","link":"/articles/suang/publish_article/"},{"title":"随笔-如何提交文章到VoidGameSpace上","text":"关于如何提交文章到VoidGameSpace论坛上的git教程。 本文章仅适用于VoidGameSpace论坛及其GitHub库。 该教程目前仅适用于Windows系统。 原博客传送面板 如何使用github进行提交一. 确认Git安装Git下载地址: Link 测试Git：打开 cmd 或者 PowerShell，输入 git -v 可以查看到当前Git的版本。 二. 配置Git设置和SSH 使用下面两个指令配置Git全局设置： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 配置ssh设置：可以参考这个文章 使用 ssh-keygen -t rsa -C &quot;你的邮箱&quot;，一路回车生成SSH。 找到文件C:\\User\\用户名\\.ssh\\id_rsa.pub，使用记事本打开并复制里面的内容。 打开GitHub在Settings界面左边找到SSH and GPG keys进入。 点击 New SSH key，在title中填入合适的标题，在SSH中填入刚刚复制的内容。 本地指令输入 ssh -T git@github.com 验证是否配置成功。 三. fork库到自己的库中打开 GitHub库 网页，点击右上角 Fork 按钮，复制该库到自己的库中。 选择owner为自己的账户，Repository name可以设置为默认GameDevWebsite。 Description用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。 点击 Create fork 按钮。 四. clone库到本地进入自己的库中找到刚刚fork的GameDevWebsite库，一般为 https://github.com/用户名/GameDevWebsite 找到 &lt;&gt; Code 绿色按钮，在本地中使用 PowerShell 打开想要部署的位置 or 在部署的位置中右键选择在终端打开 or 使用cmd cd 到要部署的文件夹，使用下面三种方式之一克隆库到本地 使用HTTPS，复制web URL，输入git clone 复制的URL部署。这个方法需要你在终端登录到Git中。 使用SSH，复制SSH key，输入git clone 复制的SSH_key部署。 点击Download ZIP，下载压缩包到要部署的文件夹并解压。 五. 编写自己的文档在部署的项目目录GameDevWebsite中，路径source\\_posts\\创建自己的文件夹，并在文件夹中创建.md文件，参考GitHub库中元数据说明，编写自己的文章。 另外，markdown的编写可以参考官方文档：Link 六. 提交文档到自己fork的库中使用 PowerShell 打开项目目录GameDevWebsite，或者在目录中右键点击在终端打开，或者使用cmd cd到目录。 创建自己的分支(可选，新手建议直接修改main分支)：使用 git checkout -b 分支名 创建并切换到新的分支。(分支的作用是保证main分支的干净，一般只有最终版本才会合并到main分支)。如果你已经创建过分支，就不需要再创建该分支了。 添加所有文件到暂存区： git add . 提交添加的文件： git commit -m &quot;修改描述&quot;。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 &quot;docs(你的名字): 添加了xxx文章&quot;。具体准则可以自行搜索学习一下。 push库：如果你使用的是新建的分支，使用git push origin 分支名 将新分支push到库中。如果你使用的是main分支或者是已经创建的库，那么使用 git push 将提交的内容push到库中。 七. 拉取申请找到自己fork的库，点击左上方 Pull requests按钮，进入页面点击右上方New pull request按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择main)，然后填写一些申请描述即可。 八. 等待审核建议留言压力v佬(bushi)","link":"/articles/zExNocs/%E9%9A%8F%E7%AC%94-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E6%96%87%E7%AB%A0%E5%88%B0VoidGameSpace%E4%B8%8A/"},{"title":"zExNocs自我介绍","text":"这是一个zExNocs的自我介绍。 介绍 这里是蒟蒻zExNocs：个人小站 欢迎各位大佬友链&amp;&amp;留言 导航 这里空空如也 这是一个神奇的公式，你知道叫什么吗？$$P(T)=e^{\\frac{\\Delta}{kT}}$$","link":"/articles/zExNocs/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"测试测试测试测试测试","slug":"测试测试测试测试测试","link":"/tags/%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95/"},{"name":"游戏开发","slug":"游戏开发","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"游戏设计","slug":"游戏设计","link":"/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"自我介绍","slug":"自我介绍","link":"/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"闲聊","slug":"闲聊","link":"/tags/%E9%97%B2%E8%81%8A/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"EasyX","slug":"EasyX","link":"/tags/EasyX/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"PCG","slug":"PCG","link":"/tags/PCG/"},{"name":"勘误","slug":"勘误","link":"/tags/%E5%8B%98%E8%AF%AF/"},{"name":"hszSoft","slug":"hszSoft","link":"/tags/hszSoft/"},{"name":"suang","slug":"suang","link":"/tags/suang/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"游戏心得","slug":"游戏心得","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BF%83%E5%BE%97/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"编码","slug":"编码","link":"/tags/%E7%BC%96%E7%A0%81/"},{"name":"发表文章","slug":"发表文章","link":"/tags/%E5%8F%91%E8%A1%A8%E6%96%87%E7%AB%A0/"},{"name":"VoidGameSpace","slug":"VoidGameSpace","link":"/tags/VoidGameSpace/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"Flaaax","slug":"Flaaax","link":"/categories/Flaaax/"},{"name":"Demo","slug":"Demo","link":"/categories/Demo/"},{"name":"FlyingfishFantasticfan","slug":"FlyingfishFantasticfan","link":"/categories/FlyingfishFantasticfan/"},{"name":"QiNuoTu","slug":"QiNuoTu","link":"/categories/QiNuoTu/"},{"name":"Touyouta","slug":"Touyouta","link":"/categories/Touyouta/"},{"name":"Voidmatrix","slug":"Voidmatrix","link":"/categories/Voidmatrix/"},{"name":"XINDENG123456","slug":"XINDENG123456","link":"/categories/XINDENG123456/"},{"name":"Ye Minglv","slug":"Ye-Minglv","link":"/categories/Ye-Minglv/"},{"name":"hszSoft","slug":"hszSoft","link":"/categories/hszSoft/"},{"name":"suang","slug":"suang","link":"/categories/suang/"},{"name":"shuo-liu16","slug":"shuo-liu16","link":"/categories/shuo-liu16/"},{"name":"yang12342","slug":"yang12342","link":"/categories/yang12342/"},{"name":"YoungFlame","slug":"YoungFlame","link":"/categories/YoungFlame/"},{"name":"zExNocs","slug":"zExNocs","link":"/categories/zExNocs/"}],"pages":[]}