---
title: 游戏角色序列帧图集资源加载类
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 项目的模块化设计原则

## 引理

​        随着项目体量的增大，会有越来越多的程序逻辑和各式各样的类定义，全部将它们挤在一起就会显得十分臃肿，不仅会导致命名空间和依赖关系混乱，在调试和修改时也很不容易定位具体的代码位置。

​        所以我们首先要做的事情就是要将这些东西分而制之，将游戏不同阶段的代码放置在不同的类中进行封装，并将不同的类代码存放在不同的头文件或源文件中。

![](articles/Zhong classmate/项目2-植物明星大乱斗/images/1.png)



## 函数(类)声明与定义(实现)分离设计准则

在C++编程中，函数和类的**定义**与**声明**分离是一种常见且推荐的设计方式。这种设计可以提高代码的可维护性、可扩展性，并减少编译时间。下面是一些具体的设计准则：

### 1. **声明与定义(实现)的基本概念**
- **声明**：告诉编译器函数或类的存在和接口以及该函数或类的使用方法，但不提供具体的实现。通常放在头文件（`.h`或`.hpp`文件）中。
  
  - 函数声明示例：
    ```cpp
    // Myfuction.h
    void fuction_one();
    void fuction_two();
    void fuction_three();
    void fuction_four();
    .....
    ```
  - 类声明示例：
    ```c++
    // MyClass.h
    class MyClass：
    //MyClass.hpp
    class MyClass// 类的声明
    {
    public:
    	int a;//成员变量声明
        ......
    public:
    	MyClass();//构造函数声明
        ~MyClass();//构造函数声明
        ......  
    public:
    	void MyClassfuction_one();//成员函数声明
    	void MyClassfuction_two();
    	void MyClassfuction_three();
    	void MyClassfuction_four();
    }:
    ```
  
- **定义(实现)**：提供函数或类的具体实现，通常放在源文件（`.cpp`文件）中。
  
  - 函数定义示例：
    ```c++
    // Myfuction.cpp
    #include "MyClass.hpp"//#include "MyClass.h"
    
    void fuction_one() {
        // 函数实现
    }
    void fuction_two() {
        // 函数实现
    }
    void fuction_three() {
        // 函数实现
    }
    void fuction_four() {
        // 函数实现
    }
    ```
  
  + 类定义示例：
  
    ```c++
    // MyClass.cpp
    #include "Myfuction.h"
    MyClass::MyClass(){
        // 构造函数实现
    }
    MyClass::~MyClass(){
        // 析构函数实现
    }
    void MyClass::MyClassfuction_one()
    {
        // 成员函数实现
    }
    void MyClass::MyClassfuction_two()
    {
        // 成员函数实现
    }
    void MyClass::MyClassfuction_three()
    {
        // 成员函数实现
    }
    void MyClass::MyClassfuction_four()
    {
        // 成员函数实现
    }
    ```
    
    

### 2. **函数定义与声明分离的设计准则**

- **头文件中只做声明**：  
  在头文件中只声明函数，不进行实现。实现部分应放在对应的源文件中。这避免了重复定义，也有助于减少依赖的耦合。
  
  例如：
  ```cpp
  // MyClass.h
  class MyClass {
  public:
      void doSomething(); // 只声明，不实现
  };
  ```

- **实现放在源文件中**：  
  函数的实现部分放在源文件中，这样可以确保头文件清晰简洁，并且减少不必要的编译开销。

  例如：
  ```cpp
  // MyClass.cpp
  #include "MyClass.h"
  
  void MyClass::doSomething() {
      // 实现代码
  }
  ```

- **减少不必要的头文件依赖**：  
  如果函数参数或返回值只需要指针或引用，可以使用前置声明来减少头文件的依赖。这可以缩短编译时间，尤其是在大型项目中。

  例如：
  ```cpp
  // MyClass.h
  class AnotherClass; // 前置声明
  
  class MyClass {
  public:
      void process(AnotherClass* obj); // 只需要指针，无需包含完整定义
  };
  ```

### 3. **类定义与声明分离的设计准则**

- **类声明放在头文件**： 
  类的声明应该放在头文件中，供其他文件引用。头文件中的类声明通常包括类的数据成员和成员函数的声明，但不包括函数的实现。

  例如：
  ```cpp
  // MyClass.h
  class MyClass {
  private:
      int data; // 数据成员声明
  public:
      MyClass(int val); // 构造函数声明
      void setData(int val); // 成员函数声明
      int getData() const; // 成员函数声明
  };
  ```

- **类实现放在源文件**： 
  类成员函数的实现应放在源文件中，这样可以防止类的实现细节泄露，并确保代码的清晰性。

  例如：
  ```cpp
  // MyClass.cpp
  #include "MyClass.h"
  
  MyClass::MyClass(int val) : data(val) {} // 构造函数实现
  
  void MyClass::setData(int val) {
      data = val;
  }
  
  int MyClass::getData() const {
      return data;
  }
  ```

- **在头文件中避免内联大量代码**： 
  如果一个函数是非常短的（如一行代码），可以将其声明为内联函数。否则，避免在头文件中定义函数，这会导致头文件臃肿并增加编译时间。

  例如：
  ```cpp
  // 内联函数（仅适用于非常简短的实现）
  class MyClass {
  public:
      int getData() const { return data; } // 简短的内联函数
  };
  ```

- **在类模板中例外**： 
  类模板通常需要在头文件中同时声明和定义，因为模板是在编译时实例化的，编译器需要看到模板的完整实现。
  
  例如：
  ```cpp
  // MyTemplate.h
  template <typename T>
  class MyTemplate {
  private:
      T data;
  public:
      MyTemplate(T val) : data(val) {} // 构造函数
      T getData() const { return data; } // 内联实现
  };
  ```

### 4. **分离的优点**

- **提高代码的可读性**： 
  通过将声明和定义分离，头文件只负责提供接口信息，使代码结构更加清晰，用户可以快速了解类或函数的功能，而不被实现细节干扰。

- **降低耦合性**： 
  通过分离，头文件与头文件之间的依赖减少，减少了编译时的耦合。这在大型项目中尤为重要，可以有效减少编译时间。

- **便于代码管理和维护**： 
  当只修改函数的实现时，通常只需重新编译源文件，头文件无需修改，减少了整个项目的重新编译。

- **隐藏实现细节**： 
  通过将实现部分放在源文件中，外部代码无法直接访问实现细节，这有助于信息隐藏（Encapsulation），提高模块的安全性和稳定性。

### 5. **常见的设计错误**

- **在头文件中定义函数**： 
  将函数定义放在头文件中会导致多个源文件包含同一个头文件时出现重复定义的链接错误。只应在头文件中声明函数，避免直接实现。

- **滥用内联函数**： 
  虽然内联函数可以提高一些性能，但过度使用会增加编译时间和代码体积，尤其是在头文件中。

### 总结
将函数和类的声明与定义分离是C++编程中的重要实践。它不仅提高了代码的清晰度和可维护性，还减少了编译时间和依赖耦合。通过将声明放在头文件，将实现放在源文件中，可以帮助开发者更好地组织和管理代码。





## 头文件与源文件的模块化设计

### 1. **模块化设计的核心思想**

**模块化设计**是一种软件工程设计方法，将系统划分为若干独立的模块，每个模块负责一个特定的功能或任务。这种设计方法强调**功能分离**和**模块独立性**，确保系统复杂性可以被有效管理，从而提高代码的可维护性、可扩展性和可读性。

在复杂项目中，模块化设计的首要目标是**降低耦合度**与**提高内聚性**。将不同功能逻辑封装在独立的模块中，有助于管理代码的复杂性。模块化设计使得每个模块能够独立开发、测试和维护，从而减少修改一个模块时对其他模块的影响。这种设计通过分而治之的方式，使得项目结构更为清晰、可扩展和易于维护。

#### 1.1 什么是模块化设计？

模块化设计是指将一个复杂的系统拆分成多个小型、独立的模块，每个模块专注于解决一个具体的问题或提供某种服务。每个模块都具备清晰的**接口**（接口定义模块之间的交互方式），并隐藏其内部实现的细节。模块之间通过接口进行通信，而非直接依赖彼此的内部逻辑。

例如，在游戏开发中，可以将一个游戏系统划分为“渲染模块”、“物理引擎模块”、“音频模块”等。这些模块彼此独立工作，各自负责不同的功能。

#### 1.2 模块化设计的意义与作用

模块化设计在软件开发中有以下几个关键作用：

1. **降低系统复杂度**：将复杂的系统划分为较小的模块，使得每个模块的逻辑更加单一和清晰，简化了开发、调试和维护的过程。
   
2. **提高代码可维护性**：每个模块独立开发和测试，减少了模块间的耦合度。当需要修改或扩展某个功能时，通常只需修改对应的模块，不影响整个系统的稳定性。

3. **促进代码复用**：模块可以在不同的项目中重复使用。通过合理设计模块的接口和抽象层，开发者可以将某些通用模块应用于多个不同的场景。
   
4. **并行开发**：不同模块可以由不同团队或开发人员同时进行开发。由于模块之间通过接口隔离，团队可以独立工作，降低协作中的复杂性。

5. **易于扩展**：当系统需要添加新功能时，只需增加新的模块，现有模块不需要修改。这使得模块化设计具有很好的扩展性，适合长期维护和迭代的项目。

#### 1.3 模块化设计的思想

模块化设计背后的主要思想是**分而治之**。它鼓励将一个复杂的问题分解为若干个独立的小问题。通过将这些小问题分别封装成模块，系统可以更好地应对变化和复杂性。

模块化设计的几个核心思想包括：

1. **高内聚**：每个模块内部应该具备单一职责，确保模块内的功能紧密相关。内聚度高的模块容易理解、测试和维护。

2. **低耦合**：模块之间的相互依赖应该尽可能少。低耦合意味着模块可以独立地被开发、修改或替换，而不会影响其他模块的功能。这种设计使系统具有较高的灵活性和扩展性。

3. **信息隐藏**：模块只通过公开的接口与外界进行交互，隐藏其内部的实现细节。外部模块不需要知道模块的内部工作原理，只需要知道如何通过接口与其交互。

4. **接口设计**：接口应当简单、稳定且易于使用。接口的设计应注重抽象，确保外部模块可以通过接口使用模块的功能，而不暴露模块的内部实现。这一原则在 C++ 中通过头文件与源文件的分离得以体现。

#### 1.4 模块化设计的实现方式

在 C++ 中，模块化设计通常通过头文件与源文件的分离来实现：

- **头文件（.h/.hpp 文件）**：头文件负责模块的接口声明，提供了类、函数、常量等的声明信息，但不包括具体的实现。其他模块通过包含头文件来了解模块的功能，并通过接口进行调用。头文件定义了模块的对外“契约”，但隐藏了实现细节。

- **源文件（.cpp 文件）**：源文件负责头文件中声明的接口的具体实现。源文件包含模块内部的逻辑，只有在编译时才会链接到其他模块。源文件的独立实现确保了系统在不改变外部接口的情况下能够对内部进行修改和优化。

模块化设计的另一种常见方式是通过使用**命名空间**（namespace）来组织代码，避免命名冲突。例如：
```cpp
namespace Graphics {
    void draw() {
        // 绘制图形的具体实现
    }
}

namespace Audio {
    void play() {
        // 播放音频的具体实现
    }
}
```

每个命名空间代表一个模块，它们通过命名空间内的函数和类提供各自的功能。

此外，模块化设计还可以通过**依赖倒置原则（Dependency Inversion Principle, DIP）**来实现。DIP 建议高层模块不应该依赖低层模块，二者应该依赖于抽象接口。通过这种方式，可以将实现细节与模块逻辑分离，使得模块更具灵活性。

#### 总结

模块化设计是一种应对系统复杂性的有效策略。它通过将系统划分为独立的模块，实现了功能的分离与封装。每个模块通过简洁稳定的接口与其他模块交互，而隐藏其内部实现。这样的设计提高了系统的可维护性、可扩展性、灵活性，并为大规模软件开发提供了良好的架构基础。

### 2. **信息隐藏与接口设计**

**信息隐藏**（Information Hiding）是模块化设计中的核心原则之一。头文件只公开必要的接口，隐藏模块的内部实现细节。这样的设计提高了模块的独立性，允许模块的实现发生变化而不影响使用该模块的其他部分。通过隐藏实现细节，模块之间的耦合度大大降低。

**接口的设计**应当简洁且稳定，确保外部模块通过头文件中的声明与功能进行交互，而不需要关心实现的具体方式。这种接口与实现的分离使得系统更具弹性，模块的更新和扩展也更为容易。

#### 2.1 信息隐藏原则

- **定义**：信息隐藏是指模块的内部状态和实现细节对外部不可见，只提供有限的接口供外部交互。 
- **实现方式**：在 C++ 中，可以通过使用类的私有（`private`）成员和公共（`public`）接口来实现信息隐藏。

  ```cpp
  // MyClass.h
  class MyClass {
  private:
      int data; // 私有成员，隐藏实现细节
  
  public:
      MyClass(int val); // 构造函数，公共接口
      void setData(int val); // 公共接口
      int getData() const; // 公共接口
  };
  ```

在这个例子中，`data` 成员是私有的，外部无法直接访问。所有对 `data` 的操作必须通过公共接口 `setData` 和 `getData` 来进行。

#### 2.2 接口设计原则

- **定义**：接口设计指的是如何设计模块对外暴露的API，以便其他模块可以安全、有效地与之交互。
- **实现方式**：设计清晰、简洁、稳定的接口，使其易于使用和理解。

  ```cpp
  // MyClass.h
  class MyClass {
  public:
      MyClass(int val); // 构造函数
      void setData(int val); // 设置数据
      int getData() const; // 获取数据
  };
  
  // MyClass.cpp
  #include "MyClass.h"
  
  MyClass::MyClass(int val) : data(val) {}
  
  void MyClass::setData(int val) {
      data = val;
  }
  
  int MyClass::getData() const {
      return data;
  }
  ```

在此例中，接口清晰易懂，用户无需了解 `data` 的具体实现即可进行操作。



### 3. **依赖管理与耦合度控制**

在大型项目中，**依赖管理**变得尤为重要。循环依赖（circular dependencies）会增加模块间的耦合，使得系统变得难以维护和扩展。因此，良好的模块化设计应尽可能减少模块间的依赖，并通过**依赖倒置原则（Dependency Inversion Principle, DIP）**与**前向声明**（forward declaration）等手段来打破直接依赖关系。



#### 3.1 依赖管理原则

- **定义**：依赖管理是通过合理设计模块之间的依赖关系，确保模块之间的相互独立性，避免紧耦合。
- **实现方式**：

  - **前置声明**：通过前置声明减少头文件的依赖关系。

    ```cpp
    // ModuleA.h
    class ModuleB; // 前置声明

    class ModuleA {
    public:
        void process(ModuleB* b); // 只需知道 ModuleB 的存在，不需完整定义
    };
    ```

  - **使用接口**：通过接口或抽象类来定义模块间的交互，进一步降低耦合。

    ```cpp
    // IModule.h
    class IModule {
    public:
        virtual void execute() = 0; // 纯虚函数，定义接口
    };
    
    // ModuleA.h
    #include "IModule.h"
    
    class ModuleA : public IModule {
    public:
        void execute() override; // 实现接口
    };
    ```

#### 3.2 耦合度控制原则

- **定义**：耦合度控制是指控制模块间的依赖程度，降低模块间的耦合，以增强系统的灵活性和可维护性。
- **实现方式**：

  - **使用接口和抽象类**：确保高层模块只依赖于接口，而不是具体实现。

    ```cpp
    // ModuleB.h
    #include "IModule.h"
    
    class ModuleB : public IModule {
    public:
        void execute() override; // 实现接口
    };
    
    // ModuleA.cpp
    #include "ModuleA.h"
    #include "ModuleB.h"
    
    void ModuleA::process(IModule* module) {
        module->execute(); // 依赖于接口，而非具体实现
    }
    ```



### 4. **编译时间与可扩展性**

C++头文件与源文件分离设计在优化**编译时间**上也具有重要作用。在大型项目中，如果所有实现都包含在头文件中，任何细微的修改都会导致整个项目的重新编译。而通过将实现部分放在源文件中，只有在实现发生改变时才需要重新编译源文件，这大大提高了开发效率。

此外，通过减少不必要的头文件依赖，系统能够更快地适应变化，提高了可扩展性和灵活性。这样的设计不仅可以优化编译时间，还能使项目具备更强的可维护性，开发者在对系统进行功能扩展或修改时，不需要担心大规模的编译和联动变化。



#### 4.1 编译时间原则

- **定义**：编译时间是指在源代码被编译为可执行文件所需的时间，影响因素包括代码的复杂性和依赖关系。
- **实现方式**：

  - **分离声明和定义**：将函数和类的声明放在头文件中，定义放在源文件中。

    ```cpp
    // MyClass.h
    class MyClass {
    public:
        void myFunction(); // 声明
    };

    // MyClass.cpp
    #include "MyClass.h"

    void MyClass::myFunction() {
        // 实现
    }
    ```

  - **减少不必要的包含**：使用前置声明来避免包含不必要的头文件，从而减少编译时间。

    ```cpp
    // MyClass.h
    class AnotherClass; // 前置声明
    
    class MyClass {
    public:
        void process(AnotherClass* obj); // 只需要指针，无需完整定义
    };
    ```

#### 4.2 可扩展性原则

- **定义**：可扩展性是指系统能够在不影响现有功能的前提下，方便地增加新功能或修改现有功能的能力。
- **实现方式**：

  - **使用接口**：通过接口设计，能够方便地扩展功能而不影响其他模块。

    ```cpp
    // IShape.h
    class IShape {
    public:
        virtual void draw() = 0; // 纯虚函数
    };

    // Circle.h
    #include "IShape.h"

    class Circle : public IShape {
    public:
        void draw() override; // 实现接口
    };

    // Square.h
    #include "IShape.h"

    class Square : public IShape {
    public:
        void draw() override; // 实现接口
    };
    ```

  - **遵循开放封闭原则**：模块应对扩展开放，对修改封闭。可以通过添加新模块来扩展系统功能，而不需修改现有模块的代码。



### 5. **模块间通信与依赖倒置**

在模块化设计中，模块之间的通信应通过接口来实现，而不是直接依赖其他模块的实现细节。使用**依赖倒置**的思想，低层模块不应该直接依赖于高层模块，二者都应依赖于抽象接口。这种设计可以使得系统具有更好的灵活性。



#### 5.1 模块间通信原则

- **定义**：模块间通信是指不同模块之间如何有效地交换信息和调用功能。
- **实现方式**：

  - **直接调用**：一个模块可以直接调用另一个模块的公共方法。

    ```cpp
    // ModuleA.h
    #include "ModuleB.h"

    class ModuleA {
    public:
        void doSomething(ModuleB& b); // 直接调用ModuleB的方法
    };
    ```

  - **事件驱动**：通过事件和回调机制进行模块间通信，降低耦合度。

    ```cpp
    // Event.h
    class Event {
    public:
        virtual void trigger() = 0; // 事件触发接口
    };
    
    // ModuleA.h
    class ModuleA : public Event {
    public:
        void trigger() override; // 实现事件触发
    };
    ```

#### 5.2 依赖倒置原则

- **定义**：依赖倒置原则（DIP）强调高层模块不应依赖于低层模块，而应依赖于抽象接口。
- **实现方式**：

  - **定义接口**：通过定义接口，确保高层模块只依赖于抽象，而非具体实现。

    ```cpp
    // ILogger.h
    class ILogger {
    public:
        virtual void log(const std::string& message) = 0; // 日志接口
    };

    // ModuleA.h
    #include "ILogger.h"

    class ModuleA {
    private:
        ILogger* logger; // 依赖抽象接口

    public:
        ModuleA(ILogger* logger) : logger(logger) {} // 通过构造函数注入依赖
        void performAction() {
            logger->log("Action performed");
        }
    };
    ```

  - **使用依赖注入**：通过构造函数或其他方法注入具体实现，确保高层模块与低层模块的解耦。

    ```cpp
    // ConsoleLogger.h
    #include "ILogger.h"
    
    class ConsoleLogger : public ILogger {
    public:
        void log(const std::string& message) override {
            std::cout << message << std::endl; // 实现日志记录
        }
    };
    
    // main.cpp
    int main() {
        ConsoleLogger logger;
        ModuleA module(&logger); // 注入依赖
        module.performAction();
        return 0;
    }
    ```



### 6.头文件与源文件在模块化设计的职责

#### 6.1 **头文件的职责**

在模块化设计中，头文件的核心职责是提供模块的**接口**声明。它定义了模块对外暴露的功能和接口，而不涉及具体的实现。头文件通过向外部模块提供抽象接口，实现了**信息隐藏**和**降低耦合**的目标。

头文件的主要职责包括：

- **声明接口**：头文件定义类、函数、常量等的声明，向其他模块提供交互的接口。其他模块通过包含头文件来调用其声明的功能，而不需要了解实现细节。
  
  例如：
  ```cpp
  // MyClass.h
  class MyClass {
  public:
      void doSomething();  // 只声明，不实现
  };
  ```

- **提供抽象**：头文件通过接口的声明来提供抽象，使得模块间的依赖仅限于接口层，而不是具体的实现层。这种设计确保了模块可以互相独立开发和测试，极大减少了相互之间的耦合。

- **依赖管理**：头文件负责处理依赖关系，决定模块需要包含哪些其他模块的头文件或前向声明。使用前向声明可以避免循环依赖，减少头文件之间的复杂依赖关系。例如：
  ```cpp
  class AnotherClass;  // 前向声明
  class MyClass {
  public:
      void process(AnotherClass* obj);  // 只需声明指针或引用
  };
  ```

- **定义常量与宏**：头文件通常包含全局常量和宏定义，这些信息通常需要在多个源文件中共享。虽然应谨慎使用宏，但常量和编译期配置在头文件中的定义是合理的。

- **防止重复包含**：头文件通过“**include guards**”或`#pragma once`指令防止同一个头文件被多次包含。这是为了避免重复声明导致的编译错误。
  
  例如：
  ```cpp
  #ifndef MYCLASS_H
  #define MYCLASS_H
  
  class MyClass {
      // 类的声明
  };
  
  #endif  // MYCLASS_H
  ```

头文件作为模块与模块之间的**契约**，应保持接口的简洁与稳定，避免将实现细节暴露给外部模块，从而确保高内聚和低耦合的设计目标。

#### 6.2 **源文件的职责**

源文件的职责是实现头文件中声明的具体逻辑，它承担了模块的**实现**部分。与头文件不同，源文件并不直接面向外部模块，它的主要任务是完成功能逻辑的具体细节实现。源文件通过实现这些逻辑来满足头文件中声明的接口要求。

源文件的主要职责包括：

- **实现接口**：源文件负责实现头文件中声明的类、函数或其他接口。例如：
  ```cpp
  // MyClass.cpp
  #include "MyClass.h"
  
  void MyClass::doSomething() {
      // 具体的实现逻辑
  }
  ```

- **隐藏实现细节**：源文件中的实现细节通常是模块的内部逻辑，不需要被外部模块所知。通过将实现逻辑封装在源文件中，可以有效地进行信息隐藏，这样外部模块只依赖于头文件中的接口，而不会受到实现细节的影响。

- **模块间解耦**：源文件通过包含头文件来获得其他模块的声明，必要时实现模块间的通信。源文件的编译独立于其他模块的实现，只需在编译时链接已编译的目标文件。这种设计解耦了模块之间的依赖链，确保代码的修改和扩展不会轻易打破系统的稳定性。

- **减少编译开销**：源文件中的实现修改通常只会影响当前源文件的编译，而不会波及整个项目。这种职责分离大大减少了编译时间，尤其是在大型项目中，如果所有实现都写在头文件里，任何细微的变化都会导致大规模的重新编译。

- **单一职责原则**：在源文件中实现具体的类或功能时，应遵循单一职责原则，即一个源文件应尽量只实现一种功能或一类功能逻辑。这样有助于提高模块的内聚性，降低模块的复杂度和耦合度。

- **防止命名冲突**：源文件中的全局变量、函数等实现应当尽量避免直接暴露给全局命名空间。通过将实现封装在特定的命名空间中或局部变量中，可以避免全局命名冲突。

源文件的设计应当注重实现的独立性和灵活性，确保实现细节与接口的分离，增强模块的可维护性和可扩展性。



头文件与源文件的职责分离是C++中模块化设计的核心。头文件负责**声明**模块的对外接口，确保模块间的低耦合与高内聚；而源文件则负责**实现**具体的功能逻辑，确保实现细节被封装和隐藏。通过这种职责分离，模块间的依赖关系被有效管理，系统可以在高效、稳定的基础上灵活扩展与维护。



### 7. **总结**

头文件与源文件分离的设计不仅仅是编译过程中的技术规范，更是**降低耦合、提高模块独立性**的设计思想的体现。通过模块化的设计，接口与实现的分离、信息隐藏、依赖管理以及编译优化等手段，使得复杂系统的开发、扩展与维护变得更为可控。

这种设计原则为项目提供了清晰的组织结构，使得代码更加易于理解和管理。在软件工程中，模块化与分离设计为应对复杂度提供了有力的工具，确保系统在不断扩展的过程中保持灵活和高效。



代码参考：Voidmatrix、ChatGPT

项目教程：【【从零开始的C++游戏开发】船新版本的植物VS植物大乱斗 | EasyX制作植物明星大乱斗】https://www.bilibili.com/video/BV1jx4y1t7eP?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642