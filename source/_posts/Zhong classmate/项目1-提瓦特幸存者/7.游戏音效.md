---
title: 游戏音效
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 游戏音效

## `Winmm.lib`链接库

`Winmm.lib` 是 Windows 多媒体库（Windows Multimedia Library）的链接库文件，提供了许多与多媒体相关的功能，如音频播放、MIDI 音乐控制、定时器以及与游戏和视频相关的多媒体功能。



### `PlaySound()` 函数

`PlaySound()` 函数是 `Windows API`中用于播放声音的函数，它可以播放波形音频（`WAV` 文件），支持从内存、文件或资源中加载音频。

#### 函数原型
```cpp
BOOL PlaySound(
    LPCSTR pszSound,   // 指向声音的文件名、资源名称或内存地址
    HMODULE hmod,      // 模块句柄，用于查找声音资源。如果从文件或内存播放声音，则为 NULL
    DWORD fdwSound     // 控制声音播放行为的标志
);
```

#### 参数说明
1. **`pszSound`**：指向声音的来源，可以是文件路径、资源标识符或内存块。
   - 如果是文件名，指定 `WAV`文件的路径。
   - 如果是内存中的声音数据，`fdwSound` 必须包含 `SND_MEMORY` 标志。
   - 如果是资源，则 `hmod` 参数指向包含该资源的模块，`pszSound` 是资源的名称或标识符。

2. **`hmod`**：当从文件或内存中播放声音时，这个参数应该是 `NULL`。如果是从资源中播放声音，`hmod` 指向包含声音资源的模块句柄。

3. **`fdwSound`**：控制声音播放行为的标志位。可以通过按位或（`|`）组合多个标志。

#### 常用标志
- **`SND_FILENAME`**：`pszSound` 是一个文件名，指向要播放的 `WAV` 文件。
- **`SND_RESOURCE`**：`pszSound` 是资源的名称，`hmod` 是模块句柄。
- **`SND_MEMORY`**：声音从内存中播放。
- **`SND_ASYNC`**：声音以异步方式播放，不会阻塞程序执行。程序会立即返回，而声音继续播放。
- **`SND_SYNC`**：声音以同步方式播放，函数会等到声音播放完毕后才返回。
- **`SND_LOOP`**：循环播放声音，必须与 `SND_ASYNC` 一起使用。使用 `PlaySound(NULL, 0, 0)` 来停止循环。
- **`SND_NOSTOP`**：如果当前正在播放其他声音，`PlaySound()` 不会停止它们。

#### 返回值
- **`TRUE`**：如果声音播放成功，返回 `TRUE`。
- **`FALSE`**：如果发生错误，返回 `FALSE`。

#### 示例
以下代码展示了如何使用 `PlaySound()` 函数来播放一个 `WAV` 文件：
```cpp
#include <windows.h>
#include <mmsystem.h>
#pragma comment(lib, "Winmm.lib")

int main() {
    // 同步播放音频文件，直到音频播放完毕后才继续执行
    PlaySound(TEXT("sound.wav"), NULL, SND_FILENAME | SND_SYNC);

    // 异步播放音频文件，程序会立即继续执行，而不等待音频播放完毕
    PlaySound(TEXT("sound.wav"), NULL, SND_FILENAME | SND_ASYNC);

    // 停止播放当前正在播放的声音
    PlaySound(NULL, NULL, 0);

    return 0;
}
```

#### 说明
1. **同步和异步**：
   - `SND_SYNC`：同步播放，会阻塞程序，直到声音播放完毕。
   - `SND_ASYNC`：异步播放，函数会立即返回，声音继续播放。

2. **停止播放**：
   - 调用 `PlaySound(NULL, NULL, 0)` 可以停止当前播放的声音。

3. **循环播放**：
   
   - 要循环播放声音，可以使用 `SND_LOOP` 和 `SND_ASYNC`，例如：
     ```cpp
     PlaySound(TEXT("sound.wav"), NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
     ```
   
4. **播放资源中的声音**：
   
   - 如果声音是应用程序资源的一部分，你可以使用 `SND_RESOURCE` 来播放它。假设资源 ID 是 `IDR_WAVE1`：
     ```cpp
     PlaySound(MAKEINTRESOURCE(IDR_WAVE1), GetModuleHandle(NULL), SND_RESOURCE | SND_ASYNC);
     ```

#### 常见用途
- 在游戏或应用程序中播放简单的音效。
- 实现通知或提示音。
- 在多媒体应用中播放简单的声音文件。

`PlaySound()` 是一种简单且方便的声音播放函数，适用于播放基本的 `WAV` 文件或资源中的音效。



#### 补充

##### `TEXT()`宏 和 `_T()` 宏

`_T()` 和 `TEXT()` 都是用于处理字符串字面量的宏，主要在 `Windows API` 编程中使用，以支持 ANSI 和 Unicode 字符集之间的转换。它们的功能相似，但用法和定义略有不同。

###### 1. `TEXT()` 宏
`TEXT()` 是 `Windows API` 提供的一个宏，用于确保字符串字面量在不同字符集之间自适应。它的定义方式如下：

```cpp
#ifdef UNICODE
    #define TEXT(s) L ## s
#else
    #define TEXT(s) s
#endif
```

- **用途**：确保字符串在定义为宽字符（Unicode）或普通字符（ANSI）时能够正确处理。
- **示例**：
    ```cpp
    MessageBox(NULL, TEXT("Hello, World!"), TEXT("Greeting"), MB_OK);
    ```

###### 2. `_T()` 宏
`_T()` 是由 Microsoft 提供的另一种宏，也用于处理字符串字面量的 ANSI 和 Unicode 适配。它通常在 `Windows SDK` 中定义，与 `TEXT()` 宏的功能相似。它的定义方式如下：

```cpp
#ifdef UNICODE
    #define _T(s) L ## s
#else
    #define _T(s) s
#endif
```

- **用途**：同样确保字符串在不同字符集之间自适应，广泛用于 Microsoft 的编程库和项目中。
- **示例**：
    ```cpp
    MessageBox(NULL, _T("Hello, World!"), _T("Greeting"), MB_OK);
    ```

###### 主要区别
1. **名称**：
   - `TEXT()` 是 Windows API 的宏，通常用于 Windows 特定的编程环境。
   - `_T()` 是 Microsoft C 运行库中的宏，主要用于 Microsoft Visual Studio 环境。

2. **使用场景**：
   - 二者在功能上几乎相同，通常可以互换使用。
   - 在代码中选择使用 `TEXT()` 还是 `_T()` 主要取决于个人或团队的编码风格和习惯。

###### 选择使用
- 在 `Windows API` 编程中，你可以选择使用 `TEXT()` 或 `_T()`，两者都能实现字符串的 Unicode 和 ANSI 适配。
- 如果你的代码中同时使用了其他 Microsoft 库，使用 `_T()` 可能会更一致。
- 确保在整个项目中保持一致性，选择其中一种宏来处理字符串，以避免混淆。

###### 例子
下面的代码示例演示了这两个宏的使用：

```cpp
#include <windows.h>
#include <tchar.h>  // 需要包含此头文件以使用 _T() 宏

int main() {
    // 使用 TEXT() 宏
    MessageBox(NULL, TEXT("Hello, World!"), TEXT("Greeting"), MB_OK);
    
    // 使用 _T() 宏
    MessageBox(NULL, _T("Hello, World!"), _T("Greeting"), MB_OK);
    
    return 0;
}
```

###### 总结
`TEXT()` 和 `_T()` 的作用相同，都是为了在 ANSI 和 Unicode 字符集之间自适应字符串的处理。选择使用哪一个宏主要取决于个人或团队的编码风格。





### `mciSendString()`函数

`mciSendString` 是 Windows 多媒体系统中的一个函数，用于向 MCI（Media Control Interface，媒体控制接口）设备发送命令字符串，以执行多媒体操作，比如播放、暂停、停止音频或视频文件等。MCI 是一个高级接口，用于控制多种多媒体设备。

#### 函数原型
```cpp
MCIERROR mciSendString(
    LPCTSTR lpszCommand,   // MCI 命令字符串
    LPTSTR lpszReturnString,   // 用于存放返回信息的缓冲区
    UINT cchReturn,   // 缓冲区的大小，以字符为单位
    HANDLE hwndCallback   // 回调窗口的句柄（用于通知消息）
);
```

#### 参数说明
1. **`lpszCommand`**：包含 MCI 命令的字符串。你可以在此发送控制命令，如 "play"、"open"、"pause" 等。
   
2. **`lpszReturnString`**：如果命令产生返回信息，该信息会存储在此缓冲区中。可以为 `NULL`，如果你不关心返回值。

3. **`cchReturn`**：指定 `lpszReturnString` 缓冲区的大小（字符数）。如果 `lpszReturnString` 为 `NULL`，则该参数为 0。

4. **`hwndCallback`**：当使用异步命令时，可以提供一个窗口句柄来接收通知消息。否则为 `NULL`。

#### 返回值
返回一个 `MCIERROR` 类型的值。如果返回值为 0，表示命令成功。如果失败，返回非 0 值，可以通过 `mciGetErrorString()` 函数获取错误描述。

#### 常见命令格式

##### 命令语法与实例

1. **打开设备（Open）**
   - **语法**: `"open <filename> type <type> alias <alias>"`
   - **示例**:
     
     ```cpp
     mciSendString("open audio\example.mp3 type mpegvideo alias myAudio", NULL, 0, NULL);
     //打开当前目录的文件夹audio中的example.mp3
     ```
   - **解释**: 
     
     - `<filename>`: 要打开的媒体文件的路径。
     - `<type>`: 媒体类型，如 `mpegvideo`、`waveaudio` 等。
     - `<alias>`: 为设备指定一个别名，以便后续引用。
   
2. **播放设备（Play）**
   
   - **语法1**: `"play <alias> [from <start>] [to <end>]"`
   
     - **示例**:
   
     ```cpp
     mciSendString("play myAudio", NULL, 0, NULL);
     mciSendString("play myAudio from 10000", NULL, 0, NULL);  // 从10秒开始播放
     mciSendString("play myAudio to 30000", NULL, 0, NULL);  // 播放到30秒停止
     ```
   
     - **解释**:
       - `<alias>`: 在打开命令中指定的设备别名。
       - `[from <start>]`: 可选参数，指定从某个时间开始播放（单位为毫秒）。
       - `[to <end>]`: 可选参数，指定播放结束的时间（单位为毫秒）。
     
   - **语法2**: `"play <alias> repeat [from <start>] [to <end>]"`
   
     - **示例**:
   
     ```cpp
     mciSendString("play bgm repeat from 0", NULL, 0, NULL);
     ```
   
     - **解释**:
       - `<alias>`: 在打开命令中指定的设备别名。
       - `repeat`:循环播放音乐
       - `[from <start>]`: 可选参数，指定从某个时间开始播放（单位为毫秒）。
       - `[to <end>]`: 可选参数，指定播放结束的时间（单位为毫秒）。
   
3. **暂停播放（Pause）**
   
   - **语法**: `"pause <alias>"`
   - **示例**:
     ```cpp
     mciSendString("pause myAudio", NULL, 0, NULL);
     ```
   
4. **停止播放（Stop）**
   - **语法**: `stop <alias>`
   - **示例**:
     ```cpp
     mciSendString("stop myAudio", NULL, 0, NULL);
     ```

5. **关闭设备（Close）**
   - **语法**: `close <alias>`
   - **示例**:
     ```cpp
     mciSendString("close myAudio", NULL, 0, NULL);
     ```

6. **获取设备状态（Status）**
   - **语法**: `status <alias> <status> [return <var>]`
   - **示例**:
     ```cpp
     char buffer[128];
     mciSendString("status myAudio length return buffer", buffer, sizeof(buffer), NULL);
     ```
   - **解释**:
     - `<status>`: 要查询的状态类型，例如 `length`（媒体长度）、`position`（当前播放位置）等。
     - `[return <var>]`: 可选参数，指定一个变量来接收返回值。

##### 注意事项

- **命令区分大小写**: MCI 命令不区分大小写，但参数（如文件名）可能区分。
- **使用引号**: 在命令中使用引号包围文件名或包含空格的别名，以确保字符串的正确解析。
- **错误处理**: 在发送命令后，可以通过检查返回值（非零表示错误）并使用 `mciGetErrorString` 函数获取详细的错误信息。

##### 示例完整命令

```cpp
mciSendString("open audio\example.mp3 type mpegvideo alias myAudio", NULL, 0, NULL);
mciSendString("play myAudio", NULL, 0, NULL);
mciSendString("pause myAudio", NULL, 0, NULL);
mciSendString("stop myAudio", NULL, 0, NULL);
mciSendString("close myAudio", NULL, 0, NULL);
```

#### 示例代码
下面是一个简单的示例，展示如何使用 `mciSendString` 打开并播放 `MP3` 文件：

```cpp
#include <windows.h>
#include <mmsystem.h>
#pragma comment(lib, "Winmm.lib")

int main() {
    // 打开 MP3 文件
    mciSendString("open sound.mp3 type mpegvideo alias mymusic", NULL, 0, NULL);
    
    // 播放 MP3 文件
    mciSendString("play mymusic", NULL, 0, NULL);

    // 暂停一下，让音乐播放一段时间
    Sleep(5000);

    // 关闭 MP3 文件
    mciSendString("close mymusic", NULL, 0, NULL);
    
    return 0;
}
```

#### 常见错误处理
如果 `mciSendString` 返回非 0 的错误代码，可以使用 `mciGetErrorString` 获取错误描述：
```cpp
MCIERROR error;
TCHAR errorMessage[128];
error = mciSendString("play mymusic", NULL, 0, NULL);
if (error) {
    mciGetErrorString(error, errorMessage, sizeof(errorMessage) / sizeof(TCHAR));
    printf("Error: %s\n", errorMessage);
}
```

#### 应用场景
- 播放音频或视频文件（如 `MP3`、`WAV`、`MIDI`、`AVI`等）。
- 控制播放进度、暂停、停止等多媒体操作。
- 管理媒体文件的打开和关闭。

`mciSendString` 提供了一种简单的方式来控制多种类型的媒体文件，适合开发需要简单多媒体控制功能的应用。





代码参考：Voidmatrix、ChatGPT、C++文档

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642
