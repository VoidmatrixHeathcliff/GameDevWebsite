---
title: 游戏设计模式
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 设计模式

## 1.享元模式（Flyweight Pattern）

- **定义**：**享元模式**是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。
- **目的**：主要用于减少内存使用，通过共享对象来支持大量细粒度的对象。
- **实现**：通过将对象的状态分为内部状态（可共享）和外部状态（特定于对象），并使用享元工厂来管理共享对象。
- **适用场景**：适合需要大量相似对象的场景，如图形应用、文本编辑器等。

### 1.1 享元模式的结构

1. **外部状态和内部状态**

   享元模式将需要重复使用的对象分为两个部分：**内部状态**和**外部状态**。

   - **内部状态**是不会变化的，可以被多个对象共享

   - **外部状态**会随着对象的使用而改变。不被其他对象共享。

   比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。

2. **享元工厂（Flyweight Factory）**: 负责创建和管理享元对象的工厂，确保享元对象的共享。

**模式的结构**

享元模式的主要角色有如下。

1. 抽象享元角色（`Flyweight`）：所有的具体享元类的基类（具体享元角色的接口或抽象类），为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
2. 具体享元角色（`Concrete Flyweight`）：实现了抽象享元角色的接口的具体享元角色类，保存内部状态。
3. 非享元角色（`Unsharable Flyweight`)：非享元角色类是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
4. 享元工厂（`Flyweight Factory`）：负责管理享元角色类的对象创建和共享。根据请求返回已存在的享元对象或创建新的享元对象。

![](articles/Zhong classmate/项目1-提瓦特幸存者/image//2.png)

如上图享元模式的结构图，其中：

- `UnsharedConcreteFlyweight` 是非享元角色，里面包含了非共享的外部状态信息 info；
- `Flyweight` 是抽象享元角色，里面包含了享元方法 operation(`UnsharedConcreteFlyweight state`)，非享元的外部状态以参数的形式通过该方法传入；
- `ConcreteFlyweight` 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；
- `FlyweightFactory` 是享元工厂角色，它是关键字 key 来管理具体享元；
- 客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。



#### C++实现示例代码

这个示例使用 C++ 实现了一个简单的图形绘制程序，其中使用圆形（`Circle`）作为享元对象。颜色作为内部状态，而坐标作为外部状态。

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

// 抽象享元角色接口类
class Shape {
public:
    virtual void DrawCenterPoint(int x, int y) = 0; // 绘制图形中心点


// 具体享元角色类（共享圆形资源类）
class SharedCircle : public Shape {
private:
    std::string color; // 内部状态：圆心共有颜色

public:
    SharedCircle(const std::string& c) : color(c) {}

    //具体享元角色类的接口方法实现
    //绘制图形中心点接口实现—绘制不同颜色中心点
    void DrawCenterPoint(int x, int y) override {
        
    }
};

// 非享元角色类（非共享圆形资源类）
class UnSharedCircle {
public:
    int radius;          // 圆的半径，特定于对象的外部状态
    std::string borderColor; // 边框颜色，特定于对象的外部状态

    UnSharedCircle(int r, const std::string& bc) : radius(r), borderColor(bc) {}
    
    void DrawBorder(int x, int y) {
       
    }
};

// 合并共享圆形资源类与非共享圆形资源类两者资源的的圆形类
class Circle{
private:
    SharedCircle* shared; // 共享的圆形资源
    UnSharedCircle* unshared; // 非共享的圆形资源

public:
    Circle(SharedCircle* shared, int radius, const std::string& borderColor) {
        this->shared=shared;
        unshared = new UnSharedCircle(radius, borderColor);
    }

    ~Circle() {
        delete unshared;  // 仅清理非共享资源(共享资源释放由享元工厂实现)
    }

    void Draw(int x, int y) override {
        shared->DrawCenterPoint(x, y); // 绘制共享资源的中心点颜色
        unshared->DrawBorder(x, y); // 绘制非共享资源的圆形的边框
    }
};

// 享元工厂类—负责管理享元资源
class SharedCircleFactory {
private:
    std::unordered_map<std::string, SharedCircle*> shapes; // 存储共享的图形资源类的示例对象

public:
    // 析构函数
    ~ShapeFactory() {
        for (auto& pair : shapes) {
            delete pair.second; // 清理动态分配的内存
        }
    }

    // 共享资源的创建
    SharedCircle* getCircle(const std::string& color) {
        // 如果颜色的圆不存在，创建一个新的圆
        if (shapes.find(color) == shapes.end()) {
            shapes[color] = new SharedCircle(color); // 创建新的享元对象
        }
        // 返回共享的圆对象
        return shapes[color];
    }
    // 共享资源的删除
    void deleteCircle(const std::string& color);
};

// 客户端代码
int main() 
{
	SharedCircleFactory factory;

    // 获取不同颜色的共享圆
    SharedCircle* redCircle = factory.getCircle("red");
    SharedCircle* blueCircle = factory.getCircle("blue");

    // 创建合并的圆形对象
    Circle* circle1 = new Circle(redCircle, 5, "black");
    Circle* circle2 = new Circle(blueCircle, 10, "green");

    // 绘制圆形
    circle1->Draw(10, 20);
    circle2->Draw(30, 40);

    // 清理内存
    delete circle1;
    delete circle2;

    return 0;
}

```

##### 代码解释

1. **抽象享元角色（`Shape`）**：
   - 定义了一个抽象接口 `Shape`，包含绘制图形中心点的方法 `DrawCenterPoint`。

2. **具体享元角色（`SharedCircle`）**：
   - `SharedCircle` 类实现了 `Shape` 接口，并保存内部状态（颜色）。重载的 `DrawCenterPoint` 方法绘制指定坐标的圆心，并输出其颜色。

3. **非享元角色（`UnSharedCircle`）**：
   - 这个类包含一些特定于对象的属性，如半径和边框颜色。这些属性不能被多个对象共享，属于外部状态。

4. **享元工厂（`SharedCircleFactory`）**：
   - 管理 `SharedCircle` 对象的创建和共享。使用一个哈希表存储已创建的共享圆形资源的对象集合，以避免重复创建相同颜色中心点的圆形。

5. **客户端代码**：
   - 创建 `SharedCircleFactory` 实例，获取共享圆的对象，创建 `Circle` 对象并绘制圆。最后，释放创建的 `Circle` 对象的内存。

##### 内部状态与外部状态

- **内部状态**：
  - 在这个示例中，内部状态是圆的中心点颜色（如“红色”或“绿色”）。这些状态是共享的，多个对象可以使用同样的颜色，而不需要重复存储。

- **外部状态**：
  - 外部状态是圆的位置坐标（如 `(10, 20)`、`(30, 40)` 和 `(50, 60)`）以及非享元角色中的半径和边框颜色。这些状态是特定于对象的，并在调用 `DrawBorder` 方法时传递。不同的坐标和属性可以通过相同的 `SharedCircle` 对象绘制。



### 1.2 享元模式的应用场景

当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。

享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。

前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。

1. 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。
2. 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。
3. 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。



### 1.3 享元模式的扩展

在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。

1. 单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类，其结构图如图所示

   ![](articles/Zhong classmate/项目1-提瓦特幸存者/image//3.png)

2. 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享，其结构图如图所示

   ![](articles/Zhong classmate/项目1-提瓦特幸存者/image//4.png)





## 2. 单例模式（Singleton Pattern）

- **目的**：确保一个类只有一个实例，并提供全局访问点。
- **实现**：通过私有构造函数和静态方法来控制实例的创建，通常使用懒加载或饿汉式加载。
- **适用场景**：适合需要全局唯一实例的场景，如配置管理、日志记录等。



### 2.1 单例模式的实现

1. **构造函数私有化**：将构造函数设为私有，以防止外部实例化对象。
2. **静态成员变量**：定义一个静态的成员变量，用于存储类的唯一实例。
3. **公共静态方法**：提供一个公共的静态方法，用于获取该唯一实例。这个方法会检查实例是否存在，如果不存在则创建一个实例并返回。
4. **禁止复制**：为了避免复制构造和赋值操作，通常会将复制构造函数和赋值操作符设为删除或私有。

下面是一个简单的 C++ 单例模式的示例：

```cpp
#include <iostream>

class Singleton {
private:
    // 私有构造函数
    Singleton() {
        std::cout << "Singleton created!" << std::endl;
    }
    
    // 静态指针，指向唯一实例
    static Singleton* instance;

public:
    // 禁止复制
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 获取唯一实例的公共静态方法
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
};

// 初始化静态成员变量
Singleton* Singleton::instance = nullptr;

int main() {
    // 获取单例实例
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();

    // 验证两个指针指向同一个实例
    if (s1 == s2) {
        std::cout << "Both instances are the same." << std::endl;
    }

    return 0;
}
```

#### 代码解析
- `Singleton` 类的构造函数被声明为私有，这样外部代码无法直接创建实例。
- `instance` 静态成员变量用于存储唯一实例。
- `getInstance` 方法检查 `instance` 是否为空，如果为空则创建新的 `Singleton` 对象。
- 在 `main` 函数中，我们获取两次单例实例，并验证这两个指针指向的是同一个实例。

#### 注意事项
1. **线程安全**：上面的示例不是线程安全的。在多线程环境中，你可能需要使用互斥锁或其他同步机制来确保线程安全。
2. **内存管理**：上面的示例中，实例是通过 `new` 创建的，通常会在程序结束时自动释放，但可以考虑使用智能指针来更好地管理内存。





## 3. 工厂模式（Factory Pattern）

- **概念**：工厂模式是最常用的设计模式之一，它提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。其在父类中提供一个创建对象的方法，定义一个用于创建对象的抽象类或接口类（），让子类决定实例化哪一个类。
- **目的**：提供一个创建对象的接口，而不需要指定具体的类。
- **实现**：通过工厂类来创建对象，通常分为简单工厂、工厂方法和抽象工厂。
- **适用场景**：适合需要创建复杂对象或需要根据条件创建不同对象的场景。



### 3.1 工厂模式的类型

1. **简单工厂模式（Simple Factory Pattern）**：
   - 简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。
   - 简单工厂模式的关键组成部分包括：
     1. **产品接口或抽象类**：定义产品的通用接口，所有具体产品都要实现这个接口或继承抽象类。
     2. **具体产品类**：实现产品接口的具体类，代表不同类型的产品。
     3. **工厂类**：负责创建不同产品的实例，通常包含一个静态方法，根据传入的参数决定创建哪种具体的产品。
2. **工厂方法模式（Factory Method Pattern）**：
   - 工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。
   - 工厂方法模式的关键组成部分包括：
     1. **产品接口**：定义产品的共同特征。
     2. **具体产品类**：实现产品接口的具体类。
     3. **工厂接口**：定义一个创建产品的方法。
     4. **具体工厂类**：实现工厂接口，负责实例化具体产品。
3. **抽象工厂模式（Abstract Factory Pattern）**：
   - 抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。
   - 抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂
   - 抽象工厂模式的主要组成部分：
     1. **抽象工厂**：定义创建一组相关产品的接口，通常包括多个创建产品的方法。
     2. **具体工厂**：实现抽象工厂接口，负责实例化具体产品。
     3. **抽象产品**：定义一组相关产品的接口，所有具体产品都实现这个接口。
     4. **具体产品**：实现抽象产品接口的具体类，代表不同类型的产品。



### 3.2 结构

#### 3.2.1 相关组成

- 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
- 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。

| 组成（角色）                 | 关系                               | 作用                                                  |
| :--------------------------- | :--------------------------------- | :---------------------------------------------------- |
| 抽象产品（Product）          | 具体产品的父类                     | 描述具体产品的公共接口                                |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品                                    |
| 抽象工厂（Creator）          | 具体工厂的父类                     | 描述具体工厂的公共接口                                |
| 具体工厂（Concrete Creator） | 抽象工厂的子类；被外界调用         | 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 |

#### 3.2.2 使用步骤

**步骤1：** 创建**抽象工厂类**，定义具体工厂的公共接口； 
**步骤2：** 创建**抽象产品类** ，定义具体产品的公共接口； 
**步骤3：** 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品； 
**步骤4：**创建**具体工厂类**（继承抽象工厂类），定义创建对应具体产品实例的方法； 
**步骤5：**外界通过调用具体工厂类的方法，从而创建不同**具体产品类的实例**



### 3.3 简单工厂模式的实现方法

1. **定义产品接口**：定义一个产品的接口，所有具体产品都实现这个接口。
2. **实现具体产品类**：实现产品接口的具体类。
3. **创建简单工厂类**：实现一个工厂类，包含一个静态方法用于创建产品。
4. **工厂类对象创建与生成对象**：通过简单工厂类创建工厂对象并实例化产品类对象，而不依赖于具体的产品类。

#### 以下以C++代码为例

```c++
#include <iostream>
#include <memory>

// 1. 定义产品接口
class Product {
public:
    virtual void use() = 0; // 纯虚函数
};

// 2. 具体产品类 - 产品A
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品A" << std::endl;
    }
};

// 3. 具体产品类 - 产品B
class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品B" << std::endl;
    }
};

// 4. 简单工厂类
class SimpleFactory {
public:
    // 创建产品的静态方法
    static std::unique_ptr<Product> createProduct(const std::string& productType) {
        if (productType == "A") {
            return std::make_unique<ConcreteProductA>(); // 创建产品A
        } else if (productType == "B") {
            return std::make_unique<ConcreteProductB>(); // 创建产品B
        }
        return nullptr; // 返回空指针，表示未知产品类型
    }
};

// 5. 工厂类对象创建与生成对象
int main() {
    // 创建产品A
    std::unique_ptr<Product> productA = SimpleFactory::createProduct("A");
    if (productA) {
        productA->use(); // 使用产品A
    }

    // 创建产品B
    std::unique_ptr<Product> productB = SimpleFactory::createProduct("B");
    if (productB) {
        productB->use(); // 使用产品B
    }
    return 0;
}

```



### 3.4 工厂方法模式实现方法

1. **定义产品接口**：为所有的产品定义一个共同的接口或抽象类。
2. **实现具体产品类**：具体的产品类实现产品接口。
3. **定义工厂接口**：定义一个工厂接口，包含一个创建产品对象的抽象方法。
4. **实现具体工厂类**：具体的工厂类实现工厂接口，负责实例化具体的产品。
5. **工厂类对象创建与生成对象**：创建工厂类对象并通过工厂接口获取产品实例，而不依赖于具体的产品类。

#### 以下以C++代码为例

````c++
#include <iostream>
#include <memory>

// 1. 定义产品接口
class Product {
public:
    virtual void use() = 0; // 纯虚函数
};

// 2. 具体产品类 - 产品A
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品A" << std::endl;
    }
};

// 3. 具体产品类 - 产品B
class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品B" << std::endl;
    }
};

// 4. 定义工厂接口
class Factory {
public:
    virtual std::unique_ptr<Product> createProduct() = 0; // 纯虚函数
};

// 5. 具体工厂类 - 工厂A
class ConcreteFactoryA : public Factory {
public:
    std::unique_ptr<Product> createProduct() override {
        return std::make_unique<ConcreteProductA>(); // 创建产品A
    }
};

// 6. 具体工厂类 - 工厂B
class ConcreteFactoryB : public Factory {
public:
    std::unique_ptr<Product> createProduct() override {
        return std::make_unique<ConcreteProductB>(); // 创建产品B
    }
};

// 7. 工厂类对象创建与生成对象
int main() {
    // 创建工厂A
    std::unique_ptr<Factory> factoryA = std::make_unique<ConcreteFactoryA>();
    std::unique_ptr<Product> productA = factoryA->createProduct();
    productA->use(); // 使用产品A

    // 创建工厂B
    std::unique_ptr<Factory> factoryB = std::make_unique<ConcreteFactoryB>();
    std::unique_ptr<Product> productB = factoryB->createProduct();
    productB->use(); // 使用产品B

    return 0;
}

````



### 3.5 抽象工厂模式实现方法

1. **定义抽象产品接口**：为每种产品类型定义一个接口。
2. **实现具体产品类**：为每种产品类型实现多个具体类。
3. **定义抽象工厂接口**：为每种产品类型定义一个工厂接口。
4. **实现具体工厂类**：为每种产品类型创建具体的工厂类，实现抽象工厂接口。
5. **工厂类对象创建与生成对象**：创建工厂类对象并通过工厂接口获取产品实例，而不依赖于具体的产品类。

#### 以下以C++代码为例

```c++
#include <iostream>
#include <memory>

// 1. 抽象产品接口 - 颜色
class Color {
public:
    virtual void fill() = 0; // 纯虚函数
};

// 2. 具体产品类 - 红色
class Red : public Color {
public:
    void fill() override {
        std::cout << "填充红色" << std::endl;
    }
};

// 3. 具体产品类 - 绿色
class Green : public Color {
public:
    void fill() override {
        std::cout << "填充绿色" << std::endl;
    }
};

// 4. 抽象产品接口 - 形状
class Shape {
public:
    virtual void draw() = 0; // 纯虚函数
};

// 5. 具体产品类 - 圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "绘制圆形" << std::endl;
    }
};

// 6. 具体产品类 - 矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "绘制矩形" << std::endl;
    }
};

// 7. 抽象工厂接口
class AbstractFactory {
public:
    virtual std::unique_ptr<Color> createColor() = 0;
    virtual std::unique_ptr<Shape> createShape() = 0;
};

// 8. 具体工厂类 - 颜色工厂
class ColorFactory : public AbstractFactory {
public:
    std::unique_ptr<Color> createColor() override {
        return std::make_unique<Red>(); // 返回具体颜色
    }

    std::unique_ptr<Shape> createShape() override {
        return nullptr; // 不支持形状创建
    }
};

// 9. 具体工厂类 - 形状工厂
class ShapeFactory : public AbstractFactory {
public:
    std::unique_ptr<Color> createColor() override {
        return nullptr; // 不支持颜色创建
    }

    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Circle>(); // 返回具体形状
    }
};

// 10. 工厂类对象创建与生成对象
int main() {
    // 创建颜色工厂
    std::unique_ptr<AbstractFactory> colorFactory = std::make_unique<ColorFactory>();
    std::unique_ptr<Color> red = colorFactory->createColor();
    red->fill();

    // 创建形状工厂
    std::unique_ptr<AbstractFactory> shapeFactory = std::make_unique<ShapeFactory>();
    std::unique_ptr<Shape> circle = shapeFactory->createShape();
    circle->draw();

    return 0;
}
```



## 比较

- **内存管理**：享元模式专注于内存的优化，通过共享对象来减少内存占用；而单例模式则确保只有一个实例存在，工厂模式则关注于对象的创建过程。
- **对象创建**：享元模式通过工厂来管理共享对象的创建，而工厂模式则是专门用于创建对象的。
- **状态管理**：享元模式将状态分为内部和外部，而单例模式和工厂模式通常不涉及状态的管理。





代码参考：Voidmatrix、ChatGPT、C++文档

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642

