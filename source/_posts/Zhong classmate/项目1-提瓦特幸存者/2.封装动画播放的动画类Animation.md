---
title: 封装动画播放的动画类Animation
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 封装动画播放的动画类`Animation`



## `Atlas`序列帧图集类的构造函数与实例化方法

### 构造函数

````c++
Atlas(LPCTSTR path, int num)
	{
		TCHAR path_file[256];
		for (size_t i = 0; i < num; i++)
		{
			_stprintf_s(path_file, _countof(path_file), path, i); // 生成具体序列帧图片的文件路径
			IMAGE* frame = new IMAGE();//声明图片临时变量
			loadimage(frame, path_file);//加载图片
			frame_list.push_back(frame);//加入序列帧图集列表
		}
	}
````

### 实例化

```c++
Atlas* atlas_player_left=new Atlas(
_T("img/player_left_%d.png"),6
);
//Atlas(LPCTSTR path, int num)
//path填_T(" 图片相对地址/图片名前缀+ 字符串'%d' + 字符串'.png'   ")，即图片序列帧通用路径的模板
//num:序列帧数量
```



## `Animation`类

`Animation` 类的是管理和播放游戏中的动画序列类。它通过封装动画帧、动画帧时间间隔和播放逻辑，使得开发者能够方便地控制动画的显示、更新和切换，使游戏图像绘制与渲染规范化管理。

### 基础封装

#### 封装思路

1. **属性封装**：类内部使用私有成员变量（如 `timer`、`idx_frame`、`interval_ms` ）来存储动画的状态和相关信息。以下为动画类必要属性：
   - 计时器 `timer` ：满足指定时间之后计时器归0
   - 动画帧时间间隔 `interval_ms` ：由构造函数传入该动画类实例的动画帧间隔
   - 当前帧索引`idx_frame`
   - 图片资源集合：`Atlas* anim_atlas`
2. **计时器管理**：通过 `timer` 和 `interval_ms` 实现简单的定时控制，确保动画帧按设定间隔切换，从而提供平滑的动画效果。
3. **构造函数**：通过构造函数接收 `Atlas` 图片资源对象和动画帧时间间隔参数，确保该动画绘制实例拥有基础图片资源与绘制所需的逻辑参数
4. **播放逻辑封装**：提供 `Play` 方法来控制动画的播放逻辑，包括根据时间更新当前帧，并调用 `putimage_alpha` 来渲染动画，使得外部调用者只需关心如何播放动画，而不需要了解其内部实现细节。
5. **进阶封装—享元模式下的封装**：`Animation` 类中仅使用公共资源`Atlas`资源（`Atlas`是`Animation` 实例对象之间共享的公共资产），不对`Atlas`资源进行管理（即不管理`Atlas`这类共享资源的释放，而交由更上层的代码控制）

#### 实现细节

````c++
class Animation
{
public:
	Animation(Atlas* atlas, int interval)
	{
		anim_atlas = atlas;
		interval_ms = interval;
	}

	~Animation() = default;

	void Play(int x, int y, int delta)//动画播放函数
	{
		timer += delta;
		if (timer >= interval_ms)//达到指定时间动画处理逻辑
		{
			idx_frame = (idx_frame + 1) % anim_atlas->frame_list.size();//更新当前动画帧索引
			timer = 0;//重置计时器
		}

		putimage_alpha(x, y, anim_atlas->frame_list[idx_frame]);//绘制带透明通道的图片
	}

private:
	int timer = 0;//计时器
	int idx_frame = 0;//当前动画帧索引
	int interval_ms = 0;//动画帧之间时间间隔（固定）

private:
	Atlas* anim_atlas;//图集
};


//putimage_alpha函数定义
#pragma comment(lib, "MSIMG32.LIB")
inline void putimage_alpha(int x, int y, IMAGE* img)//绘制带透明通道的图片
{
	int w = img->getwidth();
	int h = img->getheight();
	AlphaBlend(GetImageHDC(NULL), x, y, w, h,
		GetImageHDC(img), 0, 0, w, h, { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA });
}
````

#### 说明

这个 `Animation` 类表示一个简单的 2D 动画系统，通过从图集（也就是精灵表或图片集合）中循环显示帧，并在给定的时间间隔内播放动画。

##### 类的成员
1. **`int timer`**：累积自上次帧更新以来的时间。
2. **`int idx_frame`**：当前帧的索引。
3. **`int interval_ms`**：帧更新的时间间隔（以毫秒为单位）。
4. **`Atlas* anim_atlas`**：指向 `Atlas` 对象的指针，这个对象包含用于动画的帧（即图像）。

##### 构造函数
```cpp
Animation(Atlas* atlas, int interval)
```
- 参数包括一个 `Atlas* atlas`（包含动画帧的图集）和 `int interval`（帧之间的时间间隔，以毫秒为单位）。
- 初始化图集指针和时间间隔。

##### `Play` 函数
```cpp
void Play(int x, int y, int delta)
```
- **参数**：
  - `int x, y`：在屏幕上绘制当前帧的位置。
  - `int delta`：自上次调用 `Play` 以来经过的时间（以毫秒为单位）。此时间增量用于更新动画计时器。
  
- **逻辑**：
  - `timer` 会累积时间，直到达到或超过 `interval_ms` 值。当时间达到或超过时，帧索引 `idx_frame` 会更新到图集中的下一帧，并在最后一帧后循环回到第一帧。
  - 更新帧后，将 `timer` 重置为 0。
  
- **绘制帧**：
  - 调用 `putimage_alpha(x, y, anim_atlas->frame_list[idx_frame]);`，它可能是在指定的 `(x, y)` 位置绘制当前帧。

##### 析构函数
该类使用了默认的析构函数（`~Animation()`），由于没有动态分配的资源需要明确清理，因此它不需要执行任何操作。

#### 改进建议或额外功能
1. **暂停/恢复**：可以添加一个函数用于暂停和恢复动画。
2. **停止/重启**：添加一个方法来停止动画并将其重置为第一帧。
3. **反向播放/循环控制**：额外的参数以支持动画反向播放或控制是否循环播放。
4. **错误处理**：可以加入一些检查，确保 `anim_atlas` 不为 `nullptr`，并且 `frame_list` 非空。





### 基础封装上的额外功能

#### 实现细节

````c++
class Animation
{
public:
    Animation(Atlas* atlas, int interval, bool loop = true)
        : anim_atlas(atlas), interval_ms(interval), loop(loop)
    {
    }

    ~Animation() = default;

    // 播放动画
    void Play(int x, int y, int delta)
    {
        if (is_paused || !is_playing || anim_atlas == nullptr || anim_atlas->frame_list.empty())
            return;

        timer += delta;
        if (timer >= interval_ms)
        {
            idx_frame++;
            timer = 0;

            if (idx_frame >= anim_atlas->frame_list.size())
            {
                if (loop)
                {
                    idx_frame = 0; // 循环播放
                }
                else
                {
                    idx_frame = anim_atlas->frame_list.size() - 1; // 停留在最后一帧
                    Stop(); // 停止播放
                }
            }
        }

        putimage_alpha(x, y, anim_atlas->frame_list[idx_frame]); // 绘制当前帧
    }

    // 暂停动画
    void Pause()
    {
        is_paused = true;
    }

    // 继续播放动画
    void Resume()
    {
        is_paused = false;
    }

    // 停止动画并重置到第一帧
    void Stop()
    {
        is_playing = false;
        idx_frame = 0;
        timer = 0;
    }

    // 开始播放动画
    void Start()
    {
        is_playing = true;
        is_paused = false;
    }

    // 判断是否正在播放
    bool IsPlaying() const
    {
        return is_playing;
    }

    // 设置动画循环
    void SetLooping(bool should_loop)
    {
        loop = should_loop;
    }

    // 获取当前帧索引
    int GetCurrentFrame() const
    {
        return idx_frame;
    }

private:
    int timer = 0;            // 计时器，记录帧更新的时间
    int idx_frame = 0;        // 当前帧的索引
    int interval_ms = 0;      // 帧与帧之间的时间间隔（毫秒）
    bool loop = true;         // 是否循环播放
    bool is_playing = true;   // 是否正在播放
    bool is_paused = false;   // 是否暂停

    Atlas* anim_atlas = nullptr; // 指向图集的指针
};

````

#### 新增功能

1. **暂停和恢复**：提供 `Pause()` 和 `Resume()` 函数，用于暂停和恢复动画。
2. **停止**：`Stop()` 函数停止动画播放并重置帧和计时器。
3. **循环控制**：可以通过 `SetLooping(bool should_loop)` 来控制动画是否循环播放。
4. **状态检查**：添加了 `IsPlaying()` 方法来检查动画是否正在播放。
5. **帧索引访问**：通过 `GetCurrentFrame()` 可以获取当前的帧索引，便于外部控制。

#### 方法说明

- **`Play`**: 该方法是核心，用于控制动画的帧更新和绘制。它根据 `delta` 时间更新计时器并决定何时切换帧。如果动画完成，且不循环，则会停止播放。
- **`Pause` 和 `Resume`**: 暂停动画会冻结当前帧，而恢复则继续从当前帧开始播放。
- **`Start` 和 `Stop`**: `Start` 开始动画播放，`Stop` 停止播放并重置帧。
- **`SetLooping`**: 控制动画是否循环。





代码参考：Voidmatrix、ChatGPT

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642
