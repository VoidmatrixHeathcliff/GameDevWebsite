---
title: 敌人类与敌人自动生成
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 敌人类与敌人自动生成



## 敌人类

### 封装思路

#### 1.属性封装

类内部使用私有成员变量（如动画类实例对象资源：`Animation* anim_left`、`Animation* anim_right` ;敌人角色朝向方位信息（bool型）：`bool is_move_up`等等）来存储玩家角色的状态和相关资源信息。以下为必要属性：

- 动画类实例对象资源 `Animation*` ：角色的封装的动画类的实例对象，如向左移动或静止的动画`anim_left`、向右移动或静止的动画`anim_right`等
- 角色的状态信息：

  - 坐标信息：`POINT position = { 500, 500 };`//此处初始为（500，500）
  - 敌人角色存活状态信息：`bool alive = true;`
  - 敌人角色朝向方位信息（bool型）：
    - `bool facing_left = false;`//朝向右边
    - `bool facing_left = true;`//朝向左边
  - 角色属性信息（与玩家类类似，如下，建议以浮点型存储加大运算精度）：
    - 生命值`HP`(Hit Point）
    - 魔法值`MP`（Mana Point）
    - 速度`SPEED`
    - 攻击力`ATK`（attack） 
    - 防御力`DEF`（defence）
- 额外图片资源：`IMAGE img_shadow;`//角色阴影图片
- 其他资源相关属性（例如）：

  - 角色主题图片长度（高度）与宽度：
    - `const int FRAME_WIDTH = 80;`// 敌人角色宽度
    - `const int FRAME_HEIGHT = 80;`// 敌人角色高度
  - 角色阴影图片的长度与宽度：`const int SHADOW_WIDTH = 32;`

#### 2.构造函数

构造函数负责初始化敌人对象的各项资源和状态。

- **功能**：初始化敌人对象，加载图像资源并创建动画类对象资源。

- 细节：
  1. `loadimage(&img_shadow, _T("img/shadow_enemy.png"));`：加载敌人阴影图像。
  
  2. `anim_left = new Animation(atlas_enemy_left, 45);` 和 `anim_right = new Animation(atlas_enemy_right, 45);`：创建并初始化敌人的左右动画对象。
  
  3. 敌人随机生成的位置
  
     - 定义敌人生成的边界的枚举类型
     - 使用rand()随机生成函数选取生成的边界
     - 将敌人放置在地图外边界处的随机位置
  
     `````c++
     // 敌人生成边界
     enum class SpawnEdge
     {
     	Up = 0,
     	Down,
     	Left,
     	Right
     };
     
     //使用rand()随机生成函数选取生成的边界
     SpawnEdge edge = (SpawnEdge)(rand() % 4);
     // 将敌人放置在地图外边界处的随机位置
     switch (edge)
     {
     case SpawnEdge::Up:
     	position.x = rand() % WINDOW_WIDTH;
     	position.y = -FRAME_HEIGHT;
     	break;
     case SpawnEdge::Down:
     	position.x = rand() % WINDOW_WIDTH;
     	position.y = WINDOW_HEIGHT;
     	break;
     case SpawnEdge::Left:
     	position.x = -FRAME_WIDTH;
     	position.y = rand() % WINDOW_HEIGHT;
     	break;
     case SpawnEdge::Right:
     	position.x = WINDOW_WIDTH;
     	position.y = rand() % WINDOW_HEIGHT;
     	break;
     default:
     	break;
     }
     `````

#### 3.析构函数

析构函数负责清理动态分配的资源，确保没有内存泄漏。

- **功能**：清理动画对象的内存。
- 细节：
  - 删除 `anim_left` 和 `anim_right`，以释放内存。

#### 4.类方法（使用const引用方式传递参数防止参数不可必要的拷贝构造与无意识的参数修改问题）

1. **`Move(const Player& player)`** 方法

- **功能**：处理敌人的移动逻辑，根据玩家位置更新敌人的坐标。
- 细节：
  - 计算指向玩家的方向向量，并根据 `SPEED` 更新敌人位置。
  - 判断敌人朝向，更新 `facing_left`。

2. 碰撞检测

   - **`CheckBulletCollision(const Bullet& bullet)`** 方法

     - **功能**：检查玩家子弹与敌人之间的碰撞。

     - 细节：
       - 将子弹等效为点，计算子弹坐标位置是否在敌人矩形内。


   - **`CheckPlayerCollision(const Player& player)`** 方法

     - **功能**：检查敌人与玩家之间的碰撞。

     - 细节：
       - 计算敌人中心点位置与玩家的矩形重叠情况。

3. **`Draw(int delta)`** 方法

- **功能**：绘制敌人及其阴影，并播放相应的动画。
- 细节：
  - 计算阴影位置并使用 `putimage_alpha` 绘制阴影。
  - 根据 `facing_left` 判断朝向，调用相应的动画播放方法。

4. **`Hurt()`** 方法
   - **功能**：处理敌人受伤逻辑。
   - 细节：
     - 处理生命值减少逻辑
     - 将生命值归零或为负值的敌人的 `alive` 状态设置为 `false`，表示敌人死亡

#### 5.对外接口

- **`CheckAlive() const`** 方法
  - **功能**：检查敌人是否存活。
  - 细节：
    - 返回 `alive` 的状态。
- 其他接口
  - 提供访问并修改生命值的接口方法





### 封装代码

```c++
class Enemy
{
public:
	Enemy()
	{
		loadimage(&img_shadow, _T("img/shadow_enemy.png"));
		anim_left = new Animation(atlas_enemy_left, 45);
		anim_right = new Animation(atlas_enemy_right, 45);

		// 敌人生成边界
		enum class SpawnEdge
		{
			Up = 0,
			Down,
			Left,
			Right
		};

		//使用rand()随机生成函数选取生成的边界
		SpawnEdge edge = (SpawnEdge)(rand() % 4);
		// 将敌人放置在地图外边界处的随机位置
        switch (edge)
		{
		case SpawnEdge::Up:
			position.x = rand() % WINDOW_WIDTH;
			position.y = -FRAME_HEIGHT;
			break;
		case SpawnEdge::Down:
			position.x = rand() % WINDOW_WIDTH;
			position.y = WINDOW_HEIGHT;
			break;
		case SpawnEdge::Left:
			position.x = -FRAME_WIDTH;
			position.y = rand() % WINDOW_HEIGHT;
			break;
		case SpawnEdge::Right:
			position.x = WINDOW_WIDTH;
			position.y = rand() % WINDOW_HEIGHT;
			break;
		default:
			break;
		}
	}

	~Enemy()
	{
		delete anim_left;
		delete anim_right;
	}

	bool CheckBulletCollision(const Bullet& bullet)
	{
		// 将子弹等效为点，判断点是否在敌人矩形内
		bool is_overlap_x = bullet.position.x >= position.x && bullet.position.x <= position.x + FRAME_WIDTH;
		bool is_overlap_y = bullet.position.y >= position.y && bullet.position.y <= position.y + FRAME_HEIGHT;
		return is_overlap_x && is_overlap_y;
	}

	bool CheckPlayerCollision(const Player& player)
	{
		// 将敌人中心位置等效为点，判断点是否在玩家矩形内
		POINT check_position = { position.x + FRAME_WIDTH / 2, position.y + FRAME_HEIGHT / 2 };
		const POINT& player_position = player.GetPosition();
		bool is_overlap_x = check_position.x >= player_position.x && check_position.x <= player_position.x + player.FRAME_WIDTH;
		bool is_overlap_y = check_position.y >= player_position.y && check_position.y <= player_position.y + player.FRAME_HEIGHT;
		return is_overlap_x && is_overlap_y;
	}

	void Move(const Player& player)
	{
		const POINT& player_position = player.GetPosition();
		int dir_x = player_position.x - position.x;
		int dir_y = player_position.y - position.y;
		double len_dir = sqrt(dir_x * dir_x + dir_y * dir_y);
		if (len_dir != 0)
		{
			double normalized_x = dir_x / len_dir;
			double normalized_y = dir_y / len_dir;
			position.x += (int)(SPEED * normalized_x);
			position.y += (int)(SPEED * normalized_y);
		}

		if (dir_x < 0)
			facing_left = true;
		else if (dir_x > 0)
			facing_left = false;
	}

	void Move(const Player& player,int score)
	{
		if (score >= 20 && score <= 50)this->SPEED = 4;
		if (score > 50 && score <= 100)this->SPEED = 6;
		const POINT& player_position = player.GetPosition();
		int dir_x = player_position.x - position.x;
		int dir_y = player_position.y - position.y;
		double len_dir = sqrt(dir_x * dir_x + dir_y * dir_y);
		if (len_dir != 0)
		{
			double normalized_x = dir_x / len_dir;
			double normalized_y = dir_y / len_dir;
			position.x += (int)(SPEED * normalized_x);
			position.y += (int)(SPEED * normalized_y);
		}

		if (dir_x < 0)
			facing_left = true;
		else if (dir_x > 0)
			facing_left = false;
	}

	void Draw(int delta)
	{
		int pos_shadow_x = position.x + (FRAME_WIDTH / 2 - SHADOW_WIDTH / 2);
		int pos_shadow_y = position.y + FRAME_HEIGHT - 35;
		putimage_alpha(pos_shadow_x, pos_shadow_y, &img_shadow);

		if (facing_left)
			anim_left->Play(position.x, position.y, delta);
		else
			anim_right->Play(position.x, position.y, delta);
	}

	void Hurt(int delta)
	{
		//受伤后设置无敌时间，避免同一个子弹在最近几帧重复进行碰撞
		
		timer += delta;
		if (timer >= 100)
		{
			is_invincible =false;
			timer = 0;
		}
		if(is_invincible == false)
		{
			HP--;
			is_invincible = true;
		}
		if(HP<=0)alive = false;
	}

	bool CheckAlive()
	{
		return alive;
	}

private:
	 int SPEED = 2;
	 int HP =2;
	 int timer =0;
	const int FRAME_WIDTH = 80;		// 敌人宽度
	const int FRAME_HEIGHT = 80;	// 敌人高度
	const int SHADOW_WIDTH = 48;	// 阴影宽度

private:
	IMAGE img_shadow;
	Animation* anim_left;
	Animation* anim_right;
	POINT position = { 0, 0 };
	bool facing_left = false;
	bool alive = true;
	bool is_invincible=false;
};

```







## 敌人自动生成函数

### 函数实现思路

- **函数参数**：

  - `std::vector<Enemy*>& enemy_list`：这是一个指向 `Enemy` 指针的动态数组，用于存储生成的敌人。
  - `int delta_ms`：这个参数表示每次绘制一帧之后经过的时间，以毫秒为单位。

  **常量定义**：

  - `const int INTERVAL = 1000;`：这里的 `INTERVAL` 定义为1000毫秒（即1秒），表示每1秒生成一个新的敌人。

  **静态计时器**：

  - `static int timer = 0;`：`timer` 是一个静态变量，用于累积时间。在函数调用之间保持不变。

  **时间累加**：

  - `timer += delta_ms;`：每次调用函数时，将传入的时间增量 `delta_ms` 添加到 `timer` 中。这意味着 `timer` 将随着每次调用而增加。

  **生成敌人逻辑**：

  - `if (timer >= INTERVAL)`：这行代码检查 `timer` 是否达到了或超过了1000毫秒。如果达到了，就会进入条件体。

  **敌人生成与重置**：

  - `enemy_list.push_back(new Enemy());`：在时间达到预定间隔时，创建一个新的 `Enemy` 对象并将其添加到 `enemy_list` 中。
  - `timer = 0;`：生成敌人后，重置计时器，以便为下一次生成敌人准备。



### 实现细节

```c++
void TryGenerateEnemy(std::vector<Enemy*>& enemy_list,int delta_ms)
{
	const int INTERVAL = 1000;//时间间隔
	static int timer = 0;//计时器
	timer += delta_ms;
	if(timer>= INTERVAL)
	{
		enemy_list.push_back(new Enemy());
		timer = 0;
	}
		
}
```





代码参考：Voidmatrix

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642
