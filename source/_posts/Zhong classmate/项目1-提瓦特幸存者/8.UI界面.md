---
title: UI界面
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# UI界面设计



## 1.GUI

### 1.1 定义

GUI是图形用户界面（Graphical User Interface）的缩写，它允许用户通过图形和视觉元素（如窗口、图标和按钮）与计算机程序进行交互，而不是通过文本命令。



### 1.2 图形用户界面元素

GUI 使用共同定义界面外观的结构元素。GUI 从四个基本组中提取其元素，包括：

#### 1. 输入控制

**输入控制组件**是图形用户界面（GUI）中允许用户通过可视化方式进行对计算机输入数据、选择选项或进行操作的元素。

以下是 GUI 输入控制组件的示例：

- **按钮：**用户点击后执行特定操作，如提交表单或开始任务。如图：![按钮](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//1.png)

- **复选框：**允许用户从多个选项中选择多个项，通常以方框形式出现，选中时显示勾选标志。如图：![复选框](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//2.png)

- **下拉列表：**用户可以点击以查看和选择一个项目，通常在一个紧凑的列表中显示多个选项。下拉列表也是一种选择类型的元素，下拉列表可以节省页面的空间，默认状态下只显示一个选项，只有在点击下拉按钮的时候才会显示多个选项，如图：![下拉列表](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//3.1.png)![下拉列表](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//3.2.png)

- **列表框：**用户可以从多个项目中选择一个或多个项，通常用于长列表的选择。列表框有四种变体：单行、多选、带复选框的多选和多选-双列表框。如图：![列表框](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//4.png)

- **文本框：**提供一个输入区域，用户可以在其中键入文本信息。

  如图：![文本框](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//5.png)

- **切换：**用于切换状态，通常表现为开启或关闭。

  如图：![切换](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//6.png)



#### 2. 导航组件

**导航组件**是图形用户界面（GUI）中帮助用户在应用程序或网站中查找和访问不同部分的元素，其顾名思义起到导航的作用。

以下是 GUI 导航元素的示例：

- **面包屑导航：**显示用户当前位置的路径，帮助用户了解他们在应用程序中的位置，并快速返回之前的页面。类似文件路径，下面为面包屑导航的例子：主菜单/游戏主菜单/背包系统

  如图：![面包屑导航](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//7.png)

- **图标：**小图形表示应用程序、文件或功能，用户可以通过点击图标进行导航并跳转。如图：![图标](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//8.png)

- **图片轮播：**图片轮播可让您滚动浏览一组图片，然后选择想要放大的图片。轮播通常包含可能带有超链接的缩略图。

  如图：![图片轮播](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//9.png)

- **分页：**分页将内容划分为多个页面，并允许您在页面之间跳转或按顺序关注它们。

  如图：![分页](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//10.png)

- **搜索字段：**搜索框允许您输入关键字或短语以搜索索引以获取相关结果。它们通常是带有搜索按钮的单行文本框。

  如图：![搜索字段](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//11.png)

- **滑 块：**滑块有一个条形图和一个在其上滑动的勾号。创建者可以控制条形和刻度的大小、条形边距及其方向。

  如图：![滑 块](articles/Zhong classmate/项目1-提瓦特幸存者/GUIimage//12.png)

- **标签：**标签可让您查找同一类别中的内容。选项包括让用户能够将自己的标签添加到系统中。

- **制表符：**选项卡是一个小框，显示与特定窗口关联的名称或图形图标。选择选项卡时，您将看到该窗口中显示的特定控件和信息。例如，当您在 Web 浏览器中打开多个页面时，您将看到浏览器窗口顶部显示的不同选项卡。



#### 3. 信息组件

**信息组件**是图形用户界面（GUI）中用于向用户传达信息、提示或反馈的元素，信息组件作用是帮助用户理解应用程序的状态、操作结果或需要注意的事项等。

以下是 GUI 信息元素的示例：

- **消息框：**消息框是一个小窗口，其中包含策略或免责声明等信息。它要求您在继续之前采取措施。

- **通知：**通知是一个消息框。通常，它们用于指示紧急警告、错误消息或任务完成。

- **弹出窗口：**弹出窗口或模态窗口要求您先与其交互，然后才能返回到系统。

- **进度条：**进度条显示您在流程中的一系列步骤中所处的位置。通常，进度条不可单击。例如，进度条可能会在订单、烹饪和配送流程中显示披萨订单的状态。

- **工具提示：**当您将鼠标悬停在项目上时，工具提示会为您提供更多信息。例如，当您将鼠标悬停在某个字词或短语上时，您可能会收到定义和用法示例。



#### **4. 容器**

下面是 GUI 容器元素的示例：

- **手风琴：**折叠项是具有显示和隐藏功能的项的堆叠列表。单击标签时，列表将展开为其完整大小。



#### 5.**图形用户界面的交互元素**

除了结构元素之外，GUI 还具有交互元素

**图形用户界面的交互元素**是用户与应用程序进行互动的基本元素。这些元素通常用于输入、选择和操作，增强用户体验。

例如：

- **游标**：指示用户输入位置的图形元素，可以是指针（跟随指针设备（如鼠标）的移动）或文本光标（指示当前文本框中的焦点），随着鼠标或键盘输入移动。

- **选择：**选择是指用户将对其应用操作的项目列表。用户将选择一部分文本进行剪切、复制和粘贴操作。图像编辑应用程序允许用户使用魔杖选择或套索选择工具来选择和修改图像的某些区域。

- **调节手柄：**用于拖放操作的指示器，通常在用户开始拖动时会改变形状，以表示可以移动的状态。





## 2.游戏UI界面设计

众所周知，EasyX作为2D图形库，他与GUI库是有区别的，在EasyX中我们可以十分方便的调用函数，绘制点线面等各种图形。但是想要在窗口中创建一个带有交互效果的按钮，需要我们自己实现交互按钮的逻辑。

QT作为GUI程序开发框架的定位，决定了它必然会屏蔽太多底层的设计。在游戏开发过程中，像QT这些定位明确的GUI框架一般也不会直接参与到游戏程序本身的制作中，而是作为游戏开发工具链上的一环。想要在游戏这种即时渲染的框架中渲染更具有通用性的GUI，ImGUI等即时渲染技术是再合适不过了



### 2.1 交互式按钮

想要实现GUI组件，在现有的游戏程序中，先从最简单的按钮组件说起

按钮在游戏和各类应用程序中都很常见，在某个GUI设计哲学中说：一个按钮之所以是按钮，不是因为它长得像按钮，而是因为它能够对交互事件做出响应。

当然制作按钮也需要让他长得像按钮，让用户能够察觉他是个按钮



#### 2.1.1 按钮三大处理逻辑

1. hover:鼠标悬停在按钮上
2. pushed:按钮被按下
3. idle：按钮闲置



#### 2.1.2 设计思路

![](articles/Zhong classmate/项目1-提瓦特幸存者/image//5.png)

##### 2.1.2.1 按钮父类

###### 2.1.2.1.1 私有成员变量

1. **定义按钮状态枚举类型**

   + 枚举成员：

     1. `Idle`
        - **值**：`0`
        - **含义**：按钮当前处于静止状态，没有用户交互。
     2. `Hovered`
        - **值**：`1`（自动递增）
        - **含义**：按钮当前处于悬停状态，鼠标指针位于按钮区域内。
     3. `Pushed`
        - **值**：`2`（自动递增）
        - **含义**：按钮当前处于按下状态，鼠标点击了按钮区域。

   + **作用：**

     1. **按钮状态的定义与区分**：  枚举类型定义了按钮的三种不同状态：

        - **Idle**：表示按钮处于静止状态，未进行任何用户交互。

        - **Hovered**：表示鼠标悬停在按钮上方，但未按下。

        - **Pushed**：表示按钮被按下（点击时的状态）。

     2. **控制按钮行为**： 按钮状态枚举用于跟踪按钮的当前状态，从而控制按钮的行为和响应。通过状态的改变，程序能够根据用户的交互（如鼠标移动、点击）动态调整按钮的显示和功能。

   + **用途：**

     + **按钮的状态切换（事件处理）**： 在 `ProcessEvent` 函数中，枚举类型 `Status` 用于判断当前按钮处于什么状态，并根据用户操作更新状态。

       - 当检测到鼠标移动 (`WM_MOUSEMOVE`) 时，`ProcessEvent` 会检查光标是否位于按钮区域内，并根据当前的状态调整为 `Idle` 或 `Hovered`。

       - 当鼠标按下 (`WM_LBUTTONDOWN`) 时，状态会被切换为 `Pushed`。

       - 当鼠标释放 (`WM_LBUTTONUP`) 后，如果按钮处于 `Pushed` 状态，就会触发点击事件。

2. **`RECT region`**：

   - **作用**：存储按钮的区域信息，即按钮在屏幕上的位置和大小。
   - **用途**：用于判断鼠标是否在按钮的区域内 (`CheckCursorHit` 函数)，以及在 `Draw` 函数中绘制按钮时确定位置。

3. **`IMAGE img_idle`**：

   - **作用**：存储按钮在静止（`Idle`）状态下显示的图片。
   - **用途**：在 `Draw` 函数中，当按钮处于 `Idle` 状态时，将该图片绘制到指定区域。

4. **`IMAGE img_hovered`**：

   - **作用**：存储按钮在悬停（`Hovered`）状态下显示的图片。
   - **用途**：在 `Draw` 函数中，当按钮处于 `Hovered` 状态时，将该图片绘制到指定区域。

5. **`IMAGE img_pushed`**：

   - **作用**：存储按钮在按下（`Pushed`）状态下显示的图片。
   - **用途**：在 `Draw` 函数中，当按钮处于 `Pushed` 状态时，将该图片绘制到指定区域。

6. **`Status status`**：

   - **作用**：存储按钮的当前状态，枚举类型 `Status` 定义了按钮的三种状态：`Idle`（静止）、`Hovered`（悬停）、`Pushed`（按下）。
   - **用途**：根据用户操作（如鼠标移动或点击），实时更新按钮的状态；并在 `Draw` 函数中根据该状态决定绘制哪种图片。



###### 2.1.2.1.2 构造函数

+ 构造函数接收按钮的区域（`RECT rect`）以及三个图片路径（`path_img_idle`, `path_img_hovered`, `path_img_pushed`），分别代表按钮在不同状态下（静止、悬停、按下）的图片。通过 `loadimage` 函数加载这些图片。



###### 2.1.2.1.3 事件处理 (`ProcessEvent`)

处理三种鼠标事件：

- `WM_MOUSEMOVE`：当鼠标移动时，检查是否光标在按钮区域内。如果在内则将状态改为悬停（`Hovered`），否则恢复为静止（`Idle`）。
- `WM_LBUTTONDOWN`：当鼠标左键按下时，检查是否点击在按钮区域内，如果是，则状态改为按下（`Pushed`）。
- `WM_LBUTTONUP`：当鼠标左键抬起时，如果状态为按下（`Pushed`），则调用 `OnClick` 函数。



###### 2.1.2.1.4 绘制按钮 (`Draw`)

根据按钮当前的状态（`Idle`, `Hovered`, `Pushed`），绘制相应的图片。



###### 2.1.2.1.5 纯虚函数 `OnClick`

定义为保护成员函数，在子类中实现具体的点击行为。



###### 2.1.2.1.6 私有函数 `CheckCursorHit`

用于判断鼠标的坐标是否在按钮区域内。



##### 2.1.2.2 子类按钮

###### 开始游戏按钮类`StartGameButton`实现思路

1. **继承：** `StartGameButton` 类继承自按钮基类，并对基类的部分函数进行重写
2. **构造函数**：在 `StartGameButton` 构造函数中，使用初始化列表的方式调用基类 `Button` 的构造函数，将按钮的区域坐标和各个状态下的图片路径传递进去。
3. **纯虚函数`OnClick` 实现**：当按钮被点击时，`OnClick` 函数会将全局变量 `is_game_started` 设置为 `true`，并播放背景音乐。



###### 退出游戏按钮类`QuitGameButton`实现思路

1. **继承：** `StartGameButton` 类继承自按钮基类，并对基类的部分函数进行重写
2. **构造函数**：在 `QuitGameButton` 构造函数中，使用初始化列表的方式调用基类 `Button` 的构造函数，将按钮的区域坐标和各个状态下的图片路径传递进去。
3. **纯虚函数`OnClick` 实现**：当按钮被点击时，`OnClick` 函数会游戏循环变量（bool型） `running` 设置为 `false`，从而结束游戏循环



#### 2.1.3 代码实现

##### 2.1.3.1 按钮父类

```c++
class Button
{
public:
	Button(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_hovered, LPCTSTR path_img_pushed)
	{
		region = rect;

		loadimage(&img_idle, path_img_idle);
		loadimage(&img_hovered, path_img_hovered);
		loadimage(&img_pushed, path_img_pushed);
	}

	~Button() = default;

	void ProcessEvent(const ExMessage& msg)
	{
		switch (msg.message)
		{
		case WM_MOUSEMOVE:
			if (status == Status::Idle && CheckCursorHit(msg.x, msg.y))
				status = Status::Hovered;
			else if (status == Status::Hovered && !CheckCursorHit(msg.x, msg.y))
				status = Status::Idle;
			break;
		case WM_LBUTTONDOWN:
			if (CheckCursorHit(msg.x, msg.y))
				status = Status::Pushed;
			break;
		case WM_LBUTTONUP:
			if (status == Status::Pushed)
				OnClick();
			break;
		default:
			break;
		}
	}

	void Draw()
	{
		switch (status)
		{
		case Status::Idle:
			putimage(region.left, region.top, &img_idle);
			break;
		case Status::Hovered:
			putimage(region.left, region.top, &img_hovered);
			break;
		case Status::Pushed:
			putimage(region.left, region.top, &img_pushed);
			break;
		}
	}

protected:
	virtual void OnClick() = 0;

private:
	enum class Status
	{
		Idle = 0,
		Hovered,
		Pushed
	};

private:
	RECT region;
	IMAGE img_idle;
	IMAGE img_hovered;
	IMAGE img_pushed;
	Status status = Status::Idle;

private:
	// 检测鼠标点击
	bool CheckCursorHit(int x, int y)
	{
		return x >= region.left && x <= region.right && y >= region.top && y <= region.bottom;
	}
};

```

##### 2.1.3.2 子类按钮

```c++
// 开始游戏按钮
class StartGameButton : public Button
{
public:
	StartGameButton(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_hovered, LPCTSTR path_img_pushed)
		: Button(rect, path_img_idle, path_img_hovered, path_img_pushed) {}
	~StartGameButton() = default;

protected:
	void OnClick()
	{
		is_game_started = true;

		mciSendString(_T("play bgm repeat from 0"), NULL, 0, NULL);
	}
};

```

```c++
// 退出游戏按钮
class QuitGameButton : public Button
{
public:
	QuitGameButton(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_hovered, LPCTSTR path_img_pushed)
		: Button(rect, path_img_idle, path_img_hovered, path_img_pushed) {}
	~QuitGameButton() = default;

protected:
	void OnClick()
	{
		running = false;
	}
};
```

代码参考：Voidmatrix

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642
