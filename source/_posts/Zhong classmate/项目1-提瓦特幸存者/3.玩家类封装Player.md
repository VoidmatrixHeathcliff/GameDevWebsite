---
title: 玩家类封装Player
date: 2024-10-14
updated: 2024-10-14
permalink: articles/Zhong classmate/项目1-提瓦特幸存者/
categories: Zhong classmate
tags: [项目总结]
---

# 玩家类封装Player

## 封装思路

### 1.属性封装

类内部使用私有成员变量（如动画类实例对象资源：`Animation* anim_left`、`Animation* anim_right` ;玩家操作移动方位信息（bool型）：`bool is_move_up`等等）来存储玩家角色的状态和相关资源信息。以下为必要属性：

- 动画类实例对象资源 `Animation*` ：玩家角色的封装的动画类的实例对象，如向左移动或静止的动画`anim_left`、向右移动或静止的动画`anim_right`等
- 角色的状态信息：

  - 操作移动方位信息（bool型）（此处目的为了使角色移动更加连贯，而不是由接收与处理消息队列频率决定）：
    - `bool is_move_up = false;`//上
    - `bool is_move_down = false;`//下
    - `bool is_move_left = false;`//左
    - `bool is_move_right = false;`//右
  - 其他与角色技能和操作相关信息（bool型），如（可加可不加，根据游戏设计添加）：
    - 发射子弹`bool is_shoot=false;`
    - 跳跃`bool is_jump=false;`
  - 坐标信息：`POINT position = { 500, 500 };`//此处初始为（500，500）
  - 角色属性信息（如下，建议以浮点型存储加大运算精度）：
    - 生命值`HP`(Hit Point）
    - 魔法值`MP`（Mana Point）
    - 速度`SPEED`
    - 攻击力`ATK`（attack） 
    - 防御力`DEF`（defence）
- 额外图片资源：`IMAGE img_shadow;`//角色阴影图片
- 其他资源相关属性（例如）：

  - 角色主题图片长度（高度）与宽度：
    - `const int FRAME_WIDTH = 80;`// 玩家宽度
    - `const int FRAME_HEIGHT = 80;`// 玩家高度
  - 角色阴影图片的长度与宽度：`const int SHADOW_WIDTH = 32;`

### 2.构造函数

加载游戏图片资源，初始化玩家的向左向右动画类对象

- **功能**：初始化玩家对象，加载影像资源并创建动画。
- 细节
  
  1. `loadimage(&img_shadow, _T("img/shadow_player.png"));`：加载阴影图像。
  
  2. `anim_left = new Animation(atlas_player_left, 45);`
     `anim_right = new Animation(atlas_player_right, 45);`//创建并且初始化玩家的左右动画类Animation对象

### 3.析构函数

Animation类资源上层代码（享元模式下，上层内存管理方面代码）负责清理动画类对象的内存

**功能**：清理资源。

**细节**：

- 删除 `anim_left` 和 `anim_right` 等动画类对象，防止内存泄漏。

### 4.类方法

1. `ProcessEvent(const ExMessage& msg)`方法
   - **功能**：处理消息事件（键盘、鼠标等），处理玩家输入后的角色运动逻辑
   - 细节
     - 使用 `switch` 语句根据按下或释放的键更新玩家的角色状态信息（如`is_move_up`、`is_move_down`、`is_move_left`、`is_move_right`）。
     - `WM_KEYDOWN` 处理按键按下角色状态信息赋值为真
     - `WM_KEYUP` 处理按键释放角色状态信息赋值为假。
2. `Move()`方法
   - **功能**：处理角色移动方面的数据，更新玩家xy坐标
   - 细节
     - 根据玩家的角色状态信息（与移动相关的状态如`is_move_up`），计算移动方向 `dir_x` 和 `dir_y`。
     - 归一化方向向量并根据 `SPEED` 更新 `position`。
     - 边界检查确保玩家不超出窗口边界。
3. `Draw(int delta)`
   - **功能**：
     1. 绘制玩家及其阴影。
     2. 根据角色状态信息，对动画类对象资源进行分类整合并封装调用对应对象的play()方法
     3. 即根据不同信息播放对应的动画如向左移动播放向左序列帧动画（使用封装好的Animation对象）
   - 细节
     - 计算阴影的位置并使用 `putimage_alpha` 绘制阴影。
     - 判断玩家的朝向的角色状态信息（向左或向右），根据朝向调用相应的动画类Animation对象的方法。

### 5.对外接口

- `GetPosition() const`方法
  - **功能**：返回玩家的位置，将角色位置提供给碰撞检测相关函数
  - 细节：
    - 返回 `position`，以便外部访问。
- 其他接口
  - 提供访问并修改角色属性的接口方法



## 代码实现

`````c++
class Player
{
public:
	const int FRAME_WIDTH = 80;		// 玩家宽度
	const int FRAME_HEIGHT = 80;	// 玩家高度

public:
	Player()
	{
		loadimage(&img_shadow, _T("img/shadow_player.png"));
		anim_left = new Animation(atlas_player_left, 45);
		anim_right = new Animation(atlas_player_right, 45);
	}

	~Player()
	{
		delete anim_left;
		delete anim_right;
	}

	void ProcessEvent(const ExMessage& msg)
	{
		switch (msg.message)
		{
		case WM_KEYDOWN:
			switch (msg.vkcode)
			{
			case VK_UP:
				is_move_up = true;
				break;
			case VK_DOWN:
				is_move_down = true;
				break;
			case VK_LEFT:
				is_move_left = true;
				break;
			case VK_RIGHT:
				is_move_right = true;
				break;
			}
			break;

		case WM_KEYUP:
			switch (msg.vkcode)
			{
			case VK_UP:
				is_move_up = false;
				break;
			case VK_DOWN:
				is_move_down = false;
				break;
			case VK_LEFT:
				is_move_left = false;
				break;
			case VK_RIGHT:
				is_move_right = false;
				break;
			}
			break;
		}
	}

	void Move()
	{
		int dir_x = is_move_right - is_move_left;
		int dir_y = is_move_down - is_move_up;
		double len_dir = sqrt(dir_x * dir_x + dir_y * dir_y);
		if (len_dir != 0)
		{
			double normalized_x = dir_x / len_dir;
			double normalized_y = dir_y / len_dir;
			position.x += (int)(SPEED * normalized_x);
			position.y += (int)(SPEED * normalized_y);
		}

		if (position.x < 0) position.x = 0;
		if (position.y < 0) position.y = 0;
		if (position.x + FRAME_WIDTH > WINDOW_WIDTH) position.x = WINDOW_WIDTH - FRAME_WIDTH;
		if (position.y + FRAME_HEIGHT > WINDOW_HEIGHT) position.y = WINDOW_HEIGHT - FRAME_HEIGHT;
	}

	void Draw(int delta)
	{
		int pos_shadow_x = position.x + (FRAME_WIDTH / 2 - SHADOW_WIDTH / 2);
		int pos_shadow_y = position.y + FRAME_HEIGHT - 8;
		putimage_alpha(pos_shadow_x, pos_shadow_y, &img_shadow);

		static bool facing_left = false;
		int dir_x = is_move_right - is_move_left;
		if (dir_x < 0)
			facing_left = true;
		else if (dir_x > 0)
			facing_left = false;

		if (facing_left)
			anim_left->Play(position.x, position.y, delta);
		else
			anim_right->Play(position.x, position.y, delta);
	}

	const POINT& GetPosition() const
	{
		return position;
	}

private:
	const int SPEED = 3;
	const int SHADOW_WIDTH = 32;	// 阴影宽度

private:
	IMAGE img_shadow;
	Animation* anim_left;
	Animation* anim_right;
	POINT position = { 500, 500 };
	bool is_move_up = false;
	bool is_move_down = false;
	bool is_move_left = false;
	bool is_move_right = false;
};
`````



## 代码详解

### 类的定义

#### 公共成员

```cpp
class Player
{
public:
	const int FRAME_WIDTH = 80;		// 玩家宽度
	const int FRAME_HEIGHT = 80;	// 玩家高度
```
#### 私有成员

```cpp
private:
	const int SPEED = 3;
	const int SHADOW_WIDTH = 32;	// 阴影宽度

private:
	IMAGE img_shadow;//图片资源

	//动画类Animation对象
	Animation* anim_left;
	Animation* anim_right;
	
	POINT position = { 500, 500 };//角色坐标信息
	
	//角色移动状态信息
	bool is_move_up = false;
	bool is_move_down = false;
	bool is_move_left = false;
	bool is_move_right = false;
```

- **SPEED**：定义玩家的移动速度。
- **SHADOW_WIDTH**：阴影的宽度。
- **img_shadow**：玩家阴影的图像对象。
- **anim_left / anim_right**：指向左右动画的指针。
- **position**：表示玩家当前坐标。
- **移动状态**：记录玩家是否在某个方向上移动的布尔值。



### 构造函数与析构函数

```cpp
	Player()
	{
		loadimage(&img_shadow, _T("img/shadow_player.png"));//加载
        //初始化角色向左向右移动动画类对象
		anim_left = new Animation(atlas_player_left, 45);
		anim_right = new Animation(atlas_player_right, 45);
	}

	~Player()
	{
        ////清除角色向左向右移动动画类对象
		delete anim_left;
		delete anim_right;
	}
```
- **构造函数**：加载玩家阴影图像，并初始化左右动画。
- **析构函数**：释放分配的动画内存，避免内存泄漏。



### 事件处理

```cpp
void ProcessEvent(const ExMessage& msg)
{
	switch (msg.message)
	{
		case WM_KEYDOWN://对键盘按下的消息处理
			switch (msg.vkcode)
			{
			case VK_UP:
				is_move_up = true;
				break;
			case VK_DOWN:
				is_move_down = true;
				break;
			case VK_LEFT:
				is_move_left = true;
				break;
			case VK_RIGHT:
				is_move_right = true;
				break;
			}
			break;

		case WM_KEYUP://对键盘抬起的消息处理
			switch (msg.vkcode)
			{
			case VK_UP:
				is_move_up = false;
				break;
			case VK_DOWN:
				is_move_down = false;
				break;
			case VK_LEFT:
				is_move_left = false;
				break;
			case VK_RIGHT:
				is_move_right = false;
				break;
			}
			break;
	}
}
```
- 处理键盘事件：当按下或松开方向键时，更新相应的布尔值，指示是否在移动。



### 移动逻辑

```cpp
void Move()
{
	int dir_x = is_move_right - is_move_left;
	int dir_y = is_move_down - is_move_up;
	double len_dir = sqrt(dir_x * dir_x + dir_y * dir_y);
	if (len_dir != 0)
	{
		double normalized_x = dir_x / len_dir;
		double normalized_y = dir_y / len_dir;
		position.x += (int)(SPEED * normalized_x);
		position.y += (int)(SPEED * normalized_y);
	}

	if (position.x < 0) position.x = 0;
	if (position.y < 0) position.y = 0;
	if (position.x + FRAME_WIDTH > WINDOW_WIDTH) position.x = WINDOW_WIDTH - FRAME_WIDTH;
	if (position.y + FRAME_HEIGHT > WINDOW_HEIGHT) position.y = WINDOW_HEIGHT - FRAME_HEIGHT;
}
```
- 根据键盘输入计算移动方向和距离。
- 使用归一化向量确保玩家以固定速度移动。
- 确保玩家不超出窗口边界。



### 绘制逻辑

```cpp
void Draw(int delta)
{
	int pos_shadow_x = position.x + (FRAME_WIDTH / 2 - SHADOW_WIDTH / 2);
	int pos_shadow_y = position.y + FRAME_HEIGHT - 8;
	putimage_alpha(pos_shadow_x, pos_shadow_y, &img_shadow);

	static bool facing_left = false;
	int dir_x = is_move_right - is_move_left;
	if (dir_x < 0)
		facing_left = true;
	else if (dir_x > 0)
		facing_left = false;

	if (facing_left)
		anim_left->Play(position.x, position.y, delta);
	else
		anim_right->Play(position.x, position.y, delta);
}
```
- 计算阴影的绘制位置，并使用带透明度绘制图像的函数绘制阴影。
- 根据运动方向选择播放的动画（左或右）。



### 其他成员函数

```cpp
const POINT& GetPosition() const
{
	return position;
}
```
- 返回玩家当前位置。





## 功能优化建议

1. **成员变量—角色存活状态信息**：`bool alive = true;`
2. **成员变量—角色属性信息**：生命值`HP`
3. **玩家角色受伤/回复生命值函数**：可以添加`Hurt()`函数与`Recover()`用于处理玩家生命值减少与增加，并处理玩家角色存活状态信息。
4. **角色存活状态信息接口**：添加`Getalive()`的方法获取角色存活信息，方便游戏结束；添加`Resetalive()`的方法重置角色存活信息，方便游戏初始化





代码参考：Voidmatrix、ChatGPT

项目教程：【【从零开始的C++游戏开发】全宇宙最简单的类吸血鬼幸存者游戏开发 | EasyX制作提瓦特幸存者】https://www.bilibili.com/video/BV1eM4m1S74K?vd_source=3a9720f4e51b97861a15c946ae6f0c2d

文档错误请联系QQ1210965642
