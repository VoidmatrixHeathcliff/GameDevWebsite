{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/About.md","hash":"f3a67be02706a4f2f7af12c4a137693efd7c17dd","modified":1754793161536},{"_id":"source/images/avatar.png","hash":"b8138053a7035cc574944d73c1d804e0eecca8eb","modified":1716816559360},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709523},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709543},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709556},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709570},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709583},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709263},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709351},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709427},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709473},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1701013709507},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1701013709793},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1701013709791},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1701013709590},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"75db783b805785377db28d4cb844ee65bb7be613","modified":1701013709704},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1701013709620},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"0ca35dec92ccf383f45db905db1a5a0e92d7209e","modified":1701013709629},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"ec6596b63bfb4349ba61792d905abe8e06fea625","modified":1701013709651},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1701013709860},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1701013709864},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1701013709856},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1701013709858},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1701013709862},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1701013709870},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1701013709868},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1701013709872},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1701013709874},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1701013709866},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1701013709878},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1701013709876},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"99bf235042d0c57af15d2f108ba5eda77443fea8","modified":1701013709736},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1701013709885},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1701013709880},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1701013709882},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1701013709748},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1701013709745},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1701013709768},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1701013709763},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1701013709761},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1701013709773},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1701013709784},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1701013709641},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1701013709786},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"f233678cd656c0e300181ca79dd30cb42fc213b3","modified":1701013709687},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1701013709634},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1701013709655},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1701013709803},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1701013709806},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1701013709811},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1701013709809},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1701013709815},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1701013709825},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1701013709658},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1701013709830},{"_id":"node_modules/hexo-theme-icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1701013709661},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1701013709827},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1701013709835},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1701013709832},{"_id":"node_modules/hexo-theme-icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1701013709664},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1701013709837},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1701013709625},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1701013709839},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1701013709841},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1701013709847},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"1d06eee32ea1fcb3162227eb1d7d19be39b6f5e3","modified":1701013709740},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1701013709845},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1701013709753},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1701013709759},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1701013709750},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"de966666f1e4ef80e0d15081b2709c3065b246dd","modified":1701013709756},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1701013709766},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"4816c9099a881b5f7b13af3e42caae36edbffccd","modified":1701013709778},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1701013709770},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1701013709780},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1701013709789},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1701013709782},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1701013709821},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1701013709743},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1701013709823},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1701013709732},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1701013709843},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1701013709796},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1701013709851},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1701013709849},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1701013709776},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1701013709853},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1701013709800},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1701013709854},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1701013709601},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1701013709607},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1701013709676},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1701013709613},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"08a2641765eeaf712157ad134dd675e3f7708ae2","modified":1701013709647},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1701013709682},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1701013709690},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1701013709701},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1701013709707},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"e85c9d7f2579805beb252a1b6345d5a668a13baa","modified":1701013709693},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1701013709697},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1701013709713},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1701013709716},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1701013709719},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1701013709723},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1701013709726},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1701013709669},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1701013709679},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1701013709710},{"_id":"source/_posts/Demo/HelloWorld.md","hash":"6c6f85dae8efcce4790b01f14090ee9015a7a36f","modified":1718003655483},{"_id":"source/_posts/Flaaax/test.md","hash":"ca3e97582834612f20d11ffd74ee0a0a54c9eba4","modified":1718003655483},{"_id":"source/_posts/FlyingfishFantasticfan/git的使用学习.md","hash":"5c09a0cf214b0be4eb13a923dedba8f91137c2b8","modified":1718003655483},{"_id":"source/_posts/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性.md","hash":"d182ca4df4c86203af8f50a6676951506ee33125","modified":1718003655483},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌.md","hash":"85ca09f8fe5bb8211026418b63e85a3a51976bd5","modified":1718003367936},{"_id":"source/_posts/Touyouta/Demo.md","hash":"6e989ca1e21d201240c5367b26415df3099d8043","modified":1718003655562},{"_id":"source/_posts/QiNuoTu/Camera2D.md","hash":"7c46aeeff04f88a786da3f1023775682d0c8fcea","modified":1718003655483},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased.md","hash":"c24978343e46a6f31bc2c05922b8f5ac9af5ab24","modified":1718003655499},{"_id":"source/_posts/QiNuoTu/Iamme.md","hash":"298389e336d92f6a30ae133202f36d4477eaac95","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/OpenEasing.md","hash":"4014cc642e8727078f40fb91f85bc3984607fc0a","modified":1718003655546},{"_id":"source/_posts/QiNuoTu/一些包围盒类碰撞检测算法.md","hash":"15eb29a88bb83967f1b6cfb0fa684a11c52e72c0","modified":1718003655562},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践.md","hash":"da7836b91c6a1d2cb93254e1d360bc8ea91a1348","modified":1718003655562},{"_id":"source/_posts/XINDENG123456/self-introduction.md","hash":"16e1931fefa8865b30b9e5c946134d7f022aa1e8","modified":1754793161762},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）.md","hash":"ddf65411bca78cc8c3ba7d9b2ffc6212a0447b0a","modified":1718003655593},{"_id":"source/_posts/Ye Minglv/植物明星大乱斗系列视频——勘误.md","hash":"3134e2aaaba9b3952aef717d531351e9b987c084","modified":1718003655609},{"_id":"source/_posts/YoungFlame/测试.md","hash":"a8bbaf4b0f0f3e132b6e7f6566c1b916b07554f2","modified":1718003655609},{"_id":"source/_posts/shuo-liu16/deploy-Hexo-2024-04-10.md","hash":"69bcbcefdf496d8cbf17faf95185c25ba7afc39b","modified":1718003655609},{"_id":"source/_posts/hszSoft/hello.md","hash":"e381200254403f5f6cb3690854a2ff8033105fc6","modified":1718003655609},{"_id":"source/_posts/suang/Aboutme.md","hash":"4bf109bc2a44010b59221574bfd3381cb1f424b5","modified":1718003655609},{"_id":"source/_posts/suang/EasyX_code.md","hash":"d8418d830d32f2ab93826091eae829a5f53058ff","modified":1718003655609},{"_id":"source/_posts/suang/publish_article.md","hash":"c4405b7c631531917a798a8da745ff43cbd1d60c","modified":1718003655609},{"_id":"source/_posts/yang/奥日与萤火意志2.md","hash":"0cffdee2ce0a23957fdb57b440682163b963ff7c","modified":1737622700288},{"_id":"source/_posts/zExNocs/自我介绍.md","hash":"3f41e3ce3abb6765e3c01dbbfe9493911425d445","modified":1718003655609},{"_id":"source/_posts/Demo/HelloWorld/avatar.png","hash":"b8138053a7035cc574944d73c1d804e0eecca8eb","modified":1718003655483},{"_id":"source/_posts/zExNocs/随笔-如何提交文章到VoidGameSpace上.md","hash":"5135b3e4827354214b286e64eda7b9555c23fd59","modified":1718942505753},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Blue_Joker.webp","hash":"f6745cc28248111b1cab499f7be9adbd42449ccc","modified":1717996375794},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Cavendish.webp","hash":"3e70ce4a2f84b90aaaadc07005599fb57c1eec05","modified":1717996481255},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Four_Fingers.webp","hash":"fa1eb1282d70090f7823f5548a74aa050154ec34","modified":1717996776558},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Golden_Joker.webp","hash":"78ba5a7ef0b003bfd73e760e6965fa40cbeb746c","modified":1717996666856},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Joker.webp","hash":"b3e379d991386f196056db261390a0482955c63e","modified":1717952859029},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Photograph.webp","hash":"d60103bbd1278b130d193d10172fd848bc5f777f","modified":1717999900670},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Smiley_Face.webp","hash":"2cd9d77f597467511a9a28ec636cf8741600c5b9","modified":1717999918507},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Hanging_Chad.webp","hash":"5f4bcb823455c57cf8398f96ee774f81de3997dc","modified":1717999932084},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/四指同花顺.png","hash":"90925427835740bf04868fa3a6c1dca2d999d283","modified":1717999109507},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/10.png","hash":"d55489ccf925b67369d68c26c5505239e8709f59","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/11.png","hash":"1ba80d4165fc370c705c1a39eee035a4f1b8119f","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/12.png","hash":"52fe1b85ee90d51fc5dffb06d3a83314ccc939b7","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/13.png","hash":"963b03eeddbc0e15d4e337aa1cfe90ed2170aa7c","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/14.png","hash":"18b75a590c32e3295456696d6fb5691e4ecd4615","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/16.png","hash":"8c2cafc02d8b957265894f0493e9710886a38b6a","modified":1718003655530},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/17.png","hash":"4b1781e1faf1e6e25b5eb3353c23ea824b6780aa","modified":1718003655530},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/20.png","hash":"9814939b228987d8ba9da37409431d262e5cce1a","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/21.png","hash":"5d962b0fff964d83b6982eb634932b65aa37bb68","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/26.png","hash":"f7075d0a8c4dbef5500b0cd12546123b14228036","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/28.png","hash":"f69cf6216941ce4f49a883880658d3729a083629","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/27.png","hash":"ed07e7793fd939792896afdaf360193b68f8dada","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/5.png","hash":"16cad4bfb0cef630fe9d04cfe1d84421ed8f9c6f","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/8.png","hash":"a8f89f4b96fc815606893b517b9df8f42d03b0ac","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/9.png","hash":"944b36b8abe71940c121cb3bc079b73340cc8e67","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/Iamme/1.jpg","hash":"295c008c11894b91f3d99e0dae846a525ac6393b","modified":1718003655546},{"_id":"source/_posts/YoungFlame/img/avatar.png","hash":"b8138053a7035cc574944d73c1d804e0eecca8eb","modified":1718003655609},{"_id":"source/_posts/shuo-liu16/deploy-Hexo-2024-04-10/2.png","hash":"d1d02bc974c1f8bdd0a39744afaa2badbf78fc13","modified":1718003655609},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/151655416259069.png","hash":"9516c3ce63a8d37662ebc4cfd107e541d724a41c","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/87331419268747.png","hash":"561a836ac933a90c5899ba7fa4442b270b67e239","modified":1718003655609},{"_id":"source/_posts/suang/Aboutme/who_am_I.png","hash":"9504f232d8247506cd4c6589c8164b8c69d36139","modified":1718003655609},{"_id":"source/_posts/suang/publish_article/image_pos.png","hash":"4ee5912434f6a5f97bd3353b1663df9a45e8d940","modified":1718003655609},{"_id":"source/_posts/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/游戏设计知识分享-依赖性-1.png","hash":"af1ff967b389e3766771c3bf43ff23843edf3aad","modified":1718003655483},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/计分板.png","hash":"0674747aeccad06462ecae936370eb4b8bfe4f83","modified":1717995565205},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/15.png","hash":"41ae2aa085fc610ace55b82fe840d1f714793d71","modified":1718003655530},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/19.png","hash":"039ba395b921713c71166343aa52aea6a4185fa9","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/2.png","hash":"6b06814a55b8d717621d47b0f00312eb1340550a","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/22.png","hash":"621e14dd48159ace6a48417cb1276751dfc61b42","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/23.png","hash":"f11e21162dfbd1e294a163eaaca2cabaa88cb0c2","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/25.png","hash":"c624bff787f9aa36a7cc2bfd5d4e3bf2665015f7","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/3.png","hash":"7a6f4e0e72399aeba70112e4f34ebdaa70f017c6","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/4.png","hash":"7ac0253154d18f1a369b3f3620f6f04b84234102","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/7.png","hash":"f12c47d616df36b2cd93c2471caba8469ad34bf8","modified":1718003655531},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/231573721246935.png","hash":"816d686114823ca98711b8b64539298f50c8b6d0","modified":1718003655578},{"_id":"source/_posts/shuo-liu16/deploy-Hexo-2024-04-10/1.png","hash":"b40806b4dc4034f1f781fc1585f3e8fe9bfac94a","modified":1718003655609},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/202434217267102.png","hash":"2a4fbffdfe6984414c682f23f3ade033e6b83c94","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/59555018265066.png","hash":"d42019821f83eacecf869aa883e77f21a6454fa1","modified":1718003655593},{"_id":"source/_posts/suang/Aboutme/suang.png","hash":"88fea2975e0b0f08e317b3dd2ef746c33c97982a","modified":1718003655609},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/24.png","hash":"45f6974531ea6864ecd0e47c6daad8149266d245","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/6.png","hash":"2cf7630a9e1b1e61dc0ba97bdc8f937d5353f700","modified":1718003655531},{"_id":"source/_posts/QiNuoTu/OpenEasing/OpenEasing.png","hash":"a2a17fe92afd47f77aaed36abd6f2fefe819d674","modified":1718003655562},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/125364318267564.png","hash":"788ecd6ca06f378ab2ca4e3a738271d7b6651b67","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/161600919246307.png","hash":"161fe2736a677825a6f67777a30f9bb255d2ae06","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/532531818252080.png","hash":"90482f22ddbe2a7b3b9d45a314cf1308d6fa963d","modified":1718003655593},{"_id":"source/_posts/suang/publish_article/fork_img.png","hash":"89ecaa744302b6b8cc3f3a09088b6b76f8db84c4","modified":1718003655609},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/18.png","hash":"dbc64ce5efb6bd99dec6f83efbb24a9102b69e1b","modified":1718003655531},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/403754021267101.png","hash":"1691dcbc729a2d8c80f846407d932e19a12059bf","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/553721218256326.png","hash":"8a368b2de95d44c6eb61ec4654a1d1ab825e8d1f","modified":1718003655593},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/1.png","hash":"1a77c95f4114bd9c82ff5a9aa7f9d39b7126c32f","modified":1718003655515},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/338824221259770.gif","hash":"f9f5067d95a10cab5ae9cbea82b8ac5210e40491","modified":1718003655593},{"_id":"source/_posts/QiNuoTu/Camera2D/2.png","hash":"3d643ceea5414eb349e3db001222e3b9ad1c9203","modified":1718003655499},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/76072812230849.png","hash":"54c0937a8017653bcc1b9370fb3d30bd70e2ea91","modified":1718003655609},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/294884321256325.gif","hash":"7e4ad2a2df59f8a06b3d60a07254a83f1a37d71a","modified":1718003655593},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/101894421252079.gif","hash":"3808d32546b4ac49444352f8833287b2521869d1","modified":1718003655578},{"_id":"source/_posts/QiNuoTu/icon.png","hash":"5e446ec16d961293b49818471c01033869b50ae9","modified":1718003655562},{"_id":"source/_posts/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg","hash":"a9bda682885260f432b7b7da4302f17df6c44bfa","modified":1718003655562},{"_id":"source/_posts/QiNuoTu/Iamme/2.png","hash":"cb04ae1e7c3cd1f4aa9561ddaec48b6890ac4f56","modified":1718003655546},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/123415231.png","hash":"7447631caaa0fd561766aa39b8b14e6ec823a679","modified":1718003655515},{"_id":"source/_posts/QiNuoTu/Camera2D/1.gif","hash":"8e3b9a6ff03ed2f15570808729ff9703ff167130","modified":1718003655499},{"_id":"source/_posts/59/GAMES002_01.md","hash":"47c55f43684056eb31617adce2f64ce64d228d28","modified":1729221218444},{"_id":"source/_posts/FlyingfishFantasticfan/卡牌肉鸽开发日志01-游戏的核心玩法及预期设计.md","hash":"b3fe6c53c40c8ef469f7e243fcdba5978cbf6c06","modified":1729221218623},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1.md","hash":"c94011fb44de0ac5a7bad2320a6f851e5c708bf1","modified":1729221218632},{"_id":"source/_posts/Margoo/2d-light.md","hash":"0ab05641a68a659e2f991cae29bf3c8d5aa7d3c1","modified":1737622339486},{"_id":"source/_posts/Kritace/植物明星大乱斗血包道具.md","hash":"d5e43dd6e6d249b64f5ddd3a340f2462259d1cfd","modified":1718942505551},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误.md","hash":"c7f28c23ebde2e67a327d142eea15842c8fbb4ed","modified":1720883057474},{"_id":"source/_posts/hszSoft/pbr-theory.md","hash":"f48f7faaf2d26882480f9e2bf91e7e6789aa0076","modified":1718942505566},{"_id":"source/_posts/shuo-liu16/数据结构：常见排序算法解析.md","hash":"24f46b508d9f1afb4271b70d3e5e4daa1372e2d8","modified":1720883057490},{"_id":"source/_posts/suang/SDL_utils_1.md","hash":"89eff4b6489ac901c47266d25f1fc5356299b0bd","modified":1720883057490},{"_id":"source/_posts/suang/SDL_utils_2.md","hash":"dc3e8094624e9ff054be1e2364dfecf0ec53ad7c","modified":1720883057490},{"_id":"source/_posts/yang/c++输入与输出.md","hash":"592a6ad57d54969f39a627aa82b3c5f4f3f9a5ac","modified":1720883253255},{"_id":"source/_posts/yang/单例模式.md","hash":"14d6df260c3f948d1c60735ac66cb18878ff0a56","modified":1720883057503},{"_id":"source/_posts/yang/C++继承.md","hash":"a438ef2999f3730c797ad8e0fb31769706e29bf0","modified":1720883057493},{"_id":"source/_posts/yang/计时器的分析.md","hash":"79b5b722feac899dd270a91be9dde0d5f4db24fc","modified":1718942505739},{"_id":"source/_posts/yang/map&&unordered_map.md","hash":"120fe932f6ff5b0751463991c328e217b93258b8","modified":1720883057496},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server_data.png","hash":"04b1d26b337f4b04a8b849080813e663e00f2da6","modified":1729221218724},{"_id":"source/_posts/Margoo/2d-light/equation1.svg","hash":"d08845b473962e4459ec161acaeef7befe23fee4","modified":1729221219327},{"_id":"source/_posts/Margoo/2d-light/equation2.svg","hash":"a995620a0867f8456322ad3c37d99f064e2a8476","modified":1729221219358},{"_id":"source/_posts/Margoo/2d-light/equation3.svg","hash":"3431f571cbf38d127b270d148636a5d7b38dcb7d","modified":1729221219359},{"_id":"source/_posts/Margoo/2d-light/equation4.svg","hash":"3ea024c7a282d67dff13ce3d6195d14e3ab7fba3","modified":1729221219360},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/sun_bullet_ex.png","hash":"d54f943b9be94d20621c6458a75c8c1ce80427b1","modified":1720883057485},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/winner_bar.png","hash":"c4fbe0375fe6815868ad716716d83212eb7f80b9","modified":1720883057489},{"_id":"source/_posts/hszSoft/pbr-theory/calculate-reflectivity.png","hash":"8e33537d2b3357758cabedb529ee716b646366bd","modified":1718942505566},{"_id":"source/_posts/hszSoft/pbr-theory/cook-torrance.png","hash":"8de32ffc3089f5ba4683da8210b9f2efcab26d35","modified":1718942505566},{"_id":"source/_posts/hszSoft/pbr-theory/ct-brdf.png","hash":"2c82f4e4b07c9567859067c8f1ae5e326b3b4c58","modified":1718942505566},{"_id":"source/_posts/hszSoft/pbr-theory/direct-remapping.png","hash":"7ebbf935b893b6e52b773f8b368ac8a75be6a280","modified":1718942505567},{"_id":"source/_posts/hszSoft/pbr-theory/fresnel.png","hash":"4bbd2f9e06c23d2e111182ebf5ebee14f2e491d8","modified":1718942505571},{"_id":"source/_posts/hszSoft/pbr-theory/fresnel-schlick.png","hash":"d2dc159f598017abb0e5ec2fb6612ade28646180","modified":1718942505570},{"_id":"source/_posts/hszSoft/pbr-theory/geometry-shadowing.png","hash":"8e73da456386294897bcda65e44558d6bd5f98f6","modified":1718942505571},{"_id":"source/_posts/hszSoft/pbr-theory/geometry.png","hash":"049374b7241cf2ddc5e9d9909a83dfe11efc612c","modified":1718942505572},{"_id":"source/_posts/hszSoft/pbr-theory/lambertian.png","hash":"8a51150882346d51a49834695c462c66f5f699af","modified":1718942505572},{"_id":"source/_posts/hszSoft/pbr-theory/schlick-ggx.png","hash":"42b4f8863a59a066fa5029fab79dd7599a373bb5","modified":1718942505732},{"_id":"source/_posts/hszSoft/pbr-theory/material-base-reflectivity.png","hash":"345d415b86aab3b5f515b3a72ba4c0081ba7fff9","modified":1718942505572},{"_id":"source/_posts/hszSoft/pbr-theory/ndf.png","hash":"8c4df7cb0da280ac7e5c4d387c5a140c6a09e42d","modified":1718942505623},{"_id":"source/_posts/hszSoft/pbr-theory/smith-method.png","hash":"2d133cfd602415465f1b4994babbf986dce63554","modified":1718942505735},{"_id":"source/_posts/hszSoft/pbr-theory/trowbridge-reitz-ggx.png","hash":"4873eb7bb608bd942e70bd8e4a3e8dbc9895c6ec","modified":1718942505737},{"_id":"source/_posts/yang/C++继承/p1.png","hash":"8900a155da0fe8973be5611fe1075e8c88405826","modified":1718942505738},{"_id":"source/_posts/yang/C++继承/p3.png","hash":"8519acbda29540dd214ee6007e1326088cb493ee","modified":1718942505739},{"_id":"source/_posts/hszSoft/pbr-theory/surface-reaction.png","hash":"c640ffd8897479381435cd907e0e9c084b056478","modified":1718942505735},{"_id":"source/_posts/yang/C++继承/p2.png","hash":"7a8d4ce581c421547dd0f0a333a0cd9169174652","modified":1718942505738},{"_id":"source/_posts/yang/c++输入与输出/Center.jpeg","hash":"675b1618c8df64adb3dd3e1dd9cf8513018ba3ef","modified":1720883057493},{"_id":"source/_posts/yang/c++输入与输出/image-20240622105847430.png","hash":"b9227604fbc44641d8e16c77576834d76b0476df","modified":1720883057494},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151655.png","hash":"d066536a4d7b416e3d2247e5496577e3a0a785b5","modified":1720883057495},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151721.png","hash":"072b8fabd76e2959def58e81b43cc092c7d030f5","modified":1720883057495},{"_id":"source/_posts/yang/c++输入与输出/image-20240622103232679.png","hash":"5e6c039a485d8d55975c398a576536928c391ad9","modified":1720883057494},{"_id":"source/_posts/yang/c++输入与输出/image-20240713155355573.png","hash":"5118b786fef090967f0610411c91091ac30aa81f","modified":1720883057494},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151711.png","hash":"2552f8c2eef654ff921c8f92e68a997a8833510c","modified":1720883057495},{"_id":"source/_posts/yang/map&&unordered_map/202d8acdd52f4509b9dbab88998ab4ef.png","hash":"7335def4383128adcf661c8fd9df95ff4dd1b2a8","modified":1720883057497},{"_id":"source/_posts/yang/map&&unordered_map/74bb10b1d0024d6aaee8e2036be019f1.png","hash":"34a044264ebffdeec0b7b572bc117329da1f2ca5","modified":1720883057500},{"_id":"source/_posts/yang/map&&unordered_map/4506b0d4a9fb4c68a4f21af2e8f4b7b3.png","hash":"4cd5fde62cf287dbb50703fbb9e40ea3f55be6ba","modified":1720883057497},{"_id":"source/_posts/yang/map&&unordered_map/5e1c85cfceb84975951d63017b8bca37.png","hash":"e510babe5f37001c0b27ce853246618264b9b017","modified":1720883057499},{"_id":"source/_posts/yang/map&&unordered_map/8c4bc7708c19453186b2bb91df9ed7e9.png","hash":"4758598d42d3b665fad71319edae1dfedd3a0012","modified":1720883057500},{"_id":"source/_posts/yang/map&&unordered_map/68bfe33fe1914bf5bfcc01ad7534cd5e.png","hash":"02d445145bfeb71d242695662a2cf45b5b433d91","modified":1720883057499},{"_id":"source/_posts/yang/map&&unordered_map/f3fc7b2dc87b4bc285059b5154d9292c.png","hash":"f7506ef24a3f0bd9921b5c846a2e6af8eb6ad54e","modified":1720883057502},{"_id":"source/_posts/yang/map&&unordered_map/95b245ce93fc49bb85c42e0fbd166697.png","hash":"9621b7e2a5b604d243e73b1ffa4b416b53395c0e","modified":1720883057501},{"_id":"source/_posts/yang/单例模式/format,png-1719298517759-3.png","hash":"81455874f510de6c18fb80e6e2564022686a8399","modified":1720883057503},{"_id":"source/_posts/yang/map&&unordered_map/image-20240630204341298.png","hash":"add12048ca27a03cf042d5c50713aa1ce6049066","modified":1720883057502},{"_id":"source/_posts/yang/map&&unordered_map/99abbcbff8fb414082511a66ece8f60a.png","hash":"2ec047e18225c426910a884b379b87d27735ae5c","modified":1720883057502},{"_id":"source/_posts/yang/单例模式/format,png-1719298652881-6.png","hash":"f22e58f6709a3c61b67fb1196c1d78e294927c87","modified":1720883057504},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/big-Oh.png","hash":"79bd1aa2eb7b1bfb288fb538586a6e6ab387bba8","modified":1718942505741},{"_id":"source/_posts/yang/单例模式/image-20240625135923590.png","hash":"b0a055b4c4537496d29d8173eac7651d02385872","modified":1720883057506},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png","hash":"0ee6e781ec0aa949315883e357ebf980685e4cc6","modified":1718942505752},{"_id":"source/_posts/yang/单例模式/image-20240625125041783.png","hash":"4c9e271f733f09cb19c8f1977a2b753922447856","modified":1720883057505},{"_id":"source/_posts/yang/计时器的分析/屏幕截图 2024-06-14 135834.png","hash":"d6a6135c140cba8437e4240706fd7e8fc744ab28","modified":1718942505740},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png","hash":"0a0bda49d28b82d5538320ff43c9cbf1822c9518","modified":1718942505753},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png","hash":"473f343cddfe436c180ad1c74bac6b4efb5c0c00","modified":1718942505753},{"_id":"source/_posts/yang/计时器的分析/image-20240614140821676.png","hash":"913590a6d746c1141dfef25f0a203ca46b07490d","modified":1718942505740},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率.md","hash":"847fcdde5eb252af9b5e10764b554cdca2ad6ac1","modified":1718942505741},{"_id":"source/_posts/59/GAMES002_01/02.png","hash":"32e95c1f245479397317ce56eb27e51b32321311","modified":1729221218596},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client_2.png","hash":"b16e30a333f2fed46ca4670b44dd9794ef3b821a","modified":1729221218766},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/noooooooooooo.png","hash":"5b426bf03c75cc0d7222a4ab91613e5981dd5090","modified":1729221219322},{"_id":"source/_posts/Margoo/2d-light/cover.png","hash":"f76186dde877d046e9f451c1889b0d2fc07199ef","modified":1729221219326},{"_id":"source/_posts/Margoo/2d-light/bloom.png","hash":"0e58a86cd96896323c053b98da7e7d018e460d91","modified":1729221219325},{"_id":"source/_posts/Margoo/2d-light/light.png","hash":"fb889bb857c7e5b2c00bcb6f67839fe1060feb80","modified":1729221219361},{"_id":"source/_posts/Margoo/2d-light/normal_result.png","hash":"40a70d04b540a0c26a097f46882188a1584390ab","modified":1729221219362},{"_id":"source/_posts/yang/map&&unordered_map/0902517424204b618b2d27075e4a3d37.png","hash":"e42a9a3d4f80d84cc60d81c50d4baf70846cb406","modified":1720883057497},{"_id":"source/_posts/yang/map&&unordered_map/45d8c982a7bc4392b7cdc220c3147b22.png","hash":"6a4d0e8185bc49e8379e7dd6f0a2c6505363569f","modified":1720883057498},{"_id":"source/_posts/yang/单例模式/format,png.png","hash":"c8e3ec15561112d001b03a50f7d0d91391129ae9","modified":1720883057504},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png","hash":"db51d445dce4c5c05fdbf5fbf72f64c3dbf0860f","modified":1718942505752},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_client.png","hash":"c217bcfff1d497fd58554fa5cab0a0e72be0cce3","modified":1729221218659},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client.png","hash":"638310a825a9d038b2f413d9360195a0640d0353","modified":1729221218757},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server.png","hash":"488d8afddaab2c500f2e5f97d3185b8f4f2cafdd","modified":1729221218686},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_server.png","hash":"9ca21f31d936c0fe017a46699cfc1a4e0b542853","modified":1729221218796},{"_id":"source/_posts/Margoo/2d-light/normal_texture.png","hash":"7b3d6cb3763ef9f906f5fb664287fbf62c5fd0c6","modified":1729221219365},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/img_flipped.png","hash":"bdeb1af39f77e95d1934c388b9090acffbc34e90","modified":1720883057475},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/modify.png","hash":"b90708d47a2c99f515fbda90cbf68632df542f74","modified":1720883057479},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/main.png","hash":"386dbc5ee731161625859fa7fac661ba88f1cf7e","modified":1720883057477},{"_id":"source/_posts/Margoo/2d-light/pipeline.png","hash":"1d9eec84d5bd08e2af7252e0879f0e3d0b6972eb","modified":1729221219368},{"_id":"source/_posts/hszSoft/pbr-theory/textures.png","hash":"ada4bc69efb00e3ad313c8364ea027626ed75862","modified":1718942505736},{"_id":"source/_posts/suang/SDL_utils_2/rabbit_hole.png","hash":"73296e9b2151dd315a3e5dcdaf3692980a36369e","modified":1720883057492},{"_id":"source/_posts/Kritace/植物明星大乱斗血包道具/血包实例图.png","hash":"71aa6cda3a13a410fca1b023f57f81fdc7a0a7d2","modified":1718942505553},{"_id":"source/_posts/59/GAMES002_01/01.png","hash":"9d0ea0bc9aa004346edff5dc1d9697f827852c7f","modified":1729221218457},{"_id":"source/_posts/hszSoft/pbr-theory/disney-principled-brdf.png","hash":"3d87314438478113a1f702d5815d0b18f752a354","modified":1718942505570},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/timer_spawn_pea_ex.png","hash":"e436c6f9486ce00ac8faab07d0a8064a2ce245dd","modified":1720883057489},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/raw.png","hash":"e7798a39184be1a82336a3933d18d74889a0108a","modified":1720883057484},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/cover.png","hash":"a3c31a1e8fa1009b705784b73de4a4b9cfe9f1e6","modified":1718942505751},{"_id":"source/_posts/hszSoft/pbr-theory/metallic.gif","hash":"d67af4939ae1fcb283612e22223afed400f66f37","modified":1718942505622},{"_id":"source/_posts/hszSoft/pbr-theory/roughness.gif","hash":"5a5d90cf4609757d1e199c564741946ff6106ba7","modified":1718942505731},{"_id":"source/_posts/XZDXRZ/quadtree_notes.md","hash":"955c52f789686c97a96dd944f09e4e338a984017","modified":1737622344035},{"_id":"source/_posts/zhong/EasyX图片处理.md","hash":"386e72ff7c4e38c3dc16daff75cf936b212be6b8","modified":1737623286268},{"_id":"source/_posts/HIBIKI/unity客户端面经.md","hash":"de4bba6ec009a3201a3e646f18d96b154ffe5cc1","modified":1754793161560},{"_id":"source/_posts/InH/如何让2D角色更丝滑的移动(C++SDL2)开罐即食.md","hash":"dd72cf1a1eb9c7dcd75a27fa53328250221d9cdd","modified":1754806789903},{"_id":"source/_posts/InH/picture/cov.png","hash":"83e8c5fdbe1d3237f174a65e64530afce82a4eb8","modified":1754804533593},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台.md","hash":"2d8a20ce7aac870ea75bbab8c05138739226687c","modified":1754793161781},{"_id":"source/_posts/Flaaax/MyECS.md","hash":"0f9858a1f606e263b2fb0e391a663fb891eef4e1","modified":1754793161537},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/error_1.png","hash":"9e84d3e2b17c42f3720a0947a804170af1834507","modified":1754793161785},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/preprocessor.png","hash":"26c21cf54972a1783e4a3b817f321ec0caa38289","modified":1754793161788},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/error_2.png","hash":"8169160552f0cf7967bdd13df682380adf0cc05f","modified":1754793161786},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/additional_dependencies.png","hash":"94f139b04ac8dee6ebb73606e219cdb40098616f","modified":1754793161784},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/project_property.png","hash":"6992e11ed14a2cb2491fd6c6cd289282e1b9044a","modified":1754793161789},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/result.png","hash":"b00abad6427e86670d5e97f9caa2314bfc692ed8","modified":1754793161792}],"Category":[{"name":"Demo","_id":"clx8n2hg50001o8yea90f4i5q"},{"name":"Flaaax","_id":"clx8n2hg80006o8yeewzpfvxv"},{"name":"FlyingfishFantasticfan","_id":"clx8n2hg9000co8ye8gtq5k5g"},{"name":"Touyouta","_id":"clx8n2hgh000so8ye43vv9vin"},{"name":"QiNuoTu","_id":"clx8n2hgi0010o8ye3b0i5mnm"},{"name":"Voidmatrix","_id":"clx8n2hgo001ro8ye7h744ueg"},{"name":"XINDENG123456","_id":"clx8n2hgo001xo8ye589taadj"},{"name":"Ye Minglv","_id":"clx8n2hgp0026o8yegryw9g2u"},{"name":"YoungFlame","_id":"clx8n2hgp002bo8yegnfp6dcm"},{"name":"shuo-liu16","_id":"clx8n2hgq002eo8yefriq959i"},{"name":"hszSoft","_id":"clx8n2hgq002ho8ye2piw2uzd"},{"name":"suang","_id":"clx8n2hgr002lo8ye42fa681j"},{"name":"yang12342","_id":"clx8n2hgx003qo8yehj5hdmre"},{"name":"zExNocs","_id":"clx8n2hgy003uo8ye9xgm7r7i"},{"name":"59","_id":"cm2e5r84q0002lcutg0130egi"},{"name":"Kritace","_id":"cm2e5r85a000alcutfbqb3rh6"},{"name":"YeMinglv","_id":"cm2e5r85f000jlcut6nh30y09"},{"name":"Margoo","_id":"cm693l0ac0000i0ut4suc9a47"},{"name":"XZDXRZ","_id":"cm693l0ah0003i0ut8ayh18lo"},{"name":"zhong","_id":"cm693vzej00051out07qwdu7t"},{"name":"HIBIKI","_id":"cme5bvpf90003nofw1cikbanf"},{"name":"InH","_id":"cme5bvpfk0009nofwfpbk4b2n"}],"Data":[],"Page":[],"Post":[{"title":"欢迎来到 VoidGameSpace","date":"2024-05-26T16:00:00.000Z","updated":"2024-05-26T16:00:00.000Z","_content":"\n> VoidGameSpace 游戏开发社区博客","source":"_posts/About.md","raw":"---\ntitle: 欢迎来到 VoidGameSpace\ndate: 2024-05-27\nupdated: 2024-05-27\npermalink: about/\n---\n\n> VoidGameSpace 游戏开发社区博客","slug":"About","published":1,"__permalink":"about/","_id":"clwp1dg660000m0ut65gd3vqr","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>VoidGameSpace 游戏开发社区博客</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>VoidGameSpace 游戏开发社区博客</p>\n</blockquote>\n"},{"title":"你好，世界","date":"2024-05-26T16:00:00.000Z","updated":"2024-05-26T16:00:00.000Z","_content":"\n群友的一小步，游戏行业的一大步\n\n<!-- More -->\n\n<div style=\"text-align:center\">\n\n![ICON](articles/Demo/HelloWorld/avatar.png)\n\n</div>","source":"_posts/Demo/HelloWorld.md","raw":"---\ntitle: 你好，世界\ndate: 2024-05-27\nupdated: 2024-05-27\npermalink: articles/Demo/HelloWorld/\ncategories: Demo\ntags: [游戏开发]\n---\n\n群友的一小步，游戏行业的一大步\n\n<!-- More -->\n\n<div style=\"text-align:center\">\n\n![ICON](articles/Demo/HelloWorld/avatar.png)\n\n</div>","slug":"Demo/HelloWorld","published":1,"__permalink":"articles/Demo/HelloWorld/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hg20000o8yegq8i0076","content":"<p>群友的一小步，游戏行业的一大步</p>\n<span id=\"more\"></span>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Demo/HelloWorld/avatar.png\" alt=\"ICON\"></p>\n</div>","site":{"data":{}},"excerpt":"<p>群友的一小步，游戏行业的一大步</p>","more":"<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Demo/HelloWorld/avatar.png\" alt=\"ICON\"></p>\n</div>"},{"title":"Git使用方法学习","date":"2024-05-28T16:00:00.000Z","updated":"2024-05-29T16:00:00.000Z","_content":"\n\n这篇文章既是记录Git的学习过程，同时也是markdown的练习，操作系统为Win11，文章末尾有自我介绍。\n\n## Git的安装和初始化配置\n1. 安装Git，[Git下载连接](https://git-scm.com/download),根据自己的操作系统进行选择，下载后运行exe文件，我下载选项暂时全部都选择默认\n2. 检查是否成功安装Git，下载完成后，打开控制面板（win+R 输入cmd），查看Git版本信息\n<!-- More -->\n    ```\n    // 输入此命令进行查看\n    git --version\n    ```\n\n3. 配置Git，配置用户名和邮箱，在命令行中输入以下指令\n\n    ```\n    git config --global user.name <此处替换为你的用户名>\n    git config --global user.email <此处替换成你的邮箱>\n\n    ```\n4. 检测是否配置成功，在命令行中输入以下指令\n    ```\n    git config user.name\n    git config user.email\n    ```\n\n## Git基础使用\n[中文官方文档链接](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93)  \n\n### 获取Git仓库\n- 在已存在目录中初始化仓库  \n\n    首先，新建一个文件夹，例如testGit，记录该文件夹的路径例如:\"D:\\testGit\"，接下来点击鼠标右键，选择Git Bash，输入指令\n    ```\n    $ cd D:\\testGit      //输入你自己文件夹的路径，该步骤是转到此文件夹下\n    ```\n    再输入\n    ```\n    $ git init        //该步骤将当前文件夹转化为一个Git仓库\n    ```\n    若显示\n    ```\n    Initialized empty Git repository in D:/testGit/.git/\n    ```\n    即为操作成功  \n\n    接下来可以在文件夹中创建两个文本文档，命名为test1和test2.  \n    通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：      \n    `$ git add *.txt`  \n    `$ git commit -m 'initial project version'`  \n\n\n- 克隆现有的仓库  \n\n    使用命令\n    ```\n    git clone <url>\n    ```\n    详情参考中文官方文档  \n\n### 记录每次更新到仓库\n工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。  \n\n1. 现在开始检查Git仓库的状态  \n   \n   在Git Bash中输入以下指令，便可查看仓库当前状态\n    ```\n    $ git status\n    ```\n    若看到以下输出\n    ```\n    On branch master\n    nothing to commit, working tree clean\n    ```\n    说明你现在的工作目录相当干净。所有已跟踪文件在上次提交后都未被更改过且当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。  \n\n2. 然后在testGit中新建一个名为README的文本文档，再次输入`$ git status`  \n    可以看到以下输出\n    ```\n    On branch master\n    Untracked files:\n    (use \"git add <file>...\" to include in what will be committed)\n        README.txt\n    nothing added to commit but untracked files present (use \"git add\" to track)\n    ```\n    可以看到新建的 README 文件出现在 Untracked files 下面。除非明确表示要跟踪某文件，否则Git不会自动纳入跟踪范围，这样做生成的二进制文件或其它不想被跟踪的文件包含进来。\n\n3. 现在让我们跟踪README文件  \n\n   使用命令 git add 开始跟踪一个文件\n    ```\n    $ git add README.txt\n    ```\n    输入`$ git status`，会看到 README 文件已被跟踪，并处于暂存状态\n    ```\n    $ git status\n    On branch master\n    Changes to be committed:\n    (use \"git restore --staged <file>...\" to unstage)\n        new file:   README.txt\n    ```\n    只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 \n\n4. 接着，尝试暂存已修改的文件\n    \n    打开test1，在其中随意写一些文字，例如\"Hello World!\"并保存修改，输入`$ git status`，可以看到\n    ```\n    ........  \n\n    Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   test1.txt\n    ```\n    test1.txt出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区.  \n    \n    要暂存这次更新，需要运行 `git add test1.txt` 命令, 接着再运行`git status`命令  \n    可以看到以下输出\n    ```\n    $ git status\n    On branch master\n    Changes to be committed:\n    (use \"git restore --staged <file>...\" to unstage)\n            new file:   README.txt\n            modified:   test1.txt\n    ```\n    可以看到现在两个文件都已暂存，下次提交时就会一并记录到仓库。 \n\n5. 提交更新，输入\n    ```\n    $ git commit\n    ```\n    屏幕显示\n    ```\n    # Please enter the commit message for your changes. Lines starting\n    # with '#' will be ignored, and an empty message aborts the commit.\n    #\n    # On branch master\n    # Changes to be committed:\n    #       new file:   README.txt\n    #       modified:   test1.txt\n    #\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    .git/COMMIT_EDITMSG [unix] (20:11 29/05/2024)                          1,0-1 All\n    \"/d/testGit/.git/COMMIT_EDITMSG\" [unix] 9L, 235B\n    ```\n    按“i”键，插入`git commit`，再按“esc”键，输入`wq`,再按回车键，便可以成功提交。  \n\n### 查看提交历史\n输入`git log`即可查看该仓库提交历史。详情指令集可查看官方文档。  \n\n\n\n---\n\n\n最后写一丢丢随笔：\n我是一个普通的大学生，从小就喜欢玩电子游戏，从4399到Steam，玩了许多电子游戏，不过那时也就仅限于玩一下而已，对于怎么制作电子游戏说不上感兴趣，让我想要学习制作电子游戏的契机说起来还挺难过的，或许是长大了，又或许是因为生活中的一些不快，我慢慢的不能像儿时那样，一整天坐在电脑桌前，全身心的投入到游戏缤纷的世界里，但是我仍然热爱电子游戏，我喜欢这些用代码和美术构成的虚拟而又缤纷的世界，所以我决定把自己对游戏的热爱从玩电子游戏到制作电子游戏。  \n\n但是万事开头难，回忆自己在大学中一年多的学习，都是像数据结构，软件工程概论这样的理论上的学习，理论学习和技术学习有着巨大的鸿沟，我根本无法从命令行开始去想象如何制作一个游戏，在我为此绞尽脑汁时，意外的在EasyX的社区中看到了大V老师的视频，这才真正开启了我学习技术的道路。\n\n跟着大V老师学习差不多快两个月了，从刚开始跟着敲井字棋，到现在见证了社区的建立，大V老师质量优秀的视频和建立的学习交流群，提供给我游戏制作技术入门的途径，对大V老师的感谢难以言表，祝大V老师的教程越来越好，吸引更多对游戏制作感兴趣的人来观看，也祝社区越办越好，成为中国游戏制作的绿洲，滋养中国游戏界。\n","source":"_posts/FlyingfishFantasticfan/git的使用学习.md","raw":"---\ntitle: Git使用方法学习\ndate: 2024-05-29\nupdated: 2024-05-30\npermalink: articles/FlyingfishFantasticfan/Git学习记录/\ncategories: FlyingfishFantasticfan\ntags: [Git,学习,自我介绍]\n---\n\n\n这篇文章既是记录Git的学习过程，同时也是markdown的练习，操作系统为Win11，文章末尾有自我介绍。\n\n## Git的安装和初始化配置\n1. 安装Git，[Git下载连接](https://git-scm.com/download),根据自己的操作系统进行选择，下载后运行exe文件，我下载选项暂时全部都选择默认\n2. 检查是否成功安装Git，下载完成后，打开控制面板（win+R 输入cmd），查看Git版本信息\n<!-- More -->\n    ```\n    // 输入此命令进行查看\n    git --version\n    ```\n\n3. 配置Git，配置用户名和邮箱，在命令行中输入以下指令\n\n    ```\n    git config --global user.name <此处替换为你的用户名>\n    git config --global user.email <此处替换成你的邮箱>\n\n    ```\n4. 检测是否配置成功，在命令行中输入以下指令\n    ```\n    git config user.name\n    git config user.email\n    ```\n\n## Git基础使用\n[中文官方文档链接](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93)  \n\n### 获取Git仓库\n- 在已存在目录中初始化仓库  \n\n    首先，新建一个文件夹，例如testGit，记录该文件夹的路径例如:\"D:\\testGit\"，接下来点击鼠标右键，选择Git Bash，输入指令\n    ```\n    $ cd D:\\testGit      //输入你自己文件夹的路径，该步骤是转到此文件夹下\n    ```\n    再输入\n    ```\n    $ git init        //该步骤将当前文件夹转化为一个Git仓库\n    ```\n    若显示\n    ```\n    Initialized empty Git repository in D:/testGit/.git/\n    ```\n    即为操作成功  \n\n    接下来可以在文件夹中创建两个文本文档，命名为test1和test2.  \n    通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：      \n    `$ git add *.txt`  \n    `$ git commit -m 'initial project version'`  \n\n\n- 克隆现有的仓库  \n\n    使用命令\n    ```\n    git clone <url>\n    ```\n    详情参考中文官方文档  \n\n### 记录每次更新到仓库\n工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。  \n\n1. 现在开始检查Git仓库的状态  \n   \n   在Git Bash中输入以下指令，便可查看仓库当前状态\n    ```\n    $ git status\n    ```\n    若看到以下输出\n    ```\n    On branch master\n    nothing to commit, working tree clean\n    ```\n    说明你现在的工作目录相当干净。所有已跟踪文件在上次提交后都未被更改过且当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。  \n\n2. 然后在testGit中新建一个名为README的文本文档，再次输入`$ git status`  \n    可以看到以下输出\n    ```\n    On branch master\n    Untracked files:\n    (use \"git add <file>...\" to include in what will be committed)\n        README.txt\n    nothing added to commit but untracked files present (use \"git add\" to track)\n    ```\n    可以看到新建的 README 文件出现在 Untracked files 下面。除非明确表示要跟踪某文件，否则Git不会自动纳入跟踪范围，这样做生成的二进制文件或其它不想被跟踪的文件包含进来。\n\n3. 现在让我们跟踪README文件  \n\n   使用命令 git add 开始跟踪一个文件\n    ```\n    $ git add README.txt\n    ```\n    输入`$ git status`，会看到 README 文件已被跟踪，并处于暂存状态\n    ```\n    $ git status\n    On branch master\n    Changes to be committed:\n    (use \"git restore --staged <file>...\" to unstage)\n        new file:   README.txt\n    ```\n    只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 \n\n4. 接着，尝试暂存已修改的文件\n    \n    打开test1，在其中随意写一些文字，例如\"Hello World!\"并保存修改，输入`$ git status`，可以看到\n    ```\n    ........  \n\n    Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   test1.txt\n    ```\n    test1.txt出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区.  \n    \n    要暂存这次更新，需要运行 `git add test1.txt` 命令, 接着再运行`git status`命令  \n    可以看到以下输出\n    ```\n    $ git status\n    On branch master\n    Changes to be committed:\n    (use \"git restore --staged <file>...\" to unstage)\n            new file:   README.txt\n            modified:   test1.txt\n    ```\n    可以看到现在两个文件都已暂存，下次提交时就会一并记录到仓库。 \n\n5. 提交更新，输入\n    ```\n    $ git commit\n    ```\n    屏幕显示\n    ```\n    # Please enter the commit message for your changes. Lines starting\n    # with '#' will be ignored, and an empty message aborts the commit.\n    #\n    # On branch master\n    # Changes to be committed:\n    #       new file:   README.txt\n    #       modified:   test1.txt\n    #\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    ~\n    .git/COMMIT_EDITMSG [unix] (20:11 29/05/2024)                          1,0-1 All\n    \"/d/testGit/.git/COMMIT_EDITMSG\" [unix] 9L, 235B\n    ```\n    按“i”键，插入`git commit`，再按“esc”键，输入`wq`,再按回车键，便可以成功提交。  \n\n### 查看提交历史\n输入`git log`即可查看该仓库提交历史。详情指令集可查看官方文档。  \n\n\n\n---\n\n\n最后写一丢丢随笔：\n我是一个普通的大学生，从小就喜欢玩电子游戏，从4399到Steam，玩了许多电子游戏，不过那时也就仅限于玩一下而已，对于怎么制作电子游戏说不上感兴趣，让我想要学习制作电子游戏的契机说起来还挺难过的，或许是长大了，又或许是因为生活中的一些不快，我慢慢的不能像儿时那样，一整天坐在电脑桌前，全身心的投入到游戏缤纷的世界里，但是我仍然热爱电子游戏，我喜欢这些用代码和美术构成的虚拟而又缤纷的世界，所以我决定把自己对游戏的热爱从玩电子游戏到制作电子游戏。  \n\n但是万事开头难，回忆自己在大学中一年多的学习，都是像数据结构，软件工程概论这样的理论上的学习，理论学习和技术学习有着巨大的鸿沟，我根本无法从命令行开始去想象如何制作一个游戏，在我为此绞尽脑汁时，意外的在EasyX的社区中看到了大V老师的视频，这才真正开启了我学习技术的道路。\n\n跟着大V老师学习差不多快两个月了，从刚开始跟着敲井字棋，到现在见证了社区的建立，大V老师质量优秀的视频和建立的学习交流群，提供给我游戏制作技术入门的途径，对大V老师的感谢难以言表，祝大V老师的教程越来越好，吸引更多对游戏制作感兴趣的人来观看，也祝社区越办越好，成为中国游戏制作的绿洲，滋养中国游戏界。\n","slug":"FlyingfishFantasticfan/git的使用学习","published":1,"__permalink":"articles/FlyingfishFantasticfan/Git学习记录/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hg70004o8yeabnyg1ae","content":"<p>这篇文章既是记录Git的学习过程，同时也是markdown的练习，操作系统为Win11，文章末尾有自我介绍。</p>\n<h2 id=\"Git的安装和初始化配置\"><a href=\"#Git的安装和初始化配置\" class=\"headerlink\" title=\"Git的安装和初始化配置\"></a>Git的安装和初始化配置</h2><ol>\n<li><p>安装Git，<a href=\"https://git-scm.com/download\">Git下载连接</a>,根据自己的操作系统进行选择，下载后运行exe文件，我下载选项暂时全部都选择默认</p>\n</li>\n<li><p>检查是否成功安装Git，下载完成后，打开控制面板（win+R 输入cmd），查看Git版本信息</p>\n<span id=\"more\"></span>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输入此命令进行查看</span><br><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置Git，配置用户名和邮箱，在命令行中输入以下指令</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &lt;此处替换为你的用户名&gt;</span><br><span class=\"line\">git config --global user.email &lt;此处替换成你的邮箱&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>检测是否配置成功，在命令行中输入以下指令</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config user.name</span><br><span class=\"line\">git config user.email</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Git基础使用\"><a href=\"#Git基础使用\" class=\"headerlink\" title=\"Git基础使用\"></a>Git基础使用</h2><p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93\">中文官方文档链接</a>  </p>\n<h3 id=\"获取Git仓库\"><a href=\"#获取Git仓库\" class=\"headerlink\" title=\"获取Git仓库\"></a>获取Git仓库</h3><ul>\n<li><p>在已存在目录中初始化仓库  </p>\n<p>  首先，新建一个文件夹，例如testGit，记录该文件夹的路径例如:”D:\\testGit”，接下来点击鼠标右键，选择Git Bash，输入指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd D:\\testGit      //输入你自己文件夹的路径，该步骤是转到此文件夹下</span><br></pre></td></tr></table></figure>\n<p>  再输入</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init        //该步骤将当前文件夹转化为一个Git仓库</span><br></pre></td></tr></table></figure>\n<p>  若显示</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initialized empty Git repository in D:/testGit/.git/</span><br></pre></td></tr></table></figure>\n<p>  即为操作成功  </p>\n<p>  接下来可以在文件夹中创建两个文本文档，命名为test1和test2.<br>  通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：<br>  <code>$ git add *.txt</code><br>  <code>$ git commit -m &#39;initial project version&#39;</code>  </p>\n</li>\n<li><p>克隆现有的仓库  </p>\n<p>  使用命令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure>\n<p>  详情参考中文官方文档</p>\n</li>\n</ul>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。  </p>\n<ol>\n<li><p>现在开始检查Git仓库的状态  </p>\n<p>在Git Bash中输入以下指令，便可查看仓库当前状态</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p> 若看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n<p> 说明你现在的工作目录相当干净。所有已跟踪文件在上次提交后都未被更改过且当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。  </p>\n</li>\n<li><p>然后在testGit中新建一个名为README的文本文档，再次输入<code>$ git status</code><br> 可以看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class=\"line\">    README.txt</span><br><span class=\"line\">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>\n<p> 可以看到新建的 README 文件出现在 Untracked files 下面。除非明确表示要跟踪某文件，否则Git不会自动纳入跟踪范围，这样做生成的二进制文件或其它不想被跟踪的文件包含进来。</p>\n</li>\n<li><p>现在让我们跟踪README文件  </p>\n<p>使用命令 git add 开始跟踪一个文件</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add README.txt</span><br></pre></td></tr></table></figure>\n<p> 输入<code>$ git status</code>，会看到 README 文件已被跟踪，并处于暂存状态</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">    new file:   README.txt</span><br></pre></td></tr></table></figure>\n<p> 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 </p>\n</li>\n<li><p>接着，尝试暂存已修改的文件</p>\n<p> 打开test1，在其中随意写一些文字，例如”Hello World!”并保存修改，输入<code>$ git status</code>，可以看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">........  </span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\">    modified:   test1.txt</span><br></pre></td></tr></table></figure>\n<p> test1.txt出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区.  </p>\n<p> 要暂存这次更新，需要运行 <code>git add test1.txt</code> 命令, 接着再运行<code>git status</code>命令<br> 可以看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">        new file:   README.txt</span><br><span class=\"line\">        modified:   test1.txt</span><br></pre></td></tr></table></figure>\n<p> 可以看到现在两个文件都已暂存，下次提交时就会一并记录到仓库。 </p>\n</li>\n<li><p>提交更新，输入</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit</span><br></pre></td></tr></table></figure>\n<p> 屏幕显示</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Please enter the commit message for your changes. Lines starting</span><br><span class=\"line\"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class=\"line\">#</span><br><span class=\"line\"># On branch master</span><br><span class=\"line\"># Changes to be committed:</span><br><span class=\"line\">#       new file:   README.txt</span><br><span class=\"line\">#       modified:   test1.txt</span><br><span class=\"line\">#</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">.git/COMMIT_EDITMSG [unix] (20:11 29/05/2024)                          1,0-1 All</span><br><span class=\"line\">&quot;/d/testGit/.git/COMMIT_EDITMSG&quot; [unix] 9L, 235B</span><br></pre></td></tr></table></figure>\n<p> 按“i”键，插入<code>git commit</code>，再按“esc”键，输入<code>wq</code>,再按回车键，便可以成功提交。</p>\n</li>\n</ol>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>输入<code>git log</code>即可查看该仓库提交历史。详情指令集可查看官方文档。  </p>\n<hr>\n<p>最后写一丢丢随笔：<br>我是一个普通的大学生，从小就喜欢玩电子游戏，从4399到Steam，玩了许多电子游戏，不过那时也就仅限于玩一下而已，对于怎么制作电子游戏说不上感兴趣，让我想要学习制作电子游戏的契机说起来还挺难过的，或许是长大了，又或许是因为生活中的一些不快，我慢慢的不能像儿时那样，一整天坐在电脑桌前，全身心的投入到游戏缤纷的世界里，但是我仍然热爱电子游戏，我喜欢这些用代码和美术构成的虚拟而又缤纷的世界，所以我决定把自己对游戏的热爱从玩电子游戏到制作电子游戏。  </p>\n<p>但是万事开头难，回忆自己在大学中一年多的学习，都是像数据结构，软件工程概论这样的理论上的学习，理论学习和技术学习有着巨大的鸿沟，我根本无法从命令行开始去想象如何制作一个游戏，在我为此绞尽脑汁时，意外的在EasyX的社区中看到了大V老师的视频，这才真正开启了我学习技术的道路。</p>\n<p>跟着大V老师学习差不多快两个月了，从刚开始跟着敲井字棋，到现在见证了社区的建立，大V老师质量优秀的视频和建立的学习交流群，提供给我游戏制作技术入门的途径，对大V老师的感谢难以言表，祝大V老师的教程越来越好，吸引更多对游戏制作感兴趣的人来观看，也祝社区越办越好，成为中国游戏制作的绿洲，滋养中国游戏界。</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章既是记录Git的学习过程，同时也是markdown的练习，操作系统为Win11，文章末尾有自我介绍。</p>\n<h2 id=\"Git的安装和初始化配置\"><a href=\"#Git的安装和初始化配置\" class=\"headerlink\" title=\"Git的安装和初始化配置\"></a>Git的安装和初始化配置</h2><ol>\n<li><p>安装Git，<a href=\"https://git-scm.com/download\">Git下载连接</a>,根据自己的操作系统进行选择，下载后运行exe文件，我下载选项暂时全部都选择默认</p>\n</li>\n<li><p>检查是否成功安装Git，下载完成后，打开控制面板（win+R 输入cmd），查看Git版本信息</p>","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输入此命令进行查看</span><br><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置Git，配置用户名和邮箱，在命令行中输入以下指令</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &lt;此处替换为你的用户名&gt;</span><br><span class=\"line\">git config --global user.email &lt;此处替换成你的邮箱&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>检测是否配置成功，在命令行中输入以下指令</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config user.name</span><br><span class=\"line\">git config user.email</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Git基础使用\"><a href=\"#Git基础使用\" class=\"headerlink\" title=\"Git基础使用\"></a>Git基础使用</h2><p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93\">中文官方文档链接</a>  </p>\n<h3 id=\"获取Git仓库\"><a href=\"#获取Git仓库\" class=\"headerlink\" title=\"获取Git仓库\"></a>获取Git仓库</h3><ul>\n<li><p>在已存在目录中初始化仓库  </p>\n<p>  首先，新建一个文件夹，例如testGit，记录该文件夹的路径例如:”D:\\testGit”，接下来点击鼠标右键，选择Git Bash，输入指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd D:\\testGit      //输入你自己文件夹的路径，该步骤是转到此文件夹下</span><br></pre></td></tr></table></figure>\n<p>  再输入</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init        //该步骤将当前文件夹转化为一个Git仓库</span><br></pre></td></tr></table></figure>\n<p>  若显示</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initialized empty Git repository in D:/testGit/.git/</span><br></pre></td></tr></table></figure>\n<p>  即为操作成功  </p>\n<p>  接下来可以在文件夹中创建两个文本文档，命名为test1和test2.<br>  通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：<br>  <code>$ git add *.txt</code><br>  <code>$ git commit -m &#39;initial project version&#39;</code>  </p>\n</li>\n<li><p>克隆现有的仓库  </p>\n<p>  使用命令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure>\n<p>  详情参考中文官方文档</p>\n</li>\n</ul>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。  </p>\n<ol>\n<li><p>现在开始检查Git仓库的状态  </p>\n<p>在Git Bash中输入以下指令，便可查看仓库当前状态</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p> 若看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n<p> 说明你现在的工作目录相当干净。所有已跟踪文件在上次提交后都未被更改过且当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。  </p>\n</li>\n<li><p>然后在testGit中新建一个名为README的文本文档，再次输入<code>$ git status</code><br> 可以看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class=\"line\">    README.txt</span><br><span class=\"line\">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>\n<p> 可以看到新建的 README 文件出现在 Untracked files 下面。除非明确表示要跟踪某文件，否则Git不会自动纳入跟踪范围，这样做生成的二进制文件或其它不想被跟踪的文件包含进来。</p>\n</li>\n<li><p>现在让我们跟踪README文件  </p>\n<p>使用命令 git add 开始跟踪一个文件</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add README.txt</span><br></pre></td></tr></table></figure>\n<p> 输入<code>$ git status</code>，会看到 README 文件已被跟踪，并处于暂存状态</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">    new file:   README.txt</span><br></pre></td></tr></table></figure>\n<p> 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 </p>\n</li>\n<li><p>接着，尝试暂存已修改的文件</p>\n<p> 打开test1，在其中随意写一些文字，例如”Hello World!”并保存修改，输入<code>$ git status</code>，可以看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">........  </span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\">    modified:   test1.txt</span><br></pre></td></tr></table></figure>\n<p> test1.txt出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区.  </p>\n<p> 要暂存这次更新，需要运行 <code>git add test1.txt</code> 命令, 接着再运行<code>git status</code>命令<br> 可以看到以下输出</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">        new file:   README.txt</span><br><span class=\"line\">        modified:   test1.txt</span><br></pre></td></tr></table></figure>\n<p> 可以看到现在两个文件都已暂存，下次提交时就会一并记录到仓库。 </p>\n</li>\n<li><p>提交更新，输入</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit</span><br></pre></td></tr></table></figure>\n<p> 屏幕显示</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Please enter the commit message for your changes. Lines starting</span><br><span class=\"line\"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class=\"line\">#</span><br><span class=\"line\"># On branch master</span><br><span class=\"line\"># Changes to be committed:</span><br><span class=\"line\">#       new file:   README.txt</span><br><span class=\"line\">#       modified:   test1.txt</span><br><span class=\"line\">#</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">~</span><br><span class=\"line\">.git/COMMIT_EDITMSG [unix] (20:11 29/05/2024)                          1,0-1 All</span><br><span class=\"line\">&quot;/d/testGit/.git/COMMIT_EDITMSG&quot; [unix] 9L, 235B</span><br></pre></td></tr></table></figure>\n<p> 按“i”键，插入<code>git commit</code>，再按“esc”键，输入<code>wq</code>,再按回车键，便可以成功提交。</p>\n</li>\n</ol>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>输入<code>git log</code>即可查看该仓库提交历史。详情指令集可查看官方文档。  </p>\n<hr>\n<p>最后写一丢丢随笔：<br>我是一个普通的大学生，从小就喜欢玩电子游戏，从4399到Steam，玩了许多电子游戏，不过那时也就仅限于玩一下而已，对于怎么制作电子游戏说不上感兴趣，让我想要学习制作电子游戏的契机说起来还挺难过的，或许是长大了，又或许是因为生活中的一些不快，我慢慢的不能像儿时那样，一整天坐在电脑桌前，全身心的投入到游戏缤纷的世界里，但是我仍然热爱电子游戏，我喜欢这些用代码和美术构成的虚拟而又缤纷的世界，所以我决定把自己对游戏的热爱从玩电子游戏到制作电子游戏。  </p>\n<p>但是万事开头难，回忆自己在大学中一年多的学习，都是像数据结构，软件工程概论这样的理论上的学习，理论学习和技术学习有着巨大的鸿沟，我根本无法从命令行开始去想象如何制作一个游戏，在我为此绞尽脑汁时，意外的在EasyX的社区中看到了大V老师的视频，这才真正开启了我学习技术的道路。</p>\n<p>跟着大V老师学习差不多快两个月了，从刚开始跟着敲井字棋，到现在见证了社区的建立，大V老师质量优秀的视频和建立的学习交流群，提供给我游戏制作技术入门的途径，对大V老师的感谢难以言表，祝大V老师的教程越来越好，吸引更多对游戏制作感兴趣的人来观看，也祝社区越办越好，成为中国游戏制作的绿洲，滋养中国游戏界。</p>"},{"title":"游戏设计知识分享笔记-依赖性","date":"2024-06-07T16:00:00.000Z","updated":"2024-06-08T16:00:00.000Z","_content":"\n飞鱼丸的个人博客建成啦，欢迎大家参观！[点击传送原文](https://flyingfishfantasticfan.github.io/2024/06/08/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/)  \n## 前言\n在构思一个新游戏时常常会有许多想法，诸如不同的挑战、系统以及界面，完整的游戏常常会包含上百种机制及子系统，在已经构思好许多子系统后，紧接着我们要开始游戏的开发，现在我们有以下的选择\n- 最简单的模块\n- 最擅长的模块\n- 最具特色的模块\n- 常常能听到的核心玩法  \n\n绝大多数游戏开发者都会建议从核心玩法开始开发，但是为什么要这样做呢？  \n<!-- More -->\n## 游戏开发顺序的影响\n当我们为某个已经完成的游戏制作几个额外关卡时，开发的顺序无关紧要，关卡之间并不会相互影响，但制作游戏并不一样，不同设计之间常常相互依赖\n<div style=\"text-align:center\">\n\n![ICON](articles/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/游戏设计知识分享-依赖性-1.png)\n\n</div>\n \n当我们修改某一个模块时，依赖于该模块的部分必然也会发生变化，例如，假设最初开发时先完成了场景布局，设计了一条玩家无法跳过只能从桥梁通过的河流，完成场景布局后，为了优秀的视觉表现，把桥梁设计的十分精美，河流周围的景色也十分美丽，但是在随后的开发中发现玩家的跳跃能力不够灵活，需要增强玩家跳跃能力，导致了原本设计无法跳过去的河流可以跳过去了，就得再修改场景布局，同时依赖于场景布局的视觉表现也需要再重新制作，若能够再开发前对不同模块的依赖性有更深刻的理解，我们也许会先确立移动体系，随后再去进行场景布局和视觉表现。  \n\n## 如何确定游戏开发顺序\n我们可以通过画依赖关系图，来分析识别设计中关键的依赖性，从而确定开发顺序\n1. 将游戏分解成许多独立的因素，包含机制，操作，界面，子系统等等，每个因素应包含一份详细的设计方案。\n2. 识别出各个因素之间关键的依赖，并通过树状图的结构将所有的因素囊括进来，通过连线来描述依赖关系。\n>TIPS:对A模块进行修改时会影响B模块时，便可称B依赖A，在设计中常常会出现A与B之间互相依赖的情况，事实上任何设计之间都会存在一定的依赖关系，在依赖关系图中会有意忽略依赖性较弱的部分，以便开发时能够更加专注于最重要的元素，时刻记得依赖关系图只是帮助开发进行决策的工具，无止境的拘泥于过于细致的分析只会导致项目难以推动。  \n\n## 额外需要注意的地方\n\n### 原创的不确定性\n原创度较高的游戏常会出现不按照设计方案来实现，这种不确定性使得依赖性变得非常重要，某个设计中出现的不确定不足以说明问题，然后由于依赖性的存在，不确定性会因为多层依赖的存在逐步积累，因此位于依赖关系图顶层的内容常常重新设计，甚至直接被删除。\n\n### 应对措施\n重新梳理最初的依赖关系图，将短期内不会实现的内容以及相互独立的设计灵感放置于设计库中，将底层的内容实现并测试再进行迭代，此时并没有依赖关系的存在，因此并不会产生巨大的不确定性积累，等到底层系统确定性足够高后再将设计库某一内容添加进来。\n\n>TIPS：可以将最初版所有内容包含进来的依赖关系图中拿走但不会使游戏毫无意义的内容全部拿走，剩下的就是核心玩法，核心玩法常常可以用于定义某一游戏的类型，尽早完成核心玩法的开发，可以让项目尽快开始进行测试及迭代。  ","source":"_posts/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性.md","raw":"---\ntitle: 游戏设计知识分享笔记-依赖性\ndate: 2024-06-08\nupdated: 2024-06-09\npermalink: articles/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/\ncategories: FlyingfishFantasticfan\ntags: [游戏设计,学习]\n---\n\n飞鱼丸的个人博客建成啦，欢迎大家参观！[点击传送原文](https://flyingfishfantasticfan.github.io/2024/06/08/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/)  \n## 前言\n在构思一个新游戏时常常会有许多想法，诸如不同的挑战、系统以及界面，完整的游戏常常会包含上百种机制及子系统，在已经构思好许多子系统后，紧接着我们要开始游戏的开发，现在我们有以下的选择\n- 最简单的模块\n- 最擅长的模块\n- 最具特色的模块\n- 常常能听到的核心玩法  \n\n绝大多数游戏开发者都会建议从核心玩法开始开发，但是为什么要这样做呢？  \n<!-- More -->\n## 游戏开发顺序的影响\n当我们为某个已经完成的游戏制作几个额外关卡时，开发的顺序无关紧要，关卡之间并不会相互影响，但制作游戏并不一样，不同设计之间常常相互依赖\n<div style=\"text-align:center\">\n\n![ICON](articles/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/游戏设计知识分享-依赖性-1.png)\n\n</div>\n \n当我们修改某一个模块时，依赖于该模块的部分必然也会发生变化，例如，假设最初开发时先完成了场景布局，设计了一条玩家无法跳过只能从桥梁通过的河流，完成场景布局后，为了优秀的视觉表现，把桥梁设计的十分精美，河流周围的景色也十分美丽，但是在随后的开发中发现玩家的跳跃能力不够灵活，需要增强玩家跳跃能力，导致了原本设计无法跳过去的河流可以跳过去了，就得再修改场景布局，同时依赖于场景布局的视觉表现也需要再重新制作，若能够再开发前对不同模块的依赖性有更深刻的理解，我们也许会先确立移动体系，随后再去进行场景布局和视觉表现。  \n\n## 如何确定游戏开发顺序\n我们可以通过画依赖关系图，来分析识别设计中关键的依赖性，从而确定开发顺序\n1. 将游戏分解成许多独立的因素，包含机制，操作，界面，子系统等等，每个因素应包含一份详细的设计方案。\n2. 识别出各个因素之间关键的依赖，并通过树状图的结构将所有的因素囊括进来，通过连线来描述依赖关系。\n>TIPS:对A模块进行修改时会影响B模块时，便可称B依赖A，在设计中常常会出现A与B之间互相依赖的情况，事实上任何设计之间都会存在一定的依赖关系，在依赖关系图中会有意忽略依赖性较弱的部分，以便开发时能够更加专注于最重要的元素，时刻记得依赖关系图只是帮助开发进行决策的工具，无止境的拘泥于过于细致的分析只会导致项目难以推动。  \n\n## 额外需要注意的地方\n\n### 原创的不确定性\n原创度较高的游戏常会出现不按照设计方案来实现，这种不确定性使得依赖性变得非常重要，某个设计中出现的不确定不足以说明问题，然后由于依赖性的存在，不确定性会因为多层依赖的存在逐步积累，因此位于依赖关系图顶层的内容常常重新设计，甚至直接被删除。\n\n### 应对措施\n重新梳理最初的依赖关系图，将短期内不会实现的内容以及相互独立的设计灵感放置于设计库中，将底层的内容实现并测试再进行迭代，此时并没有依赖关系的存在，因此并不会产生巨大的不确定性积累，等到底层系统确定性足够高后再将设计库某一内容添加进来。\n\n>TIPS：可以将最初版所有内容包含进来的依赖关系图中拿走但不会使游戏毫无意义的内容全部拿走，剩下的就是核心玩法，核心玩法常常可以用于定义某一游戏的类型，尽早完成核心玩法的开发，可以让项目尽快开始进行测试及迭代。  ","slug":"FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性","published":1,"__permalink":"articles/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hg80005o8yea1488m2y","content":"<p>飞鱼丸的个人博客建成啦，欢迎大家参观！<a href=\"https://flyingfishfantasticfan.github.io/2024/06/08/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/\">点击传送原文</a>  </p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在构思一个新游戏时常常会有许多想法，诸如不同的挑战、系统以及界面，完整的游戏常常会包含上百种机制及子系统，在已经构思好许多子系统后，紧接着我们要开始游戏的开发，现在我们有以下的选择</p>\n<ul>\n<li>最简单的模块</li>\n<li>最擅长的模块</li>\n<li>最具特色的模块</li>\n<li>常常能听到的核心玩法</li>\n</ul>\n<p>绝大多数游戏开发者都会建议从核心玩法开始开发，但是为什么要这样做呢？  </p>\n<span id=\"more\"></span>\n<h2 id=\"游戏开发顺序的影响\"><a href=\"#游戏开发顺序的影响\" class=\"headerlink\" title=\"游戏开发顺序的影响\"></a>游戏开发顺序的影响</h2><p>当我们为某个已经完成的游戏制作几个额外关卡时，开发的顺序无关紧要，关卡之间并不会相互影响，但制作游戏并不一样，不同设计之间常常相互依赖</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB-%E4%BE%9D%E8%B5%96%E6%80%A7-1.png\" alt=\"ICON\"></p>\n</div>\n \n<p>当我们修改某一个模块时，依赖于该模块的部分必然也会发生变化，例如，假设最初开发时先完成了场景布局，设计了一条玩家无法跳过只能从桥梁通过的河流，完成场景布局后，为了优秀的视觉表现，把桥梁设计的十分精美，河流周围的景色也十分美丽，但是在随后的开发中发现玩家的跳跃能力不够灵活，需要增强玩家跳跃能力，导致了原本设计无法跳过去的河流可以跳过去了，就得再修改场景布局，同时依赖于场景布局的视觉表现也需要再重新制作，若能够再开发前对不同模块的依赖性有更深刻的理解，我们也许会先确立移动体系，随后再去进行场景布局和视觉表现。  </p>\n<h2 id=\"如何确定游戏开发顺序\"><a href=\"#如何确定游戏开发顺序\" class=\"headerlink\" title=\"如何确定游戏开发顺序\"></a>如何确定游戏开发顺序</h2><p>我们可以通过画依赖关系图，来分析识别设计中关键的依赖性，从而确定开发顺序</p>\n<ol>\n<li>将游戏分解成许多独立的因素，包含机制，操作，界面，子系统等等，每个因素应包含一份详细的设计方案。</li>\n<li>识别出各个因素之间关键的依赖，并通过树状图的结构将所有的因素囊括进来，通过连线来描述依赖关系。<blockquote>\n<p>TIPS:对A模块进行修改时会影响B模块时，便可称B依赖A，在设计中常常会出现A与B之间互相依赖的情况，事实上任何设计之间都会存在一定的依赖关系，在依赖关系图中会有意忽略依赖性较弱的部分，以便开发时能够更加专注于最重要的元素，时刻记得依赖关系图只是帮助开发进行决策的工具，无止境的拘泥于过于细致的分析只会导致项目难以推动。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"额外需要注意的地方\"><a href=\"#额外需要注意的地方\" class=\"headerlink\" title=\"额外需要注意的地方\"></a>额外需要注意的地方</h2><h3 id=\"原创的不确定性\"><a href=\"#原创的不确定性\" class=\"headerlink\" title=\"原创的不确定性\"></a>原创的不确定性</h3><p>原创度较高的游戏常会出现不按照设计方案来实现，这种不确定性使得依赖性变得非常重要，某个设计中出现的不确定不足以说明问题，然后由于依赖性的存在，不确定性会因为多层依赖的存在逐步积累，因此位于依赖关系图顶层的内容常常重新设计，甚至直接被删除。</p>\n<h3 id=\"应对措施\"><a href=\"#应对措施\" class=\"headerlink\" title=\"应对措施\"></a>应对措施</h3><p>重新梳理最初的依赖关系图，将短期内不会实现的内容以及相互独立的设计灵感放置于设计库中，将底层的内容实现并测试再进行迭代，此时并没有依赖关系的存在，因此并不会产生巨大的不确定性积累，等到底层系统确定性足够高后再将设计库某一内容添加进来。</p>\n<blockquote>\n<p>TIPS：可以将最初版所有内容包含进来的依赖关系图中拿走但不会使游戏毫无意义的内容全部拿走，剩下的就是核心玩法，核心玩法常常可以用于定义某一游戏的类型，尽早完成核心玩法的开发，可以让项目尽快开始进行测试及迭代。  </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>飞鱼丸的个人博客建成啦，欢迎大家参观！<a href=\"https://flyingfishfantasticfan.github.io/2024/06/08/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/\">点击传送原文</a>  </p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在构思一个新游戏时常常会有许多想法，诸如不同的挑战、系统以及界面，完整的游戏常常会包含上百种机制及子系统，在已经构思好许多子系统后，紧接着我们要开始游戏的开发，现在我们有以下的选择</p>\n<ul>\n<li>最简单的模块</li>\n<li>最擅长的模块</li>\n<li>最具特色的模块</li>\n<li>常常能听到的核心玩法</li>\n</ul>\n<p>绝大多数游戏开发者都会建议从核心玩法开始开发，但是为什么要这样做呢？  </p>","more":"<h2 id=\"游戏开发顺序的影响\"><a href=\"#游戏开发顺序的影响\" class=\"headerlink\" title=\"游戏开发顺序的影响\"></a>游戏开发顺序的影响</h2><p>当我们为某个已经完成的游戏制作几个额外关卡时，开发的顺序无关紧要，关卡之间并不会相互影响，但制作游戏并不一样，不同设计之间常常相互依赖</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%80%A7/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB-%E4%BE%9D%E8%B5%96%E6%80%A7-1.png\" alt=\"ICON\"></p>\n</div>\n \n<p>当我们修改某一个模块时，依赖于该模块的部分必然也会发生变化，例如，假设最初开发时先完成了场景布局，设计了一条玩家无法跳过只能从桥梁通过的河流，完成场景布局后，为了优秀的视觉表现，把桥梁设计的十分精美，河流周围的景色也十分美丽，但是在随后的开发中发现玩家的跳跃能力不够灵活，需要增强玩家跳跃能力，导致了原本设计无法跳过去的河流可以跳过去了，就得再修改场景布局，同时依赖于场景布局的视觉表现也需要再重新制作，若能够再开发前对不同模块的依赖性有更深刻的理解，我们也许会先确立移动体系，随后再去进行场景布局和视觉表现。  </p>\n<h2 id=\"如何确定游戏开发顺序\"><a href=\"#如何确定游戏开发顺序\" class=\"headerlink\" title=\"如何确定游戏开发顺序\"></a>如何确定游戏开发顺序</h2><p>我们可以通过画依赖关系图，来分析识别设计中关键的依赖性，从而确定开发顺序</p>\n<ol>\n<li>将游戏分解成许多独立的因素，包含机制，操作，界面，子系统等等，每个因素应包含一份详细的设计方案。</li>\n<li>识别出各个因素之间关键的依赖，并通过树状图的结构将所有的因素囊括进来，通过连线来描述依赖关系。<blockquote>\n<p>TIPS:对A模块进行修改时会影响B模块时，便可称B依赖A，在设计中常常会出现A与B之间互相依赖的情况，事实上任何设计之间都会存在一定的依赖关系，在依赖关系图中会有意忽略依赖性较弱的部分，以便开发时能够更加专注于最重要的元素，时刻记得依赖关系图只是帮助开发进行决策的工具，无止境的拘泥于过于细致的分析只会导致项目难以推动。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"额外需要注意的地方\"><a href=\"#额外需要注意的地方\" class=\"headerlink\" title=\"额外需要注意的地方\"></a>额外需要注意的地方</h2><h3 id=\"原创的不确定性\"><a href=\"#原创的不确定性\" class=\"headerlink\" title=\"原创的不确定性\"></a>原创的不确定性</h3><p>原创度较高的游戏常会出现不按照设计方案来实现，这种不确定性使得依赖性变得非常重要，某个设计中出现的不确定不足以说明问题，然后由于依赖性的存在，不确定性会因为多层依赖的存在逐步积累，因此位于依赖关系图顶层的内容常常重新设计，甚至直接被删除。</p>\n<h3 id=\"应对措施\"><a href=\"#应对措施\" class=\"headerlink\" title=\"应对措施\"></a>应对措施</h3><p>重新梳理最初的依赖关系图，将短期内不会实现的内容以及相互独立的设计灵感放置于设计库中，将底层的内容实现并测试再进行迭代，此时并没有依赖关系的存在，因此并不会产生巨大的不确定性积累，等到底层系统确定性足够高后再将设计库某一内容添加进来。</p>\n<blockquote>\n<p>TIPS：可以将最初版所有内容包含进来的依赖关系图中拿走但不会使游戏毫无意义的内容全部拿走，剩下的就是核心玩法，核心玩法常常可以用于定义某一游戏的类型，尽早完成核心玩法的开发，可以让项目尽快开始进行测试及迭代。  </p>\n</blockquote>"},{"title":"游戏评测-Balatro小丑牌","date":"2024-06-09T16:00:00.000Z","updated":"2024-06-09T16:00:00.000Z","_content":"\n## 概述\nBalatro是一款牌组构筑式类rogue游戏，玩家可以依照德州扑克的出牌规则，通过出牌弃牌两个简单的行为积累分数，当分数高于当前盲注要求的分数时便通过该盲注，每次通过盲注时会进入商店，商店中售卖小丑牌、不同卡包，玩家可以通过购买小丑牌、卡包完成卡组的构筑。  \n<!-- More -->\n## 游玩体验\n我是一个较深度的卡牌rogue玩家，玩过并且通关最高难度了许多类似游戏，包括杀戮尖塔、怪物火车、邪恶冥刻等等，卡牌rogue通过构筑、计算克服高难度的游戏体验令我十分着迷，每个种子的差异也让重复游玩都有不一样的乐趣，Balatro作为一款优秀的牌组构筑式rogue自然也有以上的优点，此外它还有自己更加独特的体验。  \n在前十个小时的游玩过程中，我尝试将以往其他卡牌rogue的经验往Balatro身上套用，Balatro通过计算筹码和倍率的乘积得到一次出牌后的分数\n\n<div style=\"text-align:center\">\n\n![蓝色为筹码，红色为倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/计分板.png)\n\n</div>  \n\n\n游戏中的小丑牌大概可以分为一下几种：  \n加筹码的小丑牌\n\n<div style=\"text-align:center\">\n\n![蓝色小丑 效果为卡组中每个剩余的牌提供2筹码](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Blue_Joker.webp)\n\n</div>  \n\n加倍率的小丑牌\n\n<div style=\"text-align:center\">\n\n![小丑 效果为+4倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Joker.webp)\n\n</div>  \n\n乘倍率的小丑牌\n\n<div style=\"text-align:center\">\n\n![卡文迪许 效果为×3倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Cavendish.webp)\n\n</div>  \n\n提供资源的小丑牌\n\n<div style=\"text-align:center\">\n\n![黄金小丑 效果为每回合后提供4金币](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Golden_Joker.webp)\n\n</div>  \n\n改变规则的小丑牌\n\n<div style=\"text-align:center\">\n\n![四指 效果为同花和顺子仅需要4张牌](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Four_Fingers.webp)\n\n</div>  \n \n游戏中还有一些消耗品：星球牌可以升级某一牌型的效果，但是我觉得除了高牌、对子以外其他牌型都有一定的不稳定性，也就是怕鬼抽；塔罗牌拥有许多效果，绝大多数拥有改造牌组的能力，但是我觉得提供的增益杯水车薪。\n于是乎我把重心全部放在拥有强力效果的小丑牌上，我将杀戮尖塔玩家群体的三端学说搬运了过来，将Balatro也分为三端，基础筹码端，基础倍率端，倍率成倍端，我基本上每一局都是拿一张加筹码的小丑牌，一张加倍率的小丑牌，剩下全拿乘倍率的小丑牌，用这个简单的思路，我很快就通关了最高难度金注，运气好的时候甚至打了个四连胜。  \n但是这样玩起来千篇一律，每一局都是差不多的赢差不多的输，我很快就感到了乏味，在玩Balatro的第15个小时便就失去了兴趣，于是乎我便想看看其他玩家是怎么玩这个游戏的，结果令我大吃一惊，我看到了钢k男爵、四指同花顺、人头流、同花五条等等极具想象力的构筑    \n\n<div style=\"text-align:center\">\n\n![同花顺原本是很难凑齐的强力牌型，但拥有四指后，变得十分容易凑出来](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/四指同花顺.png)\n\n</div>  \n\n我迫不及待的打开游戏，开始试验起了不同玩法，其中有一局让我印象十分深刻，我凑齐了以下几个小丑牌    \n\n<div style=\"text-align:center\">\n\n![未断选票 效果为将每次出牌第一个计分的牌额外触发两次](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Hanging_Chad.webp)\n\n</div>  \n\n\n<div style=\"text-align:center\">\n\n![微笑表情 效果为每个计分的人头牌提供+5倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Smiley_Face.webp)\n\n</div>  \n\n<div style=\"text-align:center\">\n\n![人脸照 效果为每次出牌第一个计分的人头牌提供×2倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Photograph.webp)\n\n</div>  \n\n再加上我通过塔罗牌改造的有大量玻璃人头牌的卡组，我随意一次出牌便可以突破十亿的分数，而以上这三张小丑牌都只是普通稀有度，十分容易凑齐。  \n\n## 总结\n通过尝试各种搭配，游戏体验变得极其丰富有趣，每一局游戏都变成了脑洞大开的实验，Balatro并没有像其他游戏那样的敌人，缺乏了些斗智斗勇的感觉，取而代之的便是将游戏的可能性提高到了一个新的高度，同时Balatro有一个不能忽略的优点，极其优秀的视听体验，当看着分数不停上涨时，动感的音效伴随计分板冒出的火焰，总能使我十分激动，每次打开卡包时的动画也让人眼前一亮。\n不过游戏并非没有缺点，事实上游戏的设计导致了很多局基本上没有玩家能够改变的余地，杀戮尖塔的顶级玩家可以做到最高难度500多连胜，几乎已经验证了玩家可以通过自身的决策赢下每一局，而Balatro目前为止最高连胜次数都没有超过十次，这反映出游戏设计可能并不完美，运气的因素有着过大的占比，此外，在我60h的游玩后，有许多构筑我仍然没有体验过，哪怕我刻意的去进行某个流派的构筑，成功构筑可能性也很低，尝试各种流派过于不稳定，胜率远远不如三端的玩法。\n总体而言，Balatro是一款十分优秀的卡牌rogue，瑕不掩瑜，近期的更新也对最高难度进行了调整，相信未来Balatro能够解决这些缺点，把如同实验室的玩法发挥到极致。\n\n\n>图片资源来源于[Balatro wiki](https://balatrogame.fandom.com/wiki/Balatro),如有侵权，联系删除。\n\n","source":"_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌.md","raw":"---\ntitle: 游戏评测-Balatro小丑牌\ndate: 2024-06-10\nupdated: 2024-06-10\npermalink: articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/\ncategories: FlyingfishFantasticfan\ntags: [游戏评测,小丑牌,Balatro]\n---\n\n## 概述\nBalatro是一款牌组构筑式类rogue游戏，玩家可以依照德州扑克的出牌规则，通过出牌弃牌两个简单的行为积累分数，当分数高于当前盲注要求的分数时便通过该盲注，每次通过盲注时会进入商店，商店中售卖小丑牌、不同卡包，玩家可以通过购买小丑牌、卡包完成卡组的构筑。  \n<!-- More -->\n## 游玩体验\n我是一个较深度的卡牌rogue玩家，玩过并且通关最高难度了许多类似游戏，包括杀戮尖塔、怪物火车、邪恶冥刻等等，卡牌rogue通过构筑、计算克服高难度的游戏体验令我十分着迷，每个种子的差异也让重复游玩都有不一样的乐趣，Balatro作为一款优秀的牌组构筑式rogue自然也有以上的优点，此外它还有自己更加独特的体验。  \n在前十个小时的游玩过程中，我尝试将以往其他卡牌rogue的经验往Balatro身上套用，Balatro通过计算筹码和倍率的乘积得到一次出牌后的分数\n\n<div style=\"text-align:center\">\n\n![蓝色为筹码，红色为倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/计分板.png)\n\n</div>  \n\n\n游戏中的小丑牌大概可以分为一下几种：  \n加筹码的小丑牌\n\n<div style=\"text-align:center\">\n\n![蓝色小丑 效果为卡组中每个剩余的牌提供2筹码](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Blue_Joker.webp)\n\n</div>  \n\n加倍率的小丑牌\n\n<div style=\"text-align:center\">\n\n![小丑 效果为+4倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Joker.webp)\n\n</div>  \n\n乘倍率的小丑牌\n\n<div style=\"text-align:center\">\n\n![卡文迪许 效果为×3倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Cavendish.webp)\n\n</div>  \n\n提供资源的小丑牌\n\n<div style=\"text-align:center\">\n\n![黄金小丑 效果为每回合后提供4金币](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Golden_Joker.webp)\n\n</div>  \n\n改变规则的小丑牌\n\n<div style=\"text-align:center\">\n\n![四指 效果为同花和顺子仅需要4张牌](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Four_Fingers.webp)\n\n</div>  \n \n游戏中还有一些消耗品：星球牌可以升级某一牌型的效果，但是我觉得除了高牌、对子以外其他牌型都有一定的不稳定性，也就是怕鬼抽；塔罗牌拥有许多效果，绝大多数拥有改造牌组的能力，但是我觉得提供的增益杯水车薪。\n于是乎我把重心全部放在拥有强力效果的小丑牌上，我将杀戮尖塔玩家群体的三端学说搬运了过来，将Balatro也分为三端，基础筹码端，基础倍率端，倍率成倍端，我基本上每一局都是拿一张加筹码的小丑牌，一张加倍率的小丑牌，剩下全拿乘倍率的小丑牌，用这个简单的思路，我很快就通关了最高难度金注，运气好的时候甚至打了个四连胜。  \n但是这样玩起来千篇一律，每一局都是差不多的赢差不多的输，我很快就感到了乏味，在玩Balatro的第15个小时便就失去了兴趣，于是乎我便想看看其他玩家是怎么玩这个游戏的，结果令我大吃一惊，我看到了钢k男爵、四指同花顺、人头流、同花五条等等极具想象力的构筑    \n\n<div style=\"text-align:center\">\n\n![同花顺原本是很难凑齐的强力牌型，但拥有四指后，变得十分容易凑出来](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/四指同花顺.png)\n\n</div>  \n\n我迫不及待的打开游戏，开始试验起了不同玩法，其中有一局让我印象十分深刻，我凑齐了以下几个小丑牌    \n\n<div style=\"text-align:center\">\n\n![未断选票 效果为将每次出牌第一个计分的牌额外触发两次](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Hanging_Chad.webp)\n\n</div>  \n\n\n<div style=\"text-align:center\">\n\n![微笑表情 效果为每个计分的人头牌提供+5倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Smiley_Face.webp)\n\n</div>  \n\n<div style=\"text-align:center\">\n\n![人脸照 效果为每次出牌第一个计分的人头牌提供×2倍率](articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Photograph.webp)\n\n</div>  \n\n再加上我通过塔罗牌改造的有大量玻璃人头牌的卡组，我随意一次出牌便可以突破十亿的分数，而以上这三张小丑牌都只是普通稀有度，十分容易凑齐。  \n\n## 总结\n通过尝试各种搭配，游戏体验变得极其丰富有趣，每一局游戏都变成了脑洞大开的实验，Balatro并没有像其他游戏那样的敌人，缺乏了些斗智斗勇的感觉，取而代之的便是将游戏的可能性提高到了一个新的高度，同时Balatro有一个不能忽略的优点，极其优秀的视听体验，当看着分数不停上涨时，动感的音效伴随计分板冒出的火焰，总能使我十分激动，每次打开卡包时的动画也让人眼前一亮。\n不过游戏并非没有缺点，事实上游戏的设计导致了很多局基本上没有玩家能够改变的余地，杀戮尖塔的顶级玩家可以做到最高难度500多连胜，几乎已经验证了玩家可以通过自身的决策赢下每一局，而Balatro目前为止最高连胜次数都没有超过十次，这反映出游戏设计可能并不完美，运气的因素有着过大的占比，此外，在我60h的游玩后，有许多构筑我仍然没有体验过，哪怕我刻意的去进行某个流派的构筑，成功构筑可能性也很低，尝试各种流派过于不稳定，胜率远远不如三端的玩法。\n总体而言，Balatro是一款十分优秀的卡牌rogue，瑕不掩瑜，近期的更新也对最高难度进行了调整，相信未来Balatro能够解决这些缺点，把如同实验室的玩法发挥到极致。\n\n\n>图片资源来源于[Balatro wiki](https://balatrogame.fandom.com/wiki/Balatro),如有侵权，联系删除。\n\n","slug":"FlyingfishFantasticfan/游戏评测-Balatro小丑牌","published":1,"__permalink":"articles/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hg90009o8ye3b9e4vsg","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Balatro是一款牌组构筑式类rogue游戏，玩家可以依照德州扑克的出牌规则，通过出牌弃牌两个简单的行为积累分数，当分数高于当前盲注要求的分数时便通过该盲注，每次通过盲注时会进入商店，商店中售卖小丑牌、不同卡包，玩家可以通过购买小丑牌、卡包完成卡组的构筑。  </p>\n<span id=\"more\"></span>\n<h2 id=\"游玩体验\"><a href=\"#游玩体验\" class=\"headerlink\" title=\"游玩体验\"></a>游玩体验</h2><p>我是一个较深度的卡牌rogue玩家，玩过并且通关最高难度了许多类似游戏，包括杀戮尖塔、怪物火车、邪恶冥刻等等，卡牌rogue通过构筑、计算克服高难度的游戏体验令我十分着迷，每个种子的差异也让重复游玩都有不一样的乐趣，Balatro作为一款优秀的牌组构筑式rogue自然也有以上的优点，此外它还有自己更加独特的体验。<br>在前十个小时的游玩过程中，我尝试将以往其他卡牌rogue的经验往Balatro身上套用，Balatro通过计算筹码和倍率的乘积得到一次出牌后的分数</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/%E8%AE%A1%E5%88%86%E6%9D%BF.png\" alt=\"蓝色为筹码，红色为倍率\"></p>\n</div>  \n\n\n<p>游戏中的小丑牌大概可以分为一下几种：<br>加筹码的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Blue_Joker.webp\" alt=\"蓝色小丑 效果为卡组中每个剩余的牌提供2筹码\"></p>\n</div>  \n\n<p>加倍率的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Joker.webp\" alt=\"小丑 效果为+4倍率\"></p>\n</div>  \n\n<p>乘倍率的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Cavendish.webp\" alt=\"卡文迪许 效果为×3倍率\"></p>\n</div>  \n\n<p>提供资源的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Golden_Joker.webp\" alt=\"黄金小丑 效果为每回合后提供4金币\"></p>\n</div>  \n\n<p>改变规则的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Four_Fingers.webp\" alt=\"四指 效果为同花和顺子仅需要4张牌\"></p>\n</div>  \n \n<p>游戏中还有一些消耗品：星球牌可以升级某一牌型的效果，但是我觉得除了高牌、对子以外其他牌型都有一定的不稳定性，也就是怕鬼抽；塔罗牌拥有许多效果，绝大多数拥有改造牌组的能力，但是我觉得提供的增益杯水车薪。<br>于是乎我把重心全部放在拥有强力效果的小丑牌上，我将杀戮尖塔玩家群体的三端学说搬运了过来，将Balatro也分为三端，基础筹码端，基础倍率端，倍率成倍端，我基本上每一局都是拿一张加筹码的小丑牌，一张加倍率的小丑牌，剩下全拿乘倍率的小丑牌，用这个简单的思路，我很快就通关了最高难度金注，运气好的时候甚至打了个四连胜。<br>但是这样玩起来千篇一律，每一局都是差不多的赢差不多的输，我很快就感到了乏味，在玩Balatro的第15个小时便就失去了兴趣，于是乎我便想看看其他玩家是怎么玩这个游戏的，结果令我大吃一惊，我看到了钢k男爵、四指同花顺、人头流、同花五条等等极具想象力的构筑    </p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/%E5%9B%9B%E6%8C%87%E5%90%8C%E8%8A%B1%E9%A1%BA.png\" alt=\"同花顺原本是很难凑齐的强力牌型，但拥有四指后，变得十分容易凑出来\"></p>\n</div>  \n\n<p>我迫不及待的打开游戏，开始试验起了不同玩法，其中有一局让我印象十分深刻，我凑齐了以下几个小丑牌    </p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Hanging_Chad.webp\" alt=\"未断选票 效果为将每次出牌第一个计分的牌额外触发两次\"></p>\n</div>  \n\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Smiley_Face.webp\" alt=\"微笑表情 效果为每个计分的人头牌提供+5倍率\"></p>\n</div>  \n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Photograph.webp\" alt=\"人脸照 效果为每次出牌第一个计分的人头牌提供×2倍率\"></p>\n</div>  \n\n<p>再加上我通过塔罗牌改造的有大量玻璃人头牌的卡组，我随意一次出牌便可以突破十亿的分数，而以上这三张小丑牌都只是普通稀有度，十分容易凑齐。  </p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过尝试各种搭配，游戏体验变得极其丰富有趣，每一局游戏都变成了脑洞大开的实验，Balatro并没有像其他游戏那样的敌人，缺乏了些斗智斗勇的感觉，取而代之的便是将游戏的可能性提高到了一个新的高度，同时Balatro有一个不能忽略的优点，极其优秀的视听体验，当看着分数不停上涨时，动感的音效伴随计分板冒出的火焰，总能使我十分激动，每次打开卡包时的动画也让人眼前一亮。<br>不过游戏并非没有缺点，事实上游戏的设计导致了很多局基本上没有玩家能够改变的余地，杀戮尖塔的顶级玩家可以做到最高难度500多连胜，几乎已经验证了玩家可以通过自身的决策赢下每一局，而Balatro目前为止最高连胜次数都没有超过十次，这反映出游戏设计可能并不完美，运气的因素有着过大的占比，此外，在我60h的游玩后，有许多构筑我仍然没有体验过，哪怕我刻意的去进行某个流派的构筑，成功构筑可能性也很低，尝试各种流派过于不稳定，胜率远远不如三端的玩法。<br>总体而言，Balatro是一款十分优秀的卡牌rogue，瑕不掩瑜，近期的更新也对最高难度进行了调整，相信未来Balatro能够解决这些缺点，把如同实验室的玩法发挥到极致。</p>\n<blockquote>\n<p>图片资源来源于<a href=\"https://balatrogame.fandom.com/wiki/Balatro\">Balatro wiki</a>,如有侵权，联系删除。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Balatro是一款牌组构筑式类rogue游戏，玩家可以依照德州扑克的出牌规则，通过出牌弃牌两个简单的行为积累分数，当分数高于当前盲注要求的分数时便通过该盲注，每次通过盲注时会进入商店，商店中售卖小丑牌、不同卡包，玩家可以通过购买小丑牌、卡包完成卡组的构筑。  </p>","more":"<h2 id=\"游玩体验\"><a href=\"#游玩体验\" class=\"headerlink\" title=\"游玩体验\"></a>游玩体验</h2><p>我是一个较深度的卡牌rogue玩家，玩过并且通关最高难度了许多类似游戏，包括杀戮尖塔、怪物火车、邪恶冥刻等等，卡牌rogue通过构筑、计算克服高难度的游戏体验令我十分着迷，每个种子的差异也让重复游玩都有不一样的乐趣，Balatro作为一款优秀的牌组构筑式rogue自然也有以上的优点，此外它还有自己更加独特的体验。<br>在前十个小时的游玩过程中，我尝试将以往其他卡牌rogue的经验往Balatro身上套用，Balatro通过计算筹码和倍率的乘积得到一次出牌后的分数</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/%E8%AE%A1%E5%88%86%E6%9D%BF.png\" alt=\"蓝色为筹码，红色为倍率\"></p>\n</div>  \n\n\n<p>游戏中的小丑牌大概可以分为一下几种：<br>加筹码的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Blue_Joker.webp\" alt=\"蓝色小丑 效果为卡组中每个剩余的牌提供2筹码\"></p>\n</div>  \n\n<p>加倍率的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Joker.webp\" alt=\"小丑 效果为+4倍率\"></p>\n</div>  \n\n<p>乘倍率的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Cavendish.webp\" alt=\"卡文迪许 效果为×3倍率\"></p>\n</div>  \n\n<p>提供资源的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Golden_Joker.webp\" alt=\"黄金小丑 效果为每回合后提供4金币\"></p>\n</div>  \n\n<p>改变规则的小丑牌</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Four_Fingers.webp\" alt=\"四指 效果为同花和顺子仅需要4张牌\"></p>\n</div>  \n \n<p>游戏中还有一些消耗品：星球牌可以升级某一牌型的效果，但是我觉得除了高牌、对子以外其他牌型都有一定的不稳定性，也就是怕鬼抽；塔罗牌拥有许多效果，绝大多数拥有改造牌组的能力，但是我觉得提供的增益杯水车薪。<br>于是乎我把重心全部放在拥有强力效果的小丑牌上，我将杀戮尖塔玩家群体的三端学说搬运了过来，将Balatro也分为三端，基础筹码端，基础倍率端，倍率成倍端，我基本上每一局都是拿一张加筹码的小丑牌，一张加倍率的小丑牌，剩下全拿乘倍率的小丑牌，用这个简单的思路，我很快就通关了最高难度金注，运气好的时候甚至打了个四连胜。<br>但是这样玩起来千篇一律，每一局都是差不多的赢差不多的输，我很快就感到了乏味，在玩Balatro的第15个小时便就失去了兴趣，于是乎我便想看看其他玩家是怎么玩这个游戏的，结果令我大吃一惊，我看到了钢k男爵、四指同花顺、人头流、同花五条等等极具想象力的构筑    </p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/%E5%9B%9B%E6%8C%87%E5%90%8C%E8%8A%B1%E9%A1%BA.png\" alt=\"同花顺原本是很难凑齐的强力牌型，但拥有四指后，变得十分容易凑出来\"></p>\n</div>  \n\n<p>我迫不及待的打开游戏，开始试验起了不同玩法，其中有一局让我印象十分深刻，我凑齐了以下几个小丑牌    </p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Hanging_Chad.webp\" alt=\"未断选票 效果为将每次出牌第一个计分的牌额外触发两次\"></p>\n</div>  \n\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Smiley_Face.webp\" alt=\"微笑表情 效果为每个计分的人头牌提供+5倍率\"></p>\n</div>  \n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/FlyingfishFantasticfan/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B-Balatro%E5%B0%8F%E4%B8%91%E7%89%8C/Photograph.webp\" alt=\"人脸照 效果为每次出牌第一个计分的人头牌提供×2倍率\"></p>\n</div>  \n\n<p>再加上我通过塔罗牌改造的有大量玻璃人头牌的卡组，我随意一次出牌便可以突破十亿的分数，而以上这三张小丑牌都只是普通稀有度，十分容易凑齐。  </p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过尝试各种搭配，游戏体验变得极其丰富有趣，每一局游戏都变成了脑洞大开的实验，Balatro并没有像其他游戏那样的敌人，缺乏了些斗智斗勇的感觉，取而代之的便是将游戏的可能性提高到了一个新的高度，同时Balatro有一个不能忽略的优点，极其优秀的视听体验，当看着分数不停上涨时，动感的音效伴随计分板冒出的火焰，总能使我十分激动，每次打开卡包时的动画也让人眼前一亮。<br>不过游戏并非没有缺点，事实上游戏的设计导致了很多局基本上没有玩家能够改变的余地，杀戮尖塔的顶级玩家可以做到最高难度500多连胜，几乎已经验证了玩家可以通过自身的决策赢下每一局，而Balatro目前为止最高连胜次数都没有超过十次，这反映出游戏设计可能并不完美，运气的因素有着过大的占比，此外，在我60h的游玩后，有许多构筑我仍然没有体验过，哪怕我刻意的去进行某个流派的构筑，成功构筑可能性也很低，尝试各种流派过于不稳定，胜率远远不如三端的玩法。<br>总体而言，Balatro是一款十分优秀的卡牌rogue，瑕不掩瑜，近期的更新也对最高难度进行了调整，相信未来Balatro能够解决这些缺点，把如同实验室的玩法发挥到极致。</p>\n<blockquote>\n<p>图片资源来源于<a href=\"https://balatrogame.fandom.com/wiki/Balatro\">Balatro wiki</a>,如有侵权，联系删除。</p>\n</blockquote>"},{"title":"自己设计一个游戏通用的2D摄像机累。Camera2D","date":"2024-06-03T16:00:00.000Z","updated":"2024-06-03T16:00:00.000Z","_content":"在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。\n![ICON](articles/QiNuoTu/Camera2D/1.gif)\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n## 一个合格的摄像机应该具有以下功能。\n    本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。\n- **视口控制：**设置视口大小适应不同的分辨率和屏幕尺寸。\n```cpp\n    void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) {\n        ViewportWidth = Viewport_Width;\n        ViewportHeight = Viewport_Height;\n        ViewportCenterX = ViewportWidth * 0.5f;\n        ViewportCenterY = ViewportHeight * 0.5f;\n    }\n```\n- **焦点跟随：**视点跟随焦点移动。\n```cpp\n    void SetTarget(float targetX, float targetY) {\n        TargetX = targetX;\n        TargetY = targetY;\n    }\n        void SmoothMoveToPosition(float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n```\n- **坐标转换：**屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。\n```cpp\n    void ScreenToWorld(float screenX, float screenY, float& worldX, float& worldY) const {\n        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;\n        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;\n    }\n\n    void WorldToScreen(float worldX, float worldY, float& screenX, float& screenY) const {\n        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;\n        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;\n    }\n```\n- **缩放功能：**适应不同的游戏场景和提供不同的视觉体验。\n```cpp\n    float GetScale() const { return Zoom; }\n\n    void SetScale(float zoom = 1)\n    {\n        Zoom = zoom;\n    }\n```\n- **边界限制：**设置移动边界，防止摄像机移动到游戏世界之外。\n```cpp\n    void SetWorldSize(float Width, float Height) {\n        WorldBoundaryLeft = -Width * 0.5f;\n        WorldBoundaryTop = -Height * 0.5f;\n        WorldBoundaryRight = Width * 0.5f;\n        WorldBoundaryBottom = Height * 0.5f;\n    }\n\n    bool SetWorldBoundaries(float left, float top, float right, float bottom) {\n        if (left < right && top < bottom) {\n            WorldBoundaryLeft = left;\n            WorldBoundaryTop = top;\n            WorldBoundaryRight = right;\n            WorldBoundaryBottom = bottom;\n            return true;\n        }\n        return false;\n    }\n\n    void ViewportCheckBoundaries() {\n        float scaledOffsetX = ViewportCenterX / Zoom;\n        float scaledOffsetY = ViewportCenterY / Zoom;\n        CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));\n        CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));\n\n        if (ViewportWidth / Zoom > WorldBoundaryRight - WorldBoundaryLeft) {\n            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;\n        }\n        if (ViewportHeight / Zoom > WorldBoundaryBottom - WorldBoundaryTop) {\n            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;\n        }\n    }\n```\n- **平滑过渡：**避免视角突变给玩家带来不适。\n```cpp\n    void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n\n    void Scale(float zoom = 1){\n        Zoom += zoom;\n    }\n```\n- **抖动效果：**模拟冲击爆炸等效果来增强游戏的氛围和反馈。\n```cpp\n    void Shake(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        CameraFocusX += disX(gen);\n        CameraFocusY += disY(gen);\n    }\n\n    void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        std::uniform_real_distribution<float> angle(-360.0f, 360.0f);\n        float radian = angle(gen) / 360 * m_PI * 2;\n        CameraFocusX += disX(gen) * std::cos(radian);\n        CameraFocusY += disY(gen) * std::sin(radian);\n    }\n```\n## 此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\n```cpp\nclass Camera2D {\npublic:\n    Camera2D(float Viewport_Width, float Viewport_Height,\n        float World_Width, float World_Height,\n        float FocusX = 0, float FocusY = 0) :\n        ViewportCenterX(Viewport_Width * 0.5f),\n        ViewportCenterY(Viewport_Height * 0.5f),\n        ViewportWidth(Viewport_Width),\n        ViewportHeight(Viewport_Height),\n        WorldBoundaryLeft(-World_Width * 0.5),\n        WorldBoundaryTop(-World_Height * 0.5),\n        WorldBoundaryRight(World_Width * 0.5),\n        WorldBoundaryBottom(World_Height * 0.5),\n        TargetX(0),\n        TargetY(0),\n        CameraFocusX(FocusX),\n        CameraFocusY(FocusY),\n        Zoom(1){}\n\n    ~Camera2D() = default;\n\n    void ScreenToWorld(float screenX, float screenY, float& worldX, float& worldY) const {\n        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;\n        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;\n    }\n\n    void WorldToScreen(float worldX, float worldY, float& screenX, float& screenY) const {\n        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;\n        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;\n    }\n\n    float GetScale() const { return Zoom; }\n\n    void SetScale(float zoom = 1)\n    {\n        Zoom = zoom;\n    }\n\n    void Scale(float zoom = 1)\n    {\n        Zoom += zoom;\n    }\n\n    void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n\n    void SetTarget(float targetX, float targetY) {\n        TargetX = targetX;\n        TargetY = targetY;\n    }\n\n    void SmoothMoveToTarget(float smoothing = 0.5f) {\n        CameraFocusX += (TargetX - CameraFocusX) * smoothing;\n        CameraFocusY += (TargetY - CameraFocusY) * smoothing;\n    }\n\n    void Shake(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        CameraFocusX += disX(gen);\n        CameraFocusY += disY(gen);\n    }\n\n    void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        std::uniform_real_distribution<float> angle(-360.0f, 360.0f);\n        float radian = angle(gen) / 360 * 3.1415926535 * 2;\n        CameraFocusX += disX(gen) * std::cos(radian);\n        CameraFocusY += disY(gen) * std::sin(radian);\n    }\n\n    void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) {\n        ViewportWidth = Viewport_Width;\n        ViewportHeight = Viewport_Height;\n        ViewportCenterX = ViewportWidth * 0.5f;\n        ViewportCenterY = ViewportHeight * 0.5f;\n    }\n\n    void SetFocus(float FocusX, float FocusY) {\n        CameraFocusX = FocusX;\n        CameraFocusY = FocusY;\n    }\n\n    void Move(float deltaX, float deltaY) {\n        CameraFocusX += deltaX;\n        CameraFocusY += deltaY;\n    }\n\n    float GetFocusX() const { return CameraFocusX; }\n\n    float GetFocusY() const { return CameraFocusY; }\n\n    void SetWorldSize(float Width, float Height) {\n        WorldBoundaryLeft = -Width * 0.5f;\n        WorldBoundaryTop = -Height * 0.5f;\n        WorldBoundaryRight = Width * 0.5f;\n        WorldBoundaryBottom = Height * 0.5f;\n    }\n\n    bool SetWorldBoundaries(float left, float top, float right, float bottom) {\n        if (left < right && top < bottom) {\n            WorldBoundaryLeft = left;\n            WorldBoundaryTop = top;\n            WorldBoundaryRight = right;\n            WorldBoundaryBottom = bottom;\n            return true;\n        }\n        return false;\n    }\n\n    void ViewportCheckBoundaries() {\n        float scaledOffsetX = ViewportCenterX / Zoom;\n        float scaledOffsetY = ViewportCenterY / Zoom;\n        CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));\n        CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));\n\n        if (ViewportWidth / Zoom > WorldBoundaryRight - WorldBoundaryLeft) {\n            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;\n        }\n        if (ViewportHeight / Zoom > WorldBoundaryBottom - WorldBoundaryTop) {\n            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;\n        }\n    }\n\n    void GetFocusRect(float& left, float& top, float& right, float& bottom) {\n         left = CameraFocusX - ViewportCenterX;\n         top = CameraFocusY - ViewportCenterY;\n         right = CameraFocusX + ViewportCenterX;\n         bottom = CameraFocusY + ViewportCenterY;\n    }\n\nprivate:\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    float TargetX, TargetY;\n    float CameraFocusX, CameraFocusY;\n    float ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight;\n    float Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;\n};\n```\n\n## 这是什么?\n![ICON](articles/QiNuoTu/Camera2D/2.png)\n","source":"_posts/QiNuoTu/Camera2D.md","raw":"---\ntitle: 自己设计一个游戏通用的2D摄像机累。Camera2D\ndate: 2024-06-4\nupdated: 2024-06-4\npermalink: articles/QiNuoTu/Camera2D/\ncategories: QiNuoTu\ntags: [教程,游戏开发]\n---\n在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。\n![ICON](articles/QiNuoTu/Camera2D/1.gif)\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n## 一个合格的摄像机应该具有以下功能。\n    本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。\n- **视口控制：**设置视口大小适应不同的分辨率和屏幕尺寸。\n```cpp\n    void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) {\n        ViewportWidth = Viewport_Width;\n        ViewportHeight = Viewport_Height;\n        ViewportCenterX = ViewportWidth * 0.5f;\n        ViewportCenterY = ViewportHeight * 0.5f;\n    }\n```\n- **焦点跟随：**视点跟随焦点移动。\n```cpp\n    void SetTarget(float targetX, float targetY) {\n        TargetX = targetX;\n        TargetY = targetY;\n    }\n        void SmoothMoveToPosition(float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n```\n- **坐标转换：**屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。\n```cpp\n    void ScreenToWorld(float screenX, float screenY, float& worldX, float& worldY) const {\n        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;\n        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;\n    }\n\n    void WorldToScreen(float worldX, float worldY, float& screenX, float& screenY) const {\n        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;\n        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;\n    }\n```\n- **缩放功能：**适应不同的游戏场景和提供不同的视觉体验。\n```cpp\n    float GetScale() const { return Zoom; }\n\n    void SetScale(float zoom = 1)\n    {\n        Zoom = zoom;\n    }\n```\n- **边界限制：**设置移动边界，防止摄像机移动到游戏世界之外。\n```cpp\n    void SetWorldSize(float Width, float Height) {\n        WorldBoundaryLeft = -Width * 0.5f;\n        WorldBoundaryTop = -Height * 0.5f;\n        WorldBoundaryRight = Width * 0.5f;\n        WorldBoundaryBottom = Height * 0.5f;\n    }\n\n    bool SetWorldBoundaries(float left, float top, float right, float bottom) {\n        if (left < right && top < bottom) {\n            WorldBoundaryLeft = left;\n            WorldBoundaryTop = top;\n            WorldBoundaryRight = right;\n            WorldBoundaryBottom = bottom;\n            return true;\n        }\n        return false;\n    }\n\n    void ViewportCheckBoundaries() {\n        float scaledOffsetX = ViewportCenterX / Zoom;\n        float scaledOffsetY = ViewportCenterY / Zoom;\n        CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));\n        CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));\n\n        if (ViewportWidth / Zoom > WorldBoundaryRight - WorldBoundaryLeft) {\n            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;\n        }\n        if (ViewportHeight / Zoom > WorldBoundaryBottom - WorldBoundaryTop) {\n            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;\n        }\n    }\n```\n- **平滑过渡：**避免视角突变给玩家带来不适。\n```cpp\n    void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n\n    void Scale(float zoom = 1){\n        Zoom += zoom;\n    }\n```\n- **抖动效果：**模拟冲击爆炸等效果来增强游戏的氛围和反馈。\n```cpp\n    void Shake(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        CameraFocusX += disX(gen);\n        CameraFocusY += disY(gen);\n    }\n\n    void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        std::uniform_real_distribution<float> angle(-360.0f, 360.0f);\n        float radian = angle(gen) / 360 * m_PI * 2;\n        CameraFocusX += disX(gen) * std::cos(radian);\n        CameraFocusY += disY(gen) * std::sin(radian);\n    }\n```\n## 此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\n```cpp\nclass Camera2D {\npublic:\n    Camera2D(float Viewport_Width, float Viewport_Height,\n        float World_Width, float World_Height,\n        float FocusX = 0, float FocusY = 0) :\n        ViewportCenterX(Viewport_Width * 0.5f),\n        ViewportCenterY(Viewport_Height * 0.5f),\n        ViewportWidth(Viewport_Width),\n        ViewportHeight(Viewport_Height),\n        WorldBoundaryLeft(-World_Width * 0.5),\n        WorldBoundaryTop(-World_Height * 0.5),\n        WorldBoundaryRight(World_Width * 0.5),\n        WorldBoundaryBottom(World_Height * 0.5),\n        TargetX(0),\n        TargetY(0),\n        CameraFocusX(FocusX),\n        CameraFocusY(FocusY),\n        Zoom(1){}\n\n    ~Camera2D() = default;\n\n    void ScreenToWorld(float screenX, float screenY, float& worldX, float& worldY) const {\n        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;\n        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;\n    }\n\n    void WorldToScreen(float worldX, float worldY, float& screenX, float& screenY) const {\n        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;\n        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;\n    }\n\n    float GetScale() const { return Zoom; }\n\n    void SetScale(float zoom = 1)\n    {\n        Zoom = zoom;\n    }\n\n    void Scale(float zoom = 1)\n    {\n        Zoom += zoom;\n    }\n\n    void SmoothMoveToPosition(float targetX, float targetY, float smoothing = 0.5f) {\n        CameraFocusX += (targetX - CameraFocusX) * smoothing;\n        CameraFocusY += (targetY - CameraFocusY) * smoothing;\n    }\n\n    void SetTarget(float targetX, float targetY) {\n        TargetX = targetX;\n        TargetY = targetY;\n    }\n\n    void SmoothMoveToTarget(float smoothing = 0.5f) {\n        CameraFocusX += (TargetX - CameraFocusX) * smoothing;\n        CameraFocusY += (TargetY - CameraFocusY) * smoothing;\n    }\n\n    void Shake(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        CameraFocusX += disX(gen);\n        CameraFocusY += disY(gen);\n    }\n\n    void ShakeCircle(float intensityX = 5.5f, float intensityY = 5.5f) {\n        std::uniform_real_distribution<float> disX(-intensityX, intensityX);\n        std::uniform_real_distribution<float> disY(-intensityY, intensityY);\n        std::uniform_real_distribution<float> angle(-360.0f, 360.0f);\n        float radian = angle(gen) / 360 * 3.1415926535 * 2;\n        CameraFocusX += disX(gen) * std::cos(radian);\n        CameraFocusY += disY(gen) * std::sin(radian);\n    }\n\n    void SetCameraCenter(short int Viewport_Width, short int Viewport_Height) {\n        ViewportWidth = Viewport_Width;\n        ViewportHeight = Viewport_Height;\n        ViewportCenterX = ViewportWidth * 0.5f;\n        ViewportCenterY = ViewportHeight * 0.5f;\n    }\n\n    void SetFocus(float FocusX, float FocusY) {\n        CameraFocusX = FocusX;\n        CameraFocusY = FocusY;\n    }\n\n    void Move(float deltaX, float deltaY) {\n        CameraFocusX += deltaX;\n        CameraFocusY += deltaY;\n    }\n\n    float GetFocusX() const { return CameraFocusX; }\n\n    float GetFocusY() const { return CameraFocusY; }\n\n    void SetWorldSize(float Width, float Height) {\n        WorldBoundaryLeft = -Width * 0.5f;\n        WorldBoundaryTop = -Height * 0.5f;\n        WorldBoundaryRight = Width * 0.5f;\n        WorldBoundaryBottom = Height * 0.5f;\n    }\n\n    bool SetWorldBoundaries(float left, float top, float right, float bottom) {\n        if (left < right && top < bottom) {\n            WorldBoundaryLeft = left;\n            WorldBoundaryTop = top;\n            WorldBoundaryRight = right;\n            WorldBoundaryBottom = bottom;\n            return true;\n        }\n        return false;\n    }\n\n    void ViewportCheckBoundaries() {\n        float scaledOffsetX = ViewportCenterX / Zoom;\n        float scaledOffsetY = ViewportCenterY / Zoom;\n        CameraFocusX = std::max(WorldBoundaryLeft + scaledOffsetX, std::min(CameraFocusX, WorldBoundaryRight - scaledOffsetX));\n        CameraFocusY = std::max(WorldBoundaryTop + scaledOffsetY, std::min(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));\n\n        if (ViewportWidth / Zoom > WorldBoundaryRight - WorldBoundaryLeft) {\n            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * 0.5f;\n        }\n        if (ViewportHeight / Zoom > WorldBoundaryBottom - WorldBoundaryTop) {\n            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * 0.5f;\n        }\n    }\n\n    void GetFocusRect(float& left, float& top, float& right, float& bottom) {\n         left = CameraFocusX - ViewportCenterX;\n         top = CameraFocusY - ViewportCenterY;\n         right = CameraFocusX + ViewportCenterX;\n         bottom = CameraFocusY + ViewportCenterY;\n    }\n\nprivate:\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    float TargetX, TargetY;\n    float CameraFocusX, CameraFocusY;\n    float ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight;\n    float Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;\n};\n```\n\n## 这是什么?\n![ICON](articles/QiNuoTu/Camera2D/2.png)\n","slug":"QiNuoTu/Camera2D","published":1,"__permalink":"articles/QiNuoTu/Camera2D/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hga000eo8ye55wzathg","content":"<p>在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。<br><img src=\"/articles/QiNuoTu/Camera2D/1.gif\" alt=\"ICON\"></p>\n<span id=\"more\"></span>\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h2 id=\"一个合格的摄像机应该具有以下功能。\"><a href=\"#一个合格的摄像机应该具有以下功能。\" class=\"headerlink\" title=\"一个合格的摄像机应该具有以下功能。\"></a>一个合格的摄像机应该具有以下功能。</h2><pre><code>本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。\n</code></pre>\n<ul>\n<li><strong>视口控制：</strong>设置视口大小适应不同的分辨率和屏幕尺寸。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetCameraCenter</span><span class=\"params\">(<span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Width, <span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Height)</span> </span>&#123;</span><br><span class=\"line\">    ViewportWidth = Viewport_Width;</span><br><span class=\"line\">    ViewportHeight = Viewport_Height;</span><br><span class=\"line\">    ViewportCenterX = ViewportWidth * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    ViewportCenterY = ViewportHeight * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>焦点跟随：</strong>视点跟随焦点移动。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetTarget</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY)</span> </span>&#123;</span><br><span class=\"line\">    TargetX = targetX;</span><br><span class=\"line\">    TargetY = targetY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">    CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>坐标转换：</strong>屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ScreenToWorld</span><span class=\"params\">(<span class=\"type\">float</span> screenX, <span class=\"type\">float</span> screenY, <span class=\"type\">float</span>&amp; worldX, <span class=\"type\">float</span>&amp; worldY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">    worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;</span><br><span class=\"line\">    worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WorldToScreen</span><span class=\"params\">(<span class=\"type\">float</span> worldX, <span class=\"type\">float</span> worldY, <span class=\"type\">float</span>&amp; screenX, <span class=\"type\">float</span>&amp; screenY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">    screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;</span><br><span class=\"line\">    screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>缩放功能：</strong>适应不同的游戏场景和提供不同的视觉体验。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetScale</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Zoom; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetScale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Zoom = zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>边界限制：</strong>设置移动边界，防止摄像机移动到游戏世界之外。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetWorldSize</span><span class=\"params\">(<span class=\"type\">float</span> Width, <span class=\"type\">float</span> Height)</span> </span>&#123;</span><br><span class=\"line\">    WorldBoundaryLeft = -Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryTop = -Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryRight = Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryBottom = Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SetWorldBoundaries</span><span class=\"params\">(<span class=\"type\">float</span> left, <span class=\"type\">float</span> top, <span class=\"type\">float</span> right, <span class=\"type\">float</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class=\"line\">        WorldBoundaryLeft = left;</span><br><span class=\"line\">        WorldBoundaryTop = top;</span><br><span class=\"line\">        WorldBoundaryRight = right;</span><br><span class=\"line\">        WorldBoundaryBottom = bottom;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ViewportCheckBoundaries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> scaledOffsetX = ViewportCenterX / Zoom;</span><br><span class=\"line\">    <span class=\"type\">float</span> scaledOffsetY = ViewportCenterY / Zoom;</span><br><span class=\"line\">    CameraFocusX = std::<span class=\"built_in\">max</span>(WorldBoundaryLeft + scaledOffsetX, std::<span class=\"built_in\">min</span>(CameraFocusX, WorldBoundaryRight - scaledOffsetX));</span><br><span class=\"line\">    CameraFocusY = std::<span class=\"built_in\">max</span>(WorldBoundaryTop + scaledOffsetY, std::<span class=\"built_in\">min</span>(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;</span><br><span class=\"line\">        CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;</span><br><span class=\"line\">        CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>平滑过渡：</strong>避免视角突变给玩家带来不适。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY, <span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">    CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Scale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span>&#123;</span><br><span class=\"line\">    Zoom += zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>抖动效果：</strong>模拟冲击爆炸等效果来增强游戏的氛围和反馈。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Shake</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">    CameraFocusX += <span class=\"built_in\">disX</span>(gen);</span><br><span class=\"line\">    CameraFocusY += <span class=\"built_in\">disY</span>(gen);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShakeCircle</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">angle</span><span class=\"params\">(<span class=\"number\">-360.0f</span>, <span class=\"number\">360.0f</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> radian = <span class=\"built_in\">angle</span>(gen) / <span class=\"number\">360</span> * m_PI * <span class=\"number\">2</span>;</span><br><span class=\"line\">    CameraFocusX += <span class=\"built_in\">disX</span>(gen) * std::<span class=\"built_in\">cos</span>(radian);</span><br><span class=\"line\">    CameraFocusY += <span class=\"built_in\">disY</span>(gen) * std::<span class=\"built_in\">sin</span>(radian);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\"><a href=\"#此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\" class=\"headerlink\" title=\"此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\"></a>此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera2D</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Camera2D</span>(<span class=\"type\">float</span> Viewport_Width, <span class=\"type\">float</span> Viewport_Height,</span><br><span class=\"line\">        <span class=\"type\">float</span> World_Width, <span class=\"type\">float</span> World_Height,</span><br><span class=\"line\">        <span class=\"type\">float</span> FocusX = <span class=\"number\">0</span>, <span class=\"type\">float</span> FocusY = <span class=\"number\">0</span>) :</span><br><span class=\"line\">        <span class=\"built_in\">ViewportCenterX</span>(Viewport_Width * <span class=\"number\">0.5f</span>),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportCenterY</span>(Viewport_Height * <span class=\"number\">0.5f</span>),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportWidth</span>(Viewport_Width),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportHeight</span>(Viewport_Height),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryLeft</span>(-World_Width * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryTop</span>(-World_Height * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryRight</span>(World_Width * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryBottom</span>(World_Height * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">TargetX</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"built_in\">TargetY</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"built_in\">CameraFocusX</span>(FocusX),</span><br><span class=\"line\">        <span class=\"built_in\">CameraFocusY</span>(FocusY),</span><br><span class=\"line\">        <span class=\"built_in\">Zoom</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Camera2D</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ScreenToWorld</span><span class=\"params\">(<span class=\"type\">float</span> screenX, <span class=\"type\">float</span> screenY, <span class=\"type\">float</span>&amp; worldX, <span class=\"type\">float</span>&amp; worldY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;</span><br><span class=\"line\">        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WorldToScreen</span><span class=\"params\">(<span class=\"type\">float</span> worldX, <span class=\"type\">float</span> worldY, <span class=\"type\">float</span>&amp; screenX, <span class=\"type\">float</span>&amp; screenY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;</span><br><span class=\"line\">        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetScale</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Zoom; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetScale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Zoom = zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Scale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Zoom += zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY, <span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">        CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetTarget</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY)</span> </span>&#123;</span><br><span class=\"line\">        TargetX = targetX;</span><br><span class=\"line\">        TargetY = targetY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToTarget</span><span class=\"params\">(<span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += (TargetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">        CameraFocusY += (TargetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Shake</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">        CameraFocusX += <span class=\"built_in\">disX</span>(gen);</span><br><span class=\"line\">        CameraFocusY += <span class=\"built_in\">disY</span>(gen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShakeCircle</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">angle</span><span class=\"params\">(<span class=\"number\">-360.0f</span>, <span class=\"number\">360.0f</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">float</span> radian = <span class=\"built_in\">angle</span>(gen) / <span class=\"number\">360</span> * <span class=\"number\">3.1415926535</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">        CameraFocusX += <span class=\"built_in\">disX</span>(gen) * std::<span class=\"built_in\">cos</span>(radian);</span><br><span class=\"line\">        CameraFocusY += <span class=\"built_in\">disY</span>(gen) * std::<span class=\"built_in\">sin</span>(radian);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetCameraCenter</span><span class=\"params\">(<span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Width, <span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Height)</span> </span>&#123;</span><br><span class=\"line\">        ViewportWidth = Viewport_Width;</span><br><span class=\"line\">        ViewportHeight = Viewport_Height;</span><br><span class=\"line\">        ViewportCenterX = ViewportWidth * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        ViewportCenterY = ViewportHeight * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetFocus</span><span class=\"params\">(<span class=\"type\">float</span> FocusX, <span class=\"type\">float</span> FocusY)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX = FocusX;</span><br><span class=\"line\">        CameraFocusY = FocusY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Move</span><span class=\"params\">(<span class=\"type\">float</span> deltaX, <span class=\"type\">float</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += deltaX;</span><br><span class=\"line\">        CameraFocusY += deltaY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetFocusX</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> CameraFocusX; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetFocusY</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> CameraFocusY; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetWorldSize</span><span class=\"params\">(<span class=\"type\">float</span> Width, <span class=\"type\">float</span> Height)</span> </span>&#123;</span><br><span class=\"line\">        WorldBoundaryLeft = -Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryTop = -Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryRight = Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryBottom = Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SetWorldBoundaries</span><span class=\"params\">(<span class=\"type\">float</span> left, <span class=\"type\">float</span> top, <span class=\"type\">float</span> right, <span class=\"type\">float</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class=\"line\">            WorldBoundaryLeft = left;</span><br><span class=\"line\">            WorldBoundaryTop = top;</span><br><span class=\"line\">            WorldBoundaryRight = right;</span><br><span class=\"line\">            WorldBoundaryBottom = bottom;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ViewportCheckBoundaries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> scaledOffsetX = ViewportCenterX / Zoom;</span><br><span class=\"line\">        <span class=\"type\">float</span> scaledOffsetY = ViewportCenterY / Zoom;</span><br><span class=\"line\">        CameraFocusX = std::<span class=\"built_in\">max</span>(WorldBoundaryLeft + scaledOffsetX, std::<span class=\"built_in\">min</span>(CameraFocusX, WorldBoundaryRight - scaledOffsetX));</span><br><span class=\"line\">        CameraFocusY = std::<span class=\"built_in\">max</span>(WorldBoundaryTop + scaledOffsetY, std::<span class=\"built_in\">min</span>(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;</span><br><span class=\"line\">            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;</span><br><span class=\"line\">            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">GetFocusRect</span><span class=\"params\">(<span class=\"type\">float</span>&amp; left, <span class=\"type\">float</span>&amp; top, <span class=\"type\">float</span>&amp; right, <span class=\"type\">float</span>&amp; bottom)</span> </span>&#123;</span><br><span class=\"line\">         left = CameraFocusX - ViewportCenterX;</span><br><span class=\"line\">         top = CameraFocusY - ViewportCenterY;</span><br><span class=\"line\">         right = CameraFocusX + ViewportCenterX;</span><br><span class=\"line\">         bottom = CameraFocusY + ViewportCenterY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::random_device rd;</span><br><span class=\"line\">    <span class=\"function\">std::mt19937 <span class=\"title\">gen</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> TargetX, TargetY;</span><br><span class=\"line\">    <span class=\"type\">float</span> CameraFocusX, CameraFocusY;</span><br><span class=\"line\">    <span class=\"type\">float</span> ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight;</span><br><span class=\"line\">    <span class=\"type\">float</span> Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"这是什么\"><a href=\"#这是什么\" class=\"headerlink\" title=\"这是什么?\"></a>这是什么?</h2><p><img src=\"/articles/QiNuoTu/Camera2D/2.png\" alt=\"ICON\"></p>\n","site":{"data":{}},"excerpt":"<p>在2D游戏开发中，摄像机是一个至关重要的组件，允许开发者控制玩家的视角，决定他们能看到游戏世界的哪些部分。这对于引导玩家的注意力和提供沉浸式体验非常重要，在战斗场景中聚焦于战斗区域；而在探索场景中扩大视野以展示更多的环境细节，跟随主要角色移动，确保玩家始终能够看到控制中的角色和周围的环境，将摄像机焦点对准可交互对象，用来提示玩家这些对象的存在和重要性，还可以用来实现特殊效果，如震动或动态缩放等，在下文中我们将会实现这样一个摄像机类用于自己的游戏。<br><img src=\"/articles/QiNuoTu/Camera2D/1.gif\" alt=\"ICON\"></p>","more":"<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h2 id=\"一个合格的摄像机应该具有以下功能。\"><a href=\"#一个合格的摄像机应该具有以下功能。\" class=\"headerlink\" title=\"一个合格的摄像机应该具有以下功能。\"></a>一个合格的摄像机应该具有以下功能。</h2><pre><code>本人习惯已屏幕中心为基准处理数据，并且正向使用坐标，所有以下实现已本人使用舒适维主进行实现，我们来弄一些碎片吧。\n</code></pre>\n<ul>\n<li><strong>视口控制：</strong>设置视口大小适应不同的分辨率和屏幕尺寸。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetCameraCenter</span><span class=\"params\">(<span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Width, <span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Height)</span> </span>&#123;</span><br><span class=\"line\">    ViewportWidth = Viewport_Width;</span><br><span class=\"line\">    ViewportHeight = Viewport_Height;</span><br><span class=\"line\">    ViewportCenterX = ViewportWidth * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    ViewportCenterY = ViewportHeight * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>焦点跟随：</strong>视点跟随焦点移动。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetTarget</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY)</span> </span>&#123;</span><br><span class=\"line\">    TargetX = targetX;</span><br><span class=\"line\">    TargetY = targetY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">    CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>坐标转换：</strong>屏幕坐标与世界坐标之间转换，便于处理用户输入和游戏对象的位置。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ScreenToWorld</span><span class=\"params\">(<span class=\"type\">float</span> screenX, <span class=\"type\">float</span> screenY, <span class=\"type\">float</span>&amp; worldX, <span class=\"type\">float</span>&amp; worldY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">    worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;</span><br><span class=\"line\">    worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WorldToScreen</span><span class=\"params\">(<span class=\"type\">float</span> worldX, <span class=\"type\">float</span> worldY, <span class=\"type\">float</span>&amp; screenX, <span class=\"type\">float</span>&amp; screenY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">    screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;</span><br><span class=\"line\">    screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>缩放功能：</strong>适应不同的游戏场景和提供不同的视觉体验。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetScale</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Zoom; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetScale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Zoom = zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>边界限制：</strong>设置移动边界，防止摄像机移动到游戏世界之外。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetWorldSize</span><span class=\"params\">(<span class=\"type\">float</span> Width, <span class=\"type\">float</span> Height)</span> </span>&#123;</span><br><span class=\"line\">    WorldBoundaryLeft = -Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryTop = -Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryRight = Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    WorldBoundaryBottom = Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SetWorldBoundaries</span><span class=\"params\">(<span class=\"type\">float</span> left, <span class=\"type\">float</span> top, <span class=\"type\">float</span> right, <span class=\"type\">float</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class=\"line\">        WorldBoundaryLeft = left;</span><br><span class=\"line\">        WorldBoundaryTop = top;</span><br><span class=\"line\">        WorldBoundaryRight = right;</span><br><span class=\"line\">        WorldBoundaryBottom = bottom;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ViewportCheckBoundaries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> scaledOffsetX = ViewportCenterX / Zoom;</span><br><span class=\"line\">    <span class=\"type\">float</span> scaledOffsetY = ViewportCenterY / Zoom;</span><br><span class=\"line\">    CameraFocusX = std::<span class=\"built_in\">max</span>(WorldBoundaryLeft + scaledOffsetX, std::<span class=\"built_in\">min</span>(CameraFocusX, WorldBoundaryRight - scaledOffsetX));</span><br><span class=\"line\">    CameraFocusY = std::<span class=\"built_in\">max</span>(WorldBoundaryTop + scaledOffsetY, std::<span class=\"built_in\">min</span>(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;</span><br><span class=\"line\">        CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;</span><br><span class=\"line\">        CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>平滑过渡：</strong>避免视角突变给玩家带来不适。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY, <span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">    CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Scale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span>&#123;</span><br><span class=\"line\">    Zoom += zoom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>抖动效果：</strong>模拟冲击爆炸等效果来增强游戏的氛围和反馈。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Shake</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">    CameraFocusX += <span class=\"built_in\">disX</span>(gen);</span><br><span class=\"line\">    CameraFocusY += <span class=\"built_in\">disY</span>(gen);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShakeCircle</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">angle</span><span class=\"params\">(<span class=\"number\">-360.0f</span>, <span class=\"number\">360.0f</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> radian = <span class=\"built_in\">angle</span>(gen) / <span class=\"number\">360</span> * m_PI * <span class=\"number\">2</span>;</span><br><span class=\"line\">    CameraFocusX += <span class=\"built_in\">disX</span>(gen) * std::<span class=\"built_in\">cos</span>(radian);</span><br><span class=\"line\">    CameraFocusY += <span class=\"built_in\">disY</span>(gen) * std::<span class=\"built_in\">sin</span>(radian);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\"><a href=\"#此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\" class=\"headerlink\" title=\"此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。\"></a>此刻Camera2D类的所有碎片都已经获得，我们把他拼起来吧。</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera2D</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Camera2D</span>(<span class=\"type\">float</span> Viewport_Width, <span class=\"type\">float</span> Viewport_Height,</span><br><span class=\"line\">        <span class=\"type\">float</span> World_Width, <span class=\"type\">float</span> World_Height,</span><br><span class=\"line\">        <span class=\"type\">float</span> FocusX = <span class=\"number\">0</span>, <span class=\"type\">float</span> FocusY = <span class=\"number\">0</span>) :</span><br><span class=\"line\">        <span class=\"built_in\">ViewportCenterX</span>(Viewport_Width * <span class=\"number\">0.5f</span>),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportCenterY</span>(Viewport_Height * <span class=\"number\">0.5f</span>),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportWidth</span>(Viewport_Width),</span><br><span class=\"line\">        <span class=\"built_in\">ViewportHeight</span>(Viewport_Height),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryLeft</span>(-World_Width * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryTop</span>(-World_Height * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryRight</span>(World_Width * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">WorldBoundaryBottom</span>(World_Height * <span class=\"number\">0.5</span>),</span><br><span class=\"line\">        <span class=\"built_in\">TargetX</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"built_in\">TargetY</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">        <span class=\"built_in\">CameraFocusX</span>(FocusX),</span><br><span class=\"line\">        <span class=\"built_in\">CameraFocusY</span>(FocusY),</span><br><span class=\"line\">        <span class=\"built_in\">Zoom</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">Camera2D</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ScreenToWorld</span><span class=\"params\">(<span class=\"type\">float</span> screenX, <span class=\"type\">float</span> screenY, <span class=\"type\">float</span>&amp; worldX, <span class=\"type\">float</span>&amp; worldY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        worldX = CameraFocusX - (screenX - ViewportCenterX) / Zoom;</span><br><span class=\"line\">        worldY = CameraFocusY - (screenY - ViewportCenterY) / Zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">WorldToScreen</span><span class=\"params\">(<span class=\"type\">float</span> worldX, <span class=\"type\">float</span> worldY, <span class=\"type\">float</span>&amp; screenX, <span class=\"type\">float</span>&amp; screenY)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        screenX = ViewportCenterX + (CameraFocusX - worldX) * Zoom;</span><br><span class=\"line\">        screenY = ViewportCenterY + (CameraFocusY - worldY) * Zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetScale</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Zoom; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetScale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Zoom = zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Scale</span><span class=\"params\">(<span class=\"type\">float</span> zoom = <span class=\"number\">1</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Zoom += zoom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToPosition</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY, <span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += (targetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">        CameraFocusY += (targetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetTarget</span><span class=\"params\">(<span class=\"type\">float</span> targetX, <span class=\"type\">float</span> targetY)</span> </span>&#123;</span><br><span class=\"line\">        TargetX = targetX;</span><br><span class=\"line\">        TargetY = targetY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SmoothMoveToTarget</span><span class=\"params\">(<span class=\"type\">float</span> smoothing = <span class=\"number\">0.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += (TargetX - CameraFocusX) * smoothing;</span><br><span class=\"line\">        CameraFocusY += (TargetY - CameraFocusY) * smoothing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Shake</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">        CameraFocusX += <span class=\"built_in\">disX</span>(gen);</span><br><span class=\"line\">        CameraFocusY += <span class=\"built_in\">disY</span>(gen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShakeCircle</span><span class=\"params\">(<span class=\"type\">float</span> intensityX = <span class=\"number\">5.5f</span>, <span class=\"type\">float</span> intensityY = <span class=\"number\">5.5f</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disX</span><span class=\"params\">(-intensityX, intensityX)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">disY</span><span class=\"params\">(-intensityY, intensityY)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">std::uniform_real_distribution&lt;<span class=\"type\">float</span>&gt; <span class=\"title\">angle</span><span class=\"params\">(<span class=\"number\">-360.0f</span>, <span class=\"number\">360.0f</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">float</span> radian = <span class=\"built_in\">angle</span>(gen) / <span class=\"number\">360</span> * <span class=\"number\">3.1415926535</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">        CameraFocusX += <span class=\"built_in\">disX</span>(gen) * std::<span class=\"built_in\">cos</span>(radian);</span><br><span class=\"line\">        CameraFocusY += <span class=\"built_in\">disY</span>(gen) * std::<span class=\"built_in\">sin</span>(radian);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetCameraCenter</span><span class=\"params\">(<span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Width, <span class=\"type\">short</span> <span class=\"type\">int</span> Viewport_Height)</span> </span>&#123;</span><br><span class=\"line\">        ViewportWidth = Viewport_Width;</span><br><span class=\"line\">        ViewportHeight = Viewport_Height;</span><br><span class=\"line\">        ViewportCenterX = ViewportWidth * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        ViewportCenterY = ViewportHeight * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetFocus</span><span class=\"params\">(<span class=\"type\">float</span> FocusX, <span class=\"type\">float</span> FocusY)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX = FocusX;</span><br><span class=\"line\">        CameraFocusY = FocusY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Move</span><span class=\"params\">(<span class=\"type\">float</span> deltaX, <span class=\"type\">float</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        CameraFocusX += deltaX;</span><br><span class=\"line\">        CameraFocusY += deltaY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetFocusX</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> CameraFocusX; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">GetFocusY</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> CameraFocusY; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetWorldSize</span><span class=\"params\">(<span class=\"type\">float</span> Width, <span class=\"type\">float</span> Height)</span> </span>&#123;</span><br><span class=\"line\">        WorldBoundaryLeft = -Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryTop = -Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryRight = Width * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        WorldBoundaryBottom = Height * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SetWorldBoundaries</span><span class=\"params\">(<span class=\"type\">float</span> left, <span class=\"type\">float</span> top, <span class=\"type\">float</span> right, <span class=\"type\">float</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class=\"line\">            WorldBoundaryLeft = left;</span><br><span class=\"line\">            WorldBoundaryTop = top;</span><br><span class=\"line\">            WorldBoundaryRight = right;</span><br><span class=\"line\">            WorldBoundaryBottom = bottom;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ViewportCheckBoundaries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> scaledOffsetX = ViewportCenterX / Zoom;</span><br><span class=\"line\">        <span class=\"type\">float</span> scaledOffsetY = ViewportCenterY / Zoom;</span><br><span class=\"line\">        CameraFocusX = std::<span class=\"built_in\">max</span>(WorldBoundaryLeft + scaledOffsetX, std::<span class=\"built_in\">min</span>(CameraFocusX, WorldBoundaryRight - scaledOffsetX));</span><br><span class=\"line\">        CameraFocusY = std::<span class=\"built_in\">max</span>(WorldBoundaryTop + scaledOffsetY, std::<span class=\"built_in\">min</span>(CameraFocusY, WorldBoundaryBottom - scaledOffsetY));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ViewportWidth / Zoom &gt; WorldBoundaryRight - WorldBoundaryLeft) &#123;</span><br><span class=\"line\">            CameraFocusX = (WorldBoundaryLeft + WorldBoundaryRight) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ViewportHeight / Zoom &gt; WorldBoundaryBottom - WorldBoundaryTop) &#123;</span><br><span class=\"line\">            CameraFocusY = (WorldBoundaryTop + WorldBoundaryBottom) * <span class=\"number\">0.5f</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">GetFocusRect</span><span class=\"params\">(<span class=\"type\">float</span>&amp; left, <span class=\"type\">float</span>&amp; top, <span class=\"type\">float</span>&amp; right, <span class=\"type\">float</span>&amp; bottom)</span> </span>&#123;</span><br><span class=\"line\">         left = CameraFocusX - ViewportCenterX;</span><br><span class=\"line\">         top = CameraFocusY - ViewportCenterY;</span><br><span class=\"line\">         right = CameraFocusX + ViewportCenterX;</span><br><span class=\"line\">         bottom = CameraFocusY + ViewportCenterY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::random_device rd;</span><br><span class=\"line\">    <span class=\"function\">std::mt19937 <span class=\"title\">gen</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> TargetX, TargetY;</span><br><span class=\"line\">    <span class=\"type\">float</span> CameraFocusX, CameraFocusY;</span><br><span class=\"line\">    <span class=\"type\">float</span> ViewportCenterX, ViewportCenterY, ViewportWidth, ViewportHeight;</span><br><span class=\"line\">    <span class=\"type\">float</span> Zoom, WorldBoundaryLeft, WorldBoundaryTop, WorldBoundaryRight, WorldBoundaryBottom;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"这是什么\"><a href=\"#这是什么\" class=\"headerlink\" title=\"这是什么?\"></a>这是什么?</h2><p><img src=\"/articles/QiNuoTu/Camera2D/2.png\" alt=\"ICON\"></p>"},{"title":"保姆级！使用网页版在VoidGameSpace中发表文章与图文。Ciallo​～","date":"2024-05-29T16:00:00.000Z","updated":"2024-06-03T16:00:00.000Z","_content":"保姆级！保姆级！保姆级！Ciallo​～！\n每一步都有图文混合讲解！\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n# 第一步，先分叉一个VoidGameSpace的原始库\n- **1**: 点击蓝字进入[VoidGameSpace](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。\n进入后，会看到这样的页面。\n![ICON](articles/QiNuoTu/CorrectlyReleased/1.png)\n- **2**: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/2.png)\n![ICON](articles/QiNuoTu/CorrectlyReleased/3.png)\n- **3**: 此刻你的库中就有了一份分叉文件，第一步完成。\n# 第二步，来到自己的库中，并进入GameDevWebsite项目。\n- **1**: 点击左上角的，点点点，标志。\n![ICON](articles/QiNuoTu/CorrectlyReleased/4.png)\n选择，自己名字加上斜杠的/GameDevWebsite项目，非常重要！\n![ICON](articles/QiNuoTu/CorrectlyReleased/5.png)\n- **2**: 这样就进入了自己库中的GameDevWebsite克隆项目。\n![ICON](articles/QiNuoTu/CorrectlyReleased/6.png)\n这里的头像变成自己的，就正确了。\n# 第三步，来到，_posts，文件夹。\n点击项目中的，source，文件夹。\n![ICON](articles/QiNuoTu/CorrectlyReleased/7.png)\n在点击，_posts，文件夹\n![ICON](articles/QiNuoTu/CorrectlyReleased/8.png)\n这里会有一大堆别人的文件夹，不需要管理。\n![ICON](articles/QiNuoTu/CorrectlyReleased/9.png)\n# 第四步，准备文章！\n此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。\n## 自己的名字！，不要抄我的名字！\n![ICON](articles/QiNuoTu/CorrectlyReleased/10.png)\n进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。\n编写参阅，[VoidGameSpace](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。下方的说明。\n- **1**: 跳过上面的说明我们创建一个。\n![ICON](articles/QiNuoTu/CorrectlyReleased/11.png)\n- **2**: 打开，在头部添加以下内容。\n![ICON](articles/QiNuoTu/CorrectlyReleased/12.png)\npermalink: 不太好理解，不用担心，请往下看，\n它是这样的结构，permalink: articles/QiNuoTu/Demo/\n- **articles**: 可以理解为根目录，必须加上。\n- **QiNuoTu**: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。\n![ICON](articles/QiNuoTu/CorrectlyReleased/10.png)\n- **Demo**: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，/，斜杠在尾部。\n![ICON](articles/QiNuoTu/CorrectlyReleased/13.png)\n这样一来，文章头就准备完毕了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/14.png)\n# 第五步，编写文章！\n- **1**: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，` <!-- More --> ` 标记下书写\n![ICON](articles/QiNuoTu/CorrectlyReleased/15.png)\n- **2**: 如何添加图片，在文章旁边使用同名创建一个文件夹。\n![ICON](articles/QiNuoTu/CorrectlyReleased/16.png)\n- **3**: 将图片丢进文件夹中，就可以使用，`![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)`表达式引用图片了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/17.png)\n- **4**: 网页链接同理，`[名称](链接)`，表达式，即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/27.png)\n- **5**: 置入代码，只需要使用，` ```cpp 代码 ``` `将代码包裹其中即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/28.png)\n# 第六步，发表文章。\n- **1**: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。\n![ICON](articles/QiNuoTu/CorrectlyReleased/18.png)\n- **2**: 把文件夹拖住丢上去。\n![ICON](articles/QiNuoTu/CorrectlyReleased/19.png)\n- **3**: 点击绿色按钮。\n![ICON](articles/QiNuoTu/CorrectlyReleased/20.png)\n- **4**: 之后就可以看到自己的文件夹了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/21.png)\n- **5**: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/22.png)\n# 第七步，提交！\n- **1**: 点击右上角的GameDevWebsite。\n![ICON](articles/QiNuoTu/CorrectlyReleased/23.png)\n- **2**: 找到，Contribote，点击绿色按钮！\n![ICON](articles/QiNuoTu/CorrectlyReleased/24.png)\n- **2**: 填写标题，点击绿色按钮！\n![ICON](articles/QiNuoTu/CorrectlyReleased/25.png)\n# 等待审核即可！\n![ICON](articles/QiNuoTu/CorrectlyReleased/26.png)\n\n# 这是什么？\n![ICON](articles/QiNuoTu/CorrectlyReleased/123415231.png)\n","source":"_posts/QiNuoTu/CorrectlyReleased.md","raw":"---\ntitle: 保姆级！使用网页版在VoidGameSpace中发表文章与图文。Ciallo​～\ndate: 2024-05-30\nupdated: 2024-06-4\npermalink: articles/QiNuoTu/CorrectlyReleased/\ncategories: QiNuoTu\ntags: [教程]\n---\n保姆级！保姆级！保姆级！Ciallo​～！\n每一步都有图文混合讲解！\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n# 第一步，先分叉一个VoidGameSpace的原始库\n- **1**: 点击蓝字进入[VoidGameSpace](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。\n进入后，会看到这样的页面。\n![ICON](articles/QiNuoTu/CorrectlyReleased/1.png)\n- **2**: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/2.png)\n![ICON](articles/QiNuoTu/CorrectlyReleased/3.png)\n- **3**: 此刻你的库中就有了一份分叉文件，第一步完成。\n# 第二步，来到自己的库中，并进入GameDevWebsite项目。\n- **1**: 点击左上角的，点点点，标志。\n![ICON](articles/QiNuoTu/CorrectlyReleased/4.png)\n选择，自己名字加上斜杠的/GameDevWebsite项目，非常重要！\n![ICON](articles/QiNuoTu/CorrectlyReleased/5.png)\n- **2**: 这样就进入了自己库中的GameDevWebsite克隆项目。\n![ICON](articles/QiNuoTu/CorrectlyReleased/6.png)\n这里的头像变成自己的，就正确了。\n# 第三步，来到，_posts，文件夹。\n点击项目中的，source，文件夹。\n![ICON](articles/QiNuoTu/CorrectlyReleased/7.png)\n在点击，_posts，文件夹\n![ICON](articles/QiNuoTu/CorrectlyReleased/8.png)\n这里会有一大堆别人的文件夹，不需要管理。\n![ICON](articles/QiNuoTu/CorrectlyReleased/9.png)\n# 第四步，准备文章！\n此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。\n## 自己的名字！，不要抄我的名字！\n![ICON](articles/QiNuoTu/CorrectlyReleased/10.png)\n进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。\n编写参阅，[VoidGameSpace](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。下方的说明。\n- **1**: 跳过上面的说明我们创建一个。\n![ICON](articles/QiNuoTu/CorrectlyReleased/11.png)\n- **2**: 打开，在头部添加以下内容。\n![ICON](articles/QiNuoTu/CorrectlyReleased/12.png)\npermalink: 不太好理解，不用担心，请往下看，\n它是这样的结构，permalink: articles/QiNuoTu/Demo/\n- **articles**: 可以理解为根目录，必须加上。\n- **QiNuoTu**: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。\n![ICON](articles/QiNuoTu/CorrectlyReleased/10.png)\n- **Demo**: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，/，斜杠在尾部。\n![ICON](articles/QiNuoTu/CorrectlyReleased/13.png)\n这样一来，文章头就准备完毕了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/14.png)\n# 第五步，编写文章！\n- **1**: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，` <!-- More --> ` 标记下书写\n![ICON](articles/QiNuoTu/CorrectlyReleased/15.png)\n- **2**: 如何添加图片，在文章旁边使用同名创建一个文件夹。\n![ICON](articles/QiNuoTu/CorrectlyReleased/16.png)\n- **3**: 将图片丢进文件夹中，就可以使用，`![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)`表达式引用图片了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/17.png)\n- **4**: 网页链接同理，`[名称](链接)`，表达式，即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/27.png)\n- **5**: 置入代码，只需要使用，` ```cpp 代码 ``` `将代码包裹其中即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/28.png)\n# 第六步，发表文章。\n- **1**: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。\n![ICON](articles/QiNuoTu/CorrectlyReleased/18.png)\n- **2**: 把文件夹拖住丢上去。\n![ICON](articles/QiNuoTu/CorrectlyReleased/19.png)\n- **3**: 点击绿色按钮。\n![ICON](articles/QiNuoTu/CorrectlyReleased/20.png)\n- **4**: 之后就可以看到自己的文件夹了。\n![ICON](articles/QiNuoTu/CorrectlyReleased/21.png)\n- **5**: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。\n![ICON](articles/QiNuoTu/CorrectlyReleased/22.png)\n# 第七步，提交！\n- **1**: 点击右上角的GameDevWebsite。\n![ICON](articles/QiNuoTu/CorrectlyReleased/23.png)\n- **2**: 找到，Contribote，点击绿色按钮！\n![ICON](articles/QiNuoTu/CorrectlyReleased/24.png)\n- **2**: 填写标题，点击绿色按钮！\n![ICON](articles/QiNuoTu/CorrectlyReleased/25.png)\n# 等待审核即可！\n![ICON](articles/QiNuoTu/CorrectlyReleased/26.png)\n\n# 这是什么？\n![ICON](articles/QiNuoTu/CorrectlyReleased/123415231.png)\n","slug":"QiNuoTu/CorrectlyReleased","published":1,"__permalink":"articles/QiNuoTu/CorrectlyReleased/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hga000go8ye6epw1ygl","content":"<p>保姆级！保姆级！保姆级！Ciallo​～！<br>每一步都有图文混合讲解！</p>\n<span id=\"more\"></span>\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h1 id=\"第一步，先分叉一个VoidGameSpace的原始库\"><a href=\"#第一步，先分叉一个VoidGameSpace的原始库\" class=\"headerlink\" title=\"第一步，先分叉一个VoidGameSpace的原始库\"></a>第一步，先分叉一个VoidGameSpace的原始库</h1><ul>\n<li><strong>1</strong>: 点击蓝字进入<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">VoidGameSpace</a>。<br>进入后，会看到这样的页面。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/1.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/2.png\" alt=\"ICON\"><br><img src=\"/articles/QiNuoTu/CorrectlyReleased/3.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 此刻你的库中就有了一份分叉文件，第一步完成。</li>\n</ul>\n<h1 id=\"第二步，来到自己的库中，并进入GameDevWebsite项目。\"><a href=\"#第二步，来到自己的库中，并进入GameDevWebsite项目。\" class=\"headerlink\" title=\"第二步，来到自己的库中，并进入GameDevWebsite项目。\"></a>第二步，来到自己的库中，并进入GameDevWebsite项目。</h1><ul>\n<li><strong>1</strong>: 点击左上角的，点点点，标志。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/4.png\" alt=\"ICON\"><br>选择，自己名字加上斜杠的&#x2F;GameDevWebsite项目，非常重要！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/5.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 这样就进入了自己库中的GameDevWebsite克隆项目。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/6.png\" alt=\"ICON\"><br>这里的头像变成自己的，就正确了。</li>\n</ul>\n<h1 id=\"第三步，来到，-posts，文件夹。\"><a href=\"#第三步，来到，-posts，文件夹。\" class=\"headerlink\" title=\"第三步，来到，_posts，文件夹。\"></a>第三步，来到，_posts，文件夹。</h1><p>点击项目中的，source，文件夹。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/7.png\" alt=\"ICON\"><br>在点击，_posts，文件夹<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/8.png\" alt=\"ICON\"><br>这里会有一大堆别人的文件夹，不需要管理。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/9.png\" alt=\"ICON\"></p>\n<h1 id=\"第四步，准备文章！\"><a href=\"#第四步，准备文章！\" class=\"headerlink\" title=\"第四步，准备文章！\"></a>第四步，准备文章！</h1><p>此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。</p>\n<h2 id=\"自己的名字！，不要抄我的名字！\"><a href=\"#自己的名字！，不要抄我的名字！\" class=\"headerlink\" title=\"自己的名字！，不要抄我的名字！\"></a>自己的名字！，不要抄我的名字！</h2><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/10.png\" alt=\"ICON\"><br>进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。<br>编写参阅，<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">VoidGameSpace</a>。下方的说明。</p>\n<ul>\n<li><strong>1</strong>: 跳过上面的说明我们创建一个。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/11.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 打开，在头部添加以下内容。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/12.png\" alt=\"ICON\"><br>permalink: 不太好理解，不用担心，请往下看，<br>它是这样的结构，permalink: articles&#x2F;QiNuoTu&#x2F;Demo&#x2F;</li>\n<li><strong>articles</strong>: 可以理解为根目录，必须加上。</li>\n<li><strong>QiNuoTu</strong>: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/10.png\" alt=\"ICON\"></li>\n<li><strong>Demo</strong>: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，&#x2F;，斜杠在尾部。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/13.png\" alt=\"ICON\"><br>这样一来，文章头就准备完毕了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/14.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第五步，编写文章！\"><a href=\"#第五步，编写文章！\" class=\"headerlink\" title=\"第五步，编写文章！\"></a>第五步，编写文章！</h1><ul>\n<li><strong>1</strong>: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，<code>&lt;!-- More --&gt;</code> 标记下书写<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/15.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 如何添加图片，在文章旁边使用同名创建一个文件夹。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/16.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 将图片丢进文件夹中，就可以使用，<code>![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)</code>表达式引用图片了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/17.png\" alt=\"ICON\"></li>\n<li><strong>4</strong>: 网页链接同理，<code>[名称](链接)</code>，表达式，即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/27.png\" alt=\"ICON\"></li>\n<li><strong>5</strong>: 置入代码，只需要使用，<code>```cpp 代码 ```</code>将代码包裹其中即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/28.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第六步，发表文章。\"><a href=\"#第六步，发表文章。\" class=\"headerlink\" title=\"第六步，发表文章。\"></a>第六步，发表文章。</h1><ul>\n<li><strong>1</strong>: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/18.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 把文件夹拖住丢上去。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/19.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 点击绿色按钮。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/20.png\" alt=\"ICON\"></li>\n<li><strong>4</strong>: 之后就可以看到自己的文件夹了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/21.png\" alt=\"ICON\"></li>\n<li><strong>5</strong>: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/22.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第七步，提交！\"><a href=\"#第七步，提交！\" class=\"headerlink\" title=\"第七步，提交！\"></a>第七步，提交！</h1><ul>\n<li><strong>1</strong>: 点击右上角的GameDevWebsite。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/23.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 找到，Contribote，点击绿色按钮！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/24.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 填写标题，点击绿色按钮！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/25.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"等待审核即可！\"><a href=\"#等待审核即可！\" class=\"headerlink\" title=\"等待审核即可！\"></a>等待审核即可！</h1><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/26.png\" alt=\"ICON\"></p>\n<h1 id=\"这是什么？\"><a href=\"#这是什么？\" class=\"headerlink\" title=\"这是什么？\"></a>这是什么？</h1><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/123415231.png\" alt=\"ICON\"></p>\n","site":{"data":{}},"excerpt":"<p>保姆级！保姆级！保姆级！Ciallo​～！<br>每一步都有图文混合讲解！</p>","more":"<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h1 id=\"第一步，先分叉一个VoidGameSpace的原始库\"><a href=\"#第一步，先分叉一个VoidGameSpace的原始库\" class=\"headerlink\" title=\"第一步，先分叉一个VoidGameSpace的原始库\"></a>第一步，先分叉一个VoidGameSpace的原始库</h1><ul>\n<li><strong>1</strong>: 点击蓝字进入<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">VoidGameSpace</a>。<br>进入后，会看到这样的页面。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/1.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 点击右上角的，Fork，如果不明白全部默认，点击绿色按钮即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/2.png\" alt=\"ICON\"><br><img src=\"/articles/QiNuoTu/CorrectlyReleased/3.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 此刻你的库中就有了一份分叉文件，第一步完成。</li>\n</ul>\n<h1 id=\"第二步，来到自己的库中，并进入GameDevWebsite项目。\"><a href=\"#第二步，来到自己的库中，并进入GameDevWebsite项目。\" class=\"headerlink\" title=\"第二步，来到自己的库中，并进入GameDevWebsite项目。\"></a>第二步，来到自己的库中，并进入GameDevWebsite项目。</h1><ul>\n<li><strong>1</strong>: 点击左上角的，点点点，标志。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/4.png\" alt=\"ICON\"><br>选择，自己名字加上斜杠的&#x2F;GameDevWebsite项目，非常重要！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/5.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 这样就进入了自己库中的GameDevWebsite克隆项目。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/6.png\" alt=\"ICON\"><br>这里的头像变成自己的，就正确了。</li>\n</ul>\n<h1 id=\"第三步，来到，-posts，文件夹。\"><a href=\"#第三步，来到，-posts，文件夹。\" class=\"headerlink\" title=\"第三步，来到，_posts，文件夹。\"></a>第三步，来到，_posts，文件夹。</h1><p>点击项目中的，source，文件夹。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/7.png\" alt=\"ICON\"><br>在点击，_posts，文件夹<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/8.png\" alt=\"ICON\"><br>这里会有一大堆别人的文件夹，不需要管理。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/9.png\" alt=\"ICON\"></p>\n<h1 id=\"第四步，准备文章！\"><a href=\"#第四步，准备文章！\" class=\"headerlink\" title=\"第四步，准备文章！\"></a>第四步，准备文章！</h1><p>此刻，网页上的操作已经完成，回到本地，用自己的名字创建一个文件夹。</p>\n<h2 id=\"自己的名字！，不要抄我的名字！\"><a href=\"#自己的名字！，不要抄我的名字！\" class=\"headerlink\" title=\"自己的名字！，不要抄我的名字！\"></a>自己的名字！，不要抄我的名字！</h2><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/10.png\" alt=\"ICON\"><br>进入文件夹，使用你任何喜欢的md文件编辑器在其中创建一个文件，然后进入，开始编写。<br>编写参阅，<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">VoidGameSpace</a>。下方的说明。</p>\n<ul>\n<li><strong>1</strong>: 跳过上面的说明我们创建一个。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/11.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 打开，在头部添加以下内容。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/12.png\" alt=\"ICON\"><br>permalink: 不太好理解，不用担心，请往下看，<br>它是这样的结构，permalink: articles&#x2F;QiNuoTu&#x2F;Demo&#x2F;</li>\n<li><strong>articles</strong>: 可以理解为根目录，必须加上。</li>\n<li><strong>QiNuoTu</strong>: 这个是我的名字，一个示意，需要修改为你名字文件夹的名称。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/10.png\" alt=\"ICON\"></li>\n<li><strong>Demo</strong>: 这个是你创建的当前文章的文件名，不要扩展名，但要加上，&#x2F;，斜杠在尾部。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/13.png\" alt=\"ICON\"><br>这样一来，文章头就准备完毕了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/14.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第五步，编写文章！\"><a href=\"#第五步，编写文章！\" class=\"headerlink\" title=\"第五步，编写文章！\"></a>第五步，编写文章！</h1><ul>\n<li><strong>1</strong>: 在上面的截图可以注意到，文章头下面有一些白字，没错，这个可以当作简介，或者先到言，具体的文章内容需要在，<code>&lt;!-- More --&gt;</code> 标记下书写<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/15.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 如何添加图片，在文章旁边使用同名创建一个文件夹。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/16.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 将图片丢进文件夹中，就可以使用，<code>![ICON](articles/自己名称文件夹名/文件夹名/文件名.后缀名)</code>表达式引用图片了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/17.png\" alt=\"ICON\"></li>\n<li><strong>4</strong>: 网页链接同理，<code>[名称](链接)</code>，表达式，即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/27.png\" alt=\"ICON\"></li>\n<li><strong>5</strong>: 置入代码，只需要使用，<code>```cpp 代码 ```</code>将代码包裹其中即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/28.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第六步，发表文章。\"><a href=\"#第六步，发表文章。\" class=\"headerlink\" title=\"第六步，发表文章。\"></a>第六步，发表文章。</h1><ul>\n<li><strong>1</strong>: 回到网页，那一堆名字的文件夹的页面，点击右上角的，上传文件。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/18.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 把文件夹拖住丢上去。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/19.png\" alt=\"ICON\"></li>\n<li><strong>3</strong>: 点击绿色按钮。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/20.png\" alt=\"ICON\"></li>\n<li><strong>4</strong>: 之后就可以看到自己的文件夹了。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/21.png\" alt=\"ICON\"></li>\n<li><strong>5</strong>: 点进去！，就可以看到自己的md文件和文件夹什么的了，在提交之前，需要说明，建立文件夹克隆库一类都只需要做一次，每次发布只要弄文章md和图片文件夹上传到自己的文件夹中即可。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/22.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"第七步，提交！\"><a href=\"#第七步，提交！\" class=\"headerlink\" title=\"第七步，提交！\"></a>第七步，提交！</h1><ul>\n<li><strong>1</strong>: 点击右上角的GameDevWebsite。<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/23.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 找到，Contribote，点击绿色按钮！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/24.png\" alt=\"ICON\"></li>\n<li><strong>2</strong>: 填写标题，点击绿色按钮！<br><img src=\"/articles/QiNuoTu/CorrectlyReleased/25.png\" alt=\"ICON\"></li>\n</ul>\n<h1 id=\"等待审核即可！\"><a href=\"#等待审核即可！\" class=\"headerlink\" title=\"等待审核即可！\"></a>等待审核即可！</h1><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/26.png\" alt=\"ICON\"></p>\n<h1 id=\"这是什么？\"><a href=\"#这是什么？\" class=\"headerlink\" title=\"这是什么？\"></a>这是什么？</h1><p><img src=\"/articles/QiNuoTu/CorrectlyReleased/123415231.png\" alt=\"ICON\"></p>"},{"title":"是琪诺兔啦！(●'◡'●)！","date":"2024-05-30T16:00:00.000Z","updated":"2024-05-30T16:00:00.000Z","_content":"琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o/\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n![ICON](articles/QiNuoTu/Iamme/1.jpg)\n\n#这是什么？\n![ICON](articles/QiNuoTu/Iamme/2.png)\n","source":"_posts/QiNuoTu/Iamme.md","raw":"---\ntitle: 是琪诺兔啦！(●'◡'●)！\ndate: 2024-05-31\nupdated: 2024-05-31\npermalink: articles/QiNuoTu/Iamme/\ncategories: QiNuoTu\ntags: [闲聊]\n---\n琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o/\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n![ICON](articles/QiNuoTu/Iamme/1.jpg)\n\n#这是什么？\n![ICON](articles/QiNuoTu/Iamme/2.png)\n","slug":"QiNuoTu/Iamme","published":1,"__permalink":"articles/QiNuoTu/Iamme/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgf000ko8ye18hp6oh1","content":"<p>琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o&#x2F;</p>\n<span id=\"more\"></span>\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<p><img src=\"/articles/QiNuoTu/Iamme/1.jpg\" alt=\"ICON\"></p>\n<p>#这是什么？<br><img src=\"/articles/QiNuoTu/Iamme/2.png\" alt=\"ICON\"></p>\n","site":{"data":{}},"excerpt":"<p>琪诺兔是一种幻想生物，他十分可爱，o( ?_? )o&#x2F;</p>","more":"<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<p><img src=\"/articles/QiNuoTu/Iamme/1.jpg\" alt=\"ICON\"></p>\n<p>#这是什么？<br><img src=\"/articles/QiNuoTu/Iamme/2.png\" alt=\"ICON\"></p>"},{"title":"开箱即用平滑插值大合集！OpenEasing！","date":"2024-05-29T16:00:00.000Z","updated":"2024-05-29T16:00:00.000Z","_content":"在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。[Easing](https://easings.net/zh-cn)，\n![ICON](articles/QiNuoTu/OpenEasing/OpenEasing.png)\n网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++.\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。\n> **begin_**: 当前时间&当前是第几段&当前位置，无需担心会被自动计算为比例。\n> \n> **start**: 开始值&开始时间&开始位置，等。\n> \n> **end**: 结束值&结束时间&结束位置，等。\n> \n> **percent_**: 将开始与结束之间分为多少段。\n\n```cpp\nint main() {\n    // 示例\n    double progress = 0.5; // 进度\n    double startValue = 0;  // 开始数值\n    double endValue = 100;  // 结束数值\n    double segments = 10;   // 分段数\n    double result = Easing(progress, startValue, endValue, segments);\n    std::cout << \"Easing price: \" << result << std::endl;\n    return 0;\n}\nRGBA ColorDifference(const RGBA& start, const RGBA& end, double t) {\n    return RGBA(start.R + (end.R - start.R) * t, \n                start.G + (end.G - start.G) * t,\n                start.B + (end.B - start.B) * t,\n                start.A + (end.A - start.A) * t);\n}\ndouble _getOutBounce(double begin_,double end_,double percent_){\n    double _st = end_ - begin_;\n    double _ed = percent_;\n    if (_st < 1 ÷ 2.75) return _ed * 7.5625 * _st * _st + begin_;\n    else if (_st < 2 ÷ 2.75) {_st = _st - 1.5 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.75) + begin_;}\n    else if (_st < 2.5 ÷ 2.75) {_st = _st - 2.25 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.9375) + begin_;}\n    _st = _st - 2.625 ÷ 2.75;\n    return _ed * (7.5625 * _st * _st + 0.984375) + begin_;\n}\ndouble _getInBounce(double begin_,double end_,double percent_){\n    double _ed = end_ - begin_;\n    return _ed - _getOutBounce (0, _ed, 1 - percent_) + begin_;\n}\ndouble Linear(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return ((_End - _Start) * percents_ * percents_ + _Start);\n}\ndouble OutQuad(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return -(_End - _Start) * percents_ * (percents_ - 2) + _Start;\n}\ndouble InOutQuad(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ts = percents_ * 2;\n    if (_ts < 1) return (_End - _Start) ÷ 2 * _ts * _ts + _Start;\n    return -(_End - _Start) ÷ 2 * (_ts * (_ts - 2) - 1) + _Start;\n}\ndouble InCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    return (_End - _Start) * (_st * _st * _st + 1) + _Start;\n}\ndouble InOutCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    if(_st < 1)return _ed1 ÷ 2 * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (_st * _st * _st + 2) + _Start;\n}\ndouble InQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    return -(_End - _Start) * (_st * _st * _st * _st - 1) + _Start;\n}\ndouble InOutQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * _st * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return -_ed1 ÷ 2 * (_st * _st * _st * _st - 2) + _Start;\n}\ndouble InQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * (_st * _st * _st * _st * _st + 1) + _Start;\n}\ndouble InOutQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * _st * _st * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (_st * _st * _st * _st * _st + 2) + _Start;\n}\ndouble InSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return -_ed1 * cos (percents_ ÷ 1 * M_PI ÷ 2) + _ed1 + _Start;\n}   \ndouble OutSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * sin (percents_ ÷ 1 * M_PI ÷ 2) + _Start;\n}\ndouble InOutSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * pow (2, 10 * (percents_ ÷ 1 - 1)) + _Start;\n}\ndouble OutExpo(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * pow (2, 10 * (_st - 1)) + _Start;\n    _st = _st - 1;\n    return _ed1 ÷ 2 * (-pow (2, -10 * _st) + 2) + _Start;\n}\ndouble InCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return -_ed1 * (sqrt (1 - percents_ * percents_) - 1) + _Start;\n}\ndouble OutCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * sqrt (1 - _st * _st) + _Start;\n}\ndouble InOutCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return -_ed1 ÷ 2 * (sqrt (1 - _st * _st) - 1) + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (sqrt (1 - _st * _st) + 1) + _Start;\n}\ndouble InBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return _getInBounce(_Start, _End, percents_);\n}\ndouble OutBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return _getOutBounce(_Start, _End, percents_);\n}\ndouble InOutBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    if (percents_ < 0.5) return _getInBounce (0, _ed, percents_ * 2) * 0.5 + _Start;\n    return _getOutBounce (0, _ed, percents_ * 2 - 1) * 0.5 + _ed * 0.5 + _Start;\n}\ndouble InBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    return _ed * percents_ * percents_ * ((_s + 1) * percents_ - _s) + _Start;\n}\ndouble OutBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    double _st = percents_ - 1;\n    return _ed * (_st * _st * ((_s + 1) * _st + _s) + 1) + _Start;\n}\ndouble InOutBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    double _st = percents_ * 2;\n    if (_st < 1){_s = _s * 1.525; return _ed ÷ 2 * _st * _st * ((_s + 1) * _st - _s) + _Start;}\n    double _st = _st - 2\n    double _s = _s * 1.525\n    return _ed ÷ 2 * (_st * _st * ((_s + 1) * _st + _s) + 2) + _Start;\n}\ndouble InElastic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    if(percents_ == 0) return _Start;\n    if(percents_ == 1) return _End;\n    double _ed = _End - _Start;\n    double _d = 1\n    double _p = _d * 0.3\n    double _s = 0\n    double _a = 0\n    if (_a = 0 || _a < ads(_ed)){_a = _ed; _s = _p ÷ 4} else {_s = _p / (2 * M_PI) * std::asin(_ed / _a);}\n    double _st = percents - 1;\n    return -(_a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p)) + _Start;\n}\ndouble OutElastic(double _Progress, double _Start, double _end, double _segments) {\n    double percents_ = _Progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _Start;\n    double _d = 1;\n    double _p = _d * 0.3;\n    double _s = 0;\n    double _a = 0;\n    if (_a == 0 || _a < abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);}\n    return _a * pow(2, -10 * percents) * sin((percents * _d - _s) * 2 * M_PI / _p) + _end;\n}\ndouble InOutElastic(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _start;\n    double _d = 1;\n    double _p = _d * 0.3;\n    double _s = 0;\n    double _a = 0;\n    double _st = percents_ * 2;\n    if (_st == 2) {return _end;}\n    if (_a == 0 || _a < abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);}\n    if (_st < 1) {_st -= 1;return -0.5 * _a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) + _start;}\n    _st -= 1;\n    return _a * pow(2, -10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) * 0.5 + _end;\n}\ndouble Clerp(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _start;\n    const double _min = 0;\n    const double _max = 360;\n    const double _half = 180;\n    double _retval = 0;\n    double _diff = 0;\n    if (_ed < -_half) {\n        _diff = (_max - _start + _end) * percents_;\n        _retval = _start + _diff;\n    } else if (_ed > _half) {\n        _diff = -(_max - _end + _start) * percents_;\n        _retval = _start + _diff;\n    } else {\n        _retval = _start + _ed * percents_;\n    }\n    return _retval;\n}\ndouble Spring(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _st = sin(percents_ * M_PI * (0.2 + 2.5 * percents_ * percents_ * percents_)) * pow(1 - percents_, 2.2) + percents_;\n    _st = _st * (1 + 1.2 * (1 - percents_));\n    return _start + (_end - _start) * _st;\n}\ndouble Punch(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    if (percents_ == 0) return 0;\n    if (percents_ == 1) return 0;\n    const double _p = 0.3;\n    double _s = _p / (2 * M_PI) * asin(0);\n    return _end * pow(2, -10 * percents) * sin((percents - _s) * 2 * M_PI / _p);\n}\n```\n# 这是什么！\n![ICON](articles/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg)\n","source":"_posts/QiNuoTu/OpenEasing.md","raw":"---\ntitle: 开箱即用平滑插值大合集！OpenEasing！\ndate: 2024-05-30\nupdated: 2024-05-30\npermalink: articles/QiNuoTu/OpenEasing/\ncategories: QiNuoTu\ntags: [游戏开发]    \n---\n在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。[Easing](https://easings.net/zh-cn)，\n![ICON](articles/QiNuoTu/OpenEasing/OpenEasing.png)\n网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++.\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。\n> **begin_**: 当前时间&当前是第几段&当前位置，无需担心会被自动计算为比例。\n> \n> **start**: 开始值&开始时间&开始位置，等。\n> \n> **end**: 结束值&结束时间&结束位置，等。\n> \n> **percent_**: 将开始与结束之间分为多少段。\n\n```cpp\nint main() {\n    // 示例\n    double progress = 0.5; // 进度\n    double startValue = 0;  // 开始数值\n    double endValue = 100;  // 结束数值\n    double segments = 10;   // 分段数\n    double result = Easing(progress, startValue, endValue, segments);\n    std::cout << \"Easing price: \" << result << std::endl;\n    return 0;\n}\nRGBA ColorDifference(const RGBA& start, const RGBA& end, double t) {\n    return RGBA(start.R + (end.R - start.R) * t, \n                start.G + (end.G - start.G) * t,\n                start.B + (end.B - start.B) * t,\n                start.A + (end.A - start.A) * t);\n}\ndouble _getOutBounce(double begin_,double end_,double percent_){\n    double _st = end_ - begin_;\n    double _ed = percent_;\n    if (_st < 1 ÷ 2.75) return _ed * 7.5625 * _st * _st + begin_;\n    else if (_st < 2 ÷ 2.75) {_st = _st - 1.5 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.75) + begin_;}\n    else if (_st < 2.5 ÷ 2.75) {_st = _st - 2.25 ÷ 2.75; return _ed * (7.5625 * _st * _st + 0.9375) + begin_;}\n    _st = _st - 2.625 ÷ 2.75;\n    return _ed * (7.5625 * _st * _st + 0.984375) + begin_;\n}\ndouble _getInBounce(double begin_,double end_,double percent_){\n    double _ed = end_ - begin_;\n    return _ed - _getOutBounce (0, _ed, 1 - percent_) + begin_;\n}\ndouble Linear(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return ((_End - _Start) * percents_ * percents_ + _Start);\n}\ndouble OutQuad(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return -(_End - _Start) * percents_ * (percents_ - 2) + _Start;\n}\ndouble InOutQuad(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ts = percents_ * 2;\n    if (_ts < 1) return (_End - _Start) ÷ 2 * _ts * _ts + _Start;\n    return -(_End - _Start) ÷ 2 * (_ts * (_ts - 2) - 1) + _Start;\n}\ndouble InCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    return (_End - _Start) * (_st * _st * _st + 1) + _Start;\n}\ndouble InOutCubic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    if(_st < 1)return _ed1 ÷ 2 * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (_st * _st * _st + 2) + _Start;\n}\ndouble InQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    return -(_End - _Start) * (_st * _st * _st * _st - 1) + _Start;\n}\ndouble InOutQuart(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * _st * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return -_ed1 ÷ 2 * (_st * _st * _st * _st - 2) + _Start;\n}\ndouble InQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;\n}\ndouble OutQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * (_st * _st * _st * _st * _st + 1) + _Start;\n}\ndouble InOutQuint(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * _st * _st * _st * _st * _st + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (_st * _st * _st * _st * _st + 2) + _Start;\n}\ndouble InSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return -_ed1 * cos (percents_ ÷ 1 * M_PI ÷ 2) + _ed1 + _Start;\n}   \ndouble OutSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * sin (percents_ ÷ 1 * M_PI ÷ 2) + _Start;\n}\ndouble InOutSine(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * pow (2, 10 * (percents_ ÷ 1 - 1)) + _Start;\n}\ndouble OutExpo(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return _ed1 ÷ 2 * pow (2, 10 * (_st - 1)) + _Start;\n    _st = _st - 1;\n    return _ed1 ÷ 2 * (-pow (2, -10 * _st) + 2) + _Start;\n}\ndouble InCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed1 = _End - _Start;\n    return -_ed1 * (sqrt (1 - percents_ * percents_) - 1) + _Start;\n}\ndouble OutCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ - 1;\n    double _ed1 = _End - _Start;\n    return _ed1 * sqrt (1 - _st * _st) + _Start;\n}\ndouble InOutCirc(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _st = percents_ * 2;\n    double _ed1 = _End - _Start;\n    if (_st < 1) return -_ed1 ÷ 2 * (sqrt (1 - _st * _st) - 1) + _Start;\n    _st = _st - 2;\n    return _ed1 ÷ 2 * (sqrt (1 - _st * _st) + 1) + _Start;\n}\ndouble InBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return _getInBounce(_Start, _End, percents_);\n}\ndouble OutBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    return _getOutBounce(_Start, _End, percents_);\n}\ndouble InOutBounce(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    if (percents_ < 0.5) return _getInBounce (0, _ed, percents_ * 2) * 0.5 + _Start;\n    return _getOutBounce (0, _ed, percents_ * 2 - 1) * 0.5 + _ed * 0.5 + _Start;\n}\ndouble InBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    return _ed * percents_ * percents_ * ((_s + 1) * percents_ - _s) + _Start;\n}\ndouble OutBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    double _st = percents_ - 1;\n    return _ed * (_st * _st * ((_s + 1) * _st + _s) + 1) + _Start;\n}\ndouble InOutBack(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    double _ed = _End - _Start;\n    double _s = 1.70158;\n    double _st = percents_ * 2;\n    if (_st < 1){_s = _s * 1.525; return _ed ÷ 2 * _st * _st * ((_s + 1) * _st - _s) + _Start;}\n    double _st = _st - 2\n    double _s = _s * 1.525\n    return _ed ÷ 2 * (_st * _st * ((_s + 1) * _st + _s) + 2) + _Start;\n}\ndouble InElastic(double _Progress,double _Start,double _End,double _segments){\n    double percents_ = _Progress / _segments;\n    if (percents < 0) percents = 0;\n    else if (percents > 1) percents = 1;\n    if(percents_ == 0) return _Start;\n    if(percents_ == 1) return _End;\n    double _ed = _End - _Start;\n    double _d = 1\n    double _p = _d * 0.3\n    double _s = 0\n    double _a = 0\n    if (_a = 0 || _a < ads(_ed)){_a = _ed; _s = _p ÷ 4} else {_s = _p / (2 * M_PI) * std::asin(_ed / _a);}\n    double _st = percents - 1;\n    return -(_a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p)) + _Start;\n}\ndouble OutElastic(double _Progress, double _Start, double _end, double _segments) {\n    double percents_ = _Progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _Start;\n    double _d = 1;\n    double _p = _d * 0.3;\n    double _s = 0;\n    double _a = 0;\n    if (_a == 0 || _a < abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);}\n    return _a * pow(2, -10 * percents) * sin((percents * _d - _s) * 2 * M_PI / _p) + _end;\n}\ndouble InOutElastic(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _start;\n    double _d = 1;\n    double _p = _d * 0.3;\n    double _s = 0;\n    double _a = 0;\n    double _st = percents_ * 2;\n    if (_st == 2) {return _end;}\n    if (_a == 0 || _a < abs(_ed)) {_a = _ed;_s = _p / 4;} else {_s = _p / (2 * M_PI) * asin(_ed / _a);}\n    if (_st < 1) {_st -= 1;return -0.5 * _a * pow(2, 10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) + _start;}\n    _st -= 1;\n    return _a * pow(2, -10 * _st) * sin((_st * _d - _s) * 2 * M_PI / _p) * 0.5 + _end;\n}\ndouble Clerp(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _ed = _end - _start;\n    const double _min = 0;\n    const double _max = 360;\n    const double _half = 180;\n    double _retval = 0;\n    double _diff = 0;\n    if (_ed < -_half) {\n        _diff = (_max - _start + _end) * percents_;\n        _retval = _start + _diff;\n    } else if (_ed > _half) {\n        _diff = -(_max - _end + _start) * percents_;\n        _retval = _start + _diff;\n    } else {\n        _retval = _start + _ed * percents_;\n    }\n    return _retval;\n}\ndouble Spring(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    double _st = sin(percents_ * M_PI * (0.2 + 2.5 * percents_ * percents_ * percents_)) * pow(1 - percents_, 2.2) + percents_;\n    _st = _st * (1 + 1.2 * (1 - percents_));\n    return _start + (_end - _start) * _st;\n}\ndouble Punch(double _progress, double _start, double _end, double _segments) {\n    double percents_ = _progress / _segments;\n    if (percents_ < 0) percents_ = 0;\n    else if (percents_ > 1) percents_ = 1;\n    if (percents_ == 0) return 0;\n    if (percents_ == 1) return 0;\n    const double _p = 0.3;\n    double _s = _p / (2 * M_PI) * asin(0);\n    return _end * pow(2, -10 * percents) * sin((percents - _s) * 2 * M_PI / _p);\n}\n```\n# 这是什么！\n![ICON](articles/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg)\n","slug":"QiNuoTu/OpenEasing","published":1,"__permalink":"articles/QiNuoTu/OpenEasing/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgf000lo8ye6hli2vre","content":"<p>在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。<a href=\"https://easings.net/zh-cn\">Easing</a>，<br><img src=\"/articles/QiNuoTu/OpenEasing/OpenEasing.png\" alt=\"ICON\"><br>网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++.</p>\n<span id=\"more\"></span>\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<p>比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。</p>\n<blockquote>\n<p><strong>begin_</strong>: 当前时间&amp;当前是第几段&amp;当前位置，无需担心会被自动计算为比例。</p>\n<p><strong>start</strong>: 开始值&amp;开始时间&amp;开始位置，等。</p>\n<p><strong>end</strong>: 结束值&amp;结束时间&amp;结束位置，等。</p>\n<p><strong>percent_</strong>: 将开始与结束之间分为多少段。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例</span></span><br><span class=\"line\">    <span class=\"type\">double</span> progress = <span class=\"number\">0.5</span>; <span class=\"comment\">// 进度</span></span><br><span class=\"line\">    <span class=\"type\">double</span> startValue = <span class=\"number\">0</span>;  <span class=\"comment\">// 开始数值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> endValue = <span class=\"number\">100</span>;  <span class=\"comment\">// 结束数值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> segments = <span class=\"number\">10</span>;   <span class=\"comment\">// 分段数</span></span><br><span class=\"line\">    <span class=\"type\">double</span> result = <span class=\"built_in\">Easing</span>(progress, startValue, endValue, segments);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Easing price: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">RGBA <span class=\"title\">ColorDifference</span><span class=\"params\">(<span class=\"type\">const</span> RGBA&amp; start, <span class=\"type\">const</span> RGBA&amp; end, <span class=\"type\">double</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">RGBA</span>(start.R + (end.R - start.R) * t, </span><br><span class=\"line\">                start.G + (end.G - start.G) * t,</span><br><span class=\"line\">                start.B + (end.B - start.B) * t,</span><br><span class=\"line\">                start.A + (end.A - start.A) * t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> _getOutBounce(<span class=\"type\">double</span> begin_,<span class=\"type\">double</span> end_,<span class=\"type\">double</span> percent_)&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = end_ - begin_;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = percent_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span> ÷ <span class=\"number\">2.75</span>) <span class=\"keyword\">return</span> _ed * <span class=\"number\">7.5625</span> * _st * _st + begin_;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">2</span> ÷ <span class=\"number\">2.75</span>) &#123;_st = _st - <span class=\"number\">1.5</span> ÷ <span class=\"number\">2.75</span>; <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.75</span>) + begin_;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">2.5</span> ÷ <span class=\"number\">2.75</span>) &#123;_st = _st - <span class=\"number\">2.25</span> ÷ <span class=\"number\">2.75</span>; <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.9375</span>) + begin_;&#125;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2.625</span> ÷ <span class=\"number\">2.75</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.984375</span>) + begin_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> _getInBounce(<span class=\"type\">double</span> begin_,<span class=\"type\">double</span> end_,<span class=\"type\">double</span> percent_)&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = end_ - begin_;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed - _getOutBounce (<span class=\"number\">0</span>, _ed, <span class=\"number\">1</span> - percent_) + begin_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Linear</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((_End - _Start) * percents_ * percents_ + _Start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuad</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) * percents_ * (percents_ - <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuad</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ts = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_ts &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> (_End - _Start) ÷ <span class=\"number\">2</span> * _ts * _ts + _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) ÷ <span class=\"number\">2</span> * (_ts * (_ts - <span class=\"number\">2</span>) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * (_st * _st * _st + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_st &lt; <span class=\"number\">1</span>)<span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) * (_st * _st * _st * _st - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st * _st - <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * (_st * _st * _st * _st * _st + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st * _st * _st + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 * <span class=\"built_in\">cos</span> (percents_ ÷ <span class=\"number\">1</span> * M_PI ÷ <span class=\"number\">2</span>) + _ed1 + _Start;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">sin</span> (percents_ ÷ <span class=\"number\">1</span> * M_PI ÷ <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">10</span> * (percents_ ÷ <span class=\"number\">1</span> - <span class=\"number\">1</span>)) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutExpo</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * <span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">10</span> * (_st - <span class=\"number\">1</span>)) + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (-<span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">-10</span> * _st) + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - percents_ * percents_) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> -_ed1 ÷ <span class=\"number\">2</span> * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getInBounce(_Start, _End, percents_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getOutBounce(_Start, _End, percents_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0.5</span>) <span class=\"keyword\">return</span> _getInBounce (<span class=\"number\">0</span>, _ed, percents_ * <span class=\"number\">2</span>) * <span class=\"number\">0.5</span> + _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getOutBounce (<span class=\"number\">0</span>, _ed, percents_ * <span class=\"number\">2</span> - <span class=\"number\">1</span>) * <span class=\"number\">0.5</span> + _ed * <span class=\"number\">0.5</span> + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * percents_ * percents_ * ((_s + <span class=\"number\">1</span>) * percents_ - _s) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * (_st * _st * ((_s + <span class=\"number\">1</span>) * _st + _s) + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>)&#123;_s = _s * <span class=\"number\">1.525</span>; <span class=\"keyword\">return</span> _ed ÷ <span class=\"number\">2</span> * _st * _st * ((_s + <span class=\"number\">1</span>) * _st - _s) + _Start;&#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = _st - <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _s = _s * <span class=\"number\">1.525</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed ÷ <span class=\"number\">2</span> * (_st * _st * ((_s + <span class=\"number\">1</span>) * _st + _s) + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InElastic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(percents_ == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(percents_ == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _End;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a = <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">ads</span>(_ed))&#123;_a = _ed; _s = _p ÷ <span class=\"number\">4</span>&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * std::<span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p)) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutElastic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress, <span class=\"type\">double</span> _Start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a == <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">abs</span>(_ed)) &#123;_a = _ed;_s = _p / <span class=\"number\">4</span>;&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * percents) * <span class=\"built_in\">sin</span>((percents * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) + _end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutElastic</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st == <span class=\"number\">2</span>) &#123;<span class=\"keyword\">return</span> _end;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a == <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">abs</span>(_ed)) &#123;_a = _ed;_s = _p / <span class=\"number\">4</span>;&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) &#123;_st -= <span class=\"number\">1</span>;<span class=\"keyword\">return</span> <span class=\"number\">-0.5</span> * _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) + _start;&#125;</span><br><span class=\"line\">    _st -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) * <span class=\"number\">0.5</span> + _end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Clerp</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _start;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _max = <span class=\"number\">360</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _half = <span class=\"number\">180</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_ed &lt; -_half) &#123;</span><br><span class=\"line\">        _diff = (_max - _start + _end) * percents_;</span><br><span class=\"line\">        _retval = _start + _diff;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ed &gt; _half) &#123;</span><br><span class=\"line\">        _diff = -(_max - _end + _start) * percents_;</span><br><span class=\"line\">        _retval = _start + _diff;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _retval = _start + _ed * percents_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _retval;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Spring</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = <span class=\"built_in\">sin</span>(percents_ * M_PI * (<span class=\"number\">0.2</span> + <span class=\"number\">2.5</span> * percents_ * percents_ * percents_)) * <span class=\"built_in\">pow</span>(<span class=\"number\">1</span> - percents_, <span class=\"number\">2.2</span>) + percents_;</span><br><span class=\"line\">    _st = _st * (<span class=\"number\">1</span> + <span class=\"number\">1.2</span> * (<span class=\"number\">1</span> - percents_));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _start + (_end - _start) * _st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Punch</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _p = <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _end * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * percents) * <span class=\"built_in\">sin</span>((percents - _s) * <span class=\"number\">2</span> * M_PI / _p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"这是什么！\"><a href=\"#这是什么！\" class=\"headerlink\" title=\"这是什么！\"></a>这是什么！</h1><p><img src=\"/articles/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg\" alt=\"ICON\"></p>\n","site":{"data":{}},"excerpt":"<p>在游戏或动画制作中，如何让一个对象或色彩等平滑过度，或在两个值之间平滑的自动分布一直以来是新人开发者的一大难题，很多同学没有那么多时间去寻找公式并将他们逐一实现，没关系已经有前人为我们铺好了路。<a href=\"https://easings.net/zh-cn\">Easing</a>，<br><img src=\"/articles/QiNuoTu/OpenEasing/OpenEasing.png\" alt=\"ICON\"><br>网站中为我们实现了一系列用于时间缓动的函数与公式，但它并不是C++的，对于超级新手也不太容易使用，于是我花了一些时间对其中的实现进行了一些翻译为C++.</p>","more":"<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<p>比例的概念可能有些困扰，在以下的实现中，我将他们重新封装为，提供四个参数的版本。</p>\n<blockquote>\n<p><strong>begin_</strong>: 当前时间&amp;当前是第几段&amp;当前位置，无需担心会被自动计算为比例。</p>\n<p><strong>start</strong>: 开始值&amp;开始时间&amp;开始位置，等。</p>\n<p><strong>end</strong>: 结束值&amp;结束时间&amp;结束位置，等。</p>\n<p><strong>percent_</strong>: 将开始与结束之间分为多少段。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例</span></span><br><span class=\"line\">    <span class=\"type\">double</span> progress = <span class=\"number\">0.5</span>; <span class=\"comment\">// 进度</span></span><br><span class=\"line\">    <span class=\"type\">double</span> startValue = <span class=\"number\">0</span>;  <span class=\"comment\">// 开始数值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> endValue = <span class=\"number\">100</span>;  <span class=\"comment\">// 结束数值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> segments = <span class=\"number\">10</span>;   <span class=\"comment\">// 分段数</span></span><br><span class=\"line\">    <span class=\"type\">double</span> result = <span class=\"built_in\">Easing</span>(progress, startValue, endValue, segments);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Easing price: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">RGBA <span class=\"title\">ColorDifference</span><span class=\"params\">(<span class=\"type\">const</span> RGBA&amp; start, <span class=\"type\">const</span> RGBA&amp; end, <span class=\"type\">double</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">RGBA</span>(start.R + (end.R - start.R) * t, </span><br><span class=\"line\">                start.G + (end.G - start.G) * t,</span><br><span class=\"line\">                start.B + (end.B - start.B) * t,</span><br><span class=\"line\">                start.A + (end.A - start.A) * t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> _getOutBounce(<span class=\"type\">double</span> begin_,<span class=\"type\">double</span> end_,<span class=\"type\">double</span> percent_)&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = end_ - begin_;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = percent_;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span> ÷ <span class=\"number\">2.75</span>) <span class=\"keyword\">return</span> _ed * <span class=\"number\">7.5625</span> * _st * _st + begin_;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">2</span> ÷ <span class=\"number\">2.75</span>) &#123;_st = _st - <span class=\"number\">1.5</span> ÷ <span class=\"number\">2.75</span>; <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.75</span>) + begin_;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">2.5</span> ÷ <span class=\"number\">2.75</span>) &#123;_st = _st - <span class=\"number\">2.25</span> ÷ <span class=\"number\">2.75</span>; <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.9375</span>) + begin_;&#125;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2.625</span> ÷ <span class=\"number\">2.75</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * (<span class=\"number\">7.5625</span> * _st * _st + <span class=\"number\">0.984375</span>) + begin_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> _getInBounce(<span class=\"type\">double</span> begin_,<span class=\"type\">double</span> end_,<span class=\"type\">double</span> percent_)&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = end_ - begin_;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed - _getOutBounce (<span class=\"number\">0</span>, _ed, <span class=\"number\">1</span> - percent_) + begin_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Linear</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((_End - _Start) * percents_ * percents_ + _Start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuad</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) * percents_ * (percents_ - <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuad</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ts = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_ts &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> (_End - _Start) ÷ <span class=\"number\">2</span> * _ts * _ts + _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) ÷ <span class=\"number\">2</span> * (_ts * (_ts - <span class=\"number\">2</span>) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * (_st * _st * _st + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutCubic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_st &lt; <span class=\"number\">1</span>)<span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_End - _Start) * (_st * _st * _st * _st - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuart</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st * _st - <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_End - _Start) * percents_ * percents_ * percents_ * percents_ * percents_ + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * (_st * _st * _st * _st * _st + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutQuint</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * _st * _st * _st * _st * _st + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (_st * _st * _st * _st * _st + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 * <span class=\"built_in\">cos</span> (percents_ ÷ <span class=\"number\">1</span> * M_PI ÷ <span class=\"number\">2</span>) + _ed1 + _Start;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">sin</span> (percents_ ÷ <span class=\"number\">1</span> * M_PI ÷ <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutSine</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">10</span> * (percents_ ÷ <span class=\"number\">1</span> - <span class=\"number\">1</span>)) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutExpo</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * <span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">10</span> * (_st - <span class=\"number\">1</span>)) + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (-<span class=\"built_in\">pow</span> (<span class=\"number\">2</span>, <span class=\"number\">-10</span> * _st) + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -_ed1 * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - percents_ * percents_) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 * <span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutCirc</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed1 = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> -_ed1 ÷ <span class=\"number\">2</span> * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) - <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">    _st = _st - <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed1 ÷ <span class=\"number\">2</span> * (<span class=\"built_in\">sqrt</span> (<span class=\"number\">1</span> - _st * _st) + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getInBounce(_Start, _End, percents_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getOutBounce(_Start, _End, percents_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutBounce</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0.5</span>) <span class=\"keyword\">return</span> _getInBounce (<span class=\"number\">0</span>, _ed, percents_ * <span class=\"number\">2</span>) * <span class=\"number\">0.5</span> + _Start;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _getOutBounce (<span class=\"number\">0</span>, _ed, percents_ * <span class=\"number\">2</span> - <span class=\"number\">1</span>) * <span class=\"number\">0.5</span> + _ed * <span class=\"number\">0.5</span> + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * percents_ * percents_ * ((_s + <span class=\"number\">1</span>) * percents_ - _s) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed * (_st * _st * ((_s + <span class=\"number\">1</span>) * _st + _s) + <span class=\"number\">1</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutBack</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">1.70158</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>)&#123;_s = _s * <span class=\"number\">1.525</span>; <span class=\"keyword\">return</span> _ed ÷ <span class=\"number\">2</span> * _st * _st * ((_s + <span class=\"number\">1</span>) * _st - _s) + _Start;&#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = _st - <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _s = _s * <span class=\"number\">1.525</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _ed ÷ <span class=\"number\">2</span> * (_st * _st * ((_s + <span class=\"number\">1</span>) * _st + _s) + <span class=\"number\">2</span>) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InElastic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress,<span class=\"type\">double</span> _Start,<span class=\"type\">double</span> _End,<span class=\"type\">double</span> _segments)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents &lt; <span class=\"number\">0</span>) percents = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents &gt; <span class=\"number\">1</span>) percents = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(percents_ == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> _Start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(percents_ == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> _End;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _End - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a = <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">ads</span>(_ed))&#123;_a = _ed; _s = _p ÷ <span class=\"number\">4</span>&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * std::<span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -(_a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p)) + _Start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">OutElastic</span><span class=\"params\">(<span class=\"type\">double</span> _Progress, <span class=\"type\">double</span> _Start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _Progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _Start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a == <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">abs</span>(_ed)) &#123;_a = _ed;_s = _p / <span class=\"number\">4</span>;&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * percents) * <span class=\"built_in\">sin</span>((percents * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) + _end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">InOutElastic</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _start;</span><br><span class=\"line\">    <span class=\"type\">double</span> _d = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _p = _d * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = percents_ * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st == <span class=\"number\">2</span>) &#123;<span class=\"keyword\">return</span> _end;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_a == <span class=\"number\">0</span> || _a &lt; <span class=\"built_in\">abs</span>(_ed)) &#123;_a = _ed;_s = _p / <span class=\"number\">4</span>;&#125; <span class=\"keyword\">else</span> &#123;_s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(_ed / _a);&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_st &lt; <span class=\"number\">1</span>) &#123;_st -= <span class=\"number\">1</span>;<span class=\"keyword\">return</span> <span class=\"number\">-0.5</span> * _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) + _start;&#125;</span><br><span class=\"line\">    _st -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _a * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * _st) * <span class=\"built_in\">sin</span>((_st * _d - _s) * <span class=\"number\">2</span> * M_PI / _p) * <span class=\"number\">0.5</span> + _end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Clerp</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _ed = _end - _start;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _max = <span class=\"number\">360</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _half = <span class=\"number\">180</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _retval = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_ed &lt; -_half) &#123;</span><br><span class=\"line\">        _diff = (_max - _start + _end) * percents_;</span><br><span class=\"line\">        _retval = _start + _diff;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_ed &gt; _half) &#123;</span><br><span class=\"line\">        _diff = -(_max - _end + _start) * percents_;</span><br><span class=\"line\">        _retval = _start + _diff;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _retval = _start + _ed * percents_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _retval;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Spring</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _st = <span class=\"built_in\">sin</span>(percents_ * M_PI * (<span class=\"number\">0.2</span> + <span class=\"number\">2.5</span> * percents_ * percents_ * percents_)) * <span class=\"built_in\">pow</span>(<span class=\"number\">1</span> - percents_, <span class=\"number\">2.2</span>) + percents_;</span><br><span class=\"line\">    _st = _st * (<span class=\"number\">1</span> + <span class=\"number\">1.2</span> * (<span class=\"number\">1</span> - percents_));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _start + (_end - _start) * _st;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Punch</span><span class=\"params\">(<span class=\"type\">double</span> _progress, <span class=\"type\">double</span> _start, <span class=\"type\">double</span> _end, <span class=\"type\">double</span> _segments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> percents_ = _progress / _segments;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ &lt; <span class=\"number\">0</span>) percents_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (percents_ &gt; <span class=\"number\">1</span>) percents_ = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (percents_ == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> _p = <span class=\"number\">0.3</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> _s = _p / (<span class=\"number\">2</span> * M_PI) * <span class=\"built_in\">asin</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _end * <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, <span class=\"number\">-10</span> * percents) * <span class=\"built_in\">sin</span>((percents - _s) * <span class=\"number\">2</span> * M_PI / _p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"这是什么！\"><a href=\"#这是什么！\" class=\"headerlink\" title=\"这是什么！\"></a>这是什么！</h1><p><img src=\"/articles/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg\" alt=\"ICON\"></p>"},{"title":"一些开箱即用碰撞检测！AABB","date":"2024-05-27T16:00:00.000Z","updated":"2024-05-27T16:00:00.000Z","_content":"听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！\n全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n## 在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\n```cpp\n// 定义一个结构体，表示二维空间中的点\nstruct Point_F {\n    double x; // 点的x坐标\n    double y; // 点的y坐标\n};\n\n// 定义一个结构体，表示矩形区域\nstruct RECT {\n    double left;   // 矩形左边缘的x坐标\n    double top;    // 矩形上边缘的y坐标\n    double right;  // 矩形右边缘的x坐标\n    double bottom; // 矩形下边缘的y坐标\n};\n\n// 判断点是否在矩形区域内\nbool AABBPointInside(const Point_F& V, const RECT& RECT) {\n    return (V.x > RECT.left && V.x < RECT.right && V.y > RECT.top && V.y < RECT.bottom);\n}\n// 判断一个矩形是否完全在另一个矩形内部\nbool AABBRectInside(const RECT& rect1, const RECT& rect2) {\n    return (rect2.left >= rect1.left && rect2.right <= rect1.right && rect2.top >= rect1.top && rect2.bottom <= rect1.bottom);\n}\n// 判断两个矩形是否重叠\nbool AABBRectOverlap(const RECT& rect1, const RECT& rect2) {\n    return (rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom) ? false : true;\n}\n// 判断矩形与圆形是否重叠，考虑矩形旋转的情况\nbool AABBRectCircleOverlap(double rectCenterX, double rectCenterY, double rectWidth, double rectHeight, double angle, double circleX, double circleY, double circleRadius) {\n    // 计算旋转后的向量坐标\n    double vectorX = circleX - rectCenterX;\n    double vectorY = circleY - rectCenterY;\n    double radians = angle * M_PI / 180.0;\n    double x = vectorX * cos(radians) + vectorY * sin(radians);\n    double y = vectorY * cos(radians) - vectorX * sin(radians);\n    // 计算矩形的半宽和半高\n    double halfWidth = rectWidth * 0.5;\n    double halfHeight = rectHeight * 0.5;\n    if (x - circleRadius < halfWidth && x + circleRadius > -halfWidth) {\n        if (y - circleRadius < halfHeight && y + circleRadius > -halfHeight) {\n            if (x < -halfWidth && y < -halfHeight){\n                if (distance(x, y, -halfWidth, -halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x < halfWidth && y < -halfHeight){\n                if (distance(x, y, halfWidth, -halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x > halfWidth && y > halfHeight){\n                if (distance(x, y, halfWidth, halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x < -halfWidth && y > halfHeight) {\n                if (distance(x, y, -halfWidth, halfHeight) >= circleRadius) { return true; }\n            }\n        }\n        return true;\n    }\n    return false;\n}\n// 判断点是否在圆内\nbool AABBPointInCircle(double pointX, double pointY, double circleCenterX, double circleCenterY, double circleRadius) {\n    // 计算点到圆心的距离，判断是否小于等于半径\n    double dx = pointX - circleCenterX;\n    double dy = pointY - circleCenterY;\n    return sqrt(dx * dx + dy * dy) <= circleRadius;\n}\n// 判断两个圆是否相交\nbool AABBCirclesIntersect(double circleCenterX1, double circleCenterY1, double circleRadius1, double circleCenterX2, double circleCenterY2, double circleRadius2) {\n    // 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和\n    double dx = circleCenterX1 - circleCenterX2;\n    double dy = circleCenterY1 - circleCenterY2;\n    return sqrt(dx * dx + dy * dy) <= circleRadius1 + circleRadius2;\n}\n// 判断点是否在圆环内\nbool AABBPointInAnnulus(double x, double y, double circleCenterX, double circleCenterY, double circleRadius, double innerThickness, double outerThickness) {\n    // 计算点到圆心的距离\n    double dx = x - circleCenterX;\n    double dy = y - circleCenterY;\n    double dist = sqrt(dx * dx + dy * dy);\n    // 判断距离是否在内圆半径和外圆半径之间\n    return (dist <= circleRadius + outerThickness && dist >= circleRadius - innerThickness);\n}\n// 判断点是否在椭圆内\nbool AABBPointInEllipse(double centerX, double centerY, double radiusA, double radiusB, double x, double y) {\n    // 计算点到椭圆中心的距离，并与椭圆的参数化方程比较\n    double dx = centerX - x;\n    double dy = centerY - y;\n    return (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) <= 1;\n}\n```\n","source":"_posts/QiNuoTu/一些包围盒类碰撞检测算法.md","raw":"---\ntitle: 一些开箱即用碰撞检测！AABB\ndate: 2024-05-28\nupdated: 2024-05-28\npermalink: articles/QiNuoTu/一些包围盒类碰撞检测算法/\ncategories: QiNuoTu\ntags: [游戏开发]\n---\n听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！\n全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！\n<!-- More -->\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n## 在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\n```cpp\n// 定义一个结构体，表示二维空间中的点\nstruct Point_F {\n    double x; // 点的x坐标\n    double y; // 点的y坐标\n};\n\n// 定义一个结构体，表示矩形区域\nstruct RECT {\n    double left;   // 矩形左边缘的x坐标\n    double top;    // 矩形上边缘的y坐标\n    double right;  // 矩形右边缘的x坐标\n    double bottom; // 矩形下边缘的y坐标\n};\n\n// 判断点是否在矩形区域内\nbool AABBPointInside(const Point_F& V, const RECT& RECT) {\n    return (V.x > RECT.left && V.x < RECT.right && V.y > RECT.top && V.y < RECT.bottom);\n}\n// 判断一个矩形是否完全在另一个矩形内部\nbool AABBRectInside(const RECT& rect1, const RECT& rect2) {\n    return (rect2.left >= rect1.left && rect2.right <= rect1.right && rect2.top >= rect1.top && rect2.bottom <= rect1.bottom);\n}\n// 判断两个矩形是否重叠\nbool AABBRectOverlap(const RECT& rect1, const RECT& rect2) {\n    return (rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom) ? false : true;\n}\n// 判断矩形与圆形是否重叠，考虑矩形旋转的情况\nbool AABBRectCircleOverlap(double rectCenterX, double rectCenterY, double rectWidth, double rectHeight, double angle, double circleX, double circleY, double circleRadius) {\n    // 计算旋转后的向量坐标\n    double vectorX = circleX - rectCenterX;\n    double vectorY = circleY - rectCenterY;\n    double radians = angle * M_PI / 180.0;\n    double x = vectorX * cos(radians) + vectorY * sin(radians);\n    double y = vectorY * cos(radians) - vectorX * sin(radians);\n    // 计算矩形的半宽和半高\n    double halfWidth = rectWidth * 0.5;\n    double halfHeight = rectHeight * 0.5;\n    if (x - circleRadius < halfWidth && x + circleRadius > -halfWidth) {\n        if (y - circleRadius < halfHeight && y + circleRadius > -halfHeight) {\n            if (x < -halfWidth && y < -halfHeight){\n                if (distance(x, y, -halfWidth, -halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x < halfWidth && y < -halfHeight){\n                if (distance(x, y, halfWidth, -halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x > halfWidth && y > halfHeight){\n                if (distance(x, y, halfWidth, halfHeight) >= circleRadius) { return true; }\n            }\n            else if (x < -halfWidth && y > halfHeight) {\n                if (distance(x, y, -halfWidth, halfHeight) >= circleRadius) { return true; }\n            }\n        }\n        return true;\n    }\n    return false;\n}\n// 判断点是否在圆内\nbool AABBPointInCircle(double pointX, double pointY, double circleCenterX, double circleCenterY, double circleRadius) {\n    // 计算点到圆心的距离，判断是否小于等于半径\n    double dx = pointX - circleCenterX;\n    double dy = pointY - circleCenterY;\n    return sqrt(dx * dx + dy * dy) <= circleRadius;\n}\n// 判断两个圆是否相交\nbool AABBCirclesIntersect(double circleCenterX1, double circleCenterY1, double circleRadius1, double circleCenterX2, double circleCenterY2, double circleRadius2) {\n    // 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和\n    double dx = circleCenterX1 - circleCenterX2;\n    double dy = circleCenterY1 - circleCenterY2;\n    return sqrt(dx * dx + dy * dy) <= circleRadius1 + circleRadius2;\n}\n// 判断点是否在圆环内\nbool AABBPointInAnnulus(double x, double y, double circleCenterX, double circleCenterY, double circleRadius, double innerThickness, double outerThickness) {\n    // 计算点到圆心的距离\n    double dx = x - circleCenterX;\n    double dy = y - circleCenterY;\n    double dist = sqrt(dx * dx + dy * dy);\n    // 判断距离是否在内圆半径和外圆半径之间\n    return (dist <= circleRadius + outerThickness && dist >= circleRadius - innerThickness);\n}\n// 判断点是否在椭圆内\nbool AABBPointInEllipse(double centerX, double centerY, double radiusA, double radiusB, double x, double y) {\n    // 计算点到椭圆中心的距离，并与椭圆的参数化方程比较\n    double dx = centerX - x;\n    double dy = centerY - y;\n    return (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) <= 1;\n}\n```\n","slug":"QiNuoTu/一些包围盒类碰撞检测算法","published":1,"__permalink":"articles/QiNuoTu/一些包围盒类碰撞检测算法/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgg000po8ye0cbe7qrr","content":"<p>听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！<br>全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！</p>\n<span id=\"more\"></span>\n<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h2 id=\"在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\"><a href=\"#在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\" class=\"headerlink\" title=\"在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\"></a>在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个结构体，表示二维空间中的点</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point_F</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> x; <span class=\"comment\">// 点的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> y; <span class=\"comment\">// 点的y坐标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个结构体，表示矩形区域</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RECT</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> left;   <span class=\"comment\">// 矩形左边缘的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> top;    <span class=\"comment\">// 矩形上边缘的y坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> right;  <span class=\"comment\">// 矩形右边缘的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> bottom; <span class=\"comment\">// 矩形下边缘的y坐标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在矩形区域内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInside</span><span class=\"params\">(<span class=\"type\">const</span> Point_F&amp; V, <span class=\"type\">const</span> RECT&amp; RECT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (V.x &gt; RECT.left &amp;&amp; V.x &lt; RECT.right &amp;&amp; V.y &gt; RECT.top &amp;&amp; V.y &lt; RECT.bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断一个矩形是否完全在另一个矩形内部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectInside</span><span class=\"params\">(<span class=\"type\">const</span> RECT&amp; rect1, <span class=\"type\">const</span> RECT&amp; rect2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rect2.left &gt;= rect1.left &amp;&amp; rect2.right &lt;= rect1.right &amp;&amp; rect2.top &gt;= rect1.top &amp;&amp; rect2.bottom &lt;= rect1.bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断两个矩形是否重叠</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectOverlap</span><span class=\"params\">(<span class=\"type\">const</span> RECT&amp; rect1, <span class=\"type\">const</span> RECT&amp; rect2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rect1.right &lt; rect2.left || rect1.left &gt; rect2.right || rect1.bottom &lt; rect2.top || rect1.top &gt; rect2.bottom) ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断矩形与圆形是否重叠，考虑矩形旋转的情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectCircleOverlap</span><span class=\"params\">(<span class=\"type\">double</span> rectCenterX, <span class=\"type\">double</span> rectCenterY, <span class=\"type\">double</span> rectWidth, <span class=\"type\">double</span> rectHeight, <span class=\"type\">double</span> angle, <span class=\"type\">double</span> circleX, <span class=\"type\">double</span> circleY, <span class=\"type\">double</span> circleRadius)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算旋转后的向量坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> vectorX = circleX - rectCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> vectorY = circleY - rectCenterY;</span><br><span class=\"line\">    <span class=\"type\">double</span> radians = angle * M_PI / <span class=\"number\">180.0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> x = vectorX * <span class=\"built_in\">cos</span>(radians) + vectorY * <span class=\"built_in\">sin</span>(radians);</span><br><span class=\"line\">    <span class=\"type\">double</span> y = vectorY * <span class=\"built_in\">cos</span>(radians) - vectorX * <span class=\"built_in\">sin</span>(radians);</span><br><span class=\"line\">    <span class=\"comment\">// 计算矩形的半宽和半高</span></span><br><span class=\"line\">    <span class=\"type\">double</span> halfWidth = rectWidth * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> halfHeight = rectHeight * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x - circleRadius &lt; halfWidth &amp;&amp; x + circleRadius &gt; -halfWidth) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y - circleRadius &lt; halfHeight &amp;&amp; y + circleRadius &gt; -halfHeight) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; -halfWidth &amp;&amp; y &lt; -halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, -halfWidth, -halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; halfWidth &amp;&amp; y &lt; -halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, halfWidth, -halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; halfWidth &amp;&amp; y &gt; halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, halfWidth, halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; -halfWidth &amp;&amp; y &gt; halfHeight) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, -halfWidth, halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在圆内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInCircle</span><span class=\"params\">(<span class=\"type\">double</span> pointX, <span class=\"type\">double</span> pointY, <span class=\"type\">double</span> circleCenterX, <span class=\"type\">double</span> circleCenterY, <span class=\"type\">double</span> circleRadius)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到圆心的距离，判断是否小于等于半径</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = pointX - circleCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = pointY - circleCenterY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy) &lt;= circleRadius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断两个圆是否相交</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBCirclesIntersect</span><span class=\"params\">(<span class=\"type\">double</span> circleCenterX1, <span class=\"type\">double</span> circleCenterY1, <span class=\"type\">double</span> circleRadius1, <span class=\"type\">double</span> circleCenterX2, <span class=\"type\">double</span> circleCenterY2, <span class=\"type\">double</span> circleRadius2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = circleCenterX1 - circleCenterX2;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = circleCenterY1 - circleCenterY2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy) &lt;= circleRadius1 + circleRadius2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在圆环内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInAnnulus</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y, <span class=\"type\">double</span> circleCenterX, <span class=\"type\">double</span> circleCenterY, <span class=\"type\">double</span> circleRadius, <span class=\"type\">double</span> innerThickness, <span class=\"type\">double</span> outerThickness)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到圆心的距离</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = x - circleCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = y - circleCenterY;</span><br><span class=\"line\">    <span class=\"type\">double</span> dist = <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy);</span><br><span class=\"line\">    <span class=\"comment\">// 判断距离是否在内圆半径和外圆半径之间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dist &lt;= circleRadius + outerThickness &amp;&amp; dist &gt;= circleRadius - innerThickness);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在椭圆内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInEllipse</span><span class=\"params\">(<span class=\"type\">double</span> centerX, <span class=\"type\">double</span> centerY, <span class=\"type\">double</span> radiusA, <span class=\"type\">double</span> radiusB, <span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到椭圆中心的距离，并与椭圆的参数化方程比较</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = centerX - x;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = centerY - y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) &lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>听说有群友已经不满足于，大V老师提供的简单检测方法了，那么让我们为自己的游戏增加更多有趣的碰撞检测罢！<br>全文采用AABB实现，包含矩矩，圆圆，矩圆，角度矩圆，椭圆，点矩，点环，点圆，点椭，等，必要情况下只要根据下文中的算法自行修改或嵌套使用即可！</p>","more":"<div align=\"center\">\n    <p align=\"center\">\n        <img src=\"/articles/QiNuoTu/icon.png\" alt=\"logo\" width=\"200\">\n    </p>\n    <h1>琪诺兔</h1>\n    <p>\n        <a href=\"https://space.bilibili.com/69720374\" target=\"_blank\">关注我的哔哩哔哩走进我的生活</a>\n        &nbsp;|&nbsp;\n        <a href=\"https://github.com/QiNuoTu\" target=\"_blank\">关注我的GitHub获得我的代码</a>\n    </p>\n</div>\n\n<h2 id=\"在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\"><a href=\"#在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\" class=\"headerlink\" title=\"在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。\"></a>在下文中，大家可能会发现，为什么没有旋转过的两个矩形的碰撞，那不是AABB了，未来在说。</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个结构体，表示二维空间中的点</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point_F</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> x; <span class=\"comment\">// 点的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> y; <span class=\"comment\">// 点的y坐标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个结构体，表示矩形区域</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RECT</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> left;   <span class=\"comment\">// 矩形左边缘的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> top;    <span class=\"comment\">// 矩形上边缘的y坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> right;  <span class=\"comment\">// 矩形右边缘的x坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> bottom; <span class=\"comment\">// 矩形下边缘的y坐标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在矩形区域内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInside</span><span class=\"params\">(<span class=\"type\">const</span> Point_F&amp; V, <span class=\"type\">const</span> RECT&amp; RECT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (V.x &gt; RECT.left &amp;&amp; V.x &lt; RECT.right &amp;&amp; V.y &gt; RECT.top &amp;&amp; V.y &lt; RECT.bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断一个矩形是否完全在另一个矩形内部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectInside</span><span class=\"params\">(<span class=\"type\">const</span> RECT&amp; rect1, <span class=\"type\">const</span> RECT&amp; rect2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rect2.left &gt;= rect1.left &amp;&amp; rect2.right &lt;= rect1.right &amp;&amp; rect2.top &gt;= rect1.top &amp;&amp; rect2.bottom &lt;= rect1.bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断两个矩形是否重叠</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectOverlap</span><span class=\"params\">(<span class=\"type\">const</span> RECT&amp; rect1, <span class=\"type\">const</span> RECT&amp; rect2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rect1.right &lt; rect2.left || rect1.left &gt; rect2.right || rect1.bottom &lt; rect2.top || rect1.top &gt; rect2.bottom) ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断矩形与圆形是否重叠，考虑矩形旋转的情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBRectCircleOverlap</span><span class=\"params\">(<span class=\"type\">double</span> rectCenterX, <span class=\"type\">double</span> rectCenterY, <span class=\"type\">double</span> rectWidth, <span class=\"type\">double</span> rectHeight, <span class=\"type\">double</span> angle, <span class=\"type\">double</span> circleX, <span class=\"type\">double</span> circleY, <span class=\"type\">double</span> circleRadius)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算旋转后的向量坐标</span></span><br><span class=\"line\">    <span class=\"type\">double</span> vectorX = circleX - rectCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> vectorY = circleY - rectCenterY;</span><br><span class=\"line\">    <span class=\"type\">double</span> radians = angle * M_PI / <span class=\"number\">180.0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> x = vectorX * <span class=\"built_in\">cos</span>(radians) + vectorY * <span class=\"built_in\">sin</span>(radians);</span><br><span class=\"line\">    <span class=\"type\">double</span> y = vectorY * <span class=\"built_in\">cos</span>(radians) - vectorX * <span class=\"built_in\">sin</span>(radians);</span><br><span class=\"line\">    <span class=\"comment\">// 计算矩形的半宽和半高</span></span><br><span class=\"line\">    <span class=\"type\">double</span> halfWidth = rectWidth * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> halfHeight = rectHeight * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x - circleRadius &lt; halfWidth &amp;&amp; x + circleRadius &gt; -halfWidth) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y - circleRadius &lt; halfHeight &amp;&amp; y + circleRadius &gt; -halfHeight) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; -halfWidth &amp;&amp; y &lt; -halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, -halfWidth, -halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; halfWidth &amp;&amp; y &lt; -halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, halfWidth, -halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; halfWidth &amp;&amp; y &gt; halfHeight)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, halfWidth, halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; -halfWidth &amp;&amp; y &gt; halfHeight) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">distance</span>(x, y, -halfWidth, halfHeight) &gt;= circleRadius) &#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在圆内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInCircle</span><span class=\"params\">(<span class=\"type\">double</span> pointX, <span class=\"type\">double</span> pointY, <span class=\"type\">double</span> circleCenterX, <span class=\"type\">double</span> circleCenterY, <span class=\"type\">double</span> circleRadius)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到圆心的距离，判断是否小于等于半径</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = pointX - circleCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = pointY - circleCenterY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy) &lt;= circleRadius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断两个圆是否相交</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBCirclesIntersect</span><span class=\"params\">(<span class=\"type\">double</span> circleCenterX1, <span class=\"type\">double</span> circleCenterY1, <span class=\"type\">double</span> circleRadius1, <span class=\"type\">double</span> circleCenterX2, <span class=\"type\">double</span> circleCenterY2, <span class=\"type\">double</span> circleRadius2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算两个圆心之间的距离，判断是否小于等于两个圆的半径之和</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = circleCenterX1 - circleCenterX2;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = circleCenterY1 - circleCenterY2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy) &lt;= circleRadius1 + circleRadius2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在圆环内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInAnnulus</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y, <span class=\"type\">double</span> circleCenterX, <span class=\"type\">double</span> circleCenterY, <span class=\"type\">double</span> circleRadius, <span class=\"type\">double</span> innerThickness, <span class=\"type\">double</span> outerThickness)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到圆心的距离</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = x - circleCenterX;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = y - circleCenterY;</span><br><span class=\"line\">    <span class=\"type\">double</span> dist = <span class=\"built_in\">sqrt</span>(dx * dx + dy * dy);</span><br><span class=\"line\">    <span class=\"comment\">// 判断距离是否在内圆半径和外圆半径之间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dist &lt;= circleRadius + outerThickness &amp;&amp; dist &gt;= circleRadius - innerThickness);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断点是否在椭圆内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">AABBPointInEllipse</span><span class=\"params\">(<span class=\"type\">double</span> centerX, <span class=\"type\">double</span> centerY, <span class=\"type\">double</span> radiusA, <span class=\"type\">double</span> radiusB, <span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算点到椭圆中心的距离，并与椭圆的参数化方程比较</span></span><br><span class=\"line\">    <span class=\"type\">double</span> dx = centerX - x;</span><br><span class=\"line\">    <span class=\"type\">double</span> dy = centerY - y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (dx * dx / (radiusA * radiusA) + dy * dy / (radiusB * radiusB)) &lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Boids集群算法浅析与实践","date":"2024-05-31T16:00:00.000Z","updated":"2024-05-31T16:00:00.000Z","_content":"\n> 鸟群算法 Boids是模拟鸟类群集行为的人工生命项目，由克雷格·雷诺兹（Craig Reynolds）于1986年开发。Boids 是涌现行为的典例，其复杂性来自于遵循一系列简单规则个体的相互作用。\n\nBoids 通常用于计算机图形学，提供鸟群和其他生物（如鱼群）的逼真表现：\n\n+ 《史丹利和史黛拉: 破冰》是第一部利用了 Boids 模型的动画片；\n+ 《半条命》中，游戏结束时出现的类似鸟类的飞行生物就使用了该模型；\n+ 《蝙蝠侠归来》电影中，蝙蝠群和成群的企鹅行进穿过哥谭市的街道时使用了该模型；\n+ 《黑客帝国》/《重装前哨》中，章鱼外形的哨兵机器人的集群特效使用了该模型。\n\n<div style=\"text-align:center\">\n\n![分离（左） - 聚集（中） - 对齐（右）](articles/Voidmatrix/boids-algorithm/231573721246935.png)\n\n</div>\n\n<!-- more -->\n\nBoids 模型由三种规则描述：\n\n1. **分离**：个体之间存在排斥趋向，自主移动避开群体拥挤处；\n3. **聚集**：个体会朝向周围同伴所处的平均位置处移动；\n2. **对齐**：个体会朝向周围同伴的平均移动方向运动。\n\n\n> 下面将使用 EasyX 可视化该算法。\n\n## 随机个体位置着色\n\n```cpp\nstd::vector<Boid> boids(500);\nfor (Boid& b : boids)\n{\n    b.position.x = (float)(rand() % 1280);\n    b.position.y = (float)(rand() % 720);\n    b.color = RGB(rand() % 255, rand() % 255, rand() % 255);\n}\n```\n\n<div style=\"text-align:center\">\n\n![随机个体位置着色](articles/Voidmatrix/boids-algorithm/403754021267101.png)\n\n</div>\n\n## 添加“聚集”规则\n\n```cpp\nVector2D cohesion(const std::vector<Boid>& boids) \n{\n    Vector2D center_of_mass(0, 0);\n    int total_neighbors = 0;\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < neighbour_distance)\n        {\n            center_of_mass = center_of_mass + b.position;\n            total_neighbors++;\n        }\n    }\n\n    if (total_neighbors > 0) \n    {\n        center_of_mass = center_of_mass * (1.0f / total_neighbors);\n        return (center_of_mass - position);\n    }\n\n    return Vector2D(0, 0);\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则](articles/Voidmatrix/boids-algorithm/338824221259770.gif)\n\n</div>\n\n## 添加“分离”规则\n\n```cpp\nVector2D separation(const std::vector<Boid>& boids) \n{\n    Vector2D separation(0, 0);\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < separation_distance) \n        {\n            Vector2D diff = position - b.position;\n            separation = separation + diff * (1.0f / distance);\n        }\n    }\n\n    return separation;\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则 + 分离规则](articles/Voidmatrix/boids-algorithm/294884321256325.gif)\n\n</div>\n\n## 添加“对齐”规则\n\n```cpp\nVector2D alignment(const std::vector<Boid>& boids) \n{\n    Vector2D avg_velocity(0, 0);\n    int total_neighbors = 0;\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < neighbour_distance) \n        {\n            avg_velocity = avg_velocity + b.velocity;\n            total_neighbors++;\n        }\n    }\n\n    if (total_neighbors > 0) \n    {\n        avg_velocity = avg_velocity * (1.0f / total_neighbors);\n        return avg_velocity - velocity;\n    }\n\n    return Vector2D(0, 0);\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则 + 分离规则 + 对齐规则](articles/Voidmatrix/boids-algorithm/101894421252079.gif)\n\n</div>\n\n## 完整代码\n\n```cpp\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <graphics.h>\n\n// 简单的二维向量\nstruct Vector2D \n{\n    float x, y;\n\n    Vector2D() = default;\n    Vector2D(float _x, float _y) : x(_x), y(_y) {}\n\n    Vector2D operator+(const Vector2D& other) const \n    {\n        return Vector2D(x + other.x, y + other.y);\n    }\n\n    Vector2D operator-(const Vector2D& other) const \n    {\n        return Vector2D(x - other.x, y - other.y);\n    }\n\n    Vector2D operator*(float scalar) const \n    {\n        return Vector2D(x * scalar, y * scalar);\n    }\n\n    float length() const \n    {\n        return std::sqrt(x * x + y * y);\n    }\n\n    void normalize() \n    {\n        float len = length();\n        x /= len;\n        y /= len;\n    }\n};\n\n// 集群单位\nstruct Boid \n{\n    COLORREF color;\n    Vector2D position;\n    Vector2D velocity;\n\n    // 聚集规则\n    Vector2D cohesion(const std::vector<Boid>& boids) \n    {\n        Vector2D center_of_mass(0, 0);\n        int total_neighbors = 0;\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < neighbour_distance)\n            {\n                center_of_mass = center_of_mass + b.position;\n                total_neighbors++;\n            }\n        }\n\n        if (total_neighbors > 0) \n        {\n            center_of_mass = center_of_mass * (1.0f / total_neighbors);\n            return (center_of_mass - position);\n        }\n\n        return Vector2D(0, 0);\n    }\n\n    // 分离规则\n    Vector2D separation(const std::vector<Boid>& boids) \n    {\n        Vector2D separation(0, 0);\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < separation_distance) \n            {\n                Vector2D diff = position - b.position;\n                separation = separation + diff * (1.0f / distance);\n            }\n        }\n\n        return separation;\n    }\n\n    // 对齐规则\n    Vector2D alignment(const std::vector<Boid>& boids) \n    {\n        Vector2D avg_velocity(0, 0);\n        int total_neighbors = 0;\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < neighbour_distance) \n            {\n                avg_velocity = avg_velocity + b.velocity;\n                total_neighbors++;\n            }\n        }\n\n        if (total_neighbors > 0) \n        {\n            avg_velocity = avg_velocity * (1.0f / total_neighbors);\n            return avg_velocity - velocity;\n        }\n\n        return Vector2D(0, 0);\n    }\n\n    // 更新方法\n    void update(const std::vector<Boid>& boids) \n    {\n        Vector2D v1 = cohesion(boids);\n        Vector2D v2 = separation(boids);\n        Vector2D v3 = alignment(boids);\n\n        // 根据规则权重调节最终行为\n        v1 = v1 * cohesion_weight;\n        v2 = v2 * separation_weight;\n        v3 = v3 * align_weight;\n\n        // 更新速度\n        velocity = velocity + v1 + v2 + v3;\n\n        // 限制速度\n        float speed = velocity.length();\n        if (speed > max_speed) velocity = velocity * (max_speed / speed);\n\n        // 更新位置\n        position = position + velocity;\n\n        // 限制位置\n        if (position.x < 0) position.x = 0;\n        if (position.x > 1280) position.x = 1280;\n        if (position.y < 0) position.y = 0;\n        if (position.y > 720) position.y = 720;\n    }\n\n    float neighbour_distance = 100.0f;      // 判定为临近单位的距离\n    float separation_distance = 50.0f;      // 临近单位的分离距离\n    float cohesion_weight = 1.0f;           // \"聚集\" 规则强度\n    float separation_weight = 1.0f;         // \"分离\" 规则强度 \n    float align_weight = 1.0f;              // \"对齐\" 规则强度\n    float max_speed = 5.0f;                 // 集群最大速度\n};\n\nint main() \n{\n    initgraph(1280, 720, EW_SHOWCONSOLE);\n    BeginBatchDraw();\n\n    // 初始化集群\n    std::vector<Boid> boids(500);\n    for (Boid& b : boids)\n    {\n        b.position.x = (float)(rand() % 1280);\n        b.position.y = (float)(rand() % 720);\n        b.color = RGB(rand() % 255, rand() % 255, rand() % 255);\n    }\n\n    // 循环模拟\n    while (true) \n    {\n        // 更新集群\n        for (Boid& b : boids)\n            b.update(boids);\n\n        // 渲染集群\n        cleardevice();\n        for (Boid& b : boids)\n        {\n            setfillcolor(b.color);\n            fillcircle((int)b.position.x, (int)b.position.y, 10);\n        }\n        FlushBatchDraw();\n\n        Sleep(25);\n    }\n\n    return 0;\n}\n```\n\n> 使用三角形等有指向性的元素，根据当前速度向量绘图模拟效果会更加清晰。\n\n<div style=\"text-align:center\">\n\n\\>\\>\\>  [在 Voidmatrix's Blog 上查看本文章](https://www.voidmatrix.work/articles/boids-algorithm/)  <<<\n\n</div>","source":"_posts/Voidmatrix/Boids集群算法浅析与实践.md","raw":"---\ntitle: Boids集群算法浅析与实践\ndate: 2024-06-01\nupdated: 2024-06-01\npermalink: articles/Voidmatrix/boids-algorithm/\ncategories: Voidmatrix\ntags: [EasyX, 算法, C++]\n---\n\n> 鸟群算法 Boids是模拟鸟类群集行为的人工生命项目，由克雷格·雷诺兹（Craig Reynolds）于1986年开发。Boids 是涌现行为的典例，其复杂性来自于遵循一系列简单规则个体的相互作用。\n\nBoids 通常用于计算机图形学，提供鸟群和其他生物（如鱼群）的逼真表现：\n\n+ 《史丹利和史黛拉: 破冰》是第一部利用了 Boids 模型的动画片；\n+ 《半条命》中，游戏结束时出现的类似鸟类的飞行生物就使用了该模型；\n+ 《蝙蝠侠归来》电影中，蝙蝠群和成群的企鹅行进穿过哥谭市的街道时使用了该模型；\n+ 《黑客帝国》/《重装前哨》中，章鱼外形的哨兵机器人的集群特效使用了该模型。\n\n<div style=\"text-align:center\">\n\n![分离（左） - 聚集（中） - 对齐（右）](articles/Voidmatrix/boids-algorithm/231573721246935.png)\n\n</div>\n\n<!-- more -->\n\nBoids 模型由三种规则描述：\n\n1. **分离**：个体之间存在排斥趋向，自主移动避开群体拥挤处；\n3. **聚集**：个体会朝向周围同伴所处的平均位置处移动；\n2. **对齐**：个体会朝向周围同伴的平均移动方向运动。\n\n\n> 下面将使用 EasyX 可视化该算法。\n\n## 随机个体位置着色\n\n```cpp\nstd::vector<Boid> boids(500);\nfor (Boid& b : boids)\n{\n    b.position.x = (float)(rand() % 1280);\n    b.position.y = (float)(rand() % 720);\n    b.color = RGB(rand() % 255, rand() % 255, rand() % 255);\n}\n```\n\n<div style=\"text-align:center\">\n\n![随机个体位置着色](articles/Voidmatrix/boids-algorithm/403754021267101.png)\n\n</div>\n\n## 添加“聚集”规则\n\n```cpp\nVector2D cohesion(const std::vector<Boid>& boids) \n{\n    Vector2D center_of_mass(0, 0);\n    int total_neighbors = 0;\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < neighbour_distance)\n        {\n            center_of_mass = center_of_mass + b.position;\n            total_neighbors++;\n        }\n    }\n\n    if (total_neighbors > 0) \n    {\n        center_of_mass = center_of_mass * (1.0f / total_neighbors);\n        return (center_of_mass - position);\n    }\n\n    return Vector2D(0, 0);\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则](articles/Voidmatrix/boids-algorithm/338824221259770.gif)\n\n</div>\n\n## 添加“分离”规则\n\n```cpp\nVector2D separation(const std::vector<Boid>& boids) \n{\n    Vector2D separation(0, 0);\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < separation_distance) \n        {\n            Vector2D diff = position - b.position;\n            separation = separation + diff * (1.0f / distance);\n        }\n    }\n\n    return separation;\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则 + 分离规则](articles/Voidmatrix/boids-algorithm/294884321256325.gif)\n\n</div>\n\n## 添加“对齐”规则\n\n```cpp\nVector2D alignment(const std::vector<Boid>& boids) \n{\n    Vector2D avg_velocity(0, 0);\n    int total_neighbors = 0;\n\n    for (const Boid& b : boids)\n    {\n        float distance = (b.position - position).length();\n\n        if (distance > 0 && distance < neighbour_distance) \n        {\n            avg_velocity = avg_velocity + b.velocity;\n            total_neighbors++;\n        }\n    }\n\n    if (total_neighbors > 0) \n    {\n        avg_velocity = avg_velocity * (1.0f / total_neighbors);\n        return avg_velocity - velocity;\n    }\n\n    return Vector2D(0, 0);\n}\n```\n\n<div style=\"text-align:center\">\n\n![聚集规则 + 分离规则 + 对齐规则](articles/Voidmatrix/boids-algorithm/101894421252079.gif)\n\n</div>\n\n## 完整代码\n\n```cpp\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <graphics.h>\n\n// 简单的二维向量\nstruct Vector2D \n{\n    float x, y;\n\n    Vector2D() = default;\n    Vector2D(float _x, float _y) : x(_x), y(_y) {}\n\n    Vector2D operator+(const Vector2D& other) const \n    {\n        return Vector2D(x + other.x, y + other.y);\n    }\n\n    Vector2D operator-(const Vector2D& other) const \n    {\n        return Vector2D(x - other.x, y - other.y);\n    }\n\n    Vector2D operator*(float scalar) const \n    {\n        return Vector2D(x * scalar, y * scalar);\n    }\n\n    float length() const \n    {\n        return std::sqrt(x * x + y * y);\n    }\n\n    void normalize() \n    {\n        float len = length();\n        x /= len;\n        y /= len;\n    }\n};\n\n// 集群单位\nstruct Boid \n{\n    COLORREF color;\n    Vector2D position;\n    Vector2D velocity;\n\n    // 聚集规则\n    Vector2D cohesion(const std::vector<Boid>& boids) \n    {\n        Vector2D center_of_mass(0, 0);\n        int total_neighbors = 0;\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < neighbour_distance)\n            {\n                center_of_mass = center_of_mass + b.position;\n                total_neighbors++;\n            }\n        }\n\n        if (total_neighbors > 0) \n        {\n            center_of_mass = center_of_mass * (1.0f / total_neighbors);\n            return (center_of_mass - position);\n        }\n\n        return Vector2D(0, 0);\n    }\n\n    // 分离规则\n    Vector2D separation(const std::vector<Boid>& boids) \n    {\n        Vector2D separation(0, 0);\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < separation_distance) \n            {\n                Vector2D diff = position - b.position;\n                separation = separation + diff * (1.0f / distance);\n            }\n        }\n\n        return separation;\n    }\n\n    // 对齐规则\n    Vector2D alignment(const std::vector<Boid>& boids) \n    {\n        Vector2D avg_velocity(0, 0);\n        int total_neighbors = 0;\n\n        for (const Boid& b : boids)\n        {\n            float distance = (b.position - position).length();\n\n            if (distance > 0 && distance < neighbour_distance) \n            {\n                avg_velocity = avg_velocity + b.velocity;\n                total_neighbors++;\n            }\n        }\n\n        if (total_neighbors > 0) \n        {\n            avg_velocity = avg_velocity * (1.0f / total_neighbors);\n            return avg_velocity - velocity;\n        }\n\n        return Vector2D(0, 0);\n    }\n\n    // 更新方法\n    void update(const std::vector<Boid>& boids) \n    {\n        Vector2D v1 = cohesion(boids);\n        Vector2D v2 = separation(boids);\n        Vector2D v3 = alignment(boids);\n\n        // 根据规则权重调节最终行为\n        v1 = v1 * cohesion_weight;\n        v2 = v2 * separation_weight;\n        v3 = v3 * align_weight;\n\n        // 更新速度\n        velocity = velocity + v1 + v2 + v3;\n\n        // 限制速度\n        float speed = velocity.length();\n        if (speed > max_speed) velocity = velocity * (max_speed / speed);\n\n        // 更新位置\n        position = position + velocity;\n\n        // 限制位置\n        if (position.x < 0) position.x = 0;\n        if (position.x > 1280) position.x = 1280;\n        if (position.y < 0) position.y = 0;\n        if (position.y > 720) position.y = 720;\n    }\n\n    float neighbour_distance = 100.0f;      // 判定为临近单位的距离\n    float separation_distance = 50.0f;      // 临近单位的分离距离\n    float cohesion_weight = 1.0f;           // \"聚集\" 规则强度\n    float separation_weight = 1.0f;         // \"分离\" 规则强度 \n    float align_weight = 1.0f;              // \"对齐\" 规则强度\n    float max_speed = 5.0f;                 // 集群最大速度\n};\n\nint main() \n{\n    initgraph(1280, 720, EW_SHOWCONSOLE);\n    BeginBatchDraw();\n\n    // 初始化集群\n    std::vector<Boid> boids(500);\n    for (Boid& b : boids)\n    {\n        b.position.x = (float)(rand() % 1280);\n        b.position.y = (float)(rand() % 720);\n        b.color = RGB(rand() % 255, rand() % 255, rand() % 255);\n    }\n\n    // 循环模拟\n    while (true) \n    {\n        // 更新集群\n        for (Boid& b : boids)\n            b.update(boids);\n\n        // 渲染集群\n        cleardevice();\n        for (Boid& b : boids)\n        {\n            setfillcolor(b.color);\n            fillcircle((int)b.position.x, (int)b.position.y, 10);\n        }\n        FlushBatchDraw();\n\n        Sleep(25);\n    }\n\n    return 0;\n}\n```\n\n> 使用三角形等有指向性的元素，根据当前速度向量绘图模拟效果会更加清晰。\n\n<div style=\"text-align:center\">\n\n\\>\\>\\>  [在 Voidmatrix's Blog 上查看本文章](https://www.voidmatrix.work/articles/boids-algorithm/)  <<<\n\n</div>","slug":"Voidmatrix/Boids集群算法浅析与实践","published":1,"__permalink":"articles/Voidmatrix/boids-algorithm/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgh000ro8ye7fyj2j4x","content":"<blockquote>\n<p>鸟群算法 Boids是模拟鸟类群集行为的人工生命项目，由克雷格·雷诺兹（Craig Reynolds）于1986年开发。Boids 是涌现行为的典例，其复杂性来自于遵循一系列简单规则个体的相互作用。</p>\n</blockquote>\n<p>Boids 通常用于计算机图形学，提供鸟群和其他生物（如鱼群）的逼真表现：</p>\n<ul>\n<li>《史丹利和史黛拉: 破冰》是第一部利用了 Boids 模型的动画片；</li>\n<li>《半条命》中，游戏结束时出现的类似鸟类的飞行生物就使用了该模型；</li>\n<li>《蝙蝠侠归来》电影中，蝙蝠群和成群的企鹅行进穿过哥谭市的街道时使用了该模型；</li>\n<li>《黑客帝国》&#x2F;《重装前哨》中，章鱼外形的哨兵机器人的集群特效使用了该模型。</li>\n</ul>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/231573721246935.png\" alt=\"分离（左） - 聚集（中） - 对齐（右）\"></p>\n</div>\n\n<span id=\"more\"></span>\n\n<p>Boids 模型由三种规则描述：</p>\n<ol>\n<li><strong>分离</strong>：个体之间存在排斥趋向，自主移动避开群体拥挤处；</li>\n<li><strong>聚集</strong>：个体会朝向周围同伴所处的平均位置处移动；</li>\n<li><strong>对齐</strong>：个体会朝向周围同伴的平均移动方向运动。</li>\n</ol>\n<blockquote>\n<p>下面将使用 EasyX 可视化该算法。</p>\n</blockquote>\n<h2 id=\"随机个体位置着色\"><a href=\"#随机个体位置着色\" class=\"headerlink\" title=\"随机个体位置着色\"></a>随机个体位置着色</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::vector&lt;Boid&gt; <span class=\"title\">boids</span><span class=\"params\">(<span class=\"number\">500</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    b.position.x = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">1280</span>);</span><br><span class=\"line\">    b.position.y = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">720</span>);</span><br><span class=\"line\">    b.color = <span class=\"built_in\">RGB</span>(<span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/403754021267101.png\" alt=\"随机个体位置着色\"></p>\n</div>\n\n<h2 id=\"添加“聚集”规则\"><a href=\"#添加“聚集”规则\" class=\"headerlink\" title=\"添加“聚集”规则\"></a>添加“聚集”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">cohesion</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">center_of_mass</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            center_of_mass = center_of_mass + b.position;</span><br><span class=\"line\">            total_neighbors++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        center_of_mass = center_of_mass * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (center_of_mass - position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/338824221259770.gif\" alt=\"聚集规则\"></p>\n</div>\n\n<h2 id=\"添加“分离”规则\"><a href=\"#添加“分离”规则\" class=\"headerlink\" title=\"添加“分离”规则\"></a>添加“分离”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; separation_distance) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Vector2D diff = position - b.position;</span><br><span class=\"line\">            separation = separation + diff * (<span class=\"number\">1.0f</span> / distance);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> separation;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/294884321256325.gif\" alt=\"聚集规则 + 分离规则\"></p>\n</div>\n\n<h2 id=\"添加“对齐”规则\"><a href=\"#添加“对齐”规则\" class=\"headerlink\" title=\"添加“对齐”规则\"></a>添加“对齐”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">alignment</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">avg_velocity</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            avg_velocity = avg_velocity + b.velocity;</span><br><span class=\"line\">            total_neighbors++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        avg_velocity = avg_velocity * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_velocity - velocity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/101894421252079.gif\" alt=\"聚集规则 + 分离规则 + 对齐规则\"></p>\n</div>\n\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的二维向量</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Vector2D</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Vector2D</span>(<span class=\"type\">float</span> _x, <span class=\"type\">float</span> _y) : <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Vector2D&amp; other) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>-(<span class=\"type\">const</span> Vector2D&amp; other) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x - other.x, y - other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>*(<span class=\"type\">float</span> scalar) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x * scalar, y * scalar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">sqrt</span>(x * x + y * y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">normalize</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> len = <span class=\"built_in\">length</span>();</span><br><span class=\"line\">        x /= len;</span><br><span class=\"line\">        y /= len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 集群单位</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Boid</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    COLORREF color;</span><br><span class=\"line\">    Vector2D position;</span><br><span class=\"line\">    Vector2D velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 聚集规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">cohesion</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">center_of_mass</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                center_of_mass = center_of_mass + b.position;</span><br><span class=\"line\">                total_neighbors++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            center_of_mass = center_of_mass * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (center_of_mass - position);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分离规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; separation_distance) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Vector2D diff = position - b.position;</span><br><span class=\"line\">                separation = separation + diff * (<span class=\"number\">1.0f</span> / distance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> separation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对齐规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">alignment</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">avg_velocity</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                avg_velocity = avg_velocity + b.velocity;</span><br><span class=\"line\">                total_neighbors++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            avg_velocity = avg_velocity * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> avg_velocity - velocity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Vector2D v1 = <span class=\"built_in\">cohesion</span>(boids);</span><br><span class=\"line\">        Vector2D v2 = <span class=\"built_in\">separation</span>(boids);</span><br><span class=\"line\">        Vector2D v3 = <span class=\"built_in\">alignment</span>(boids);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据规则权重调节最终行为</span></span><br><span class=\"line\">        v1 = v1 * cohesion_weight;</span><br><span class=\"line\">        v2 = v2 * separation_weight;</span><br><span class=\"line\">        v3 = v3 * align_weight;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新速度</span></span><br><span class=\"line\">        velocity = velocity + v1 + v2 + v3;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 限制速度</span></span><br><span class=\"line\">        <span class=\"type\">float</span> speed = velocity.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (speed &gt; max_speed) velocity = velocity * (max_speed / speed);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新位置</span></span><br><span class=\"line\">        position = position + velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 限制位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.x &lt; <span class=\"number\">0</span>) position.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.x &gt; <span class=\"number\">1280</span>) position.x = <span class=\"number\">1280</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.y &lt; <span class=\"number\">0</span>) position.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.y &gt; <span class=\"number\">720</span>) position.y = <span class=\"number\">720</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> neighbour_distance = <span class=\"number\">100.0f</span>;      <span class=\"comment\">// 判定为临近单位的距离</span></span><br><span class=\"line\">    <span class=\"type\">float</span> separation_distance = <span class=\"number\">50.0f</span>;      <span class=\"comment\">// 临近单位的分离距离</span></span><br><span class=\"line\">    <span class=\"type\">float</span> cohesion_weight = <span class=\"number\">1.0f</span>;           <span class=\"comment\">// &quot;聚集&quot; 规则强度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> separation_weight = <span class=\"number\">1.0f</span>;         <span class=\"comment\">// &quot;分离&quot; 规则强度 </span></span><br><span class=\"line\">    <span class=\"type\">float</span> align_weight = <span class=\"number\">1.0f</span>;              <span class=\"comment\">// &quot;对齐&quot; 规则强度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> max_speed = <span class=\"number\">5.0f</span>;                 <span class=\"comment\">// 集群最大速度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(<span class=\"number\">1280</span>, <span class=\"number\">720</span>, EW_SHOWCONSOLE);</span><br><span class=\"line\">    <span class=\"built_in\">BeginBatchDraw</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化集群</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Boid&gt; <span class=\"title\">boids</span><span class=\"params\">(<span class=\"number\">500</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b.position.x = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">1280</span>);</span><br><span class=\"line\">        b.position.y = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">720</span>);</span><br><span class=\"line\">        b.color = <span class=\"built_in\">RGB</span>(<span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 循环模拟</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新集群</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">            b.<span class=\"built_in\">update</span>(boids);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 渲染集群</span></span><br><span class=\"line\">        <span class=\"built_in\">cleardevice</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">setfillcolor</span>(b.color);</span><br><span class=\"line\">            <span class=\"built_in\">fillcircle</span>((<span class=\"type\">int</span>)b.position.x, (<span class=\"type\">int</span>)b.position.y, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FlushBatchDraw</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Sleep</span>(<span class=\"number\">25</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用三角形等有指向性的元素，根据当前速度向量绘图模拟效果会更加清晰。</p>\n</blockquote>\n<div style=\"text-align:center\">\n\n<p>&gt;&gt;&gt;  <a href=\"https://www.voidmatrix.work/articles/boids-algorithm/\">在 Voidmatrix’s Blog 上查看本文章</a>  &lt;&lt;&lt;</p>\n</div>","site":{"data":{}},"excerpt":"<blockquote>\n<p>鸟群算法 Boids是模拟鸟类群集行为的人工生命项目，由克雷格·雷诺兹（Craig Reynolds）于1986年开发。Boids 是涌现行为的典例，其复杂性来自于遵循一系列简单规则个体的相互作用。</p>\n</blockquote>\n<p>Boids 通常用于计算机图形学，提供鸟群和其他生物（如鱼群）的逼真表现：</p>\n<ul>\n<li>《史丹利和史黛拉: 破冰》是第一部利用了 Boids 模型的动画片；</li>\n<li>《半条命》中，游戏结束时出现的类似鸟类的飞行生物就使用了该模型；</li>\n<li>《蝙蝠侠归来》电影中，蝙蝠群和成群的企鹅行进穿过哥谭市的街道时使用了该模型；</li>\n<li>《黑客帝国》&#x2F;《重装前哨》中，章鱼外形的哨兵机器人的集群特效使用了该模型。</li>\n</ul>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/231573721246935.png\" alt=\"分离（左） - 聚集（中） - 对齐（右）\"></p>\n</div>","more":"<p>Boids 模型由三种规则描述：</p>\n<ol>\n<li><strong>分离</strong>：个体之间存在排斥趋向，自主移动避开群体拥挤处；</li>\n<li><strong>聚集</strong>：个体会朝向周围同伴所处的平均位置处移动；</li>\n<li><strong>对齐</strong>：个体会朝向周围同伴的平均移动方向运动。</li>\n</ol>\n<blockquote>\n<p>下面将使用 EasyX 可视化该算法。</p>\n</blockquote>\n<h2 id=\"随机个体位置着色\"><a href=\"#随机个体位置着色\" class=\"headerlink\" title=\"随机个体位置着色\"></a>随机个体位置着色</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::vector&lt;Boid&gt; <span class=\"title\">boids</span><span class=\"params\">(<span class=\"number\">500</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    b.position.x = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">1280</span>);</span><br><span class=\"line\">    b.position.y = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">720</span>);</span><br><span class=\"line\">    b.color = <span class=\"built_in\">RGB</span>(<span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/403754021267101.png\" alt=\"随机个体位置着色\"></p>\n</div>\n\n<h2 id=\"添加“聚集”规则\"><a href=\"#添加“聚集”规则\" class=\"headerlink\" title=\"添加“聚集”规则\"></a>添加“聚集”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">cohesion</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">center_of_mass</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            center_of_mass = center_of_mass + b.position;</span><br><span class=\"line\">            total_neighbors++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        center_of_mass = center_of_mass * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (center_of_mass - position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/338824221259770.gif\" alt=\"聚集规则\"></p>\n</div>\n\n<h2 id=\"添加“分离”规则\"><a href=\"#添加“分离”规则\" class=\"headerlink\" title=\"添加“分离”规则\"></a>添加“分离”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; separation_distance) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Vector2D diff = position - b.position;</span><br><span class=\"line\">            separation = separation + diff * (<span class=\"number\">1.0f</span> / distance);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> separation;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/294884321256325.gif\" alt=\"聚集规则 + 分离规则\"></p>\n</div>\n\n<h2 id=\"添加“对齐”规则\"><a href=\"#添加“对齐”规则\" class=\"headerlink\" title=\"添加“对齐”规则\"></a>添加“对齐”规则</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector2D <span class=\"title\">alignment</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">avg_velocity</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            avg_velocity = avg_velocity + b.velocity;</span><br><span class=\"line\">            total_neighbors++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        avg_velocity = avg_velocity * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> avg_velocity - velocity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/boids-algorithm/101894421252079.gif\" alt=\"聚集规则 + 分离规则 + 对齐规则\"></p>\n</div>\n\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简单的二维向量</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Vector2D</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Vector2D</span>(<span class=\"type\">float</span> _x, <span class=\"type\">float</span> _y) : <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Vector2D&amp; other) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>-(<span class=\"type\">const</span> Vector2D&amp; other) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x - other.x, y - other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2D <span class=\"keyword\">operator</span>*(<span class=\"type\">float</span> scalar) <span class=\"type\">const</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(x * scalar, y * scalar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">sqrt</span>(x * x + y * y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">normalize</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> len = <span class=\"built_in\">length</span>();</span><br><span class=\"line\">        x /= len;</span><br><span class=\"line\">        y /= len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 集群单位</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Boid</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    COLORREF color;</span><br><span class=\"line\">    Vector2D position;</span><br><span class=\"line\">    Vector2D velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 聚集规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">cohesion</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">center_of_mass</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                center_of_mass = center_of_mass + b.position;</span><br><span class=\"line\">                total_neighbors++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            center_of_mass = center_of_mass * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (center_of_mass - position);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分离规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">separation</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; separation_distance) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Vector2D diff = position - b.position;</span><br><span class=\"line\">                separation = separation + diff * (<span class=\"number\">1.0f</span> / distance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> separation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对齐规则</span></span><br><span class=\"line\">    <span class=\"function\">Vector2D <span class=\"title\">alignment</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Vector2D <span class=\"title\">avg_velocity</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> total_neighbors = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> distance = (b.position - position).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt; <span class=\"number\">0</span> &amp;&amp; distance &lt; neighbour_distance) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                avg_velocity = avg_velocity + b.velocity;</span><br><span class=\"line\">                total_neighbors++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (total_neighbors &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            avg_velocity = avg_velocity * (<span class=\"number\">1.0f</span> / total_neighbors);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> avg_velocity - velocity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">const</span> std::vector&lt;Boid&gt;&amp; boids)</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Vector2D v1 = <span class=\"built_in\">cohesion</span>(boids);</span><br><span class=\"line\">        Vector2D v2 = <span class=\"built_in\">separation</span>(boids);</span><br><span class=\"line\">        Vector2D v3 = <span class=\"built_in\">alignment</span>(boids);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据规则权重调节最终行为</span></span><br><span class=\"line\">        v1 = v1 * cohesion_weight;</span><br><span class=\"line\">        v2 = v2 * separation_weight;</span><br><span class=\"line\">        v3 = v3 * align_weight;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新速度</span></span><br><span class=\"line\">        velocity = velocity + v1 + v2 + v3;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 限制速度</span></span><br><span class=\"line\">        <span class=\"type\">float</span> speed = velocity.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (speed &gt; max_speed) velocity = velocity * (max_speed / speed);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新位置</span></span><br><span class=\"line\">        position = position + velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 限制位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.x &lt; <span class=\"number\">0</span>) position.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.x &gt; <span class=\"number\">1280</span>) position.x = <span class=\"number\">1280</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.y &lt; <span class=\"number\">0</span>) position.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position.y &gt; <span class=\"number\">720</span>) position.y = <span class=\"number\">720</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> neighbour_distance = <span class=\"number\">100.0f</span>;      <span class=\"comment\">// 判定为临近单位的距离</span></span><br><span class=\"line\">    <span class=\"type\">float</span> separation_distance = <span class=\"number\">50.0f</span>;      <span class=\"comment\">// 临近单位的分离距离</span></span><br><span class=\"line\">    <span class=\"type\">float</span> cohesion_weight = <span class=\"number\">1.0f</span>;           <span class=\"comment\">// &quot;聚集&quot; 规则强度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> separation_weight = <span class=\"number\">1.0f</span>;         <span class=\"comment\">// &quot;分离&quot; 规则强度 </span></span><br><span class=\"line\">    <span class=\"type\">float</span> align_weight = <span class=\"number\">1.0f</span>;              <span class=\"comment\">// &quot;对齐&quot; 规则强度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> max_speed = <span class=\"number\">5.0f</span>;                 <span class=\"comment\">// 集群最大速度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(<span class=\"number\">1280</span>, <span class=\"number\">720</span>, EW_SHOWCONSOLE);</span><br><span class=\"line\">    <span class=\"built_in\">BeginBatchDraw</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化集群</span></span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;Boid&gt; <span class=\"title\">boids</span><span class=\"params\">(<span class=\"number\">500</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b.position.x = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">1280</span>);</span><br><span class=\"line\">        b.position.y = (<span class=\"type\">float</span>)(<span class=\"built_in\">rand</span>() % <span class=\"number\">720</span>);</span><br><span class=\"line\">        b.color = <span class=\"built_in\">RGB</span>(<span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>, <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 循环模拟</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新集群</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">            b.<span class=\"built_in\">update</span>(boids);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 渲染集群</span></span><br><span class=\"line\">        <span class=\"built_in\">cleardevice</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Boid&amp; b : boids)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">setfillcolor</span>(b.color);</span><br><span class=\"line\">            <span class=\"built_in\">fillcircle</span>((<span class=\"type\">int</span>)b.position.x, (<span class=\"type\">int</span>)b.position.y, <span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">FlushBatchDraw</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Sleep</span>(<span class=\"number\">25</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用三角形等有指向性的元素，根据当前速度向量绘图模拟效果会更加清晰。</p>\n</blockquote>\n<div style=\"text-align:center\">\n\n<p>&gt;&gt;&gt;  <a href=\"https://www.voidmatrix.work/articles/boids-algorithm/\">在 Voidmatrix’s Blog 上查看本文章</a>  &lt;&lt;&lt;</p>\n</div>"},{"title":"XINDENG123456自我介绍","date":"2024-05-27T16:00:00.000Z","updated":"2024-05-27T16:00:00.000Z","_content":"\n\n>'hello everyone! Hello world!!  😝🤪😜'\n>阿巴阿巴啦啦啦\n>👻👻\n> ---\n> etc.\n> ...\n\n<!-- More -->\n\n---\n\n# **自我介绍**\n1. 本人贪吃贪睡，玩世不恭\n2. 本人积懒成疾，无可救药\n3. 本人大愚若智，爱好躺平\n\n\n## 今天做的事： \n  - [x]  吃饭\n  - [x] 睡觉\n  - [x] 赶作业\n  - [ ] ==学习==\n  - [ ] <U>找对象</u>\n\n## 试写代码：\n \n  ```c\n  \n  int main(){\n  return 0;\n}\n```\n\n##  试写公式\n\n...算了不会，晚点学[^晚点学 ]\n\nx^2^\n\n\n##  下面画一个表\n- 不想写，还是抄一个\n\n|                |ASCII                          |HTML                         |\n|----------------|-------------------------------|-----------------------------|\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n---\n\n## 我的GitHub\n在这里\n[XINDENG123456]([github.com\"一个小链接\"](github.com/XINDENG123456))\n\n[^晚点学]： 指不知道多晚，可以参考[自我介绍](#自我介绍)\n\n","source":"_posts/XINDENG123456/self-introduction.md","raw":"---\ntitle: XINDENG123456自我介绍\ndate: 2024-05-28\nupdated: 2024-05-28\npermalink: articles/XINDENG123456/self-introduction/\ncategories: XINDENG123456\ntags: \n    - 自我介绍\n---\n\n\n>'hello everyone! Hello world!!  😝🤪😜'\n>阿巴阿巴啦啦啦\n>👻👻\n> ---\n> etc.\n> ...\n\n<!-- More -->\n\n---\n\n# **自我介绍**\n1. 本人贪吃贪睡，玩世不恭\n2. 本人积懒成疾，无可救药\n3. 本人大愚若智，爱好躺平\n\n\n## 今天做的事： \n  - [x]  吃饭\n  - [x] 睡觉\n  - [x] 赶作业\n  - [ ] ==学习==\n  - [ ] <U>找对象</u>\n\n## 试写代码：\n \n  ```c\n  \n  int main(){\n  return 0;\n}\n```\n\n##  试写公式\n\n...算了不会，晚点学[^晚点学 ]\n\nx^2^\n\n\n##  下面画一个表\n- 不想写，还是抄一个\n\n|                |ASCII                          |HTML                         |\n|----------------|-------------------------------|-----------------------------|\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n---\n\n## 我的GitHub\n在这里\n[XINDENG123456]([github.com\"一个小链接\"](github.com/XINDENG123456))\n\n[^晚点学]： 指不知道多晚，可以参考[自我介绍](#自我介绍)\n\n","slug":"XINDENG123456/self-introduction","published":1,"__permalink":"articles/XINDENG123456/self-introduction/","_id":"clx8n2hgh000vo8ye3fv08lzg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<h2 id=\"‘hello-everyone-Hello-world-😝🤪😜’阿巴阿巴啦啦啦👻👻\"><a href=\"#‘hello-everyone-Hello-world-😝🤪😜’阿巴阿巴啦啦啦👻👻\" class=\"headerlink\" title=\"‘hello everyone! Hello world!!  😝🤪😜’阿巴阿巴啦啦啦👻👻\"></a>‘hello everyone! Hello world!!  😝🤪😜’<br>阿巴阿巴啦啦啦<br>👻👻</h2><p>etc.<br>…</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a><strong>自我介绍</strong></h1><ol>\n<li>本人贪吃贪睡，玩世不恭</li>\n<li>本人积懒成疾，无可救药</li>\n<li>本人大愚若智，爱好躺平</li>\n</ol>\n<h2 id=\"今天做的事：\"><a href=\"#今天做的事：\" class=\"headerlink\" title=\"今天做的事：\"></a>今天做的事：</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 吃饭</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 睡觉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 赶作业</li>\n<li><input disabled=\"\" type=\"checkbox\"> &#x3D;&#x3D;学习&#x3D;&#x3D;</li>\n<li><input disabled=\"\" type=\"checkbox\"> <U>找对象</u></li>\n</ul>\n<h2 id=\"试写代码：\"><a href=\"#试写代码：\" class=\"headerlink\" title=\"试写代码：\"></a>试写代码：</h2>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"试写公式\"><a href=\"#试写公式\" class=\"headerlink\" title=\"试写公式\"></a>试写公式</h2><p>…算了不会，晚点学[^晚点学 ]</p>\n<p>x^2^</p>\n<h2 id=\"下面画一个表\"><a href=\"#下面画一个表\" class=\"headerlink\" title=\"下面画一个表\"></a>下面画一个表</h2><ul>\n<li>不想写，还是抄一个</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ASCII</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single backticks</td>\n<td><code>&#39;Isn&#39;t this fun?&#39;</code></td>\n<td>‘Isn’t this fun?’</td>\n</tr>\n<tr>\n<td>Quotes</td>\n<td><code>&quot;Isn&#39;t this fun?&quot;</code></td>\n<td>“Isn’t this fun?”</td>\n</tr>\n<tr>\n<td>Dashes</td>\n<td><code>-- is en-dash, --- is em-dash</code></td>\n<td>– is en-dash, — is em-dash</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"我的GitHub\"><a href=\"#我的GitHub\" class=\"headerlink\" title=\"我的GitHub\"></a>我的GitHub</h2><p>在这里<br><a href=\"%5Bgithub.com%22%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%93%BE%E6%8E%A5%22%5D(github.com/XINDENG123456)\">XINDENG123456</a></p>\n<p>[^晚点学]： 指不知道多晚，可以参考<a href=\"#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D\">自我介绍</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h2 id=\"‘hello-everyone-Hello-world-😝🤪😜’阿巴阿巴啦啦啦👻👻\"><a href=\"#‘hello-everyone-Hello-world-😝🤪😜’阿巴阿巴啦啦啦👻👻\" class=\"headerlink\" title=\"‘hello everyone! Hello world!!  😝🤪😜’阿巴阿巴啦啦啦👻👻\"></a>‘hello everyone! Hello world!!  😝🤪😜’<br>阿巴阿巴啦啦啦<br>👻👻</h2><p>etc.<br>…</p>\n</blockquote>","more":"<hr>\n<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a><strong>自我介绍</strong></h1><ol>\n<li>本人贪吃贪睡，玩世不恭</li>\n<li>本人积懒成疾，无可救药</li>\n<li>本人大愚若智，爱好躺平</li>\n</ol>\n<h2 id=\"今天做的事：\"><a href=\"#今天做的事：\" class=\"headerlink\" title=\"今天做的事：\"></a>今天做的事：</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 吃饭</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 睡觉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 赶作业</li>\n<li><input disabled=\"\" type=\"checkbox\"> &#x3D;&#x3D;学习&#x3D;&#x3D;</li>\n<li><input disabled=\"\" type=\"checkbox\"> <U>找对象</u></li>\n</ul>\n<h2 id=\"试写代码：\"><a href=\"#试写代码：\" class=\"headerlink\" title=\"试写代码：\"></a>试写代码：</h2>  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"试写公式\"><a href=\"#试写公式\" class=\"headerlink\" title=\"试写公式\"></a>试写公式</h2><p>…算了不会，晚点学[^晚点学 ]</p>\n<p>x^2^</p>\n<h2 id=\"下面画一个表\"><a href=\"#下面画一个表\" class=\"headerlink\" title=\"下面画一个表\"></a>下面画一个表</h2><ul>\n<li>不想写，还是抄一个</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ASCII</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single backticks</td>\n<td><code>&#39;Isn&#39;t this fun?&#39;</code></td>\n<td>‘Isn’t this fun?’</td>\n</tr>\n<tr>\n<td>Quotes</td>\n<td><code>&quot;Isn&#39;t this fun?&quot;</code></td>\n<td>“Isn’t this fun?”</td>\n</tr>\n<tr>\n<td>Dashes</td>\n<td><code>-- is en-dash, --- is em-dash</code></td>\n<td>– is en-dash, — is em-dash</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"我的GitHub\"><a href=\"#我的GitHub\" class=\"headerlink\" title=\"我的GitHub\"></a>我的GitHub</h2><p>在这里<br><a href=\"%5Bgithub.com%22%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%93%BE%E6%8E%A5%22%5D(github.com/XINDENG123456)\">XINDENG123456</a></p>\n<p>[^晚点学]： 指不知道多晚，可以参考<a href=\"#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D\">自我介绍</a></p>"},{"title":"程序化游戏地图生成浅析（一）","date":"2024-06-01T16:00:00.000Z","updated":"2024-06-01T16:00:00.000Z","_content":"\n使用 **程序化内容生成（PCG）** 的优势：\n\n+ 无限地图内容：两个维度，一是单次游玩的地图内容趋近于无限，即无限大世界；二是可以生成近似无限多的世界，提升游戏的可重复游玩性；\n+ 节省开发成本：开发者只需要定义生成规则来描述世界最底层的机制，而不需要从上到下事无巨细地完成玩家可游玩的全部内容；\n+ 挑战与变化：使用程序生成地图可以很好地控制随机性，给玩家创造挑战的机会，更具趣味性；\n+ 动态难度调整：使用规则描述世界生成可以站在更高的维度去调控世界资源，更好地平衡游戏难度或创造特殊难度的世界。\n\n在大多数情况下，程序化生成地图的游戏也并不能完全地摆脱传统的手工制作的部分，即便是程序化内容生成主导的世界中，也存在细粒度的部分需要开发者进行人工设计（如 Minecraft 中的村庄等内容），这同样也可以使用更细致的生成规则来描述。\n\n<!-- more -->\n\n## 生成思路总览\n\n对于程序化生成的游戏世界地图，可以使用**分批次地、递归地**类似分形的思想逐步进行细化处理，每一层处理都基本满足以下三个步骤：\n\n<div style=\"text-align:center\">\n\n![每层递归的三个生成步骤](articles/Voidmatrix/pcg-game-map-1/151655416259069.png)\n\n</div>\n\n1. **随机**：根据随机数或噪声算法生成最粗略的数据模板；\n2. **平滑**：根据当前生成内容的维度和粒度对得到的数据进行插值和过渡处理；\n3. **修正**：根据游戏内容和更上层的设计规则调整平滑后的世界。\n\n一个使用此思想实现的流程可以如下所示：\n\n<div style=\"text-align:center\">\n\n![三步走递归生成示例](articles/Voidmatrix/pcg-game-map-1/202434217267102.png)\n\n</div>\n\n在前两个步骤中，我们需要确保使用的算法满足下列三个条件：\n\n1. **随机性**：这个过程是随机的，或者说在相当大范围内不会出现重复的生成周期；\n2. **可哈希**：使用相同的随机数输入（种子），得到的随机内容是一致的；\n3. **连续性**：无论粒度大小，生成的内容都是连续且平滑的。\n\n> 可哈希的特性给游戏的增量存档提供了可能，存储游戏世界信息的存档不需要在初始化生成时便保存全部数据内容，而是可以随着游戏进行，只增量存储玩家探索过或修改过的内容。\n\n下面我们将分类讨论在随机和平滑的过程中使用的算法思路。\n\n## 直接使用随机数\n\n直接使用`rand()`等随机函数会存在以下问题：\n\n+ **不连续性**：随机数的生成是跳跃的，直接使用时无法起到平滑的效果；\n+ **易受影响**：虽然我们可以使用`srand()`等函数设置随机数的种子来确保随机数的哈希性，但是程序的其他部分可能需要使用时间来初始化随机数种子来获取更灵活的随机数，这就导致在全局环境下生成的随机数不稳定。\n\n使用如下代码生成的灰度图，可以很清楚地看出其不连续性：\n\n<div style=\"text-align:center\">\n\n![`rand()`随机数灰度图](articles/Voidmatrix/pcg-game-map-1/553721218256326.png)\n\n</div>\n\n```cpp\n#include <graphics.h>\n\nint main()\n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height, EW_SHOWCONSOLE);\n\n    for (int x = 0; x < width; x++)\n    {\n        for (int y = 0; y < height; y++)\n        {\n            int val = rand() % 255;\n            putpixel(x, y, RGB(val, val, val));\n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n但是，这并不意味着随机数函数是无用的，我们可以直接使用随机数生成离散的影响点，再根据距离权重进行平滑处理，如《文明6》等游戏中使用的**米切尔候选算法**（Mitchell's best-candidate algorithm），在处理初期时可以直接使用随机数进行候选节点的生成的，这将在后续的游戏资源生成章节再进行详细讨论。\n\n在上古项目[随机地图高度图](https://github.com/EtherProject/EtherWorkCollection/tree/main/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E9%AB%98%E5%BA%A6%E5%9B%BE)生成过程中，也是使用了简单的先随机后平滑的思路：\n\n<div style=\"text-align:center\">\n\n![随机地图高度图（白色为随机生成的影响点）](articles/Voidmatrix/pcg-game-map-1/532531818252080.png)\n\n</div>\n\n## 平滑的噪声函数\n\n在[《基于EasyX软渲染实现常见故障艺术》](https://www.voidmatrix.work/articles/%E5%9F%BA%E4%BA%8EEasyX%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%89%BA%E6%9C%AF/)一文中，提供了一种可行的随机噪声函数：\n\n<div style=\"text-align:center\">\n\n![f(x, y) = frac(sin(x * 12.9898 + y * 78.233) * 43758.5453)](articles/Voidmatrix/pcg-game-map-1/76072812230849.png)\n\n</div>\n\n```cpp\n// 获取随机噪声\nvirtual double GetRandomNoise(double x, double y)\n{\n\tdouble val = sin(x * 12.9898 + y * 78.233) * 43758.5453;\n\treturn val - floor(val);\n}\n```\n\n简单地，我们也可以使用正弦波叠加的思想处理类似的噪声生成：\n\n<div style=\"text-align:center\">\n\n![简单的正弦波叠加同样可以模拟地形效果](articles/Voidmatrix/pcg-game-map-1/125364318267564.png)\n\n</div>\n\n但是，我们可以很清晰地看出，这种直接使用函数生成的噪声即便可以满足哈希性和连续性，但它们的周期性太强，直接将生成得到的计算结果应用于游戏中会导致整个世界出现大量重复地形，并不能完全满足随机性的要求：\n\n<div style=\"text-align:center\">\n\n![噪声函数存在较强的周期性](articles/Voidmatrix/pcg-game-map-1/59555018265066.png)\n\n</div>\n\n```cpp\ndouble noise(int x, int y)\n{\n    double val_x = abs((1 * sin(x * 1)) + (0.5 * sin(x * 2)) + (0.25 * sin(x * 4)) + (0.125 * sin(x * 8)));\n    double val_y = abs((1 * sin(y * 1)) + (0.5 * sin(y * 2)) + (0.25 * sin(y * 4)) + (0.125 * sin(y * 8)));\n\n    // 对得到的结果进行归一化\n    return (val_x + val_y) / ((1 + 0.5 + 0.25 + 0.125) * 2);\n}\n\nint main()\n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height, EW_SHOWCONSOLE);\n\n    for (int x = 0; x < width; x++)\n    {\n        for (int y = 0; y < height; y++)\n        {\n            int val = (int)(noise(x / 10, y / 10) * 255);\n            putpixel(x, y, RGB(val, val, val));\n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n即便如此，这些生成噪声的方式，同样可以作为**分形噪声**等更进阶的噪声生成时的原始数据。\n\n## 更进阶的噪声生成\n\n有许多已经被实践证明满足上述需求的噪声算法，如：Perlin噪声，Simplex噪声，Wavelet噪声，Value噪声和Worley噪声等，下面将以大名鼎鼎的**柏林噪声**（Perlin）为例讲解实现思路。\n\n> 柏林噪声本质上可以算是一种非典型的晶格噪声技术，晶格噪声是一种在离散的、规则的网格上生成的噪声，所以晶格噪声通常在规则的格点上有着明确定义的数值，而柏林噪声的特殊之处在于，在使用晶格为单位生成基础噪声后，又通过插值和平滑处理，产生了空间中连续的噪声变化。\n\n柏林噪声的生成可以归纳为三步：\n\n1. **梯度生成**：在空间中随机生成梯度向量网格，梯度向量由每个整数坐标点（晶格）上随机确定的。这些梯度向量定义了一个在整个空间内变化的方向；\n2. **插值**：当需要计算某一点的噪声值时，首先确定其所处的网格单元，然后计算该点到网格单元内各个梯度向量的距离，并将这些距离用于权重插值，在这个过程中噪声得到了平滑的处理；\n3. **分形**：对生成得到的结果进行不同尺度的缩放和叠加，来生成更具随机性且不同粒度的结果。\n\n<div style=\"text-align:center\">\n\n![柏林噪声灰度图](articles/Voidmatrix/pcg-game-map-1/161600919246307.png)\n\n</div>\n\n```cpp\n#include <cmath>\n#include <graphics.h>\n\n// 生成基础噪声值\ndouble noise(int x, int y)\n{\n    return fmod(sin(x * 12.9898 + y * 78.233) * 43758.5453, 1.0);\n}\n\n// 生成平滑噪声值\ndouble smooth_noise(int x, int y) \n{\n    // 计算角落、边和中心的平均噪声值\n    double corners = (noise(x - 1, y - 1) + noise(x + 1, y - 1) + noise(x - 1, y + 1) + noise(x + 1, y + 1)) / 16;\n    double sides = (noise(x - 1, y) + noise(x + 1, y) + noise(x, y - 1) + noise(x, y + 1)) / 8;\n    double center = noise(x, y) / 4;\n    // 返回平滑噪声值\n    return corners + sides + center; \n}\n\n// 线性插值\ndouble interpolate(double a, double b, double x) \n{\n    // 计算插值权重\n    double ft = x * 3.1415927; \n    double f = (1 - cos(ft)) * 0.5;\n    // 返回插值结果\n    return a * (1 - f) + b * f; \n}\n\n// 插值计算\ndouble interpolated_noise(double x, double y) \n{\n    // 提取整数部分和小数部分\n    int integer_X = static_cast<int>(x);\n    double fractional_X = x - integer_X;\n\n    int integer_Y = static_cast<int>(y);\n    double fractional_Y = y - integer_Y;\n\n    // 计算插值点的噪声值\n    double v1 = smooth_noise(integer_X, integer_Y);\n    double v2 = smooth_noise(integer_X + 1, integer_Y);\n    double v3 = smooth_noise(integer_X, integer_Y + 1);\n    double v4 = smooth_noise(integer_X + 1, integer_Y + 1);\n\n    double i1 = interpolate(v1, v2, fractional_X);\n    double i2 = interpolate(v3, v4, fractional_X);\n\n    // 返回插值后的噪声值\n    return interpolate(i1, i2, fractional_Y); \n}\n\nint main() \n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height);\n\n    // 循环生成每个像素点的噪声值并转换为灰度颜色\n    for (int y = 0; y < height; y++) \n    {\n        for (int x = 0; x < width; x++) \n        {\n            // 生成插值噪声，并控制噪声的规模\n            double value = interpolated_noise(x / 50.0, y / 50.0); \n            // 将噪声值转换为灰度颜色\n            COLORREF color = RGB((int)(value * 255),\n                (int)(value * 255), (int)(value * 255)); \n            // 在指定位置绘制像素\n            putpixel(x, y, color); \n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n<div style=\"text-align:center\">\n\n![“痛苦终结者”](articles/Voidmatrix/pcg-game-map-1/87331419268747.png)\n\n</div>\n\n<div style=\"text-align:center\">\n\n\\>\\>\\>  [在 Voidmatrix's Blog 上查看本文章](https://www.voidmatrix.work/articles/pcg-game-map-1/)  <<<\n\n</div>","source":"_posts/Voidmatrix/程序化游戏地图生成浅析（一）.md","raw":"---\ntitle: 程序化游戏地图生成浅析（一）\ndate: 2024-06-02\nupdated: 2024-06-02\npermalink: articles/Voidmatrix/pcg-game-map-1/\ncategories: Voidmatrix\ntags: [EasyX, 算法, C++, PCG]\n---\n\n使用 **程序化内容生成（PCG）** 的优势：\n\n+ 无限地图内容：两个维度，一是单次游玩的地图内容趋近于无限，即无限大世界；二是可以生成近似无限多的世界，提升游戏的可重复游玩性；\n+ 节省开发成本：开发者只需要定义生成规则来描述世界最底层的机制，而不需要从上到下事无巨细地完成玩家可游玩的全部内容；\n+ 挑战与变化：使用程序生成地图可以很好地控制随机性，给玩家创造挑战的机会，更具趣味性；\n+ 动态难度调整：使用规则描述世界生成可以站在更高的维度去调控世界资源，更好地平衡游戏难度或创造特殊难度的世界。\n\n在大多数情况下，程序化生成地图的游戏也并不能完全地摆脱传统的手工制作的部分，即便是程序化内容生成主导的世界中，也存在细粒度的部分需要开发者进行人工设计（如 Minecraft 中的村庄等内容），这同样也可以使用更细致的生成规则来描述。\n\n<!-- more -->\n\n## 生成思路总览\n\n对于程序化生成的游戏世界地图，可以使用**分批次地、递归地**类似分形的思想逐步进行细化处理，每一层处理都基本满足以下三个步骤：\n\n<div style=\"text-align:center\">\n\n![每层递归的三个生成步骤](articles/Voidmatrix/pcg-game-map-1/151655416259069.png)\n\n</div>\n\n1. **随机**：根据随机数或噪声算法生成最粗略的数据模板；\n2. **平滑**：根据当前生成内容的维度和粒度对得到的数据进行插值和过渡处理；\n3. **修正**：根据游戏内容和更上层的设计规则调整平滑后的世界。\n\n一个使用此思想实现的流程可以如下所示：\n\n<div style=\"text-align:center\">\n\n![三步走递归生成示例](articles/Voidmatrix/pcg-game-map-1/202434217267102.png)\n\n</div>\n\n在前两个步骤中，我们需要确保使用的算法满足下列三个条件：\n\n1. **随机性**：这个过程是随机的，或者说在相当大范围内不会出现重复的生成周期；\n2. **可哈希**：使用相同的随机数输入（种子），得到的随机内容是一致的；\n3. **连续性**：无论粒度大小，生成的内容都是连续且平滑的。\n\n> 可哈希的特性给游戏的增量存档提供了可能，存储游戏世界信息的存档不需要在初始化生成时便保存全部数据内容，而是可以随着游戏进行，只增量存储玩家探索过或修改过的内容。\n\n下面我们将分类讨论在随机和平滑的过程中使用的算法思路。\n\n## 直接使用随机数\n\n直接使用`rand()`等随机函数会存在以下问题：\n\n+ **不连续性**：随机数的生成是跳跃的，直接使用时无法起到平滑的效果；\n+ **易受影响**：虽然我们可以使用`srand()`等函数设置随机数的种子来确保随机数的哈希性，但是程序的其他部分可能需要使用时间来初始化随机数种子来获取更灵活的随机数，这就导致在全局环境下生成的随机数不稳定。\n\n使用如下代码生成的灰度图，可以很清楚地看出其不连续性：\n\n<div style=\"text-align:center\">\n\n![`rand()`随机数灰度图](articles/Voidmatrix/pcg-game-map-1/553721218256326.png)\n\n</div>\n\n```cpp\n#include <graphics.h>\n\nint main()\n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height, EW_SHOWCONSOLE);\n\n    for (int x = 0; x < width; x++)\n    {\n        for (int y = 0; y < height; y++)\n        {\n            int val = rand() % 255;\n            putpixel(x, y, RGB(val, val, val));\n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n但是，这并不意味着随机数函数是无用的，我们可以直接使用随机数生成离散的影响点，再根据距离权重进行平滑处理，如《文明6》等游戏中使用的**米切尔候选算法**（Mitchell's best-candidate algorithm），在处理初期时可以直接使用随机数进行候选节点的生成的，这将在后续的游戏资源生成章节再进行详细讨论。\n\n在上古项目[随机地图高度图](https://github.com/EtherProject/EtherWorkCollection/tree/main/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E9%AB%98%E5%BA%A6%E5%9B%BE)生成过程中，也是使用了简单的先随机后平滑的思路：\n\n<div style=\"text-align:center\">\n\n![随机地图高度图（白色为随机生成的影响点）](articles/Voidmatrix/pcg-game-map-1/532531818252080.png)\n\n</div>\n\n## 平滑的噪声函数\n\n在[《基于EasyX软渲染实现常见故障艺术》](https://www.voidmatrix.work/articles/%E5%9F%BA%E4%BA%8EEasyX%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%89%BA%E6%9C%AF/)一文中，提供了一种可行的随机噪声函数：\n\n<div style=\"text-align:center\">\n\n![f(x, y) = frac(sin(x * 12.9898 + y * 78.233) * 43758.5453)](articles/Voidmatrix/pcg-game-map-1/76072812230849.png)\n\n</div>\n\n```cpp\n// 获取随机噪声\nvirtual double GetRandomNoise(double x, double y)\n{\n\tdouble val = sin(x * 12.9898 + y * 78.233) * 43758.5453;\n\treturn val - floor(val);\n}\n```\n\n简单地，我们也可以使用正弦波叠加的思想处理类似的噪声生成：\n\n<div style=\"text-align:center\">\n\n![简单的正弦波叠加同样可以模拟地形效果](articles/Voidmatrix/pcg-game-map-1/125364318267564.png)\n\n</div>\n\n但是，我们可以很清晰地看出，这种直接使用函数生成的噪声即便可以满足哈希性和连续性，但它们的周期性太强，直接将生成得到的计算结果应用于游戏中会导致整个世界出现大量重复地形，并不能完全满足随机性的要求：\n\n<div style=\"text-align:center\">\n\n![噪声函数存在较强的周期性](articles/Voidmatrix/pcg-game-map-1/59555018265066.png)\n\n</div>\n\n```cpp\ndouble noise(int x, int y)\n{\n    double val_x = abs((1 * sin(x * 1)) + (0.5 * sin(x * 2)) + (0.25 * sin(x * 4)) + (0.125 * sin(x * 8)));\n    double val_y = abs((1 * sin(y * 1)) + (0.5 * sin(y * 2)) + (0.25 * sin(y * 4)) + (0.125 * sin(y * 8)));\n\n    // 对得到的结果进行归一化\n    return (val_x + val_y) / ((1 + 0.5 + 0.25 + 0.125) * 2);\n}\n\nint main()\n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height, EW_SHOWCONSOLE);\n\n    for (int x = 0; x < width; x++)\n    {\n        for (int y = 0; y < height; y++)\n        {\n            int val = (int)(noise(x / 10, y / 10) * 255);\n            putpixel(x, y, RGB(val, val, val));\n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n即便如此，这些生成噪声的方式，同样可以作为**分形噪声**等更进阶的噪声生成时的原始数据。\n\n## 更进阶的噪声生成\n\n有许多已经被实践证明满足上述需求的噪声算法，如：Perlin噪声，Simplex噪声，Wavelet噪声，Value噪声和Worley噪声等，下面将以大名鼎鼎的**柏林噪声**（Perlin）为例讲解实现思路。\n\n> 柏林噪声本质上可以算是一种非典型的晶格噪声技术，晶格噪声是一种在离散的、规则的网格上生成的噪声，所以晶格噪声通常在规则的格点上有着明确定义的数值，而柏林噪声的特殊之处在于，在使用晶格为单位生成基础噪声后，又通过插值和平滑处理，产生了空间中连续的噪声变化。\n\n柏林噪声的生成可以归纳为三步：\n\n1. **梯度生成**：在空间中随机生成梯度向量网格，梯度向量由每个整数坐标点（晶格）上随机确定的。这些梯度向量定义了一个在整个空间内变化的方向；\n2. **插值**：当需要计算某一点的噪声值时，首先确定其所处的网格单元，然后计算该点到网格单元内各个梯度向量的距离，并将这些距离用于权重插值，在这个过程中噪声得到了平滑的处理；\n3. **分形**：对生成得到的结果进行不同尺度的缩放和叠加，来生成更具随机性且不同粒度的结果。\n\n<div style=\"text-align:center\">\n\n![柏林噪声灰度图](articles/Voidmatrix/pcg-game-map-1/161600919246307.png)\n\n</div>\n\n```cpp\n#include <cmath>\n#include <graphics.h>\n\n// 生成基础噪声值\ndouble noise(int x, int y)\n{\n    return fmod(sin(x * 12.9898 + y * 78.233) * 43758.5453, 1.0);\n}\n\n// 生成平滑噪声值\ndouble smooth_noise(int x, int y) \n{\n    // 计算角落、边和中心的平均噪声值\n    double corners = (noise(x - 1, y - 1) + noise(x + 1, y - 1) + noise(x - 1, y + 1) + noise(x + 1, y + 1)) / 16;\n    double sides = (noise(x - 1, y) + noise(x + 1, y) + noise(x, y - 1) + noise(x, y + 1)) / 8;\n    double center = noise(x, y) / 4;\n    // 返回平滑噪声值\n    return corners + sides + center; \n}\n\n// 线性插值\ndouble interpolate(double a, double b, double x) \n{\n    // 计算插值权重\n    double ft = x * 3.1415927; \n    double f = (1 - cos(ft)) * 0.5;\n    // 返回插值结果\n    return a * (1 - f) + b * f; \n}\n\n// 插值计算\ndouble interpolated_noise(double x, double y) \n{\n    // 提取整数部分和小数部分\n    int integer_X = static_cast<int>(x);\n    double fractional_X = x - integer_X;\n\n    int integer_Y = static_cast<int>(y);\n    double fractional_Y = y - integer_Y;\n\n    // 计算插值点的噪声值\n    double v1 = smooth_noise(integer_X, integer_Y);\n    double v2 = smooth_noise(integer_X + 1, integer_Y);\n    double v3 = smooth_noise(integer_X, integer_Y + 1);\n    double v4 = smooth_noise(integer_X + 1, integer_Y + 1);\n\n    double i1 = interpolate(v1, v2, fractional_X);\n    double i2 = interpolate(v3, v4, fractional_X);\n\n    // 返回插值后的噪声值\n    return interpolate(i1, i2, fractional_Y); \n}\n\nint main() \n{\n    const int width = 1280;\n    const int height = 720;\n\n    initgraph(width, height);\n\n    // 循环生成每个像素点的噪声值并转换为灰度颜色\n    for (int y = 0; y < height; y++) \n    {\n        for (int x = 0; x < width; x++) \n        {\n            // 生成插值噪声，并控制噪声的规模\n            double value = interpolated_noise(x / 50.0, y / 50.0); \n            // 将噪声值转换为灰度颜色\n            COLORREF color = RGB((int)(value * 255),\n                (int)(value * 255), (int)(value * 255)); \n            // 在指定位置绘制像素\n            putpixel(x, y, color); \n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n<div style=\"text-align:center\">\n\n![“痛苦终结者”](articles/Voidmatrix/pcg-game-map-1/87331419268747.png)\n\n</div>\n\n<div style=\"text-align:center\">\n\n\\>\\>\\>  [在 Voidmatrix's Blog 上查看本文章](https://www.voidmatrix.work/articles/pcg-game-map-1/)  <<<\n\n</div>","slug":"Voidmatrix/程序化游戏地图生成浅析（一）","published":1,"__permalink":"articles/Voidmatrix/pcg-game-map-1/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgi000yo8yedk2m781a","content":"<p>使用 <strong>程序化内容生成（PCG）</strong> 的优势：</p>\n<ul>\n<li>无限地图内容：两个维度，一是单次游玩的地图内容趋近于无限，即无限大世界；二是可以生成近似无限多的世界，提升游戏的可重复游玩性；</li>\n<li>节省开发成本：开发者只需要定义生成规则来描述世界最底层的机制，而不需要从上到下事无巨细地完成玩家可游玩的全部内容；</li>\n<li>挑战与变化：使用程序生成地图可以很好地控制随机性，给玩家创造挑战的机会，更具趣味性；</li>\n<li>动态难度调整：使用规则描述世界生成可以站在更高的维度去调控世界资源，更好地平衡游戏难度或创造特殊难度的世界。</li>\n</ul>\n<p>在大多数情况下，程序化生成地图的游戏也并不能完全地摆脱传统的手工制作的部分，即便是程序化内容生成主导的世界中，也存在细粒度的部分需要开发者进行人工设计（如 Minecraft 中的村庄等内容），这同样也可以使用更细致的生成规则来描述。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"生成思路总览\"><a href=\"#生成思路总览\" class=\"headerlink\" title=\"生成思路总览\"></a>生成思路总览</h2><p>对于程序化生成的游戏世界地图，可以使用<strong>分批次地、递归地</strong>类似分形的思想逐步进行细化处理，每一层处理都基本满足以下三个步骤：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/151655416259069.png\" alt=\"每层递归的三个生成步骤\"></p>\n</div>\n\n<ol>\n<li><strong>随机</strong>：根据随机数或噪声算法生成最粗略的数据模板；</li>\n<li><strong>平滑</strong>：根据当前生成内容的维度和粒度对得到的数据进行插值和过渡处理；</li>\n<li><strong>修正</strong>：根据游戏内容和更上层的设计规则调整平滑后的世界。</li>\n</ol>\n<p>一个使用此思想实现的流程可以如下所示：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/202434217267102.png\" alt=\"三步走递归生成示例\"></p>\n</div>\n\n<p>在前两个步骤中，我们需要确保使用的算法满足下列三个条件：</p>\n<ol>\n<li><strong>随机性</strong>：这个过程是随机的，或者说在相当大范围内不会出现重复的生成周期；</li>\n<li><strong>可哈希</strong>：使用相同的随机数输入（种子），得到的随机内容是一致的；</li>\n<li><strong>连续性</strong>：无论粒度大小，生成的内容都是连续且平滑的。</li>\n</ol>\n<blockquote>\n<p>可哈希的特性给游戏的增量存档提供了可能，存储游戏世界信息的存档不需要在初始化生成时便保存全部数据内容，而是可以随着游戏进行，只增量存储玩家探索过或修改过的内容。</p>\n</blockquote>\n<p>下面我们将分类讨论在随机和平滑的过程中使用的算法思路。</p>\n<h2 id=\"直接使用随机数\"><a href=\"#直接使用随机数\" class=\"headerlink\" title=\"直接使用随机数\"></a>直接使用随机数</h2><p>直接使用<code>rand()</code>等随机函数会存在以下问题：</p>\n<ul>\n<li><strong>不连续性</strong>：随机数的生成是跳跃的，直接使用时无法起到平滑的效果；</li>\n<li><strong>易受影响</strong>：虽然我们可以使用<code>srand()</code>等函数设置随机数的种子来确保随机数的哈希性，但是程序的其他部分可能需要使用时间来初始化随机数种子来获取更灵活的随机数，这就导致在全局环境下生成的随机数不稳定。</li>\n</ul>\n<p>使用如下代码生成的灰度图，可以很清楚地看出其不连续性：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/553721218256326.png\" alt=\"`rand()`随机数灰度图\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height, EW_SHOWCONSOLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>;</span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, <span class=\"built_in\">RGB</span>(val, val, val));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，这并不意味着随机数函数是无用的，我们可以直接使用随机数生成离散的影响点，再根据距离权重进行平滑处理，如《文明6》等游戏中使用的<strong>米切尔候选算法</strong>（Mitchell’s best-candidate algorithm），在处理初期时可以直接使用随机数进行候选节点的生成的，这将在后续的游戏资源生成章节再进行详细讨论。</p>\n<p>在上古项目<a href=\"https://github.com/EtherProject/EtherWorkCollection/tree/main/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E9%AB%98%E5%BA%A6%E5%9B%BE\">随机地图高度图</a>生成过程中，也是使用了简单的先随机后平滑的思路：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/532531818252080.png\" alt=\"随机地图高度图（白色为随机生成的影响点）\"></p>\n</div>\n\n<h2 id=\"平滑的噪声函数\"><a href=\"#平滑的噪声函数\" class=\"headerlink\" title=\"平滑的噪声函数\"></a>平滑的噪声函数</h2><p>在<a href=\"https://www.voidmatrix.work/articles/%E5%9F%BA%E4%BA%8EEasyX%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%89%BA%E6%9C%AF/\">《基于EasyX软渲染实现常见故障艺术》</a>一文中，提供了一种可行的随机噪声函数：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/76072812230849.png\" alt=\"f(x, y) = frac(sin(x * 12.9898 + y * 78.233) * 43758.5453)\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取随机噪声</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">GetRandomNoise</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> val = <span class=\"built_in\">sin</span>(x * <span class=\"number\">12.9898</span> + y * <span class=\"number\">78.233</span>) * <span class=\"number\">43758.5453</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val - <span class=\"built_in\">floor</span>(val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单地，我们也可以使用正弦波叠加的思想处理类似的噪声生成：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/125364318267564.png\" alt=\"简单的正弦波叠加同样可以模拟地形效果\"></p>\n</div>\n\n<p>但是，我们可以很清晰地看出，这种直接使用函数生成的噪声即便可以满足哈希性和连续性，但它们的周期性太强，直接将生成得到的计算结果应用于游戏中会导致整个世界出现大量重复地形，并不能完全满足随机性的要求：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/59555018265066.png\" alt=\"噪声函数存在较强的周期性\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> val_x = <span class=\"built_in\">abs</span>((<span class=\"number\">1</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">1</span>)) + (<span class=\"number\">0.5</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">2</span>)) + (<span class=\"number\">0.25</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">4</span>)) + (<span class=\"number\">0.125</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">8</span>)));</span><br><span class=\"line\">    <span class=\"type\">double</span> val_y = <span class=\"built_in\">abs</span>((<span class=\"number\">1</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">1</span>)) + (<span class=\"number\">0.5</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">2</span>)) + (<span class=\"number\">0.25</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">4</span>)) + (<span class=\"number\">0.125</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">8</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对得到的结果进行归一化</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (val_x + val_y) / ((<span class=\"number\">1</span> + <span class=\"number\">0.5</span> + <span class=\"number\">0.25</span> + <span class=\"number\">0.125</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height, EW_SHOWCONSOLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = (<span class=\"type\">int</span>)(<span class=\"built_in\">noise</span>(x / <span class=\"number\">10</span>, y / <span class=\"number\">10</span>) * <span class=\"number\">255</span>);</span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, <span class=\"built_in\">RGB</span>(val, val, val));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>即便如此，这些生成噪声的方式，同样可以作为<strong>分形噪声</strong>等更进阶的噪声生成时的原始数据。</p>\n<h2 id=\"更进阶的噪声生成\"><a href=\"#更进阶的噪声生成\" class=\"headerlink\" title=\"更进阶的噪声生成\"></a>更进阶的噪声生成</h2><p>有许多已经被实践证明满足上述需求的噪声算法，如：Perlin噪声，Simplex噪声，Wavelet噪声，Value噪声和Worley噪声等，下面将以大名鼎鼎的<strong>柏林噪声</strong>（Perlin）为例讲解实现思路。</p>\n<blockquote>\n<p>柏林噪声本质上可以算是一种非典型的晶格噪声技术，晶格噪声是一种在离散的、规则的网格上生成的噪声，所以晶格噪声通常在规则的格点上有着明确定义的数值，而柏林噪声的特殊之处在于，在使用晶格为单位生成基础噪声后，又通过插值和平滑处理，产生了空间中连续的噪声变化。</p>\n</blockquote>\n<p>柏林噪声的生成可以归纳为三步：</p>\n<ol>\n<li><strong>梯度生成</strong>：在空间中随机生成梯度向量网格，梯度向量由每个整数坐标点（晶格）上随机确定的。这些梯度向量定义了一个在整个空间内变化的方向；</li>\n<li><strong>插值</strong>：当需要计算某一点的噪声值时，首先确定其所处的网格单元，然后计算该点到网格单元内各个梯度向量的距离，并将这些距离用于权重插值，在这个过程中噪声得到了平滑的处理；</li>\n<li><strong>分形</strong>：对生成得到的结果进行不同尺度的缩放和叠加，来生成更具随机性且不同粒度的结果。</li>\n</ol>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/161600919246307.png\" alt=\"柏林噪声灰度图\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成基础噪声值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">fmod</span>(<span class=\"built_in\">sin</span>(x * <span class=\"number\">12.9898</span> + y * <span class=\"number\">78.233</span>) * <span class=\"number\">43758.5453</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成平滑噪声值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">smooth_noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算角落、边和中心的平均噪声值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> corners = (<span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y + <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>)) / <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> sides = (<span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y) + <span class=\"built_in\">noise</span>(x, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x, y + <span class=\"number\">1</span>)) / <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> center = <span class=\"built_in\">noise</span>(x, y) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回平滑噪声值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> corners + sides + center; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线性插值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">interpolate</span><span class=\"params\">(<span class=\"type\">double</span> a, <span class=\"type\">double</span> b, <span class=\"type\">double</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插值权重</span></span><br><span class=\"line\">    <span class=\"type\">double</span> ft = x * <span class=\"number\">3.1415927</span>; </span><br><span class=\"line\">    <span class=\"type\">double</span> f = (<span class=\"number\">1</span> - <span class=\"built_in\">cos</span>(ft)) * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回插值结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (<span class=\"number\">1</span> - f) + b * f; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插值计算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">interpolated_noise</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 提取整数部分和小数部分</span></span><br><span class=\"line\">    <span class=\"type\">int</span> integer_X = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(x);</span><br><span class=\"line\">    <span class=\"type\">double</span> fractional_X = x - integer_X;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> integer_Y = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(y);</span><br><span class=\"line\">    <span class=\"type\">double</span> fractional_Y = y - integer_Y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算插值点的噪声值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> v1 = <span class=\"built_in\">smooth_noise</span>(integer_X, integer_Y);</span><br><span class=\"line\">    <span class=\"type\">double</span> v2 = <span class=\"built_in\">smooth_noise</span>(integer_X + <span class=\"number\">1</span>, integer_Y);</span><br><span class=\"line\">    <span class=\"type\">double</span> v3 = <span class=\"built_in\">smooth_noise</span>(integer_X, integer_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">double</span> v4 = <span class=\"built_in\">smooth_noise</span>(integer_X + <span class=\"number\">1</span>, integer_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> i1 = <span class=\"built_in\">interpolate</span>(v1, v2, fractional_X);</span><br><span class=\"line\">    <span class=\"type\">double</span> i2 = <span class=\"built_in\">interpolate</span>(v3, v4, fractional_X);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回插值后的噪声值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">interpolate</span>(i1, i2, fractional_Y); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 循环生成每个像素点的噪声值并转换为灰度颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 生成插值噪声，并控制噪声的规模</span></span><br><span class=\"line\">            <span class=\"type\">double</span> value = <span class=\"built_in\">interpolated_noise</span>(x / <span class=\"number\">50.0</span>, y / <span class=\"number\">50.0</span>); </span><br><span class=\"line\">            <span class=\"comment\">// 将噪声值转换为灰度颜色</span></span><br><span class=\"line\">            COLORREF color = <span class=\"built_in\">RGB</span>((<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>),</span><br><span class=\"line\">                (<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>), (<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>)); </span><br><span class=\"line\">            <span class=\"comment\">// 在指定位置绘制像素</span></span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, color); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/87331419268747.png\" alt=\"“痛苦终结者”\"></p>\n</div>\n\n<div style=\"text-align:center\">\n\n<p>&gt;&gt;&gt;  <a href=\"https://www.voidmatrix.work/articles/pcg-game-map-1/\">在 Voidmatrix’s Blog 上查看本文章</a>  &lt;&lt;&lt;</p>\n</div>","site":{"data":{}},"excerpt":"<p>使用 <strong>程序化内容生成（PCG）</strong> 的优势：</p>\n<ul>\n<li>无限地图内容：两个维度，一是单次游玩的地图内容趋近于无限，即无限大世界；二是可以生成近似无限多的世界，提升游戏的可重复游玩性；</li>\n<li>节省开发成本：开发者只需要定义生成规则来描述世界最底层的机制，而不需要从上到下事无巨细地完成玩家可游玩的全部内容；</li>\n<li>挑战与变化：使用程序生成地图可以很好地控制随机性，给玩家创造挑战的机会，更具趣味性；</li>\n<li>动态难度调整：使用规则描述世界生成可以站在更高的维度去调控世界资源，更好地平衡游戏难度或创造特殊难度的世界。</li>\n</ul>\n<p>在大多数情况下，程序化生成地图的游戏也并不能完全地摆脱传统的手工制作的部分，即便是程序化内容生成主导的世界中，也存在细粒度的部分需要开发者进行人工设计（如 Minecraft 中的村庄等内容），这同样也可以使用更细致的生成规则来描述。</p>","more":"<h2 id=\"生成思路总览\"><a href=\"#生成思路总览\" class=\"headerlink\" title=\"生成思路总览\"></a>生成思路总览</h2><p>对于程序化生成的游戏世界地图，可以使用<strong>分批次地、递归地</strong>类似分形的思想逐步进行细化处理，每一层处理都基本满足以下三个步骤：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/151655416259069.png\" alt=\"每层递归的三个生成步骤\"></p>\n</div>\n\n<ol>\n<li><strong>随机</strong>：根据随机数或噪声算法生成最粗略的数据模板；</li>\n<li><strong>平滑</strong>：根据当前生成内容的维度和粒度对得到的数据进行插值和过渡处理；</li>\n<li><strong>修正</strong>：根据游戏内容和更上层的设计规则调整平滑后的世界。</li>\n</ol>\n<p>一个使用此思想实现的流程可以如下所示：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/202434217267102.png\" alt=\"三步走递归生成示例\"></p>\n</div>\n\n<p>在前两个步骤中，我们需要确保使用的算法满足下列三个条件：</p>\n<ol>\n<li><strong>随机性</strong>：这个过程是随机的，或者说在相当大范围内不会出现重复的生成周期；</li>\n<li><strong>可哈希</strong>：使用相同的随机数输入（种子），得到的随机内容是一致的；</li>\n<li><strong>连续性</strong>：无论粒度大小，生成的内容都是连续且平滑的。</li>\n</ol>\n<blockquote>\n<p>可哈希的特性给游戏的增量存档提供了可能，存储游戏世界信息的存档不需要在初始化生成时便保存全部数据内容，而是可以随着游戏进行，只增量存储玩家探索过或修改过的内容。</p>\n</blockquote>\n<p>下面我们将分类讨论在随机和平滑的过程中使用的算法思路。</p>\n<h2 id=\"直接使用随机数\"><a href=\"#直接使用随机数\" class=\"headerlink\" title=\"直接使用随机数\"></a>直接使用随机数</h2><p>直接使用<code>rand()</code>等随机函数会存在以下问题：</p>\n<ul>\n<li><strong>不连续性</strong>：随机数的生成是跳跃的，直接使用时无法起到平滑的效果；</li>\n<li><strong>易受影响</strong>：虽然我们可以使用<code>srand()</code>等函数设置随机数的种子来确保随机数的哈希性，但是程序的其他部分可能需要使用时间来初始化随机数种子来获取更灵活的随机数，这就导致在全局环境下生成的随机数不稳定。</li>\n</ul>\n<p>使用如下代码生成的灰度图，可以很清楚地看出其不连续性：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/553721218256326.png\" alt=\"`rand()`随机数灰度图\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height, EW_SHOWCONSOLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = <span class=\"built_in\">rand</span>() % <span class=\"number\">255</span>;</span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, <span class=\"built_in\">RGB</span>(val, val, val));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，这并不意味着随机数函数是无用的，我们可以直接使用随机数生成离散的影响点，再根据距离权重进行平滑处理，如《文明6》等游戏中使用的<strong>米切尔候选算法</strong>（Mitchell’s best-candidate algorithm），在处理初期时可以直接使用随机数进行候选节点的生成的，这将在后续的游戏资源生成章节再进行详细讨论。</p>\n<p>在上古项目<a href=\"https://github.com/EtherProject/EtherWorkCollection/tree/main/%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E9%AB%98%E5%BA%A6%E5%9B%BE\">随机地图高度图</a>生成过程中，也是使用了简单的先随机后平滑的思路：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/532531818252080.png\" alt=\"随机地图高度图（白色为随机生成的影响点）\"></p>\n</div>\n\n<h2 id=\"平滑的噪声函数\"><a href=\"#平滑的噪声函数\" class=\"headerlink\" title=\"平滑的噪声函数\"></a>平滑的噪声函数</h2><p>在<a href=\"https://www.voidmatrix.work/articles/%E5%9F%BA%E4%BA%8EEasyX%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%89%BA%E6%9C%AF/\">《基于EasyX软渲染实现常见故障艺术》</a>一文中，提供了一种可行的随机噪声函数：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/76072812230849.png\" alt=\"f(x, y) = frac(sin(x * 12.9898 + y * 78.233) * 43758.5453)\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取随机噪声</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">GetRandomNoise</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> val = <span class=\"built_in\">sin</span>(x * <span class=\"number\">12.9898</span> + y * <span class=\"number\">78.233</span>) * <span class=\"number\">43758.5453</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val - <span class=\"built_in\">floor</span>(val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单地，我们也可以使用正弦波叠加的思想处理类似的噪声生成：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/125364318267564.png\" alt=\"简单的正弦波叠加同样可以模拟地形效果\"></p>\n</div>\n\n<p>但是，我们可以很清晰地看出，这种直接使用函数生成的噪声即便可以满足哈希性和连续性，但它们的周期性太强，直接将生成得到的计算结果应用于游戏中会导致整个世界出现大量重复地形，并不能完全满足随机性的要求：</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/59555018265066.png\" alt=\"噪声函数存在较强的周期性\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> val_x = <span class=\"built_in\">abs</span>((<span class=\"number\">1</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">1</span>)) + (<span class=\"number\">0.5</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">2</span>)) + (<span class=\"number\">0.25</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">4</span>)) + (<span class=\"number\">0.125</span> * <span class=\"built_in\">sin</span>(x * <span class=\"number\">8</span>)));</span><br><span class=\"line\">    <span class=\"type\">double</span> val_y = <span class=\"built_in\">abs</span>((<span class=\"number\">1</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">1</span>)) + (<span class=\"number\">0.5</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">2</span>)) + (<span class=\"number\">0.25</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">4</span>)) + (<span class=\"number\">0.125</span> * <span class=\"built_in\">sin</span>(y * <span class=\"number\">8</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对得到的结果进行归一化</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (val_x + val_y) / ((<span class=\"number\">1</span> + <span class=\"number\">0.5</span> + <span class=\"number\">0.25</span> + <span class=\"number\">0.125</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height, EW_SHOWCONSOLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> val = (<span class=\"type\">int</span>)(<span class=\"built_in\">noise</span>(x / <span class=\"number\">10</span>, y / <span class=\"number\">10</span>) * <span class=\"number\">255</span>);</span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, <span class=\"built_in\">RGB</span>(val, val, val));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>即便如此，这些生成噪声的方式，同样可以作为<strong>分形噪声</strong>等更进阶的噪声生成时的原始数据。</p>\n<h2 id=\"更进阶的噪声生成\"><a href=\"#更进阶的噪声生成\" class=\"headerlink\" title=\"更进阶的噪声生成\"></a>更进阶的噪声生成</h2><p>有许多已经被实践证明满足上述需求的噪声算法，如：Perlin噪声，Simplex噪声，Wavelet噪声，Value噪声和Worley噪声等，下面将以大名鼎鼎的<strong>柏林噪声</strong>（Perlin）为例讲解实现思路。</p>\n<blockquote>\n<p>柏林噪声本质上可以算是一种非典型的晶格噪声技术，晶格噪声是一种在离散的、规则的网格上生成的噪声，所以晶格噪声通常在规则的格点上有着明确定义的数值，而柏林噪声的特殊之处在于，在使用晶格为单位生成基础噪声后，又通过插值和平滑处理，产生了空间中连续的噪声变化。</p>\n</blockquote>\n<p>柏林噪声的生成可以归纳为三步：</p>\n<ol>\n<li><strong>梯度生成</strong>：在空间中随机生成梯度向量网格，梯度向量由每个整数坐标点（晶格）上随机确定的。这些梯度向量定义了一个在整个空间内变化的方向；</li>\n<li><strong>插值</strong>：当需要计算某一点的噪声值时，首先确定其所处的网格单元，然后计算该点到网格单元内各个梯度向量的距离，并将这些距离用于权重插值，在这个过程中噪声得到了平滑的处理；</li>\n<li><strong>分形</strong>：对生成得到的结果进行不同尺度的缩放和叠加，来生成更具随机性且不同粒度的结果。</li>\n</ol>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/161600919246307.png\" alt=\"柏林噪声灰度图\"></p>\n</div>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成基础噪声值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">fmod</span>(<span class=\"built_in\">sin</span>(x * <span class=\"number\">12.9898</span> + y * <span class=\"number\">78.233</span>) * <span class=\"number\">43758.5453</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成平滑噪声值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">smooth_noise</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算角落、边和中心的平均噪声值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> corners = (<span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y + <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>)) / <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> sides = (<span class=\"built_in\">noise</span>(x - <span class=\"number\">1</span>, y) + <span class=\"built_in\">noise</span>(x + <span class=\"number\">1</span>, y) + <span class=\"built_in\">noise</span>(x, y - <span class=\"number\">1</span>) + <span class=\"built_in\">noise</span>(x, y + <span class=\"number\">1</span>)) / <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> center = <span class=\"built_in\">noise</span>(x, y) / <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回平滑噪声值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> corners + sides + center; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线性插值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">interpolate</span><span class=\"params\">(<span class=\"type\">double</span> a, <span class=\"type\">double</span> b, <span class=\"type\">double</span> x)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插值权重</span></span><br><span class=\"line\">    <span class=\"type\">double</span> ft = x * <span class=\"number\">3.1415927</span>; </span><br><span class=\"line\">    <span class=\"type\">double</span> f = (<span class=\"number\">1</span> - <span class=\"built_in\">cos</span>(ft)) * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回插值结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (<span class=\"number\">1</span> - f) + b * f; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插值计算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">interpolated_noise</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 提取整数部分和小数部分</span></span><br><span class=\"line\">    <span class=\"type\">int</span> integer_X = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(x);</span><br><span class=\"line\">    <span class=\"type\">double</span> fractional_X = x - integer_X;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> integer_Y = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(y);</span><br><span class=\"line\">    <span class=\"type\">double</span> fractional_Y = y - integer_Y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算插值点的噪声值</span></span><br><span class=\"line\">    <span class=\"type\">double</span> v1 = <span class=\"built_in\">smooth_noise</span>(integer_X, integer_Y);</span><br><span class=\"line\">    <span class=\"type\">double</span> v2 = <span class=\"built_in\">smooth_noise</span>(integer_X + <span class=\"number\">1</span>, integer_Y);</span><br><span class=\"line\">    <span class=\"type\">double</span> v3 = <span class=\"built_in\">smooth_noise</span>(integer_X, integer_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">double</span> v4 = <span class=\"built_in\">smooth_noise</span>(integer_X + <span class=\"number\">1</span>, integer_Y + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> i1 = <span class=\"built_in\">interpolate</span>(v1, v2, fractional_X);</span><br><span class=\"line\">    <span class=\"type\">double</span> i2 = <span class=\"built_in\">interpolate</span>(v3, v4, fractional_X);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回插值后的噪声值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">interpolate</span>(i1, i2, fractional_Y); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> height = <span class=\"number\">720</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">initgraph</span>(width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 循环生成每个像素点的噪声值并转换为灰度颜色</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt; height; y++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt; width; x++) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 生成插值噪声，并控制噪声的规模</span></span><br><span class=\"line\">            <span class=\"type\">double</span> value = <span class=\"built_in\">interpolated_noise</span>(x / <span class=\"number\">50.0</span>, y / <span class=\"number\">50.0</span>); </span><br><span class=\"line\">            <span class=\"comment\">// 将噪声值转换为灰度颜色</span></span><br><span class=\"line\">            COLORREF color = <span class=\"built_in\">RGB</span>((<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>),</span><br><span class=\"line\">                (<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>), (<span class=\"type\">int</span>)(value * <span class=\"number\">255</span>)); </span><br><span class=\"line\">            <span class=\"comment\">// 在指定位置绘制像素</span></span><br><span class=\"line\">            <span class=\"built_in\">putpixel</span>(x, y, color); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/Voidmatrix/pcg-game-map-1/87331419268747.png\" alt=\"“痛苦终结者”\"></p>\n</div>\n\n<div style=\"text-align:center\">\n\n<p>&gt;&gt;&gt;  <a href=\"https://www.voidmatrix.work/articles/pcg-game-map-1/\">在 Voidmatrix’s Blog 上查看本文章</a>  &lt;&lt;&lt;</p>\n</div>"},{"title":"博客第一步：将Hexo部署在GitHub上","date":"2024-04-09T16:00:00.000Z","_content":"\nHexo 是一个快速、简单且强大的静态博客框架，与 GitHub 结合使用可轻松搭建个人博客网站。\n\n<!-- more -->\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。其主题，模板也更加丰富多样，更适合创建功能丰富的个人博客或其他类型的静态网站。\n\n## Quick Start\n\n接下来，我将分享我在GitHub上部署Hexo的过程步骤，并给出其中我遇到的一些困难与解决方法。。\n\n### 1.安装Node\n\nHexo是一个基于Node.js的静态网站生成器，需要在本地安装Node.js环境，并通过命令行来创建、编译和部署网站。\n\n下载链接: [Node](https://nodejs.cn/)\n\n### 2.安装Sublime text\n\n这个算是文本编辑器，但功能更加强大，有许多妙用。\n\n下载链接: [Sublime text](https://www.sublimetext.com/)\n\n### 3.下载Git\n\n下载链接: [Git](https://git-scm.com/)\n\n#### 基本配置Git\n\n打开gitbush终端输入一下指令（名字邮箱皆与GitHub相关），这将关系到你是否能将仓库推送到GitHub上\n\na.配置昵称，邮箱\n\n``` bash\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"your.email@example.com\"\n```\n\nb.生成ssh\n\n``` bash\n$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"         //生成ssh密钥\n```\n\nc.添加 SSH 公钥到GitHub账户\n\n#### 使用Git链接远程仓库（后续会使用到）\n\n需要替换url\n\n``` bash\n$ git init          //初始化仓库\n$ git remote add origin https://github.com/exampleuser/example.git    \n$ git remote -v     //查看是否关联成功\n```\n\n### 4.创建GitHub仓库\n\n建立一个公共仓库，仓库名：<你的 GitHub 用户名>.github.io\neg：Dream-verylively.github.io\n\n### 5.配置并使用Hexo\n\na.配置hexo\n\n这个步骤将生成blog文件夹，接下来的诸多操作将围绕这个文件夹进行\n\n``` bash\n$ npm install hexo-cli -g       //安装 Hexo CLI（命令行工具）到全局环境\n$ hexo init blog                //始化 Hexo 博客，创建一个名为 \"blog\" 的目录，并在其中初始化 Hexo（名字可更改）\n$ cd blog                       //进入到刚创建的 \"blog\" 目录中\n$ npm install                   //npm install\n$ hexo server                   //启动 Hexo 服务器，用于本地预览您的博客\n```\n\nMore info: [hexo](https://hexo.io/zh-cn/)\n\nb.编辑你的 _config.yml\n\n第一处\n![ICON](articles/shuo-liu16/deploy-hexo/1.png)\n第二处\n![ICON](articles/shuo-liu16/deploy-hexo/2.png)\n\nc.在博客文件夹下打开终端执行以下命令\n\n``` bash\n$ hexo clean            //清理 Hexo 生成的静态文件和缓存\n$ hexo g                //使用 Hexo 生成静态文件，将 Markdown 格式的文章转换为 HTML 等静态文件\n$ hexo deploy           //部署生成的静态文件到指定的部署目标（例如 GitHub Pages、FTP 等）\n```\n\n### GithubPages 404问题\n\n#### 1、github 仓库名称不匹配\n\n在 github 上面创建的仓库名称没有使用自己的 github 账号名称，例如你的 github 账号名称是 zhanghao，而你创建的仓库名称是 suibian.github.io，这样你是无法访问你的博客网站的。\n\n#### 2、配置文件错误\n\n在你的本地博客目录下（我创建的名称是 hexo，注意不是 themes 主题目录下的那个配置文件），有个配置文件 _config.yml，注意观察里边的内容是否符合条件。\n\n#### 3、分支错误\n\n注意提交的分支要与GitHub仓库中的默认分支一致\n\n#### 4、hexo 依赖不全\n\n检查依赖安装是否有不全的情况，可以使用 npm list 命令\n\n``` bash\n$ npm list --depth 0\n```\n\n如果检查有问题，会在控制台提示类似 npm ERR! missing xxxxx。\n\n#### 5.版本不匹配问题（node与hexo）\n\n``` bash\n$ node -v           //检查两者的版本\n$ hexo -v\n```\n\n看这个：[版本限制](https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6)\n\n###### 写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。","source":"_posts/shuo-liu16/deploy-Hexo-2024-04-10.md","raw":"---\ntitle: 博客第一步：将Hexo部署在GitHub上\n# author: shuo-liu16\ndate: 2024-4-10\npermalink: articles/shuo-liu16/deploy-hexo/\ncategories: shuo-liu16\ntags: hexo\n---\n\nHexo 是一个快速、简单且强大的静态博客框架，与 GitHub 结合使用可轻松搭建个人博客网站。\n\n<!-- more -->\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。其主题，模板也更加丰富多样，更适合创建功能丰富的个人博客或其他类型的静态网站。\n\n## Quick Start\n\n接下来，我将分享我在GitHub上部署Hexo的过程步骤，并给出其中我遇到的一些困难与解决方法。。\n\n### 1.安装Node\n\nHexo是一个基于Node.js的静态网站生成器，需要在本地安装Node.js环境，并通过命令行来创建、编译和部署网站。\n\n下载链接: [Node](https://nodejs.cn/)\n\n### 2.安装Sublime text\n\n这个算是文本编辑器，但功能更加强大，有许多妙用。\n\n下载链接: [Sublime text](https://www.sublimetext.com/)\n\n### 3.下载Git\n\n下载链接: [Git](https://git-scm.com/)\n\n#### 基本配置Git\n\n打开gitbush终端输入一下指令（名字邮箱皆与GitHub相关），这将关系到你是否能将仓库推送到GitHub上\n\na.配置昵称，邮箱\n\n``` bash\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"your.email@example.com\"\n```\n\nb.生成ssh\n\n``` bash\n$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"         //生成ssh密钥\n```\n\nc.添加 SSH 公钥到GitHub账户\n\n#### 使用Git链接远程仓库（后续会使用到）\n\n需要替换url\n\n``` bash\n$ git init          //初始化仓库\n$ git remote add origin https://github.com/exampleuser/example.git    \n$ git remote -v     //查看是否关联成功\n```\n\n### 4.创建GitHub仓库\n\n建立一个公共仓库，仓库名：<你的 GitHub 用户名>.github.io\neg：Dream-verylively.github.io\n\n### 5.配置并使用Hexo\n\na.配置hexo\n\n这个步骤将生成blog文件夹，接下来的诸多操作将围绕这个文件夹进行\n\n``` bash\n$ npm install hexo-cli -g       //安装 Hexo CLI（命令行工具）到全局环境\n$ hexo init blog                //始化 Hexo 博客，创建一个名为 \"blog\" 的目录，并在其中初始化 Hexo（名字可更改）\n$ cd blog                       //进入到刚创建的 \"blog\" 目录中\n$ npm install                   //npm install\n$ hexo server                   //启动 Hexo 服务器，用于本地预览您的博客\n```\n\nMore info: [hexo](https://hexo.io/zh-cn/)\n\nb.编辑你的 _config.yml\n\n第一处\n![ICON](articles/shuo-liu16/deploy-hexo/1.png)\n第二处\n![ICON](articles/shuo-liu16/deploy-hexo/2.png)\n\nc.在博客文件夹下打开终端执行以下命令\n\n``` bash\n$ hexo clean            //清理 Hexo 生成的静态文件和缓存\n$ hexo g                //使用 Hexo 生成静态文件，将 Markdown 格式的文章转换为 HTML 等静态文件\n$ hexo deploy           //部署生成的静态文件到指定的部署目标（例如 GitHub Pages、FTP 等）\n```\n\n### GithubPages 404问题\n\n#### 1、github 仓库名称不匹配\n\n在 github 上面创建的仓库名称没有使用自己的 github 账号名称，例如你的 github 账号名称是 zhanghao，而你创建的仓库名称是 suibian.github.io，这样你是无法访问你的博客网站的。\n\n#### 2、配置文件错误\n\n在你的本地博客目录下（我创建的名称是 hexo，注意不是 themes 主题目录下的那个配置文件），有个配置文件 _config.yml，注意观察里边的内容是否符合条件。\n\n#### 3、分支错误\n\n注意提交的分支要与GitHub仓库中的默认分支一致\n\n#### 4、hexo 依赖不全\n\n检查依赖安装是否有不全的情况，可以使用 npm list 命令\n\n``` bash\n$ npm list --depth 0\n```\n\n如果检查有问题，会在控制台提示类似 npm ERR! missing xxxxx。\n\n#### 5.版本不匹配问题（node与hexo）\n\n``` bash\n$ node -v           //检查两者的版本\n$ hexo -v\n```\n\n看这个：[版本限制](https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6)\n\n###### 写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。","slug":"shuo-liu16/deploy-Hexo-2024-04-10","published":1,"updated":"2024-06-10T07:14:15.609Z","__permalink":"articles/shuo-liu16/deploy-hexo/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgk0018o8yecnntceft","content":"<p>Hexo 是一个快速、简单且强大的静态博客框架，与 GitHub 结合使用可轻松搭建个人博客网站。</p>\n<span id=\"more\"></span>\n\n<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。其主题，模板也更加丰富多样，更适合创建功能丰富的个人博客或其他类型的静态网站。</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><p>接下来，我将分享我在GitHub上部署Hexo的过程步骤，并给出其中我遇到的一些困难与解决方法。。</p>\n<h3 id=\"1-安装Node\"><a href=\"#1-安装Node\" class=\"headerlink\" title=\"1.安装Node\"></a>1.安装Node</h3><p>Hexo是一个基于Node.js的静态网站生成器，需要在本地安装Node.js环境，并通过命令行来创建、编译和部署网站。</p>\n<p>下载链接: <a href=\"https://nodejs.cn/\">Node</a></p>\n<h3 id=\"2-安装Sublime-text\"><a href=\"#2-安装Sublime-text\" class=\"headerlink\" title=\"2.安装Sublime text\"></a>2.安装Sublime text</h3><p>这个算是文本编辑器，但功能更加强大，有许多妙用。</p>\n<p>下载链接: <a href=\"https://www.sublimetext.com/\">Sublime text</a></p>\n<h3 id=\"3-下载Git\"><a href=\"#3-下载Git\" class=\"headerlink\" title=\"3.下载Git\"></a>3.下载Git</h3><p>下载链接: <a href=\"https://git-scm.com/\">Git</a></p>\n<h4 id=\"基本配置Git\"><a href=\"#基本配置Git\" class=\"headerlink\" title=\"基本配置Git\"></a>基本配置Git</h4><p>打开gitbush终端输入一下指令（名字邮箱皆与GitHub相关），这将关系到你是否能将仓库推送到GitHub上</p>\n<p>a.配置昵称，邮箱</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">&quot;Your Name&quot;</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">&quot;your.email@example.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>b.生成ssh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C <span class=\"string\">&quot;your_email@example.com&quot;</span>         //生成ssh密钥</span><br></pre></td></tr></table></figure>\n\n<p>c.添加 SSH 公钥到GitHub账户</p>\n<h4 id=\"使用Git链接远程仓库（后续会使用到）\"><a href=\"#使用Git链接远程仓库（后续会使用到）\" class=\"headerlink\" title=\"使用Git链接远程仓库（后续会使用到）\"></a>使用Git链接远程仓库（后续会使用到）</h4><p>需要替换url</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init          //初始化仓库</span><br><span class=\"line\">$ git remote add origin https://github.com/exampleuser/example.git    </span><br><span class=\"line\">$ git remote -v     //查看是否关联成功</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-创建GitHub仓库\"><a href=\"#4-创建GitHub仓库\" class=\"headerlink\" title=\"4.创建GitHub仓库\"></a>4.创建GitHub仓库</h3><p>建立一个公共仓库，仓库名：&lt;你的 GitHub 用户名&gt;.github.io<br>eg：Dream-verylively.github.io</p>\n<h3 id=\"5-配置并使用Hexo\"><a href=\"#5-配置并使用Hexo\" class=\"headerlink\" title=\"5.配置并使用Hexo\"></a>5.配置并使用Hexo</h3><p>a.配置hexo</p>\n<p>这个步骤将生成blog文件夹，接下来的诸多操作将围绕这个文件夹进行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g       //安装 Hexo CLI（命令行工具）到全局环境</span><br><span class=\"line\">$ hexo init blog                //始化 Hexo 博客，创建一个名为 <span class=\"string\">&quot;blog&quot;</span> 的目录，并在其中初始化 Hexo（名字可更改）</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> blog                       //进入到刚创建的 <span class=\"string\">&quot;blog&quot;</span> 目录中</span><br><span class=\"line\">$ npm install                   //npm install</span><br><span class=\"line\">$ hexo server                   //启动 Hexo 服务器，用于本地预览您的博客</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/zh-cn/\">hexo</a></p>\n<p>b.编辑你的 _config.yml</p>\n<p>第一处<br><img src=\"/articles/shuo-liu16/deploy-hexo/1.png\" alt=\"ICON\"><br>第二处<br><img src=\"/articles/shuo-liu16/deploy-hexo/2.png\" alt=\"ICON\"></p>\n<p>c.在博客文件夹下打开终端执行以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean            //清理 Hexo 生成的静态文件和缓存</span><br><span class=\"line\">$ hexo g                //使用 Hexo 生成静态文件，将 Markdown 格式的文章转换为 HTML 等静态文件</span><br><span class=\"line\">$ hexo deploy           //部署生成的静态文件到指定的部署目标（例如 GitHub Pages、FTP 等）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GithubPages-404问题\"><a href=\"#GithubPages-404问题\" class=\"headerlink\" title=\"GithubPages 404问题\"></a>GithubPages 404问题</h3><h4 id=\"1、github-仓库名称不匹配\"><a href=\"#1、github-仓库名称不匹配\" class=\"headerlink\" title=\"1、github 仓库名称不匹配\"></a>1、github 仓库名称不匹配</h4><p>在 github 上面创建的仓库名称没有使用自己的 github 账号名称，例如你的 github 账号名称是 zhanghao，而你创建的仓库名称是 suibian.github.io，这样你是无法访问你的博客网站的。</p>\n<h4 id=\"2、配置文件错误\"><a href=\"#2、配置文件错误\" class=\"headerlink\" title=\"2、配置文件错误\"></a>2、配置文件错误</h4><p>在你的本地博客目录下（我创建的名称是 hexo，注意不是 themes 主题目录下的那个配置文件），有个配置文件 _config.yml，注意观察里边的内容是否符合条件。</p>\n<h4 id=\"3、分支错误\"><a href=\"#3、分支错误\" class=\"headerlink\" title=\"3、分支错误\"></a>3、分支错误</h4><p>注意提交的分支要与GitHub仓库中的默认分支一致</p>\n<h4 id=\"4、hexo-依赖不全\"><a href=\"#4、hexo-依赖不全\" class=\"headerlink\" title=\"4、hexo 依赖不全\"></a>4、hexo 依赖不全</h4><p>检查依赖安装是否有不全的情况，可以使用 npm list 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm list --depth 0</span><br></pre></td></tr></table></figure>\n\n<p>如果检查有问题，会在控制台提示类似 npm ERR! missing xxxxx。</p>\n<h4 id=\"5-版本不匹配问题（node与hexo）\"><a href=\"#5-版本不匹配问题（node与hexo）\" class=\"headerlink\" title=\"5.版本不匹配问题（node与hexo）\"></a>5.版本不匹配问题（node与hexo）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v           //检查两者的版本</span><br><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p>看这个：<a href=\"https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6\">版本限制</a></p>\n<h6 id=\"写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\"><a href=\"#写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\" class=\"headerlink\" title=\"写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\"></a>写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。</h6>","site":{"data":{}},"excerpt":"<p>Hexo 是一个快速、简单且强大的静态博客框架，与 GitHub 结合使用可轻松搭建个人博客网站。</p>","more":"<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。其主题，模板也更加丰富多样，更适合创建功能丰富的个人博客或其他类型的静态网站。</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><p>接下来，我将分享我在GitHub上部署Hexo的过程步骤，并给出其中我遇到的一些困难与解决方法。。</p>\n<h3 id=\"1-安装Node\"><a href=\"#1-安装Node\" class=\"headerlink\" title=\"1.安装Node\"></a>1.安装Node</h3><p>Hexo是一个基于Node.js的静态网站生成器，需要在本地安装Node.js环境，并通过命令行来创建、编译和部署网站。</p>\n<p>下载链接: <a href=\"https://nodejs.cn/\">Node</a></p>\n<h3 id=\"2-安装Sublime-text\"><a href=\"#2-安装Sublime-text\" class=\"headerlink\" title=\"2.安装Sublime text\"></a>2.安装Sublime text</h3><p>这个算是文本编辑器，但功能更加强大，有许多妙用。</p>\n<p>下载链接: <a href=\"https://www.sublimetext.com/\">Sublime text</a></p>\n<h3 id=\"3-下载Git\"><a href=\"#3-下载Git\" class=\"headerlink\" title=\"3.下载Git\"></a>3.下载Git</h3><p>下载链接: <a href=\"https://git-scm.com/\">Git</a></p>\n<h4 id=\"基本配置Git\"><a href=\"#基本配置Git\" class=\"headerlink\" title=\"基本配置Git\"></a>基本配置Git</h4><p>打开gitbush终端输入一下指令（名字邮箱皆与GitHub相关），这将关系到你是否能将仓库推送到GitHub上</p>\n<p>a.配置昵称，邮箱</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">&quot;Your Name&quot;</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">&quot;your.email@example.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>b.生成ssh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C <span class=\"string\">&quot;your_email@example.com&quot;</span>         //生成ssh密钥</span><br></pre></td></tr></table></figure>\n\n<p>c.添加 SSH 公钥到GitHub账户</p>\n<h4 id=\"使用Git链接远程仓库（后续会使用到）\"><a href=\"#使用Git链接远程仓库（后续会使用到）\" class=\"headerlink\" title=\"使用Git链接远程仓库（后续会使用到）\"></a>使用Git链接远程仓库（后续会使用到）</h4><p>需要替换url</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init          //初始化仓库</span><br><span class=\"line\">$ git remote add origin https://github.com/exampleuser/example.git    </span><br><span class=\"line\">$ git remote -v     //查看是否关联成功</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-创建GitHub仓库\"><a href=\"#4-创建GitHub仓库\" class=\"headerlink\" title=\"4.创建GitHub仓库\"></a>4.创建GitHub仓库</h3><p>建立一个公共仓库，仓库名：&lt;你的 GitHub 用户名&gt;.github.io<br>eg：Dream-verylively.github.io</p>\n<h3 id=\"5-配置并使用Hexo\"><a href=\"#5-配置并使用Hexo\" class=\"headerlink\" title=\"5.配置并使用Hexo\"></a>5.配置并使用Hexo</h3><p>a.配置hexo</p>\n<p>这个步骤将生成blog文件夹，接下来的诸多操作将围绕这个文件夹进行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g       //安装 Hexo CLI（命令行工具）到全局环境</span><br><span class=\"line\">$ hexo init blog                //始化 Hexo 博客，创建一个名为 <span class=\"string\">&quot;blog&quot;</span> 的目录，并在其中初始化 Hexo（名字可更改）</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> blog                       //进入到刚创建的 <span class=\"string\">&quot;blog&quot;</span> 目录中</span><br><span class=\"line\">$ npm install                   //npm install</span><br><span class=\"line\">$ hexo server                   //启动 Hexo 服务器，用于本地预览您的博客</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/zh-cn/\">hexo</a></p>\n<p>b.编辑你的 _config.yml</p>\n<p>第一处<br><img src=\"/articles/shuo-liu16/deploy-hexo/1.png\" alt=\"ICON\"><br>第二处<br><img src=\"/articles/shuo-liu16/deploy-hexo/2.png\" alt=\"ICON\"></p>\n<p>c.在博客文件夹下打开终端执行以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean            //清理 Hexo 生成的静态文件和缓存</span><br><span class=\"line\">$ hexo g                //使用 Hexo 生成静态文件，将 Markdown 格式的文章转换为 HTML 等静态文件</span><br><span class=\"line\">$ hexo deploy           //部署生成的静态文件到指定的部署目标（例如 GitHub Pages、FTP 等）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GithubPages-404问题\"><a href=\"#GithubPages-404问题\" class=\"headerlink\" title=\"GithubPages 404问题\"></a>GithubPages 404问题</h3><h4 id=\"1、github-仓库名称不匹配\"><a href=\"#1、github-仓库名称不匹配\" class=\"headerlink\" title=\"1、github 仓库名称不匹配\"></a>1、github 仓库名称不匹配</h4><p>在 github 上面创建的仓库名称没有使用自己的 github 账号名称，例如你的 github 账号名称是 zhanghao，而你创建的仓库名称是 suibian.github.io，这样你是无法访问你的博客网站的。</p>\n<h4 id=\"2、配置文件错误\"><a href=\"#2、配置文件错误\" class=\"headerlink\" title=\"2、配置文件错误\"></a>2、配置文件错误</h4><p>在你的本地博客目录下（我创建的名称是 hexo，注意不是 themes 主题目录下的那个配置文件），有个配置文件 _config.yml，注意观察里边的内容是否符合条件。</p>\n<h4 id=\"3、分支错误\"><a href=\"#3、分支错误\" class=\"headerlink\" title=\"3、分支错误\"></a>3、分支错误</h4><p>注意提交的分支要与GitHub仓库中的默认分支一致</p>\n<h4 id=\"4、hexo-依赖不全\"><a href=\"#4、hexo-依赖不全\" class=\"headerlink\" title=\"4、hexo 依赖不全\"></a>4、hexo 依赖不全</h4><p>检查依赖安装是否有不全的情况，可以使用 npm list 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm list --depth 0</span><br></pre></td></tr></table></figure>\n\n<p>如果检查有问题，会在控制台提示类似 npm ERR! missing xxxxx。</p>\n<h4 id=\"5-版本不匹配问题（node与hexo）\"><a href=\"#5-版本不匹配问题（node与hexo）\" class=\"headerlink\" title=\"5.版本不匹配问题（node与hexo）\"></a>5.版本不匹配问题（node与hexo）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v           //检查两者的版本</span><br><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p>看这个：<a href=\"https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6\">版本限制</a></p>\n<h6 id=\"写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\"><a href=\"#写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\" class=\"headerlink\" title=\"写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。\"></a>写在最后：这个过程并不是一帆风顺的，很多时候甚至让我痛苦，但最后我坚持下来了，现在想想尽管痛苦，但是成功了，似乎还不错。</h6>"},{"title":"hszSoft 向大家问好","date":"2024-05-27T16:00:00.000Z","update":"2024-05-27T16:00:00.000Z","_content":"\n各位好，这里是 hszSoft，项目 StardustEngine 的参与者之一。\n\n除了程序以外，本人也爱好编曲，并常年混迹于东方圈。\n\n由于工作原因，StardustEngine 的更新进度非常慢，很长时间看不到一个提交，但这个项目是不会鸽的。\n\n因为比较忙，所以一般也很少看到我发言吧...？\n\n本人研究与游戏相关的多个方向，并会总结一些自己的心得在我的博客中 >>> [hszSoft 的博客](https://hszsoft.com) <<<\n\n早期的一些文章因为其内容不够深入，所以没有全部发布上来，对我正在做的事情感兴趣的小伙伴们，欢迎联系我 >>> https://github.com/hszSoft <<<\n\n相信总有一天，hszSoft 的成果能够让你眼前一亮。","source":"_posts/hszSoft/hello.md","raw":"---\ntitle: hszSoft 向大家问好\ndate: 2024-05-28\nupdate: 2024-05-28\npermalink: articles/hszSoft/hello/\ncategories: hszSoft\ntags: [hszSoft]\n---\n\n各位好，这里是 hszSoft，项目 StardustEngine 的参与者之一。\n\n除了程序以外，本人也爱好编曲，并常年混迹于东方圈。\n\n由于工作原因，StardustEngine 的更新进度非常慢，很长时间看不到一个提交，但这个项目是不会鸽的。\n\n因为比较忙，所以一般也很少看到我发言吧...？\n\n本人研究与游戏相关的多个方向，并会总结一些自己的心得在我的博客中 >>> [hszSoft 的博客](https://hszsoft.com) <<<\n\n早期的一些文章因为其内容不够深入，所以没有全部发布上来，对我正在做的事情感兴趣的小伙伴们，欢迎联系我 >>> https://github.com/hszSoft <<<\n\n相信总有一天，hszSoft 的成果能够让你眼前一亮。","slug":"hszSoft/hello","published":1,"updated":"2024-06-10T07:14:15.609Z","__permalink":"articles/hszSoft/hello/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgk001bo8yeemd78tcv","content":"<p>各位好，这里是 hszSoft，项目 StardustEngine 的参与者之一。</p>\n<p>除了程序以外，本人也爱好编曲，并常年混迹于东方圈。</p>\n<p>由于工作原因，StardustEngine 的更新进度非常慢，很长时间看不到一个提交，但这个项目是不会鸽的。</p>\n<p>因为比较忙，所以一般也很少看到我发言吧…？</p>\n<p>本人研究与游戏相关的多个方向，并会总结一些自己的心得在我的博客中 &gt;&gt;&gt; <a href=\"https://hszsoft.com/\">hszSoft 的博客</a> &lt;&lt;&lt;</p>\n<p>早期的一些文章因为其内容不够深入，所以没有全部发布上来，对我正在做的事情感兴趣的小伙伴们，欢迎联系我 &gt;&gt;&gt; <a href=\"https://github.com/hszSoft\">https://github.com/hszSoft</a> &lt;&lt;&lt;</p>\n<p>相信总有一天，hszSoft 的成果能够让你眼前一亮。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>各位好，这里是 hszSoft，项目 StardustEngine 的参与者之一。</p>\n<p>除了程序以外，本人也爱好编曲，并常年混迹于东方圈。</p>\n<p>由于工作原因，StardustEngine 的更新进度非常慢，很长时间看不到一个提交，但这个项目是不会鸽的。</p>\n<p>因为比较忙，所以一般也很少看到我发言吧…？</p>\n<p>本人研究与游戏相关的多个方向，并会总结一些自己的心得在我的博客中 &gt;&gt;&gt; <a href=\"https://hszsoft.com/\">hszSoft 的博客</a> &lt;&lt;&lt;</p>\n<p>早期的一些文章因为其内容不够深入，所以没有全部发布上来，对我正在做的事情感兴趣的小伙伴们，欢迎联系我 &gt;&gt;&gt; <a href=\"https://github.com/hszSoft\">https://github.com/hszSoft</a> &lt;&lt;&lt;</p>\n<p>相信总有一天，hszSoft 的成果能够让你眼前一亮。</p>\n"},{"title":"suang","date":"2024-05-27T16:00:00.000Z","update":"2024-06-03T16:00:00.000Z","_content":"\n这里是suang的自我介绍~\n\n<!-- More -->\n\n# 我是谁？\n\n<div style=\"text-align:center\">\n\n![是谁呢~](articles/suang/Aboutme/who_am_I.png)\n\n</div>\n\n# suang！\n\n<div style=\"text-align:center\">\n\n![是suang！](articles/suang/Aboutme/suang.png)\n\n</div>\n\n我是suang！一个永远都在追求快乐的人!\n一名很菜但正在学习的大一蒟蒻\n\n\n非常感谢大v老师建立这样一个平台\n希望能够在VSpace里和大家一起学习，共同进步啦~\n\n最后非常非常感谢帮助过我的各位，爱你们~","source":"_posts/suang/Aboutme.md","raw":"---\ntitle: suang\ndate: 2024-05-28\nupdate: 2024-06-04\npermalink: articles/suang/Aboutme/\ncategories: suang\ntags: [suang, 自我介绍]\n---\n\n这里是suang的自我介绍~\n\n<!-- More -->\n\n# 我是谁？\n\n<div style=\"text-align:center\">\n\n![是谁呢~](articles/suang/Aboutme/who_am_I.png)\n\n</div>\n\n# suang！\n\n<div style=\"text-align:center\">\n\n![是suang！](articles/suang/Aboutme/suang.png)\n\n</div>\n\n我是suang！一个永远都在追求快乐的人!\n一名很菜但正在学习的大一蒟蒻\n\n\n非常感谢大v老师建立这样一个平台\n希望能够在VSpace里和大家一起学习，共同进步啦~\n\n最后非常非常感谢帮助过我的各位，爱你们~","slug":"suang/Aboutme","published":1,"updated":"2024-06-10T07:14:15.609Z","__permalink":"articles/suang/Aboutme/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgl001do8yeeffv3tdm","content":"<p>这里是suang的自我介绍~</p>\n<span id=\"more\"></span>\n\n<h1 id=\"我是谁？\"><a href=\"#我是谁？\" class=\"headerlink\" title=\"我是谁？\"></a>我是谁？</h1><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/Aboutme/who_am_I.png\" alt=\"是谁呢~\"></p>\n</div>\n\n<h1 id=\"suang！\"><a href=\"#suang！\" class=\"headerlink\" title=\"suang！\"></a>suang！</h1><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/Aboutme/suang.png\" alt=\"是suang！\"></p>\n</div>\n\n<p>我是suang！一个永远都在追求快乐的人!<br>一名很菜但正在学习的大一蒟蒻</p>\n<p>非常感谢大v老师建立这样一个平台<br>希望能够在VSpace里和大家一起学习，共同进步啦~</p>\n<p>最后非常非常感谢帮助过我的各位，爱你们~</p>\n","site":{"data":{}},"excerpt":"<p>这里是suang的自我介绍~</p>","more":"<h1 id=\"我是谁？\"><a href=\"#我是谁？\" class=\"headerlink\" title=\"我是谁？\"></a>我是谁？</h1><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/Aboutme/who_am_I.png\" alt=\"是谁呢~\"></p>\n</div>\n\n<h1 id=\"suang！\"><a href=\"#suang！\" class=\"headerlink\" title=\"suang！\"></a>suang！</h1><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/Aboutme/suang.png\" alt=\"是suang！\"></p>\n</div>\n\n<p>我是suang！一个永远都在追求快乐的人!<br>一名很菜但正在学习的大一蒟蒻</p>\n<p>非常感谢大v老师建立这样一个平台<br>希望能够在VSpace里和大家一起学习，共同进步啦~</p>\n<p>最后非常非常感谢帮助过我的各位，爱你们~</p>"},{"title":"使用EasyX制作游戏需要读写文件时遇到编码问题的解决方法","date":"2024-05-27T16:00:00.000Z","update":"2024-06-03T16:00:00.000Z","_content":"\n痛苦之子suang又遇到了什么问题呢？\n噢！原来是编码问题！\n快来帮他解决吧！\n痛苦之子~~~乔戈亚~~~~~\n\n<!-- More -->\n\n### 一、编码问题\n例如我们需要从file.txt中读取文字，再使用`outtextxy()`函数向窗口绘制文字。\n查找EasyX的官方文档可知，该函数有两个重载，分别为：`void outtextxy(int x, int y, LPCTSTR str)`和`void outtextxy(int x, int y, TCHAR c)`。\n如果我们的file.txt文件使用GBK或者GB2312编码的话，会导致VS编译器混合utf-8编码和GBK编码，导致程序不能正确绘制文字。\n编码问题一直是令人头痛的问题，这里给出通用的方法论，希望能够带来一些帮助。\n\n### 二、解决方法\n\n#### 1. 重新编码txt文件\n\n首先使用vscode打开file.txt文件，确保文件编码为utf-8。\n\n如果不是utf-8编码，点击选择编码，通过编码重新打开，选择utf-8编码，这时原来的内容会变成乱码，将原来的内容删除，重新输入，保存即可。\n\n#### 2. 代码部分\n\n首先，我们需要用到`std::wstring_convert`，这个标准库需要头文件`#include<codecvt>`，我们定义`string str`，用`static std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;`定义我们所需要的从utf-8编码的字符串到宽字符串的转换器。\n\n打开文件，读取文件内容到str内，使用`from_bytes(str)`函数即可实现字符串的转换，又由于outtextxy没有使用wstring的重载，使用wstring的成员函数`c_str()`即可转换成`wchar_t`字符串，最终，我们用这样的代码将文字绘制在窗口上`outtextxy(10, 10, converter.from_bytes(str).c_str());`。\n\n完整代码如下：\n\n```cpp\n#include<fstream>\n#include<codecvt>\n#include<string>\n#include<iostream>\n#include<graphics.h>\n\nstd::string str;\n\nint main()\n{\n\tinitgraph(500, 500);\n\n\tstatic std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n\n\tstd::ifstream infile(\"file.txt\");\n\tif (!infile)\n\t{\n\t\tstd::cerr << \"无法打开文件\" << std::endl;\n\t\treturn 0;\n\t}\n\tstd::getline(infile, str);\n\tinfile.close();\n\n\twhile (true)\n\t{\n\t\touttextxy(10, 10, converter.from_bytes(str).c_str());\n\t}\n}\n```\n\n### 三、问题延伸\n\n如果我们需要在程序内使用`InputBox`对话框输入，并将输入的内容正确保存在文件里，该如何操作呢。\n首先查看`InputBox`的参数列表`bool InputBox(LPTSTR pString, int nMaxCount, LPCTSTR pPrompt = NULL, LPCTSTR pTitle = NULL, LPCTSTR pDefault = NULL, int width = 0, int height = 0, bool bOnlyOK = true);`，我们关注第一个参数，`InputBox`只接受`&wchar_t`的参数，因此，假设输入的字符串最大长度为256，我们定义`TCHAR buffer[256];`数组来接收输入，写下这样的代码来弹出对话框`InputBox(buffer, 256, _T(\"请输入：\"), _T(\"输入框\"), NULL, 0, 0, TRUE);`打开文件，定义`std::string str;`，仍然使用我们刚才定义的转换器，使用`to_bytes()`函数，即可将输入的内容转换为utf-8字符串。再进行输入即可。\n\n完整代码如下：\n\n```cpp\n#include<fstream>\n#include<codecvt>\n#include<string>\n#include<iostream>\n#include<graphics.h>\n\nint main()\n{\n\tinitgraph(500, 500);\n\n\tstatic std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n\n\tTCHAR buffer[256];\n\tInputBox(buffer, 256, _T(\"请输入：\"), _T(\"输入框\"), NULL, 0, 0, TRUE);\n\n\tstd::ofstream outfile(\"file.txt\");\n\tif (!outfile)\n\t{\n\t\tstd::cerr << \"无法打开文件\" << std::endl;\n\t\treturn 0;\n\t}\n\tstd::string str = converter.to_bytes(buffer);\n\toutfile << str;\n\toutfile.close();\n}\n```\n\n---\n\n说些题外话，suang心事很重，虽然表面看上去什么都不在乎，但是其实内心很脆弱很敏感。\n时常会独自emo，我的朋友跟我说啊，要把不开心的事情说出去，不能憋着。\n其实我是不想憋的，但是我说不出口，或者说我已经不知道怎么去说了，每次难受的时候，就什么都说不出来了，也许发生在我身上的事情真的那么那么复杂，也许只有亲身经历过，才能感同身受，才能知道怎么解开我的心结罢。\n可我没什么文采，写不来文章，又没那么专业，拍不了电影。所以，我想做游戏，在另一个世界里，说我想说但说不出口的，做我想做却没勇气做的，弥补我曾经的遗憾。也许这样，我就真的释然了。\n\n---\n\n做游戏的想法埋下了，我却一直都没去做，一是我确实没什么实力，二是我并不知道如何开始，直到我发现了大V老师......\n\n我真的没想到，大V老师能帮我远程解决问题，当时真的震惊到我了，我跟我的室友炫耀了好久，我真的没想到，在那些卖课的占据b站首页大部分的今天，还有大V老师这样的一股清流。来到群里之后我发现，真的有乐于分享，愿意帮助我的人，suang真的真的很感动。\n","source":"_posts/suang/EasyX_code.md","raw":"---\ntitle: 使用EasyX制作游戏需要读写文件时遇到编码问题的解决方法\ndate: 2024-05-28\nupdate: 2024-06-04\npermalink: articles/suang/EasyX_code/\ncategories: suang\ntags: [c++, 编码, EasyX]\n---\n\n痛苦之子suang又遇到了什么问题呢？\n噢！原来是编码问题！\n快来帮他解决吧！\n痛苦之子~~~乔戈亚~~~~~\n\n<!-- More -->\n\n### 一、编码问题\n例如我们需要从file.txt中读取文字，再使用`outtextxy()`函数向窗口绘制文字。\n查找EasyX的官方文档可知，该函数有两个重载，分别为：`void outtextxy(int x, int y, LPCTSTR str)`和`void outtextxy(int x, int y, TCHAR c)`。\n如果我们的file.txt文件使用GBK或者GB2312编码的话，会导致VS编译器混合utf-8编码和GBK编码，导致程序不能正确绘制文字。\n编码问题一直是令人头痛的问题，这里给出通用的方法论，希望能够带来一些帮助。\n\n### 二、解决方法\n\n#### 1. 重新编码txt文件\n\n首先使用vscode打开file.txt文件，确保文件编码为utf-8。\n\n如果不是utf-8编码，点击选择编码，通过编码重新打开，选择utf-8编码，这时原来的内容会变成乱码，将原来的内容删除，重新输入，保存即可。\n\n#### 2. 代码部分\n\n首先，我们需要用到`std::wstring_convert`，这个标准库需要头文件`#include<codecvt>`，我们定义`string str`，用`static std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;`定义我们所需要的从utf-8编码的字符串到宽字符串的转换器。\n\n打开文件，读取文件内容到str内，使用`from_bytes(str)`函数即可实现字符串的转换，又由于outtextxy没有使用wstring的重载，使用wstring的成员函数`c_str()`即可转换成`wchar_t`字符串，最终，我们用这样的代码将文字绘制在窗口上`outtextxy(10, 10, converter.from_bytes(str).c_str());`。\n\n完整代码如下：\n\n```cpp\n#include<fstream>\n#include<codecvt>\n#include<string>\n#include<iostream>\n#include<graphics.h>\n\nstd::string str;\n\nint main()\n{\n\tinitgraph(500, 500);\n\n\tstatic std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n\n\tstd::ifstream infile(\"file.txt\");\n\tif (!infile)\n\t{\n\t\tstd::cerr << \"无法打开文件\" << std::endl;\n\t\treturn 0;\n\t}\n\tstd::getline(infile, str);\n\tinfile.close();\n\n\twhile (true)\n\t{\n\t\touttextxy(10, 10, converter.from_bytes(str).c_str());\n\t}\n}\n```\n\n### 三、问题延伸\n\n如果我们需要在程序内使用`InputBox`对话框输入，并将输入的内容正确保存在文件里，该如何操作呢。\n首先查看`InputBox`的参数列表`bool InputBox(LPTSTR pString, int nMaxCount, LPCTSTR pPrompt = NULL, LPCTSTR pTitle = NULL, LPCTSTR pDefault = NULL, int width = 0, int height = 0, bool bOnlyOK = true);`，我们关注第一个参数，`InputBox`只接受`&wchar_t`的参数，因此，假设输入的字符串最大长度为256，我们定义`TCHAR buffer[256];`数组来接收输入，写下这样的代码来弹出对话框`InputBox(buffer, 256, _T(\"请输入：\"), _T(\"输入框\"), NULL, 0, 0, TRUE);`打开文件，定义`std::string str;`，仍然使用我们刚才定义的转换器，使用`to_bytes()`函数，即可将输入的内容转换为utf-8字符串。再进行输入即可。\n\n完整代码如下：\n\n```cpp\n#include<fstream>\n#include<codecvt>\n#include<string>\n#include<iostream>\n#include<graphics.h>\n\nint main()\n{\n\tinitgraph(500, 500);\n\n\tstatic std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;\n\n\tTCHAR buffer[256];\n\tInputBox(buffer, 256, _T(\"请输入：\"), _T(\"输入框\"), NULL, 0, 0, TRUE);\n\n\tstd::ofstream outfile(\"file.txt\");\n\tif (!outfile)\n\t{\n\t\tstd::cerr << \"无法打开文件\" << std::endl;\n\t\treturn 0;\n\t}\n\tstd::string str = converter.to_bytes(buffer);\n\toutfile << str;\n\toutfile.close();\n}\n```\n\n---\n\n说些题外话，suang心事很重，虽然表面看上去什么都不在乎，但是其实内心很脆弱很敏感。\n时常会独自emo，我的朋友跟我说啊，要把不开心的事情说出去，不能憋着。\n其实我是不想憋的，但是我说不出口，或者说我已经不知道怎么去说了，每次难受的时候，就什么都说不出来了，也许发生在我身上的事情真的那么那么复杂，也许只有亲身经历过，才能感同身受，才能知道怎么解开我的心结罢。\n可我没什么文采，写不来文章，又没那么专业，拍不了电影。所以，我想做游戏，在另一个世界里，说我想说但说不出口的，做我想做却没勇气做的，弥补我曾经的遗憾。也许这样，我就真的释然了。\n\n---\n\n做游戏的想法埋下了，我却一直都没去做，一是我确实没什么实力，二是我并不知道如何开始，直到我发现了大V老师......\n\n我真的没想到，大V老师能帮我远程解决问题，当时真的震惊到我了，我跟我的室友炫耀了好久，我真的没想到，在那些卖课的占据b站首页大部分的今天，还有大V老师这样的一股清流。来到群里之后我发现，真的有乐于分享，愿意帮助我的人，suang真的真的很感动。\n","slug":"suang/EasyX_code","published":1,"updated":"2024-06-10T07:14:15.609Z","__permalink":"articles/suang/EasyX_code/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgm001io8ye5rbnald2","content":"<p>痛苦之子suang又遇到了什么问题呢？<br>噢！原来是编码问题！<br>快来帮他解决吧！<br>痛苦之子~~~乔戈亚~~~~~</p>\n<span id=\"more\"></span>\n\n<h3 id=\"一、编码问题\"><a href=\"#一、编码问题\" class=\"headerlink\" title=\"一、编码问题\"></a>一、编码问题</h3><p>例如我们需要从file.txt中读取文字，再使用<code>outtextxy()</code>函数向窗口绘制文字。<br>查找EasyX的官方文档可知，该函数有两个重载，分别为：<code>void outtextxy(int x, int y, LPCTSTR str)</code>和<code>void outtextxy(int x, int y, TCHAR c)</code>。<br>如果我们的file.txt文件使用GBK或者GB2312编码的话，会导致VS编译器混合utf-8编码和GBK编码，导致程序不能正确绘制文字。<br>编码问题一直是令人头痛的问题，这里给出通用的方法论，希望能够带来一些帮助。</p>\n<h3 id=\"二、解决方法\"><a href=\"#二、解决方法\" class=\"headerlink\" title=\"二、解决方法\"></a>二、解决方法</h3><h4 id=\"1-重新编码txt文件\"><a href=\"#1-重新编码txt文件\" class=\"headerlink\" title=\"1. 重新编码txt文件\"></a>1. 重新编码txt文件</h4><p>首先使用vscode打开file.txt文件，确保文件编码为utf-8。</p>\n<p>如果不是utf-8编码，点击选择编码，通过编码重新打开，选择utf-8编码，这时原来的内容会变成乱码，将原来的内容删除，重新输入，保存即可。</p>\n<h4 id=\"2-代码部分\"><a href=\"#2-代码部分\" class=\"headerlink\" title=\"2. 代码部分\"></a>2. 代码部分</h4><p>首先，我们需要用到<code>std::wstring_convert</code>，这个标准库需要头文件<code>#include&lt;codecvt&gt;</code>，我们定义<code>string str</code>，用<code>static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; converter;</code>定义我们所需要的从utf-8编码的字符串到宽字符串的转换器。</p>\n<p>打开文件，读取文件内容到str内，使用<code>from_bytes(str)</code>函数即可实现字符串的转换，又由于outtextxy没有使用wstring的重载，使用wstring的成员函数<code>c_str()</code>即可转换成<code>wchar_t</code>字符串，最终，我们用这样的代码将文字绘制在窗口上<code>outtextxy(10, 10, converter.from_bytes(str).c_str());</code>。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;codecvt&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::string str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">initgraph</span>(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> std::wstring_convert&lt;std::codecvt_utf8&lt;<span class=\"type\">wchar_t</span>&gt;, <span class=\"type\">wchar_t</span>&gt; converter;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">std::ifstream <span class=\"title\">infile</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!infile)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::cerr &lt;&lt; <span class=\"string\">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">getline</span>(infile, str);</span><br><span class=\"line\">\tinfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">outtextxy</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, converter.<span class=\"built_in\">from_bytes</span>(str).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、问题延伸\"><a href=\"#三、问题延伸\" class=\"headerlink\" title=\"三、问题延伸\"></a>三、问题延伸</h3><p>如果我们需要在程序内使用<code>InputBox</code>对话框输入，并将输入的内容正确保存在文件里，该如何操作呢。<br>首先查看<code>InputBox</code>的参数列表<code>bool InputBox(LPTSTR pString, int nMaxCount, LPCTSTR pPrompt = NULL, LPCTSTR pTitle = NULL, LPCTSTR pDefault = NULL, int width = 0, int height = 0, bool bOnlyOK = true);</code>，我们关注第一个参数，<code>InputBox</code>只接受<code>&amp;wchar_t</code>的参数，因此，假设输入的字符串最大长度为256，我们定义<code>TCHAR buffer[256];</code>数组来接收输入，写下这样的代码来弹出对话框<code>InputBox(buffer, 256, _T(&quot;请输入：&quot;), _T(&quot;输入框&quot;), NULL, 0, 0, TRUE);</code>打开文件，定义<code>std::string str;</code>，仍然使用我们刚才定义的转换器，使用<code>to_bytes()</code>函数，即可将输入的内容转换为utf-8字符串。再进行输入即可。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;codecvt&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">initgraph</span>(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> std::wstring_convert&lt;std::codecvt_utf8&lt;<span class=\"type\">wchar_t</span>&gt;, <span class=\"type\">wchar_t</span>&gt; converter;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTCHAR buffer[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">InputBox</span>(buffer, <span class=\"number\">256</span>, _T(<span class=\"string\">&quot;请输入：&quot;</span>), _T(<span class=\"string\">&quot;输入框&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, TRUE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">std::ofstream <span class=\"title\">outfile</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!outfile)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::cerr &lt;&lt; <span class=\"string\">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::string str = converter.<span class=\"built_in\">to_bytes</span>(buffer);</span><br><span class=\"line\">\toutfile &lt;&lt; str;</span><br><span class=\"line\">\toutfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>说些题外话，suang心事很重，虽然表面看上去什么都不在乎，但是其实内心很脆弱很敏感。<br>时常会独自emo，我的朋友跟我说啊，要把不开心的事情说出去，不能憋着。<br>其实我是不想憋的，但是我说不出口，或者说我已经不知道怎么去说了，每次难受的时候，就什么都说不出来了，也许发生在我身上的事情真的那么那么复杂，也许只有亲身经历过，才能感同身受，才能知道怎么解开我的心结罢。<br>可我没什么文采，写不来文章，又没那么专业，拍不了电影。所以，我想做游戏，在另一个世界里，说我想说但说不出口的，做我想做却没勇气做的，弥补我曾经的遗憾。也许这样，我就真的释然了。</p>\n<hr>\n<p>做游戏的想法埋下了，我却一直都没去做，一是我确实没什么实力，二是我并不知道如何开始，直到我发现了大V老师……</p>\n<p>我真的没想到，大V老师能帮我远程解决问题，当时真的震惊到我了，我跟我的室友炫耀了好久，我真的没想到，在那些卖课的占据b站首页大部分的今天，还有大V老师这样的一股清流。来到群里之后我发现，真的有乐于分享，愿意帮助我的人，suang真的真的很感动。</p>\n","site":{"data":{}},"excerpt":"<p>痛苦之子suang又遇到了什么问题呢？<br>噢！原来是编码问题！<br>快来帮他解决吧！<br>痛苦之子~~~乔戈亚~~~~~</p>","more":"<h3 id=\"一、编码问题\"><a href=\"#一、编码问题\" class=\"headerlink\" title=\"一、编码问题\"></a>一、编码问题</h3><p>例如我们需要从file.txt中读取文字，再使用<code>outtextxy()</code>函数向窗口绘制文字。<br>查找EasyX的官方文档可知，该函数有两个重载，分别为：<code>void outtextxy(int x, int y, LPCTSTR str)</code>和<code>void outtextxy(int x, int y, TCHAR c)</code>。<br>如果我们的file.txt文件使用GBK或者GB2312编码的话，会导致VS编译器混合utf-8编码和GBK编码，导致程序不能正确绘制文字。<br>编码问题一直是令人头痛的问题，这里给出通用的方法论，希望能够带来一些帮助。</p>\n<h3 id=\"二、解决方法\"><a href=\"#二、解决方法\" class=\"headerlink\" title=\"二、解决方法\"></a>二、解决方法</h3><h4 id=\"1-重新编码txt文件\"><a href=\"#1-重新编码txt文件\" class=\"headerlink\" title=\"1. 重新编码txt文件\"></a>1. 重新编码txt文件</h4><p>首先使用vscode打开file.txt文件，确保文件编码为utf-8。</p>\n<p>如果不是utf-8编码，点击选择编码，通过编码重新打开，选择utf-8编码，这时原来的内容会变成乱码，将原来的内容删除，重新输入，保存即可。</p>\n<h4 id=\"2-代码部分\"><a href=\"#2-代码部分\" class=\"headerlink\" title=\"2. 代码部分\"></a>2. 代码部分</h4><p>首先，我们需要用到<code>std::wstring_convert</code>，这个标准库需要头文件<code>#include&lt;codecvt&gt;</code>，我们定义<code>string str</code>，用<code>static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; converter;</code>定义我们所需要的从utf-8编码的字符串到宽字符串的转换器。</p>\n<p>打开文件，读取文件内容到str内，使用<code>from_bytes(str)</code>函数即可实现字符串的转换，又由于outtextxy没有使用wstring的重载，使用wstring的成员函数<code>c_str()</code>即可转换成<code>wchar_t</code>字符串，最终，我们用这样的代码将文字绘制在窗口上<code>outtextxy(10, 10, converter.from_bytes(str).c_str());</code>。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;codecvt&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::string str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">initgraph</span>(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> std::wstring_convert&lt;std::codecvt_utf8&lt;<span class=\"type\">wchar_t</span>&gt;, <span class=\"type\">wchar_t</span>&gt; converter;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">std::ifstream <span class=\"title\">infile</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!infile)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::cerr &lt;&lt; <span class=\"string\">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::<span class=\"built_in\">getline</span>(infile, str);</span><br><span class=\"line\">\tinfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">outtextxy</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, converter.<span class=\"built_in\">from_bytes</span>(str).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、问题延伸\"><a href=\"#三、问题延伸\" class=\"headerlink\" title=\"三、问题延伸\"></a>三、问题延伸</h3><p>如果我们需要在程序内使用<code>InputBox</code>对话框输入，并将输入的内容正确保存在文件里，该如何操作呢。<br>首先查看<code>InputBox</code>的参数列表<code>bool InputBox(LPTSTR pString, int nMaxCount, LPCTSTR pPrompt = NULL, LPCTSTR pTitle = NULL, LPCTSTR pDefault = NULL, int width = 0, int height = 0, bool bOnlyOK = true);</code>，我们关注第一个参数，<code>InputBox</code>只接受<code>&amp;wchar_t</code>的参数，因此，假设输入的字符串最大长度为256，我们定义<code>TCHAR buffer[256];</code>数组来接收输入，写下这样的代码来弹出对话框<code>InputBox(buffer, 256, _T(&quot;请输入：&quot;), _T(&quot;输入框&quot;), NULL, 0, 0, TRUE);</code>打开文件，定义<code>std::string str;</code>，仍然使用我们刚才定义的转换器，使用<code>to_bytes()</code>函数，即可将输入的内容转换为utf-8字符串。再进行输入即可。</p>\n<p>完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;codecvt&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">initgraph</span>(<span class=\"number\">500</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">static</span> std::wstring_convert&lt;std::codecvt_utf8&lt;<span class=\"type\">wchar_t</span>&gt;, <span class=\"type\">wchar_t</span>&gt; converter;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTCHAR buffer[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">InputBox</span>(buffer, <span class=\"number\">256</span>, _T(<span class=\"string\">&quot;请输入：&quot;</span>), _T(<span class=\"string\">&quot;输入框&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, TRUE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">std::ofstream <span class=\"title\">outfile</span><span class=\"params\">(<span class=\"string\">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!outfile)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::cerr &lt;&lt; <span class=\"string\">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::string str = converter.<span class=\"built_in\">to_bytes</span>(buffer);</span><br><span class=\"line\">\toutfile &lt;&lt; str;</span><br><span class=\"line\">\toutfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>说些题外话，suang心事很重，虽然表面看上去什么都不在乎，但是其实内心很脆弱很敏感。<br>时常会独自emo，我的朋友跟我说啊，要把不开心的事情说出去，不能憋着。<br>其实我是不想憋的，但是我说不出口，或者说我已经不知道怎么去说了，每次难受的时候，就什么都说不出来了，也许发生在我身上的事情真的那么那么复杂，也许只有亲身经历过，才能感同身受，才能知道怎么解开我的心结罢。<br>可我没什么文采，写不来文章，又没那么专业，拍不了电影。所以，我想做游戏，在另一个世界里，说我想说但说不出口的，做我想做却没勇气做的，弥补我曾经的遗憾。也许这样，我就真的释然了。</p>\n<hr>\n<p>做游戏的想法埋下了，我却一直都没去做，一是我确实没什么实力，二是我并不知道如何开始，直到我发现了大V老师……</p>\n<p>我真的没想到，大V老师能帮我远程解决问题，当时真的震惊到我了，我跟我的室友炫耀了好久，我真的没想到，在那些卖课的占据b站首页大部分的今天，还有大V老师这样的一股清流。来到群里之后我发现，真的有乐于分享，愿意帮助我的人，suang真的真的很感动。</p>"},{"title":"使用GitHub Desktop在论坛中发表文章的方法及注意事项","date":"2024-05-27T16:00:00.000Z","update":"2024-06-03T16:00:00.000Z","_content":"\n**suang教你用GitHub Desktop发表文章！**\n**超级简单！超级详细！超级耐心！**\n**一定要看！一看就会！**\n\n<!-- More -->\n\n### 一、提交文章的流程\n\n#### 1. 安装以下工具\n\n- **GitHub Desktop**\n- **VSCode**\n\n#### 2. 将GitHub库中的资源clone到本地\n\n进入 **VoidGameSpace** 论坛的 **GitHub** 库网站，点击 `< > Code` ，选择`Open with GitHub Desktop`将资源克隆到本地。\n\n#### 3. 使用VSCode打开库中资源并进行编辑\n\n切换到 **GitHub Desktop** ，点击 `Open in Visual Studio Code` 即可在 **VSCode** 中进行编辑。\n在左侧资源管理器中打开目录 `/GAMEDEVWEBSITE/source/_posts` 在这个目录下新建一个独立的、专属于自己的文件夹。\n在自己的文件夹中新建 `markdown` 文件，编辑完成保存后返回 **GitHub Desktop** 。 \n\n#### 4. 提交本地代码，将本地所做的更改同步到远程代码库\n\n返回 **GitHub Desktop** 后，会自动跳转到 `Changes` 界面，确认代码无误后，点击 `Commit to main` 进行提交，再点击 `Push origin` 将更改同步到远程代码库。\n\n#### 5. 进入自己的fork，拉取合并更改的请求\n\n回到 **GitHub** 中并刷新网页，此时，一定要在自己fork的文件中！！！\n按照下图方式点击，进入自己的fork，才能进行之后的操作。\n\n<div style=\"text-align:center\">\n\n![xdm一定要记得fork啊，不然我白教了](articles/suang/publish_article/fork_img.png)\n\n</div>\n\n接下来点击 `Pull requests` ，再点击 `New pull request` 拉取合并更改的请求。最后点击 `Create pull request` 生成请求。\n\n#### 6. 等待Vercel部署和大V老师的审核\n\n完成了这一步，恭喜你已经成功将你的文章提交了，接下来就是耐心地等待你的文章通过审核了。\n不过别急着高兴，关于 `markdown` 文件，还有一些注意事项。\n\n### 二、关于markdown文件\n\n#### 1. markdown文件的写法\n\nmarkdown的语法很简单，可以参考 [Markdown 官方教程](https://markdown.com.cn/basic-syntax/) 来进行查找和学习。\n\n#### 2. 注意事项\n\n***敲重点！！！！！***\n\n- **元数据一定不能少！** **元数据一定不能少！** **元数据一定不能少！**\n\n重要的事情说一万遍！\n\n元数据是用两个`---`分割线包围的数据，记录你的文章的**标题**、**上传时间**，**修改时间**、**永久链接**、**目录**、**标签** 这些信息，缺少了元数据的文章无法通过审核。写法如下：\n\n```md\n---\ntitle: 使用GitHub Desktop在论坛中发表文章的方法及注意事项\ndate: 2024-05-28\nupdate: 2024-05-29\npermalink: articles/suang/publish_article/\ncategories: suang\ntags: [suang, 教程, 发表文章]\n---\n```\n- 其中，`permalink` 项要填写 `article/你的专属目录/子目录（可选）/`\n\n虽然子目录是可选项，但是，你也不想把所有的文章都丢在同一个文件夹下吧。真的不要这样做啊！！！\n\n- 元数据中有 `title` 属性不需要写一级标题\n\n- 最好使用 `<!-- More -->` 注释添加概述否则主页文章会全部展开显得很长\n\n### 三、关于图片的插入\n\n#### 1. 导入图片资源\n\n<div style=\"text-align:center\">\n\n![图片在哪里呀？](articles/suang/publish_article/image_pos.png)\n\n</div>\n\n首先，将你所需要的图片资源导入到你的专属文件夹中，然后就可以修改markdown文件啦~\n\n像这样\n```md\n<div style=\"text-align:center\">\n\n![图片在哪里呀？](articles/suang/publish_article/image_pos.png)\n\n</div>\n```\n\n括号里面写上你的图片的相对路径就可以将图片导入啦！\n\n---\n\n真的是保姆级了，正常来说照着我的教程一步一步来应该不会出问题了。\n如果遇到了问题记得在群里@我\n\n**Yeah~**\n","source":"_posts/suang/publish_article.md","raw":"---\ntitle: 使用GitHub Desktop在论坛中发表文章的方法及注意事项\ndate: 2024-05-28\nupdate: 2024-06-04\npermalink: articles/suang/publish_article/\ncategories: suang\ntags: [suang, 教程, 发表文章]\n---\n\n**suang教你用GitHub Desktop发表文章！**\n**超级简单！超级详细！超级耐心！**\n**一定要看！一看就会！**\n\n<!-- More -->\n\n### 一、提交文章的流程\n\n#### 1. 安装以下工具\n\n- **GitHub Desktop**\n- **VSCode**\n\n#### 2. 将GitHub库中的资源clone到本地\n\n进入 **VoidGameSpace** 论坛的 **GitHub** 库网站，点击 `< > Code` ，选择`Open with GitHub Desktop`将资源克隆到本地。\n\n#### 3. 使用VSCode打开库中资源并进行编辑\n\n切换到 **GitHub Desktop** ，点击 `Open in Visual Studio Code` 即可在 **VSCode** 中进行编辑。\n在左侧资源管理器中打开目录 `/GAMEDEVWEBSITE/source/_posts` 在这个目录下新建一个独立的、专属于自己的文件夹。\n在自己的文件夹中新建 `markdown` 文件，编辑完成保存后返回 **GitHub Desktop** 。 \n\n#### 4. 提交本地代码，将本地所做的更改同步到远程代码库\n\n返回 **GitHub Desktop** 后，会自动跳转到 `Changes` 界面，确认代码无误后，点击 `Commit to main` 进行提交，再点击 `Push origin` 将更改同步到远程代码库。\n\n#### 5. 进入自己的fork，拉取合并更改的请求\n\n回到 **GitHub** 中并刷新网页，此时，一定要在自己fork的文件中！！！\n按照下图方式点击，进入自己的fork，才能进行之后的操作。\n\n<div style=\"text-align:center\">\n\n![xdm一定要记得fork啊，不然我白教了](articles/suang/publish_article/fork_img.png)\n\n</div>\n\n接下来点击 `Pull requests` ，再点击 `New pull request` 拉取合并更改的请求。最后点击 `Create pull request` 生成请求。\n\n#### 6. 等待Vercel部署和大V老师的审核\n\n完成了这一步，恭喜你已经成功将你的文章提交了，接下来就是耐心地等待你的文章通过审核了。\n不过别急着高兴，关于 `markdown` 文件，还有一些注意事项。\n\n### 二、关于markdown文件\n\n#### 1. markdown文件的写法\n\nmarkdown的语法很简单，可以参考 [Markdown 官方教程](https://markdown.com.cn/basic-syntax/) 来进行查找和学习。\n\n#### 2. 注意事项\n\n***敲重点！！！！！***\n\n- **元数据一定不能少！** **元数据一定不能少！** **元数据一定不能少！**\n\n重要的事情说一万遍！\n\n元数据是用两个`---`分割线包围的数据，记录你的文章的**标题**、**上传时间**，**修改时间**、**永久链接**、**目录**、**标签** 这些信息，缺少了元数据的文章无法通过审核。写法如下：\n\n```md\n---\ntitle: 使用GitHub Desktop在论坛中发表文章的方法及注意事项\ndate: 2024-05-28\nupdate: 2024-05-29\npermalink: articles/suang/publish_article/\ncategories: suang\ntags: [suang, 教程, 发表文章]\n---\n```\n- 其中，`permalink` 项要填写 `article/你的专属目录/子目录（可选）/`\n\n虽然子目录是可选项，但是，你也不想把所有的文章都丢在同一个文件夹下吧。真的不要这样做啊！！！\n\n- 元数据中有 `title` 属性不需要写一级标题\n\n- 最好使用 `<!-- More -->` 注释添加概述否则主页文章会全部展开显得很长\n\n### 三、关于图片的插入\n\n#### 1. 导入图片资源\n\n<div style=\"text-align:center\">\n\n![图片在哪里呀？](articles/suang/publish_article/image_pos.png)\n\n</div>\n\n首先，将你所需要的图片资源导入到你的专属文件夹中，然后就可以修改markdown文件啦~\n\n像这样\n```md\n<div style=\"text-align:center\">\n\n![图片在哪里呀？](articles/suang/publish_article/image_pos.png)\n\n</div>\n```\n\n括号里面写上你的图片的相对路径就可以将图片导入啦！\n\n---\n\n真的是保姆级了，正常来说照着我的教程一步一步来应该不会出问题了。\n如果遇到了问题记得在群里@我\n\n**Yeah~**\n","slug":"suang/publish_article","published":1,"updated":"2024-06-10T07:14:15.609Z","__permalink":"articles/suang/publish_article/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgm001jo8ye2klu8hcu","content":"<p><strong>suang教你用GitHub Desktop发表文章！</strong><br><strong>超级简单！超级详细！超级耐心！</strong><br><strong>一定要看！一看就会！</strong></p>\n<span id=\"more\"></span>\n\n<h3 id=\"一、提交文章的流程\"><a href=\"#一、提交文章的流程\" class=\"headerlink\" title=\"一、提交文章的流程\"></a>一、提交文章的流程</h3><h4 id=\"1-安装以下工具\"><a href=\"#1-安装以下工具\" class=\"headerlink\" title=\"1. 安装以下工具\"></a>1. 安装以下工具</h4><ul>\n<li><strong>GitHub Desktop</strong></li>\n<li><strong>VSCode</strong></li>\n</ul>\n<h4 id=\"2-将GitHub库中的资源clone到本地\"><a href=\"#2-将GitHub库中的资源clone到本地\" class=\"headerlink\" title=\"2. 将GitHub库中的资源clone到本地\"></a>2. 将GitHub库中的资源clone到本地</h4><p>进入 <strong>VoidGameSpace</strong> 论坛的 <strong>GitHub</strong> 库网站，点击 <code>&lt; &gt; Code</code> ，选择<code>Open with GitHub Desktop</code>将资源克隆到本地。</p>\n<h4 id=\"3-使用VSCode打开库中资源并进行编辑\"><a href=\"#3-使用VSCode打开库中资源并进行编辑\" class=\"headerlink\" title=\"3. 使用VSCode打开库中资源并进行编辑\"></a>3. 使用VSCode打开库中资源并进行编辑</h4><p>切换到 <strong>GitHub Desktop</strong> ，点击 <code>Open in Visual Studio Code</code> 即可在 <strong>VSCode</strong> 中进行编辑。<br>在左侧资源管理器中打开目录 <code>/GAMEDEVWEBSITE/source/_posts</code> 在这个目录下新建一个独立的、专属于自己的文件夹。<br>在自己的文件夹中新建 <code>markdown</code> 文件，编辑完成保存后返回 <strong>GitHub Desktop</strong> 。 </p>\n<h4 id=\"4-提交本地代码，将本地所做的更改同步到远程代码库\"><a href=\"#4-提交本地代码，将本地所做的更改同步到远程代码库\" class=\"headerlink\" title=\"4. 提交本地代码，将本地所做的更改同步到远程代码库\"></a>4. 提交本地代码，将本地所做的更改同步到远程代码库</h4><p>返回 <strong>GitHub Desktop</strong> 后，会自动跳转到 <code>Changes</code> 界面，确认代码无误后，点击 <code>Commit to main</code> 进行提交，再点击 <code>Push origin</code> 将更改同步到远程代码库。</p>\n<h4 id=\"5-进入自己的fork，拉取合并更改的请求\"><a href=\"#5-进入自己的fork，拉取合并更改的请求\" class=\"headerlink\" title=\"5. 进入自己的fork，拉取合并更改的请求\"></a>5. 进入自己的fork，拉取合并更改的请求</h4><p>回到 <strong>GitHub</strong> 中并刷新网页，此时，一定要在自己fork的文件中！！！<br>按照下图方式点击，进入自己的fork，才能进行之后的操作。</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/publish_article/fork_img.png\" alt=\"xdm一定要记得fork啊，不然我白教了\"></p>\n</div>\n\n<p>接下来点击 <code>Pull requests</code> ，再点击 <code>New pull request</code> 拉取合并更改的请求。最后点击 <code>Create pull request</code> 生成请求。</p>\n<h4 id=\"6-等待Vercel部署和大V老师的审核\"><a href=\"#6-等待Vercel部署和大V老师的审核\" class=\"headerlink\" title=\"6. 等待Vercel部署和大V老师的审核\"></a>6. 等待Vercel部署和大V老师的审核</h4><p>完成了这一步，恭喜你已经成功将你的文章提交了，接下来就是耐心地等待你的文章通过审核了。<br>不过别急着高兴，关于 <code>markdown</code> 文件，还有一些注意事项。</p>\n<h3 id=\"二、关于markdown文件\"><a href=\"#二、关于markdown文件\" class=\"headerlink\" title=\"二、关于markdown文件\"></a>二、关于markdown文件</h3><h4 id=\"1-markdown文件的写法\"><a href=\"#1-markdown文件的写法\" class=\"headerlink\" title=\"1. markdown文件的写法\"></a>1. markdown文件的写法</h4><p>markdown的语法很简单，可以参考 <a href=\"https://markdown.com.cn/basic-syntax/\">Markdown 官方教程</a> 来进行查找和学习。</p>\n<h4 id=\"2-注意事项\"><a href=\"#2-注意事项\" class=\"headerlink\" title=\"2. 注意事项\"></a>2. 注意事项</h4><p><em><strong>敲重点！！！！！</strong></em></p>\n<ul>\n<li><strong>元数据一定不能少！</strong> <strong>元数据一定不能少！</strong> <strong>元数据一定不能少！</strong></li>\n</ul>\n<p>重要的事情说一万遍！</p>\n<p>元数据是用两个<code>---</code>分割线包围的数据，记录你的文章的<strong>标题</strong>、<strong>上传时间</strong>，<strong>修改时间</strong>、<strong>永久链接</strong>、<strong>目录</strong>、<strong>标签</strong> 这些信息，缺少了元数据的文章无法通过审核。写法如下：</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 使用GitHub Desktop在论坛中发表文章的方法及注意事项</span><br><span class=\"line\">date: 2024-05-28</span><br><span class=\"line\">update: 2024-05-29</span><br><span class=\"line\">permalink: articles/suang/publish<span class=\"emphasis\">_article/</span></span><br><span class=\"line\"><span class=\"emphasis\">categories: suang</span></span><br><span class=\"line\"><span class=\"emphasis\">tags: [suang, 教程, 发表文章]</span></span><br><span class=\"line\"><span class=\"emphasis\">---</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中，<code>permalink</code> 项要填写 <code>article/你的专属目录/子目录（可选）/</code></li>\n</ul>\n<p>虽然子目录是可选项，但是，你也不想把所有的文章都丢在同一个文件夹下吧。真的不要这样做啊！！！</p>\n<ul>\n<li><p>元数据中有 <code>title</code> 属性不需要写一级标题</p>\n</li>\n<li><p>最好使用 <code>&lt;!-- More --&gt;</code> 注释添加概述否则主页文章会全部展开显得很长</p>\n</li>\n</ul>\n<h3 id=\"三、关于图片的插入\"><a href=\"#三、关于图片的插入\" class=\"headerlink\" title=\"三、关于图片的插入\"></a>三、关于图片的插入</h3><h4 id=\"1-导入图片资源\"><a href=\"#1-导入图片资源\" class=\"headerlink\" title=\"1. 导入图片资源\"></a>1. 导入图片资源</h4><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/publish_article/image_pos.png\" alt=\"图片在哪里呀？\"></p>\n</div>\n\n<p>首先，将你所需要的图片资源导入到你的专属文件夹中，然后就可以修改markdown文件啦~</p>\n<p>像这样</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;text-align:center&quot;</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">![<span class=\"string\">图片在哪里呀？</span>](<span class=\"link\">articles/suang/publish_article/image_pos.png</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>括号里面写上你的图片的相对路径就可以将图片导入啦！</p>\n<hr>\n<p>真的是保姆级了，正常来说照着我的教程一步一步来应该不会出问题了。<br>如果遇到了问题记得在群里@我</p>\n<p><strong>Yeah~</strong></p>\n","site":{"data":{}},"excerpt":"<p><strong>suang教你用GitHub Desktop发表文章！</strong><br><strong>超级简单！超级详细！超级耐心！</strong><br><strong>一定要看！一看就会！</strong></p>","more":"<h3 id=\"一、提交文章的流程\"><a href=\"#一、提交文章的流程\" class=\"headerlink\" title=\"一、提交文章的流程\"></a>一、提交文章的流程</h3><h4 id=\"1-安装以下工具\"><a href=\"#1-安装以下工具\" class=\"headerlink\" title=\"1. 安装以下工具\"></a>1. 安装以下工具</h4><ul>\n<li><strong>GitHub Desktop</strong></li>\n<li><strong>VSCode</strong></li>\n</ul>\n<h4 id=\"2-将GitHub库中的资源clone到本地\"><a href=\"#2-将GitHub库中的资源clone到本地\" class=\"headerlink\" title=\"2. 将GitHub库中的资源clone到本地\"></a>2. 将GitHub库中的资源clone到本地</h4><p>进入 <strong>VoidGameSpace</strong> 论坛的 <strong>GitHub</strong> 库网站，点击 <code>&lt; &gt; Code</code> ，选择<code>Open with GitHub Desktop</code>将资源克隆到本地。</p>\n<h4 id=\"3-使用VSCode打开库中资源并进行编辑\"><a href=\"#3-使用VSCode打开库中资源并进行编辑\" class=\"headerlink\" title=\"3. 使用VSCode打开库中资源并进行编辑\"></a>3. 使用VSCode打开库中资源并进行编辑</h4><p>切换到 <strong>GitHub Desktop</strong> ，点击 <code>Open in Visual Studio Code</code> 即可在 <strong>VSCode</strong> 中进行编辑。<br>在左侧资源管理器中打开目录 <code>/GAMEDEVWEBSITE/source/_posts</code> 在这个目录下新建一个独立的、专属于自己的文件夹。<br>在自己的文件夹中新建 <code>markdown</code> 文件，编辑完成保存后返回 <strong>GitHub Desktop</strong> 。 </p>\n<h4 id=\"4-提交本地代码，将本地所做的更改同步到远程代码库\"><a href=\"#4-提交本地代码，将本地所做的更改同步到远程代码库\" class=\"headerlink\" title=\"4. 提交本地代码，将本地所做的更改同步到远程代码库\"></a>4. 提交本地代码，将本地所做的更改同步到远程代码库</h4><p>返回 <strong>GitHub Desktop</strong> 后，会自动跳转到 <code>Changes</code> 界面，确认代码无误后，点击 <code>Commit to main</code> 进行提交，再点击 <code>Push origin</code> 将更改同步到远程代码库。</p>\n<h4 id=\"5-进入自己的fork，拉取合并更改的请求\"><a href=\"#5-进入自己的fork，拉取合并更改的请求\" class=\"headerlink\" title=\"5. 进入自己的fork，拉取合并更改的请求\"></a>5. 进入自己的fork，拉取合并更改的请求</h4><p>回到 <strong>GitHub</strong> 中并刷新网页，此时，一定要在自己fork的文件中！！！<br>按照下图方式点击，进入自己的fork，才能进行之后的操作。</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/publish_article/fork_img.png\" alt=\"xdm一定要记得fork啊，不然我白教了\"></p>\n</div>\n\n<p>接下来点击 <code>Pull requests</code> ，再点击 <code>New pull request</code> 拉取合并更改的请求。最后点击 <code>Create pull request</code> 生成请求。</p>\n<h4 id=\"6-等待Vercel部署和大V老师的审核\"><a href=\"#6-等待Vercel部署和大V老师的审核\" class=\"headerlink\" title=\"6. 等待Vercel部署和大V老师的审核\"></a>6. 等待Vercel部署和大V老师的审核</h4><p>完成了这一步，恭喜你已经成功将你的文章提交了，接下来就是耐心地等待你的文章通过审核了。<br>不过别急着高兴，关于 <code>markdown</code> 文件，还有一些注意事项。</p>\n<h3 id=\"二、关于markdown文件\"><a href=\"#二、关于markdown文件\" class=\"headerlink\" title=\"二、关于markdown文件\"></a>二、关于markdown文件</h3><h4 id=\"1-markdown文件的写法\"><a href=\"#1-markdown文件的写法\" class=\"headerlink\" title=\"1. markdown文件的写法\"></a>1. markdown文件的写法</h4><p>markdown的语法很简单，可以参考 <a href=\"https://markdown.com.cn/basic-syntax/\">Markdown 官方教程</a> 来进行查找和学习。</p>\n<h4 id=\"2-注意事项\"><a href=\"#2-注意事项\" class=\"headerlink\" title=\"2. 注意事项\"></a>2. 注意事项</h4><p><em><strong>敲重点！！！！！</strong></em></p>\n<ul>\n<li><strong>元数据一定不能少！</strong> <strong>元数据一定不能少！</strong> <strong>元数据一定不能少！</strong></li>\n</ul>\n<p>重要的事情说一万遍！</p>\n<p>元数据是用两个<code>---</code>分割线包围的数据，记录你的文章的<strong>标题</strong>、<strong>上传时间</strong>，<strong>修改时间</strong>、<strong>永久链接</strong>、<strong>目录</strong>、<strong>标签</strong> 这些信息，缺少了元数据的文章无法通过审核。写法如下：</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 使用GitHub Desktop在论坛中发表文章的方法及注意事项</span><br><span class=\"line\">date: 2024-05-28</span><br><span class=\"line\">update: 2024-05-29</span><br><span class=\"line\">permalink: articles/suang/publish<span class=\"emphasis\">_article/</span></span><br><span class=\"line\"><span class=\"emphasis\">categories: suang</span></span><br><span class=\"line\"><span class=\"emphasis\">tags: [suang, 教程, 发表文章]</span></span><br><span class=\"line\"><span class=\"emphasis\">---</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中，<code>permalink</code> 项要填写 <code>article/你的专属目录/子目录（可选）/</code></li>\n</ul>\n<p>虽然子目录是可选项，但是，你也不想把所有的文章都丢在同一个文件夹下吧。真的不要这样做啊！！！</p>\n<ul>\n<li><p>元数据中有 <code>title</code> 属性不需要写一级标题</p>\n</li>\n<li><p>最好使用 <code>&lt;!-- More --&gt;</code> 注释添加概述否则主页文章会全部展开显得很长</p>\n</li>\n</ul>\n<h3 id=\"三、关于图片的插入\"><a href=\"#三、关于图片的插入\" class=\"headerlink\" title=\"三、关于图片的插入\"></a>三、关于图片的插入</h3><h4 id=\"1-导入图片资源\"><a href=\"#1-导入图片资源\" class=\"headerlink\" title=\"1. 导入图片资源\"></a>1. 导入图片资源</h4><div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/publish_article/image_pos.png\" alt=\"图片在哪里呀？\"></p>\n</div>\n\n<p>首先，将你所需要的图片资源导入到你的专属文件夹中，然后就可以修改markdown文件啦~</p>\n<p>像这样</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;text-align:center&quot;</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">![<span class=\"string\">图片在哪里呀？</span>](<span class=\"link\">articles/suang/publish_article/image_pos.png</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>括号里面写上你的图片的相对路径就可以将图片导入啦！</p>\n<hr>\n<p>真的是保姆级了，正常来说照着我的教程一步一步来应该不会出问题了。<br>如果遇到了问题记得在群里@我</p>\n<p><strong>Yeah~</strong></p>"},{"title":"奥日与萤火意志2","date":"2024-05-30T16:00:00.000Z","updated":"2024-05-30T16:00:00.000Z","_content":"\n# 玩奥日有感（真随笔）\n\n<!-- More -->\n\n## 剧情上\n- 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。\n这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图\n解锁了地底下和森林的碎片\n唤醒了底下的蜘蛛（被腐朽吞噬了心智）\n夸洛克牺牲了自我换回碎片\n\n- 剧情就不得不提到npc了\n莫基——路人角色，大大小小的任务都有承担，森林的原住民算是\n库克——地图提供者\n猴子——推动剧情，教会武器方面技能\n商人——交易升级技能\n夸洛克——沼泽的庇护神\n工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情\n\n\n- 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候\n\n\n- 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡\n\n\n- 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器\n\n\n## 玩法上\n在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。\n在角色系统我会介绍这些对玩法的贡献\n\n主要是——场景，场景关卡设置，物品和玩法剖析\n- 场景的关卡\n前期的最大关卡就是\n【1】找到散落的楔石打开石门\n小的关卡\n【2】\n拖拽石头来阻挡机关和帮助跳跃\n还有类似司机挡位的机关——触发一些机关，打开石门等等\n【3】\n还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏\n\n- 场景物品\n藤条——帮助跳跃\n竖直木棒——陷阱悬停\n水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）\n灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了\n羽毛——\n还有库和奥日的配合玩法——\n\n补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯\n\n\n\n\n- 玩法\n其实有的已经融合在以上或者以下的分析里面\n主要探索，打斗\n剧情的玩法——\n对话\n打斗boss等\nboss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣\n\n- 场景\n第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景\n\n## 从角色系统上分析\n主要分为四个部分\n\n- 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）\n\n- 武器+主动技能系统\n从光剑到弓箭到重锤，技能则有光之箭和回血等\n评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。\n光剑——可以打碎一些木板障碍物\n例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速\n重锤——可以打碎石板\n光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）\n其他目前武器目前没有看到对地图探索的作用，有再补充\n\n\n- 不可见的被动技能\n例如二连跳\n抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。\n抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深\n\n\n- 课拆卸购买升级的被动技能\n首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级\n技能框则是探索地图一步一步的去扩展\n讲几个印象比较深的技能:\n攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行\n三连跳——好吧也是默认了，不仅帅而且探索地图确实方便\n其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧\n\n\n（4）美术\n\n\n\n<div style=\"text-align:center\">\n</div>\n<!-- More -->\n\n# 玩奥日有感（真随笔）\n\n\n## 剧情上\n- 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。\n这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图\n解锁了地底下和森林的碎片\n唤醒了底下的蜘蛛（被腐朽吞噬了心智）\n夸洛克牺牲了自我换回碎片\n\n- 剧情就不得不提到npc了\n莫基——路人角色，大大小小的任务都有承担，森林的原住民算是\n库克——地图提供者\n猴子——推动剧情，教会武器方面技能\n商人——交易升级技能\n夸洛克——沼泽的庇护神\n工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情\n\n\n- 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候\n\n\n- 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡\n\n\n- 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器\n\n\n## 玩法上\n在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。\n在角色系统我会介绍这些对玩法的贡献\n\n主要是——场景，场景关卡设置，物品和玩法剖析\n- 场景的关卡\n前期的最大关卡就是\n【1】找到散落的楔石打开石门\n小的关卡\n【2】\n拖拽石头来阻挡机关和帮助跳跃\n还有类似司机挡位的机关——触发一些机关，打开石门等等\n【3】\n还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏\n\n- 场景物品\n藤条——帮助跳跃\n竖直木棒——陷阱悬停\n水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）\n灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了\n羽毛——\n还有库和奥日的配合玩法——\n\n补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯\n\n\n\n\n- 玩法\n其实有的已经融合在以上或者以下的分析里面\n主要探索，打斗\n剧情的玩法——\n对话\n打斗boss等\nboss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣\n\n- 场景\n第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景\n\n## 从角色系统上分析\n主要分为四个部分\n\n- 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）\n\n- 武器+主动技能系统\n从光剑到弓箭到重锤，技能则有光之箭和回血等\n评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。\n光剑——可以打碎一些木板障碍物\n例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速\n重锤——可以打碎石板\n光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）\n其他目前武器目前没有看到对地图探索的作用，有再补充\n\n\n- 不可见的被动技能\n例如二连跳\n抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。\n抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深\n\n\n- 课拆卸购买升级的被动技能\n首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级\n技能框则是探索地图一步一步的去扩展\n讲几个印象比较深的技能:\n攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行\n三连跳——好吧也是默认了，不仅帅而且探索地图确实方便\n其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧\n\n\n（4）美术\n\n\n\n<div style=\"text-align:center\">\n</div>","source":"_posts/yang/奥日与萤火意志2.md","raw":"---\ntitle: 奥日与萤火意志2\ndate: 2024-05-31\nupdated: 2024-05-31\npermalink: articles/yang12342/奥日与萤火意志2/\ncategories: yang12342\ntags: [游戏心得]\n---\n\n# 玩奥日有感（真随笔）\n\n<!-- More -->\n\n## 剧情上\n- 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。\n这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图\n解锁了地底下和森林的碎片\n唤醒了底下的蜘蛛（被腐朽吞噬了心智）\n夸洛克牺牲了自我换回碎片\n\n- 剧情就不得不提到npc了\n莫基——路人角色，大大小小的任务都有承担，森林的原住民算是\n库克——地图提供者\n猴子——推动剧情，教会武器方面技能\n商人——交易升级技能\n夸洛克——沼泽的庇护神\n工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情\n\n\n- 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候\n\n\n- 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡\n\n\n- 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器\n\n\n## 玩法上\n在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。\n在角色系统我会介绍这些对玩法的贡献\n\n主要是——场景，场景关卡设置，物品和玩法剖析\n- 场景的关卡\n前期的最大关卡就是\n【1】找到散落的楔石打开石门\n小的关卡\n【2】\n拖拽石头来阻挡机关和帮助跳跃\n还有类似司机挡位的机关——触发一些机关，打开石门等等\n【3】\n还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏\n\n- 场景物品\n藤条——帮助跳跃\n竖直木棒——陷阱悬停\n水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）\n灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了\n羽毛——\n还有库和奥日的配合玩法——\n\n补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯\n\n\n\n\n- 玩法\n其实有的已经融合在以上或者以下的分析里面\n主要探索，打斗\n剧情的玩法——\n对话\n打斗boss等\nboss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣\n\n- 场景\n第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景\n\n## 从角色系统上分析\n主要分为四个部分\n\n- 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）\n\n- 武器+主动技能系统\n从光剑到弓箭到重锤，技能则有光之箭和回血等\n评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。\n光剑——可以打碎一些木板障碍物\n例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速\n重锤——可以打碎石板\n光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）\n其他目前武器目前没有看到对地图探索的作用，有再补充\n\n\n- 不可见的被动技能\n例如二连跳\n抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。\n抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深\n\n\n- 课拆卸购买升级的被动技能\n首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级\n技能框则是探索地图一步一步的去扩展\n讲几个印象比较深的技能:\n攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行\n三连跳——好吧也是默认了，不仅帅而且探索地图确实方便\n其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧\n\n\n（4）美术\n\n\n\n<div style=\"text-align:center\">\n</div>\n<!-- More -->\n\n# 玩奥日有感（真随笔）\n\n\n## 剧情上\n- 剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。\n这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图\n解锁了地底下和森林的碎片\n唤醒了底下的蜘蛛（被腐朽吞噬了心智）\n夸洛克牺牲了自我换回碎片\n\n- 剧情就不得不提到npc了\n莫基——路人角色，大大小小的任务都有承担，森林的原住民算是\n库克——地图提供者\n猴子——推动剧情，教会武器方面技能\n商人——交易升级技能\n夸洛克——沼泽的庇护神\n工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情\n\n\n- 还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候\n\n\n- 前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡\n\n\n- 细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器\n\n\n## 玩法上\n在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。\n在角色系统我会介绍这些对玩法的贡献\n\n主要是——场景，场景关卡设置，物品和玩法剖析\n- 场景的关卡\n前期的最大关卡就是\n【1】找到散落的楔石打开石门\n小的关卡\n【2】\n拖拽石头来阻挡机关和帮助跳跃\n还有类似司机挡位的机关——触发一些机关，打开石门等等\n【3】\n还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏\n\n- 场景物品\n藤条——帮助跳跃\n竖直木棒——陷阱悬停\n水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）\n灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了\n羽毛——\n还有库和奥日的配合玩法——\n\n补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯\n\n\n\n\n- 玩法\n其实有的已经融合在以上或者以下的分析里面\n主要探索，打斗\n剧情的玩法——\n对话\n打斗boss等\nboss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣\n\n- 场景\n第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景\n\n## 从角色系统上分析\n主要分为四个部分\n\n- 蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）\n\n- 武器+主动技能系统\n从光剑到弓箭到重锤，技能则有光之箭和回血等\n评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。\n光剑——可以打碎一些木板障碍物\n例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速\n重锤——可以打碎石板\n光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）\n其他目前武器目前没有看到对地图探索的作用，有再补充\n\n\n- 不可见的被动技能\n例如二连跳\n抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。\n抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深\n\n\n- 课拆卸购买升级的被动技能\n首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级\n技能框则是探索地图一步一步的去扩展\n讲几个印象比较深的技能:\n攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行\n三连跳——好吧也是默认了，不仅帅而且探索地图确实方便\n其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧\n\n\n（4）美术\n\n\n\n<div style=\"text-align:center\">\n</div>","slug":"yang/奥日与萤火意志2","published":1,"__permalink":"articles/yang12342/奥日与萤火意志2/","_id":"clx8n2hgw003oo8yeh89ohgvt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"玩奥日有感（真随笔）\"><a href=\"#玩奥日有感（真随笔）\" class=\"headerlink\" title=\"玩奥日有感（真随笔）\"></a>玩奥日有感（真随笔）</h1><span id=\"more\"></span>\n\n<h2 id=\"剧情上\"><a href=\"#剧情上\" class=\"headerlink\" title=\"剧情上\"></a>剧情上</h2><ul>\n<li><p>剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。<br>这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图<br>解锁了地底下和森林的碎片<br>唤醒了底下的蜘蛛（被腐朽吞噬了心智）<br>夸洛克牺牲了自我换回碎片</p>\n</li>\n<li><p>剧情就不得不提到npc了<br>莫基——路人角色，大大小小的任务都有承担，森林的原住民算是<br>库克——地图提供者<br>猴子——推动剧情，教会武器方面技能<br>商人——交易升级技能<br>夸洛克——沼泽的庇护神<br>工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情</p>\n</li>\n<li><p>还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候</p>\n</li>\n<li><p>前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡</p>\n</li>\n<li><p>细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器</p>\n</li>\n</ul>\n<h2 id=\"玩法上\"><a href=\"#玩法上\" class=\"headerlink\" title=\"玩法上\"></a>玩法上</h2><p>在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。<br>在角色系统我会介绍这些对玩法的贡献</p>\n<p>主要是——场景，场景关卡设置，物品和玩法剖析</p>\n<ul>\n<li><p>场景的关卡<br>前期的最大关卡就是<br>【1】找到散落的楔石打开石门<br>小的关卡<br>【2】<br>拖拽石头来阻挡机关和帮助跳跃<br>还有类似司机挡位的机关——触发一些机关，打开石门等等<br>【3】<br>还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏</p>\n</li>\n<li><p>场景物品<br>藤条——帮助跳跃<br>竖直木棒——陷阱悬停<br>水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）<br>灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了<br>羽毛——<br>还有库和奥日的配合玩法——</p>\n</li>\n</ul>\n<p>补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯</p>\n<ul>\n<li><p>玩法<br>其实有的已经融合在以上或者以下的分析里面<br>主要探索，打斗<br>剧情的玩法——<br>对话<br>打斗boss等<br>boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣</p>\n</li>\n<li><p>场景<br>第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景</p>\n</li>\n</ul>\n<h2 id=\"从角色系统上分析\"><a href=\"#从角色系统上分析\" class=\"headerlink\" title=\"从角色系统上分析\"></a>从角色系统上分析</h2><p>主要分为四个部分</p>\n<ul>\n<li><p>蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）</p>\n</li>\n<li><p>武器+主动技能系统<br>从光剑到弓箭到重锤，技能则有光之箭和回血等<br>评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。<br>光剑——可以打碎一些木板障碍物<br>例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速<br>重锤——可以打碎石板<br>光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）<br>其他目前武器目前没有看到对地图探索的作用，有再补充</p>\n</li>\n<li><p>不可见的被动技能<br>例如二连跳<br>抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。<br>抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深</p>\n</li>\n<li><p>课拆卸购买升级的被动技能<br>首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级<br>技能框则是探索地图一步一步的去扩展<br>讲几个印象比较深的技能:<br>攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行<br>三连跳——好吧也是默认了，不仅帅而且探索地图确实方便<br>其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧</p>\n</li>\n</ul>\n<p>（4）美术</p>\n<div style=\"text-align:center\">\n</div>\n<!-- More -->\n\n<h1 id=\"玩奥日有感（真随笔）-1\"><a href=\"#玩奥日有感（真随笔）-1\" class=\"headerlink\" title=\"玩奥日有感（真随笔）\"></a>玩奥日有感（真随笔）</h1><h2 id=\"剧情上-1\"><a href=\"#剧情上-1\" class=\"headerlink\" title=\"剧情上\"></a>剧情上</h2><ul>\n<li><p>剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。<br>这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图<br>解锁了地底下和森林的碎片<br>唤醒了底下的蜘蛛（被腐朽吞噬了心智）<br>夸洛克牺牲了自我换回碎片</p>\n</li>\n<li><p>剧情就不得不提到npc了<br>莫基——路人角色，大大小小的任务都有承担，森林的原住民算是<br>库克——地图提供者<br>猴子——推动剧情，教会武器方面技能<br>商人——交易升级技能<br>夸洛克——沼泽的庇护神<br>工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情</p>\n</li>\n<li><p>还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候</p>\n</li>\n<li><p>前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡</p>\n</li>\n<li><p>细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器</p>\n</li>\n</ul>\n<h2 id=\"玩法上-1\"><a href=\"#玩法上-1\" class=\"headerlink\" title=\"玩法上\"></a>玩法上</h2><p>在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。<br>在角色系统我会介绍这些对玩法的贡献</p>\n<p>主要是——场景，场景关卡设置，物品和玩法剖析</p>\n<ul>\n<li><p>场景的关卡<br>前期的最大关卡就是<br>【1】找到散落的楔石打开石门<br>小的关卡<br>【2】<br>拖拽石头来阻挡机关和帮助跳跃<br>还有类似司机挡位的机关——触发一些机关，打开石门等等<br>【3】<br>还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏</p>\n</li>\n<li><p>场景物品<br>藤条——帮助跳跃<br>竖直木棒——陷阱悬停<br>水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）<br>灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了<br>羽毛——<br>还有库和奥日的配合玩法——</p>\n</li>\n</ul>\n<p>补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯</p>\n<ul>\n<li><p>玩法<br>其实有的已经融合在以上或者以下的分析里面<br>主要探索，打斗<br>剧情的玩法——<br>对话<br>打斗boss等<br>boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣</p>\n</li>\n<li><p>场景<br>第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景</p>\n</li>\n</ul>\n<h2 id=\"从角色系统上分析-1\"><a href=\"#从角色系统上分析-1\" class=\"headerlink\" title=\"从角色系统上分析\"></a>从角色系统上分析</h2><p>主要分为四个部分</p>\n<ul>\n<li><p>蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）</p>\n</li>\n<li><p>武器+主动技能系统<br>从光剑到弓箭到重锤，技能则有光之箭和回血等<br>评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。<br>光剑——可以打碎一些木板障碍物<br>例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速<br>重锤——可以打碎石板<br>光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）<br>其他目前武器目前没有看到对地图探索的作用，有再补充</p>\n</li>\n<li><p>不可见的被动技能<br>例如二连跳<br>抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。<br>抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深</p>\n</li>\n<li><p>课拆卸购买升级的被动技能<br>首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级<br>技能框则是探索地图一步一步的去扩展<br>讲几个印象比较深的技能:<br>攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行<br>三连跳——好吧也是默认了，不仅帅而且探索地图确实方便<br>其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧</p>\n</li>\n</ul>\n<p>（4）美术</p>\n<div style=\"text-align:center\">\n</div>","site":{"data":{}},"excerpt":"<h1 id=\"玩奥日有感（真随笔）\"><a href=\"#玩奥日有感（真随笔）\" class=\"headerlink\" title=\"玩奥日有感（真随笔）\"></a>玩奥日有感（真随笔）</h1>","more":"<h2 id=\"剧情上\"><a href=\"#剧情上\" class=\"headerlink\" title=\"剧情上\"></a>剧情上</h2><ul>\n<li><p>剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。<br>这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图<br>解锁了地底下和森林的碎片<br>唤醒了底下的蜘蛛（被腐朽吞噬了心智）<br>夸洛克牺牲了自我换回碎片</p>\n</li>\n<li><p>剧情就不得不提到npc了<br>莫基——路人角色，大大小小的任务都有承担，森林的原住民算是<br>库克——地图提供者<br>猴子——推动剧情，教会武器方面技能<br>商人——交易升级技能<br>夸洛克——沼泽的庇护神<br>工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情</p>\n</li>\n<li><p>还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候</p>\n</li>\n<li><p>前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡</p>\n</li>\n<li><p>细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器</p>\n</li>\n</ul>\n<h2 id=\"玩法上\"><a href=\"#玩法上\" class=\"headerlink\" title=\"玩法上\"></a>玩法上</h2><p>在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。<br>在角色系统我会介绍这些对玩法的贡献</p>\n<p>主要是——场景，场景关卡设置，物品和玩法剖析</p>\n<ul>\n<li><p>场景的关卡<br>前期的最大关卡就是<br>【1】找到散落的楔石打开石门<br>小的关卡<br>【2】<br>拖拽石头来阻挡机关和帮助跳跃<br>还有类似司机挡位的机关——触发一些机关，打开石门等等<br>【3】<br>还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏</p>\n</li>\n<li><p>场景物品<br>藤条——帮助跳跃<br>竖直木棒——陷阱悬停<br>水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）<br>灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了<br>羽毛——<br>还有库和奥日的配合玩法——</p>\n</li>\n</ul>\n<p>补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯</p>\n<ul>\n<li><p>玩法<br>其实有的已经融合在以上或者以下的分析里面<br>主要探索，打斗<br>剧情的玩法——<br>对话<br>打斗boss等<br>boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣</p>\n</li>\n<li><p>场景<br>第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景</p>\n</li>\n</ul>\n<h2 id=\"从角色系统上分析\"><a href=\"#从角色系统上分析\" class=\"headerlink\" title=\"从角色系统上分析\"></a>从角色系统上分析</h2><p>主要分为四个部分</p>\n<ul>\n<li><p>蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）</p>\n</li>\n<li><p>武器+主动技能系统<br>从光剑到弓箭到重锤，技能则有光之箭和回血等<br>评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。<br>光剑——可以打碎一些木板障碍物<br>例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速<br>重锤——可以打碎石板<br>光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）<br>其他目前武器目前没有看到对地图探索的作用，有再补充</p>\n</li>\n<li><p>不可见的被动技能<br>例如二连跳<br>抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。<br>抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深</p>\n</li>\n<li><p>课拆卸购买升级的被动技能<br>首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级<br>技能框则是探索地图一步一步的去扩展<br>讲几个印象比较深的技能:<br>攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行<br>三连跳——好吧也是默认了，不仅帅而且探索地图确实方便<br>其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧</p>\n</li>\n</ul>\n<p>（4）美术</p>\n<div style=\"text-align:center\">\n</div>\n<!-- More -->\n\n<h1 id=\"玩奥日有感（真随笔）-1\"><a href=\"#玩奥日有感（真随笔）-1\" class=\"headerlink\" title=\"玩奥日有感（真随笔）\"></a>玩奥日有感（真随笔）</h1><h2 id=\"剧情上-1\"><a href=\"#剧情上-1\" class=\"headerlink\" title=\"剧情上\"></a>剧情上</h2><ul>\n<li><p>剧情上，目前是主角是一位精灵，不小心与猫头鹰库到一处森林分离，在初期的探索中初步认识了这个地方，认识了莫基小生物和地方守护者夸洛克，解决了当地的水源问题，与朋友会和但又不幸主角的朋友库在静谧森林因为攻击而晕过去，于是为了朋友和森林又踏上了整个大陆的冒险寻找森林光的碎片。<br>这里分析一下主线推动和技能玩法的探索，显然在一些必备的要素技能都没有，你是探索不了主线的地图<br>解锁了地底下和森林的碎片<br>唤醒了底下的蜘蛛（被腐朽吞噬了心智）<br>夸洛克牺牲了自我换回碎片</p>\n</li>\n<li><p>剧情就不得不提到npc了<br>莫基——路人角色，大大小小的任务都有承担，森林的原住民算是<br>库克——地图提供者<br>猴子——推动剧情，教会武器方面技能<br>商人——交易升级技能<br>夸洛克——沼泽的庇护神<br>工匠——建造地图的一些的传送点和解锁地图的通道，建造触发剧情</p>\n</li>\n<li><p>还有就是在设计上，制作者在获得技能前面的地图中总会遗留一些之后技能解锁的机关，延长玩家的游戏时间，有的可能会返回头探索，因为总有卡关的时候，在不看攻略的时候，这时候就是回头探索的时候</p>\n</li>\n<li><p>前期对玩法的探索拓展可以说循序渐进了，十分缓和友好，真的是十分流畅的过渡</p>\n</li>\n<li><p>细节方面上，对于地图map的里面功能的设置可以说非常全面了而且分类也很好，还有筛选器</p>\n</li>\n</ul>\n<h2 id=\"玩法上-1\"><a href=\"#玩法上-1\" class=\"headerlink\" title=\"玩法上\"></a>玩法上</h2><p>在玩法上，在前期的森林的探索中一步一步扩展开了，从单纯的跳跃到各种技能帮助拓展玩法。<br>在角色系统我会介绍这些对玩法的贡献</p>\n<p>主要是——场景，场景关卡设置，物品和玩法剖析</p>\n<ul>\n<li><p>场景的关卡<br>前期的最大关卡就是<br>【1】找到散落的楔石打开石门<br>小的关卡<br>【2】<br>拖拽石头来阻挡机关和帮助跳跃<br>还有类似司机挡位的机关——触发一些机关，打开石门等等<br>【3】<br>还有全球玩家的小跑酷，也还算比较有趣，但也就一般般，扔掉也没关系，毕竟是单机游戏</p>\n</li>\n<li><p>场景物品<br>藤条——帮助跳跃<br>竖直木棒——陷阱悬停<br>水平木棒——这个真的是太amazin，可以按w转圈让后松开向上冲刺（从玩的方面来看，转速和角色的数值向上的速度有关，因为我竖直跳上去就会有转圈的行为，显然不是w是触发，向上的运动才是触发，w向上在棍子就会加速，松开就是结束转圈动画，此时决定转速的向上speed此时就是你的竖直速度）<br>灯笼，苔藓，藤条，蓝色的抓钩物———不作分析了<br>羽毛——<br>还有库和奥日的配合玩法——</p>\n</li>\n</ul>\n<p>补充：其实场景物品最让我惊讶的是角色动作的多样性，竖直木棍站在最顶端的单手倒立的动作，单手倒立起跳，还有竖直藤条木棍水平冲刺上去还会转几圈，真的是十分连贯</p>\n<ul>\n<li><p>玩法<br>其实有的已经融合在以上或者以下的分析里面<br>主要探索，打斗<br>剧情的玩法——<br>对话<br>打斗boss等<br>boss追击，我逃跑，这样完全发挥了跑图里面机制的乐趣</p>\n</li>\n<li><p>场景<br>第一个地图就是单纯的地图，但偶尔有几个门，进去新的场景</p>\n</li>\n</ul>\n<h2 id=\"从角色系统上分析-1\"><a href=\"#从角色系统上分析-1\" class=\"headerlink\" title=\"从角色系统上分析\"></a>从角色系统上分析</h2><p>主要分为四个部分</p>\n<ul>\n<li><p>蓝条和血条（在地图中寻找能量和生命碎片获得一步一步扩展，部分和技能有关，例如交换最大生命值和最大蓝条）</p>\n</li>\n<li><p>武器+主动技能系统<br>从光剑到弓箭到重锤，技能则有光之箭和回血等<br>评价：武器不仅仅帮助我们更加轻松应对敌人，而且帮助我们能有效触发机关和障碍物，帮助探索地图。<br>光剑——可以打碎一些木板障碍物<br>例如弓箭——可以触发高处的机关，且技能还能扩大弓箭的特性，例如分裂和加攻速<br>重锤——可以打碎石板<br>光之箭——打碎一些易碎物，且伤害极高（光之箭的动作真的是让我记忆尤深，悬停瞄准，穿插在各种动作中，十分流畅帅气）<br>其他目前武器目前没有看到对地图探索的作用，有再补充</p>\n</li>\n<li><p>不可见的被动技能<br>例如二连跳<br>抓取——这真的amazing，流畅的难以置信，从飞行物到敌人全部都能抓取，靠近就能抓取，而且是时停性质的，可以将目标反向射出，而自己朝选的方向射出，虽然没有伤害但是极大的提高了游戏的可玩性，帮助了地图探索的乐趣还提高了打斗的技巧性，帮助玩家们在打斗中获得成就感。<br>抓钩——准确的就是能飞到一些蓝色苔藓和的灯笼处，相当于蜘蛛侠吐丝吧，还行，但是印象不是特别深</p>\n</li>\n<li><p>课拆卸购买升级的被动技能<br>首先部分被动技能实在地图中寻找灵树或者在技能商人购买升级<br>技能框则是探索地图一步一步的去扩展<br>讲几个印象比较深的技能:<br>攀爬——好吧，我已经把他默认为不可见的被动技能了，探索地图没了他不行<br>三连跳——好吧也是默认了，不仅帅而且探索地图确实方便<br>其他就是什么主动吸收光之碎片，减伤啥的，有印象深的再说吧</p>\n</li>\n</ul>\n<p>（4）美术</p>\n<div style=\"text-align:center\">\n</div>"},{"title":"zExNocs自我介绍","date":"2024-05-26T16:00:00.000Z","updated":"2024-05-27T16:00:00.000Z","_content":"\n这是一个zExNocs的自我介绍。\n\n<!-- More -->\n\n---\n\n# 介绍\n<div style=\"text-align:center\">\n<img src=\"https://zexnocs.github.io/img/avatar.jpg\" alt=\"去码头整点薯条。\" width=\"100\">\n\n这里是蒟蒻zExNocs：[个人小站](https://zexnocs.github.io/)\n\n欢迎各位大佬友链&&留言\n</div>\n\n---\n\n# 导航\n- 这里空空如也\n\n---\n\n这是一个神奇的公式，你知道叫什么吗？\n$$P(T)=e^{\\frac{\\Delta}{kT}}$$","source":"_posts/zExNocs/自我介绍.md","raw":"---\ntitle: zExNocs自我介绍\ndate: 2024-05-27\nupdated: 2024-05-28\npermalink: articles/zExNocs/自我介绍/\ncategories: zExNocs\ntags: \n    - 自我介绍\n---\n\n这是一个zExNocs的自我介绍。\n\n<!-- More -->\n\n---\n\n# 介绍\n<div style=\"text-align:center\">\n<img src=\"https://zexnocs.github.io/img/avatar.jpg\" alt=\"去码头整点薯条。\" width=\"100\">\n\n这里是蒟蒻zExNocs：[个人小站](https://zexnocs.github.io/)\n\n欢迎各位大佬友链&&留言\n</div>\n\n---\n\n# 导航\n- 这里空空如也\n\n---\n\n这是一个神奇的公式，你知道叫什么吗？\n$$P(T)=e^{\\frac{\\Delta}{kT}}$$","slug":"zExNocs/自我介绍","published":1,"__permalink":"articles/zExNocs/自我介绍/","comments":1,"layout":"post","photos":[],"link":"","_id":"clx8n2hgx003po8ye39c50tl1","content":"<p>这是一个zExNocs的自我介绍。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><div style=\"text-align:center\">\n<img src=\"https://zexnocs.github.io/img/avatar.jpg\" alt=\"去码头整点薯条。\" width=\"100\">\n\n<p>这里是蒟蒻zExNocs：<a href=\"https://zexnocs.github.io/\">个人小站</a></p>\n<p>欢迎各位大佬友链&amp;&amp;留言</p>\n</div>\n\n<hr>\n<h1 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h1><ul>\n<li>这里空空如也</li>\n</ul>\n<hr>\n<p>这是一个神奇的公式，你知道叫什么吗？<br>$$P(T)&#x3D;e^{\\frac{\\Delta}{kT}}$$</p>\n","site":{"data":{}},"excerpt":"<p>这是一个zExNocs的自我介绍。</p>","more":"<hr>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><div style=\"text-align:center\">\n<img src=\"https://zexnocs.github.io/img/avatar.jpg\" alt=\"去码头整点薯条。\" width=\"100\">\n\n<p>这里是蒟蒻zExNocs：<a href=\"https://zexnocs.github.io/\">个人小站</a></p>\n<p>欢迎各位大佬友链&amp;&amp;留言</p>\n</div>\n\n<hr>\n<h1 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h1><ul>\n<li>这里空空如也</li>\n</ul>\n<hr>\n<p>这是一个神奇的公式，你知道叫什么吗？<br>$$P(T)&#x3D;e^{\\frac{\\Delta}{kT}}$$</p>"},{"title":"随笔-如何提交文章到VoidGameSpace上","date":"2024-05-27T16:00:00.000Z","updated":"2024-05-27T16:00:00.000Z","_content":"\n关于如果提交文章到VoidGameSpace论坛上的git教程。\n\n<!-- More -->\n\n---\n\n本文章仅适用于[VoidGameSpace论坛](https://www.voidgame.space/)及其[GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。\n\n该教程目前仅适用于**Windows**系统。\n\n# 如何使用github进行提交\n\n## 一. 确认Git安装\n\nGit下载地址: [Link](https://git-scm.com/downloads)\n\n测试Git：打开 `cmd` 或者 `PowerShell`，输入 `git -v` 可以查看到当前Git的版本。\n\n## 二. 配置Git设置和SSH\n\n- 使用下面两个指令配置Git全局设置：\n\n```\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n```\n\n- 配置ssh设置：[可以参考这个文章](https://blog.csdn.net/Yaoyao2024/article/details/132123525)\n\n1. 使用 `ssh-keygen -t rsa -C \"你的邮箱\"`，一路回车生成SSH。\n2. 找到文件`C:\\User\\用户名\\.ssh\\id_rsa.pub`，使用记事本打开并复制里面的内容。\n3. 打开GitHub在`Settings`界面左边找到`SSH and GPG keys`进入。\n4. 点击 `New SSH key`，在`title`中填入合适的标题，在`SSH`中填入刚刚复制的内容。\n5. 本地指令输入 `ssh -T git@github.com` 验证是否配置成功。\n\n## 三. fork库到自己的库中\n\n打开 [GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite) 网页，点击右上角 `Fork` 按钮，复制该库到自己的库中。\n\n选择`owner`为自己的账户，`Repository name`可以设置为默认`GameDevWebsite`。\n\n`Description`用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。\n\n点击 `Create fork` 按钮。\n\n## 四. clone库到本地\n\n进入自己的库中找到刚刚fork的`GameDevWebsite`库，一般为 `https://github.com/用户名/GameDevWebsite`\n\n找到 `<> Code` 绿色按钮，在本地中使用 `PowerShell` 打开想要部署的位置 or 在部署的位置中右键选择`在终端打开` or 使用`cmd` `cd` 到要部署的文件夹，使用下面三种方式之一克隆库到本地\n\n1. 使用`HTTPS`，复制`web URL`，输入`git clone 复制的URL`部署。这个方法需要你在终端登录到Git中。\n2. 使用`SSH`，复制`SSH key`，输入`git clone 复制的SSH_key`部署。\n3. 点击`Download ZIP`，下载压缩包到要部署的文件夹并解压。\n\n## 五. 编写自己的文档\n\n在部署的项目目录`GameDevWebsite`中，路径`source\\_posts\\`创建自己的文件夹，并在文件夹中创建`.md`文件，参考[GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)中元数据说明，编写自己的文章。\n\n另外，markdown的编写可以参考官方文档：[Link](https://markdown.com.cn/)\n\n## 六. 提交文档到自己fork的库中\n\n使用 `PowerShell` 打开项目目录`GameDevWebsite`，或者在目录中右键点击`在终端打开`，或者使用`cmd` `cd`到目录。\n\n1. 创建自己的分支(可选，新手建议直接修改`main`分支)：使用 `git checkout -b 分支名` 创建并切换到新的分支。(分支的作用是保证`main`分支的干净，一般只有最终版本才会合并到`main`分支)。如果你已经创建过分支，就不需要再创建该分支了。\n2. 添加所有文件到暂存区： `git add .`\n3. 提交添加的文件： `git commit -m \"修改描述\"`。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 `\"docs(你的名字): 添加了xxx文章\"`。具体准则可以自行搜索学习一下。\n4. push库：如果你使用的是新建的分支，使用`git push origin 分支名` 将新分支push到库中。如果你使用的是`main`分支或者是已经创建的库，那么使用 `git push` 将提交的内容push到库中。\n5. 拉取申请：找到自己fork的库，点击左上方 `Pull requests`按钮，进入页面点击右上方`New pull request`按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择`main`)，然后填写一些申请描述即可。\n6. 等待审核。","source":"_posts/zExNocs/随笔-如何提交文章到VoidGameSpace上.md","raw":"---\ntitle: 随笔-如何提交文章到VoidGameSpace上\ndate: 2024-05-28\nupdated: 2024-05-28\npermalink: articles/zExNocs/随笔-如何提交文章到VoidGameSpace上/\ncategories: zExNocs\ntags:\n  - VoidGameSpace\n  - Hexo\n  - Git\n---\n\n关于如果提交文章到VoidGameSpace论坛上的git教程。\n\n<!-- More -->\n\n---\n\n本文章仅适用于[VoidGameSpace论坛](https://www.voidgame.space/)及其[GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)。\n\n该教程目前仅适用于**Windows**系统。\n\n# 如何使用github进行提交\n\n## 一. 确认Git安装\n\nGit下载地址: [Link](https://git-scm.com/downloads)\n\n测试Git：打开 `cmd` 或者 `PowerShell`，输入 `git -v` 可以查看到当前Git的版本。\n\n## 二. 配置Git设置和SSH\n\n- 使用下面两个指令配置Git全局设置：\n\n```\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n```\n\n- 配置ssh设置：[可以参考这个文章](https://blog.csdn.net/Yaoyao2024/article/details/132123525)\n\n1. 使用 `ssh-keygen -t rsa -C \"你的邮箱\"`，一路回车生成SSH。\n2. 找到文件`C:\\User\\用户名\\.ssh\\id_rsa.pub`，使用记事本打开并复制里面的内容。\n3. 打开GitHub在`Settings`界面左边找到`SSH and GPG keys`进入。\n4. 点击 `New SSH key`，在`title`中填入合适的标题，在`SSH`中填入刚刚复制的内容。\n5. 本地指令输入 `ssh -T git@github.com` 验证是否配置成功。\n\n## 三. fork库到自己的库中\n\n打开 [GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite) 网页，点击右上角 `Fork` 按钮，复制该库到自己的库中。\n\n选择`owner`为自己的账户，`Repository name`可以设置为默认`GameDevWebsite`。\n\n`Description`用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。\n\n点击 `Create fork` 按钮。\n\n## 四. clone库到本地\n\n进入自己的库中找到刚刚fork的`GameDevWebsite`库，一般为 `https://github.com/用户名/GameDevWebsite`\n\n找到 `<> Code` 绿色按钮，在本地中使用 `PowerShell` 打开想要部署的位置 or 在部署的位置中右键选择`在终端打开` or 使用`cmd` `cd` 到要部署的文件夹，使用下面三种方式之一克隆库到本地\n\n1. 使用`HTTPS`，复制`web URL`，输入`git clone 复制的URL`部署。这个方法需要你在终端登录到Git中。\n2. 使用`SSH`，复制`SSH key`，输入`git clone 复制的SSH_key`部署。\n3. 点击`Download ZIP`，下载压缩包到要部署的文件夹并解压。\n\n## 五. 编写自己的文档\n\n在部署的项目目录`GameDevWebsite`中，路径`source\\_posts\\`创建自己的文件夹，并在文件夹中创建`.md`文件，参考[GitHub库](https://github.com/VoidmatrixHeathcliff/GameDevWebsite)中元数据说明，编写自己的文章。\n\n另外，markdown的编写可以参考官方文档：[Link](https://markdown.com.cn/)\n\n## 六. 提交文档到自己fork的库中\n\n使用 `PowerShell` 打开项目目录`GameDevWebsite`，或者在目录中右键点击`在终端打开`，或者使用`cmd` `cd`到目录。\n\n1. 创建自己的分支(可选，新手建议直接修改`main`分支)：使用 `git checkout -b 分支名` 创建并切换到新的分支。(分支的作用是保证`main`分支的干净，一般只有最终版本才会合并到`main`分支)。如果你已经创建过分支，就不需要再创建该分支了。\n2. 添加所有文件到暂存区： `git add .`\n3. 提交添加的文件： `git commit -m \"修改描述\"`。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 `\"docs(你的名字): 添加了xxx文章\"`。具体准则可以自行搜索学习一下。\n4. push库：如果你使用的是新建的分支，使用`git push origin 分支名` 将新分支push到库中。如果你使用的是`main`分支或者是已经创建的库，那么使用 `git push` 将提交的内容push到库中。\n5. 拉取申请：找到自己fork的库，点击左上方 `Pull requests`按钮，进入页面点击右上方`New pull request`按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择`main`)，然后填写一些申请描述即可。\n6. 等待审核。","slug":"zExNocs/随笔-如何提交文章到VoidGameSpace上","published":1,"__permalink":"articles/zExNocs/随笔-如何提交文章到VoidGameSpace上/","_id":"clx8n2hgx003so8ye8ozq9748","comments":1,"layout":"post","photos":[],"link":"","content":"<p>关于如果提交文章到VoidGameSpace论坛上的git教程。</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>本文章仅适用于<a href=\"https://www.voidgame.space/\">VoidGameSpace论坛</a>及其<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a>。</p>\n<p>该教程目前仅适用于<strong>Windows</strong>系统。</p>\n<h1 id=\"如何使用github进行提交\"><a href=\"#如何使用github进行提交\" class=\"headerlink\" title=\"如何使用github进行提交\"></a>如何使用github进行提交</h1><h2 id=\"一-确认Git安装\"><a href=\"#一-确认Git安装\" class=\"headerlink\" title=\"一. 确认Git安装\"></a>一. 确认Git安装</h2><p>Git下载地址: <a href=\"https://git-scm.com/downloads\">Link</a></p>\n<p>测试Git：打开 <code>cmd</code> 或者 <code>PowerShell</code>，输入 <code>git -v</code> 可以查看到当前Git的版本。</p>\n<h2 id=\"二-配置Git设置和SSH\"><a href=\"#二-配置Git设置和SSH\" class=\"headerlink\" title=\"二. 配置Git设置和SSH\"></a>二. 配置Git设置和SSH</h2><ul>\n<li>使用下面两个指令配置Git全局设置：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;你的用户名&quot;</span><br><span class=\"line\">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置ssh设置：<a href=\"https://blog.csdn.net/Yaoyao2024/article/details/132123525\">可以参考这个文章</a></li>\n</ul>\n<ol>\n<li>使用 <code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，一路回车生成SSH。</li>\n<li>找到文件<code>C:\\User\\用户名\\.ssh\\id_rsa.pub</code>，使用记事本打开并复制里面的内容。</li>\n<li>打开GitHub在<code>Settings</code>界面左边找到<code>SSH and GPG keys</code>进入。</li>\n<li>点击 <code>New SSH key</code>，在<code>title</code>中填入合适的标题，在<code>SSH</code>中填入刚刚复制的内容。</li>\n<li>本地指令输入 <code>ssh -T git@github.com</code> 验证是否配置成功。</li>\n</ol>\n<h2 id=\"三-fork库到自己的库中\"><a href=\"#三-fork库到自己的库中\" class=\"headerlink\" title=\"三. fork库到自己的库中\"></a>三. fork库到自己的库中</h2><p>打开 <a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a> 网页，点击右上角 <code>Fork</code> 按钮，复制该库到自己的库中。</p>\n<p>选择<code>owner</code>为自己的账户，<code>Repository name</code>可以设置为默认<code>GameDevWebsite</code>。</p>\n<p><code>Description</code>用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。</p>\n<p>点击 <code>Create fork</code> 按钮。</p>\n<h2 id=\"四-clone库到本地\"><a href=\"#四-clone库到本地\" class=\"headerlink\" title=\"四. clone库到本地\"></a>四. clone库到本地</h2><p>进入自己的库中找到刚刚fork的<code>GameDevWebsite</code>库，一般为 <code>https://github.com/用户名/GameDevWebsite</code></p>\n<p>找到 <code>&lt;&gt; Code</code> 绿色按钮，在本地中使用 <code>PowerShell</code> 打开想要部署的位置 or 在部署的位置中右键选择<code>在终端打开</code> or 使用<code>cmd</code> <code>cd</code> 到要部署的文件夹，使用下面三种方式之一克隆库到本地</p>\n<ol>\n<li>使用<code>HTTPS</code>，复制<code>web URL</code>，输入<code>git clone 复制的URL</code>部署。这个方法需要你在终端登录到Git中。</li>\n<li>使用<code>SSH</code>，复制<code>SSH key</code>，输入<code>git clone 复制的SSH_key</code>部署。</li>\n<li>点击<code>Download ZIP</code>，下载压缩包到要部署的文件夹并解压。</li>\n</ol>\n<h2 id=\"五-编写自己的文档\"><a href=\"#五-编写自己的文档\" class=\"headerlink\" title=\"五. 编写自己的文档\"></a>五. 编写自己的文档</h2><p>在部署的项目目录<code>GameDevWebsite</code>中，路径<code>source\\_posts\\</code>创建自己的文件夹，并在文件夹中创建<code>.md</code>文件，参考<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a>中元数据说明，编写自己的文章。</p>\n<p>另外，markdown的编写可以参考官方文档：<a href=\"https://markdown.com.cn/\">Link</a></p>\n<h2 id=\"六-提交文档到自己fork的库中\"><a href=\"#六-提交文档到自己fork的库中\" class=\"headerlink\" title=\"六. 提交文档到自己fork的库中\"></a>六. 提交文档到自己fork的库中</h2><p>使用 <code>PowerShell</code> 打开项目目录<code>GameDevWebsite</code>，或者在目录中右键点击<code>在终端打开</code>，或者使用<code>cmd</code> <code>cd</code>到目录。</p>\n<ol>\n<li>创建自己的分支(可选，新手建议直接修改<code>main</code>分支)：使用 <code>git checkout -b 分支名</code> 创建并切换到新的分支。(分支的作用是保证<code>main</code>分支的干净，一般只有最终版本才会合并到<code>main</code>分支)。如果你已经创建过分支，就不需要再创建该分支了。</li>\n<li>添加所有文件到暂存区： <code>git add .</code></li>\n<li>提交添加的文件： <code>git commit -m &quot;修改描述&quot;</code>。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 <code>&quot;docs(你的名字): 添加了xxx文章&quot;</code>。具体准则可以自行搜索学习一下。</li>\n<li>push库：如果你使用的是新建的分支，使用<code>git push origin 分支名</code> 将新分支push到库中。如果你使用的是<code>main</code>分支或者是已经创建的库，那么使用 <code>git push</code> 将提交的内容push到库中。</li>\n<li>拉取申请：找到自己fork的库，点击左上方 <code>Pull requests</code>按钮，进入页面点击右上方<code>New pull request</code>按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择<code>main</code>)，然后填写一些申请描述即可。</li>\n<li>等待审核。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>关于如果提交文章到VoidGameSpace论坛上的git教程。</p>","more":"<hr>\n<p>本文章仅适用于<a href=\"https://www.voidgame.space/\">VoidGameSpace论坛</a>及其<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a>。</p>\n<p>该教程目前仅适用于<strong>Windows</strong>系统。</p>\n<h1 id=\"如何使用github进行提交\"><a href=\"#如何使用github进行提交\" class=\"headerlink\" title=\"如何使用github进行提交\"></a>如何使用github进行提交</h1><h2 id=\"一-确认Git安装\"><a href=\"#一-确认Git安装\" class=\"headerlink\" title=\"一. 确认Git安装\"></a>一. 确认Git安装</h2><p>Git下载地址: <a href=\"https://git-scm.com/downloads\">Link</a></p>\n<p>测试Git：打开 <code>cmd</code> 或者 <code>PowerShell</code>，输入 <code>git -v</code> 可以查看到当前Git的版本。</p>\n<h2 id=\"二-配置Git设置和SSH\"><a href=\"#二-配置Git设置和SSH\" class=\"headerlink\" title=\"二. 配置Git设置和SSH\"></a>二. 配置Git设置和SSH</h2><ul>\n<li>使用下面两个指令配置Git全局设置：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;你的用户名&quot;</span><br><span class=\"line\">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置ssh设置：<a href=\"https://blog.csdn.net/Yaoyao2024/article/details/132123525\">可以参考这个文章</a></li>\n</ul>\n<ol>\n<li>使用 <code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，一路回车生成SSH。</li>\n<li>找到文件<code>C:\\User\\用户名\\.ssh\\id_rsa.pub</code>，使用记事本打开并复制里面的内容。</li>\n<li>打开GitHub在<code>Settings</code>界面左边找到<code>SSH and GPG keys</code>进入。</li>\n<li>点击 <code>New SSH key</code>，在<code>title</code>中填入合适的标题，在<code>SSH</code>中填入刚刚复制的内容。</li>\n<li>本地指令输入 <code>ssh -T git@github.com</code> 验证是否配置成功。</li>\n</ol>\n<h2 id=\"三-fork库到自己的库中\"><a href=\"#三-fork库到自己的库中\" class=\"headerlink\" title=\"三. fork库到自己的库中\"></a>三. fork库到自己的库中</h2><p>打开 <a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a> 网页，点击右上角 <code>Fork</code> 按钮，复制该库到自己的库中。</p>\n<p>选择<code>owner</code>为自己的账户，<code>Repository name</code>可以设置为默认<code>GameDevWebsite</code>。</p>\n<p><code>Description</code>用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。</p>\n<p>点击 <code>Create fork</code> 按钮。</p>\n<h2 id=\"四-clone库到本地\"><a href=\"#四-clone库到本地\" class=\"headerlink\" title=\"四. clone库到本地\"></a>四. clone库到本地</h2><p>进入自己的库中找到刚刚fork的<code>GameDevWebsite</code>库，一般为 <code>https://github.com/用户名/GameDevWebsite</code></p>\n<p>找到 <code>&lt;&gt; Code</code> 绿色按钮，在本地中使用 <code>PowerShell</code> 打开想要部署的位置 or 在部署的位置中右键选择<code>在终端打开</code> or 使用<code>cmd</code> <code>cd</code> 到要部署的文件夹，使用下面三种方式之一克隆库到本地</p>\n<ol>\n<li>使用<code>HTTPS</code>，复制<code>web URL</code>，输入<code>git clone 复制的URL</code>部署。这个方法需要你在终端登录到Git中。</li>\n<li>使用<code>SSH</code>，复制<code>SSH key</code>，输入<code>git clone 复制的SSH_key</code>部署。</li>\n<li>点击<code>Download ZIP</code>，下载压缩包到要部署的文件夹并解压。</li>\n</ol>\n<h2 id=\"五-编写自己的文档\"><a href=\"#五-编写自己的文档\" class=\"headerlink\" title=\"五. 编写自己的文档\"></a>五. 编写自己的文档</h2><p>在部署的项目目录<code>GameDevWebsite</code>中，路径<code>source\\_posts\\</code>创建自己的文件夹，并在文件夹中创建<code>.md</code>文件，参考<a href=\"https://github.com/VoidmatrixHeathcliff/GameDevWebsite\">GitHub库</a>中元数据说明，编写自己的文章。</p>\n<p>另外，markdown的编写可以参考官方文档：<a href=\"https://markdown.com.cn/\">Link</a></p>\n<h2 id=\"六-提交文档到自己fork的库中\"><a href=\"#六-提交文档到自己fork的库中\" class=\"headerlink\" title=\"六. 提交文档到自己fork的库中\"></a>六. 提交文档到自己fork的库中</h2><p>使用 <code>PowerShell</code> 打开项目目录<code>GameDevWebsite</code>，或者在目录中右键点击<code>在终端打开</code>，或者使用<code>cmd</code> <code>cd</code>到目录。</p>\n<ol>\n<li>创建自己的分支(可选，新手建议直接修改<code>main</code>分支)：使用 <code>git checkout -b 分支名</code> 创建并切换到新的分支。(分支的作用是保证<code>main</code>分支的干净，一般只有最终版本才会合并到<code>main</code>分支)。如果你已经创建过分支，就不需要再创建该分支了。</li>\n<li>添加所有文件到暂存区： <code>git add .</code></li>\n<li>提交添加的文件： <code>git commit -m &quot;修改描述&quot;</code>。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 <code>&quot;docs(你的名字): 添加了xxx文章&quot;</code>。具体准则可以自行搜索学习一下。</li>\n<li>push库：如果你使用的是新建的分支，使用<code>git push origin 分支名</code> 将新分支push到库中。如果你使用的是<code>main</code>分支或者是已经创建的库，那么使用 <code>git push</code> 将提交的内容push到库中。</li>\n<li>拉取申请：找到自己fork的库，点击左上方 <code>Pull requests</code>按钮，进入页面点击右上方<code>New pull request</code>按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择<code>main</code>)，然后填写一些申请描述即可。</li>\n<li>等待审核。</li>\n</ol>"},{"title":"GAMES002第一课 Linux + Shell","date":"2024-07-13T16:00:00.000Z","updated":"2024-07-13T16:00:00.000Z","_content":"GAMES002-图形学研发基础工具第一课 Linux + Shell\n<!--More-->\n\n[课程链接](https://www.bilibili.com/video/BV1cC411L7uG)\n\n课程并没有教怎么装一个Linux系统\n## Linux基础\n\n### Shell\n\n#### Shell 是如何工作的\n- 本质是调用程序\n\t- 例如前面的 echo 实际上是系统内置的程序\n- 命令行第一个词是程序名称，随后是参数\n\t- 词之间用空格分隔\n- 敲下回车之后会开启一个子进程运行相应程序\n#### Shell 如何找到要调用的程序\n- 环境变量 PATH\n- 每一个路径就是它的搜索空间，Shell 会遍历 PATH 中的所有位置来搜索\n\n---\n\n### 绝对路径与相对路径\n- 绝对路径以'/'开头（' / ' 本身表示根目录）\n- 相对路径从当前路径出发 （显示在用户名之后，可以用pwd命令查看）\n- 特殊路径\n\t- ' . '：当前路径，' .. '：父路径（类似Windows里面的后退）\n\t- ' - '：上次到达的路径\n\t- ' ~ '：home所在的路径\n**Linux 一切皆文件**：Linux 将所有资源都视为文件来管理，包括硬件设备、网络套接字等。带来的好处就是不同种类的资源可以用同种方式管理。例如 /sys/class 目录下的每个文件夹代表一种设备，其中的文件则表示设备的各种参数。\n---\n### 重定向与管道\n\nLinux有三种标准I/O流：\n- 标准输入（stdin）：文件描述符为0\n- 标准输出（stdout）：文件描述符为1\n- 标准错误（stderr）：文件描述符为2\n- Shell 中的每个指令都有输入、输出流\n\t- 默认输入流读取键盘输入，输出流显示到屏幕\n\t- ' < '改变输入流， ' > '改变输出流\n\t- ' >> '在文件末尾追加\n\n#### 输出重定向\n\n`>`：覆盖写入 `2>`：覆盖写入`&>`：覆盖写入\n`>>`：追加写入`2>>`：追加写入`&>>`：追加写入\n将命令的标准输出重定向到文件。\n\n##### 覆盖写入 (Overwrite)\n\n覆盖写入会将文件的内容替换为新的输出。如果文件已经存在，之前的内容会被删除，文件中只会保留新的内容。如果文件不存在，则会创建一个新文件。\n例如：\n`echo \"Hello, World!\" > file.txt`\n如果`file.txt`已经存在，其内容将被替换为`\"Hello, World!\"`。\n\n##### 追加写入 (Append)\n\n追加写入不会删除文件的现有内容，而是在文件末尾添加新的输出。如果文件不存在，则会创建一个新文件。\n将命令的输出追加写入到文件中：\n`echo \"Hello, again!\" >> file.txt`\n如果`file.txt`已经存在，`\"Hello, again!\"`会被添加到文件末尾，文件原有内容保持不变。\n\n---\n\n#### 管道 ' | '\n\na | b，a 的输出作为 b 的输入\n\n`cat blank.txt | grep eth` \n`grep eth`会在该文件中查找包含`eth`的行并输出这些行\n\n`echo something | sudo tee blank.txt`\n`sudo` 只以管理员权限执行紧接着的那个指令\n`tee` 用于读取标准输入并将其内容同时写入标准输出和一个或多个文件。\n\n`ls | grep \"pattern\"` \n这个命令会列出当前目录中的所有文件，并将结果过滤出包含`pattern`的行。\n\n`cat file.txt | sort | uniq`\n将`cat`命令的输出通过管道传递给`sort`命令，再通过管道传递给`uniq`命令。\n这个命令会读取`file.txt`的内容，将其排序，然后去除重复的行。\n\n---\n\n### 权限\n\n- 用 ' ls -l '可以查看权限位\n![ICON](articles/59/GAMES002_01/01.png)\n- 用 ' chmod ' 修改权限位有两种方式\n![ICON](articles/59/GAMES002_01/02.png)\n- chmod 用户 +/- 权限 文件名\n- chmod 权限对应八进制数 文件名 （r=4 w=2 x=1）\n\t- `chmod 754 myfile.txt` \n\t1. 所有者权限 `rwx` = 7\n\t2. 组用户权限 `r-x` = 5\n\t3. 其他用户权限 `r--` = 4\n---\n\n### 变量\n\n- 赋值：变量名=字符串\n\t- 赋值只会添加 Shell 变量，关闭Shell后就会消失\n\t- 赋值语句前面加 export 可以添加环境变量，但是是一次性的\n\t- foo = bar 有空格是错误的\n访问变量的内容：变量前面加上 `$` 符号。 `$foo`，将 `foo` 的值替换掉 `$foo`\n- env - 查看环境变量\n- set - 环境变量 + Shell 变量 \n- 永久添加：\n\t- 将 export 赋值语句放入 home 下的 .bashrc 文件中\n\t- source ~/.bashrc\n该文件前面有` . ` ，代表它是隐藏文件，用 `ls -a` 才能看到\n\n---\n\n### 命令替换与进程替换\n\n当我们希望将指令的输出结果作为参数时\n- 命令替换：`$( command )`将指令执行后的输出替换掉\n```\nusers=$(who | wc -l)\necho \"There are $users users currently logged in.\"\n```\n\n这个示例中，`who | wc -l`命令用于统计当前登录用户数，并将结果赋值给变量`users`，然后通过`echo`命令输出。\n\n- 进程替换：**输入替换**：`<(command)` **输出替换**：`>(command)`\n\t- 将指令的输出重定向到临时文件，并用临时文件名替换 <( command ) \n\t- 它允许你使用命令的输出作为另一个命令的输入，而不需要显式地使用临时文件\n\n例如 `diff <(ls dir1) <(ls dir2)`\n在这个示例中，`<(ls dir1)`和`<(ls dir2)`将两个`ls`命令的输出作为文件名传递给`diff`命令。\n\n---\n\n### Shell 脚本\n\n脚本语言：脚本语言是指不需要编译而直接由解释器逐行执行的一类编程语言。源代码在运行时由解释器动态解析和执行。例如Bash 与 python 都是脚本语言 。\n编译语言：程序执行之前需要通过编译器将源代码转换成机器码（可执行文件）的一类编程语言。编译过程将源代码一次性转换为目标机器能够直接执行的代码。\n\n\n \\#！ Sharp-bang 符号\n- 放在脚本文件的开头，同一行后面跟着解释器的路径\n- 实际运行时会调用 sharp-bang 后的解释器，并将脚本文件名作为参数\n-  `#` 表示注释 \n- 可以直接用 `./script-name` 执行脚本\n一个典型的shell脚本文件以`#!/bin/sh`或`#!/bin/bash`开始，这一行称为shebang / sharp-bang，用来指明使用哪个shell来执行脚本。`#!` 后面添加解释器的路径与名称。\n例如名为`copy.py`的文件第一行为`#!/usr/bin/env python3`，当我们用`./script-name`运行脚本时，相当于`python3 copy.py` 。 \n后续的行则是具体的命令和逻辑。\n\n","source":"_posts/59/GAMES002_01.md","raw":"---\ntitle: GAMES002第一课 Linux + Shell\ndate: 2024-07-14\nupdated: 2024-07-14\npermalink: articles/59/GAMES002_01/\ncategories: 59\ntags: [Linux]\n---\nGAMES002-图形学研发基础工具第一课 Linux + Shell\n<!--More-->\n\n[课程链接](https://www.bilibili.com/video/BV1cC411L7uG)\n\n课程并没有教怎么装一个Linux系统\n## Linux基础\n\n### Shell\n\n#### Shell 是如何工作的\n- 本质是调用程序\n\t- 例如前面的 echo 实际上是系统内置的程序\n- 命令行第一个词是程序名称，随后是参数\n\t- 词之间用空格分隔\n- 敲下回车之后会开启一个子进程运行相应程序\n#### Shell 如何找到要调用的程序\n- 环境变量 PATH\n- 每一个路径就是它的搜索空间，Shell 会遍历 PATH 中的所有位置来搜索\n\n---\n\n### 绝对路径与相对路径\n- 绝对路径以'/'开头（' / ' 本身表示根目录）\n- 相对路径从当前路径出发 （显示在用户名之后，可以用pwd命令查看）\n- 特殊路径\n\t- ' . '：当前路径，' .. '：父路径（类似Windows里面的后退）\n\t- ' - '：上次到达的路径\n\t- ' ~ '：home所在的路径\n**Linux 一切皆文件**：Linux 将所有资源都视为文件来管理，包括硬件设备、网络套接字等。带来的好处就是不同种类的资源可以用同种方式管理。例如 /sys/class 目录下的每个文件夹代表一种设备，其中的文件则表示设备的各种参数。\n---\n### 重定向与管道\n\nLinux有三种标准I/O流：\n- 标准输入（stdin）：文件描述符为0\n- 标准输出（stdout）：文件描述符为1\n- 标准错误（stderr）：文件描述符为2\n- Shell 中的每个指令都有输入、输出流\n\t- 默认输入流读取键盘输入，输出流显示到屏幕\n\t- ' < '改变输入流， ' > '改变输出流\n\t- ' >> '在文件末尾追加\n\n#### 输出重定向\n\n`>`：覆盖写入 `2>`：覆盖写入`&>`：覆盖写入\n`>>`：追加写入`2>>`：追加写入`&>>`：追加写入\n将命令的标准输出重定向到文件。\n\n##### 覆盖写入 (Overwrite)\n\n覆盖写入会将文件的内容替换为新的输出。如果文件已经存在，之前的内容会被删除，文件中只会保留新的内容。如果文件不存在，则会创建一个新文件。\n例如：\n`echo \"Hello, World!\" > file.txt`\n如果`file.txt`已经存在，其内容将被替换为`\"Hello, World!\"`。\n\n##### 追加写入 (Append)\n\n追加写入不会删除文件的现有内容，而是在文件末尾添加新的输出。如果文件不存在，则会创建一个新文件。\n将命令的输出追加写入到文件中：\n`echo \"Hello, again!\" >> file.txt`\n如果`file.txt`已经存在，`\"Hello, again!\"`会被添加到文件末尾，文件原有内容保持不变。\n\n---\n\n#### 管道 ' | '\n\na | b，a 的输出作为 b 的输入\n\n`cat blank.txt | grep eth` \n`grep eth`会在该文件中查找包含`eth`的行并输出这些行\n\n`echo something | sudo tee blank.txt`\n`sudo` 只以管理员权限执行紧接着的那个指令\n`tee` 用于读取标准输入并将其内容同时写入标准输出和一个或多个文件。\n\n`ls | grep \"pattern\"` \n这个命令会列出当前目录中的所有文件，并将结果过滤出包含`pattern`的行。\n\n`cat file.txt | sort | uniq`\n将`cat`命令的输出通过管道传递给`sort`命令，再通过管道传递给`uniq`命令。\n这个命令会读取`file.txt`的内容，将其排序，然后去除重复的行。\n\n---\n\n### 权限\n\n- 用 ' ls -l '可以查看权限位\n![ICON](articles/59/GAMES002_01/01.png)\n- 用 ' chmod ' 修改权限位有两种方式\n![ICON](articles/59/GAMES002_01/02.png)\n- chmod 用户 +/- 权限 文件名\n- chmod 权限对应八进制数 文件名 （r=4 w=2 x=1）\n\t- `chmod 754 myfile.txt` \n\t1. 所有者权限 `rwx` = 7\n\t2. 组用户权限 `r-x` = 5\n\t3. 其他用户权限 `r--` = 4\n---\n\n### 变量\n\n- 赋值：变量名=字符串\n\t- 赋值只会添加 Shell 变量，关闭Shell后就会消失\n\t- 赋值语句前面加 export 可以添加环境变量，但是是一次性的\n\t- foo = bar 有空格是错误的\n访问变量的内容：变量前面加上 `$` 符号。 `$foo`，将 `foo` 的值替换掉 `$foo`\n- env - 查看环境变量\n- set - 环境变量 + Shell 变量 \n- 永久添加：\n\t- 将 export 赋值语句放入 home 下的 .bashrc 文件中\n\t- source ~/.bashrc\n该文件前面有` . ` ，代表它是隐藏文件，用 `ls -a` 才能看到\n\n---\n\n### 命令替换与进程替换\n\n当我们希望将指令的输出结果作为参数时\n- 命令替换：`$( command )`将指令执行后的输出替换掉\n```\nusers=$(who | wc -l)\necho \"There are $users users currently logged in.\"\n```\n\n这个示例中，`who | wc -l`命令用于统计当前登录用户数，并将结果赋值给变量`users`，然后通过`echo`命令输出。\n\n- 进程替换：**输入替换**：`<(command)` **输出替换**：`>(command)`\n\t- 将指令的输出重定向到临时文件，并用临时文件名替换 <( command ) \n\t- 它允许你使用命令的输出作为另一个命令的输入，而不需要显式地使用临时文件\n\n例如 `diff <(ls dir1) <(ls dir2)`\n在这个示例中，`<(ls dir1)`和`<(ls dir2)`将两个`ls`命令的输出作为文件名传递给`diff`命令。\n\n---\n\n### Shell 脚本\n\n脚本语言：脚本语言是指不需要编译而直接由解释器逐行执行的一类编程语言。源代码在运行时由解释器动态解析和执行。例如Bash 与 python 都是脚本语言 。\n编译语言：程序执行之前需要通过编译器将源代码转换成机器码（可执行文件）的一类编程语言。编译过程将源代码一次性转换为目标机器能够直接执行的代码。\n\n\n \\#！ Sharp-bang 符号\n- 放在脚本文件的开头，同一行后面跟着解释器的路径\n- 实际运行时会调用 sharp-bang 后的解释器，并将脚本文件名作为参数\n-  `#` 表示注释 \n- 可以直接用 `./script-name` 执行脚本\n一个典型的shell脚本文件以`#!/bin/sh`或`#!/bin/bash`开始，这一行称为shebang / sharp-bang，用来指明使用哪个shell来执行脚本。`#!` 后面添加解释器的路径与名称。\n例如名为`copy.py`的文件第一行为`#!/usr/bin/env python3`，当我们用`./script-name`运行脚本时，相当于`python3 copy.py` 。 \n后续的行则是具体的命令和逻辑。\n\n","slug":"59/GAMES002_01","published":1,"__permalink":"articles/59/GAMES002_01/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r84m0000lcut9rcohb1k","content":"<p>GAMES002-图形学研发基础工具第一课 Linux + Shell</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://www.bilibili.com/video/BV1cC411L7uG\">课程链接</a></p>\n<p>课程并没有教怎么装一个Linux系统</p>\n<h2 id=\"Linux基础\"><a href=\"#Linux基础\" class=\"headerlink\" title=\"Linux基础\"></a>Linux基础</h2><h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><h4 id=\"Shell-是如何工作的\"><a href=\"#Shell-是如何工作的\" class=\"headerlink\" title=\"Shell 是如何工作的\"></a>Shell 是如何工作的</h4><ul>\n<li>本质是调用程序<ul>\n<li>例如前面的 echo 实际上是系统内置的程序</li>\n</ul>\n</li>\n<li>命令行第一个词是程序名称，随后是参数<ul>\n<li>词之间用空格分隔</li>\n</ul>\n</li>\n<li>敲下回车之后会开启一个子进程运行相应程序</li>\n</ul>\n<h4 id=\"Shell-如何找到要调用的程序\"><a href=\"#Shell-如何找到要调用的程序\" class=\"headerlink\" title=\"Shell 如何找到要调用的程序\"></a>Shell 如何找到要调用的程序</h4><ul>\n<li>环境变量 PATH</li>\n<li>每一个路径就是它的搜索空间，Shell 会遍历 PATH 中的所有位置来搜索</li>\n</ul>\n<hr>\n<h3 id=\"绝对路径与相对路径\"><a href=\"#绝对路径与相对路径\" class=\"headerlink\" title=\"绝对路径与相对路径\"></a>绝对路径与相对路径</h3><ul>\n<li>绝对路径以’&#x2F;‘开头（’ &#x2F; ‘ 本身表示根目录）</li>\n<li>相对路径从当前路径出发 （显示在用户名之后，可以用pwd命令查看）</li>\n<li>特殊路径<ul>\n<li>‘ . ‘：当前路径，’ .. ‘：父路径（类似Windows里面的后退）</li>\n<li>‘ - ‘：上次到达的路径</li>\n<li>‘ ~ ‘：home所在的路径<br><strong>Linux 一切皆文件</strong>：Linux 将所有资源都视为文件来管理，包括硬件设备、网络套接字等。带来的好处就是不同种类的资源可以用同种方式管理。例如 &#x2F;sys&#x2F;class 目录下的每个文件夹代表一种设备，其中的文件则表示设备的各种参数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"重定向与管道\"><a href=\"#重定向与管道\" class=\"headerlink\" title=\"重定向与管道\"></a>重定向与管道</h3><p>Linux有三种标准I&#x2F;O流：</p>\n<ul>\n<li>标准输入（stdin）：文件描述符为0</li>\n<li>标准输出（stdout）：文件描述符为1</li>\n<li>标准错误（stderr）：文件描述符为2</li>\n<li>Shell 中的每个指令都有输入、输出流<ul>\n<li>默认输入流读取键盘输入，输出流显示到屏幕</li>\n<li>‘ &lt; ‘改变输入流， ‘ &gt; ‘改变输出流</li>\n<li>‘ &gt;&gt; ‘在文件末尾追加</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><p><code>&gt;</code>：覆盖写入 <code>2&gt;</code>：覆盖写入<code>&amp;&gt;</code>：覆盖写入<br><code>&gt;&gt;</code>：追加写入<code>2&gt;&gt;</code>：追加写入<code>&amp;&gt;&gt;</code>：追加写入<br>将命令的标准输出重定向到文件。</p>\n<h5 id=\"覆盖写入-Overwrite\"><a href=\"#覆盖写入-Overwrite\" class=\"headerlink\" title=\"覆盖写入 (Overwrite)\"></a>覆盖写入 (Overwrite)</h5><p>覆盖写入会将文件的内容替换为新的输出。如果文件已经存在，之前的内容会被删除，文件中只会保留新的内容。如果文件不存在，则会创建一个新文件。<br>例如：<br><code>echo &quot;Hello, World!&quot; &gt; file.txt</code><br>如果<code>file.txt</code>已经存在，其内容将被替换为<code>&quot;Hello, World!&quot;</code>。</p>\n<h5 id=\"追加写入-Append\"><a href=\"#追加写入-Append\" class=\"headerlink\" title=\"追加写入 (Append)\"></a>追加写入 (Append)</h5><p>追加写入不会删除文件的现有内容，而是在文件末尾添加新的输出。如果文件不存在，则会创建一个新文件。<br>将命令的输出追加写入到文件中：<br><code>echo &quot;Hello, again!&quot; &gt;&gt; file.txt</code><br>如果<code>file.txt</code>已经存在，<code>&quot;Hello, again!&quot;</code>会被添加到文件末尾，文件原有内容保持不变。</p>\n<hr>\n<h4 id=\"管道-‘-‘\"><a href=\"#管道-‘-‘\" class=\"headerlink\" title=\"管道 ‘ | ‘\"></a>管道 ‘ | ‘</h4><p>a | b，a 的输出作为 b 的输入</p>\n<p><code>cat blank.txt | grep eth</code><br><code>grep eth</code>会在该文件中查找包含<code>eth</code>的行并输出这些行</p>\n<p><code>echo something | sudo tee blank.txt</code><br><code>sudo</code> 只以管理员权限执行紧接着的那个指令<br><code>tee</code> 用于读取标准输入并将其内容同时写入标准输出和一个或多个文件。</p>\n<p><code>ls | grep &quot;pattern&quot;</code><br>这个命令会列出当前目录中的所有文件，并将结果过滤出包含<code>pattern</code>的行。</p>\n<p><code>cat file.txt | sort | uniq</code><br>将<code>cat</code>命令的输出通过管道传递给<code>sort</code>命令，再通过管道传递给<code>uniq</code>命令。<br>这个命令会读取<code>file.txt</code>的内容，将其排序，然后去除重复的行。</p>\n<hr>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><ul>\n<li>用 ‘ ls -l ‘可以查看权限位<br><img src=\"/articles/59/GAMES002_01/01.png\" alt=\"ICON\"></li>\n<li>用 ‘ chmod ‘ 修改权限位有两种方式<br><img src=\"/articles/59/GAMES002_01/02.png\" alt=\"ICON\"></li>\n<li>chmod 用户 +&#x2F;- 权限 文件名</li>\n<li>chmod 权限对应八进制数 文件名 （r&#x3D;4 w&#x3D;2 x&#x3D;1）<ul>\n<li><code>chmod 754 myfile.txt</code></li>\n</ul>\n<ol>\n<li>所有者权限 <code>rwx</code> &#x3D; 7</li>\n<li>组用户权限 <code>r-x</code> &#x3D; 5</li>\n<li>其他用户权限 <code>r--</code> &#x3D; 4</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li>赋值：变量名&#x3D;字符串<ul>\n<li>赋值只会添加 Shell 变量，关闭Shell后就会消失</li>\n<li>赋值语句前面加 export 可以添加环境变量，但是是一次性的</li>\n<li>foo &#x3D; bar 有空格是错误的<br>访问变量的内容：变量前面加上 <code>$</code> 符号。 <code>$foo</code>，将 <code>foo</code> 的值替换掉 <code>$foo</code></li>\n</ul>\n</li>\n<li>env - 查看环境变量</li>\n<li>set - 环境变量 + Shell 变量 </li>\n<li>永久添加：<ul>\n<li>将 export 赋值语句放入 home 下的 .bashrc 文件中</li>\n<li>source ~&#x2F;.bashrc<br>该文件前面有<code>.</code> ，代表它是隐藏文件，用 <code>ls -a</code> 才能看到</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"命令替换与进程替换\"><a href=\"#命令替换与进程替换\" class=\"headerlink\" title=\"命令替换与进程替换\"></a>命令替换与进程替换</h3><p>当我们希望将指令的输出结果作为参数时</p>\n<ul>\n<li>命令替换：<code>$( command )</code>将指令执行后的输出替换掉<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">users=$(who | wc -l)</span><br><span class=\"line\">echo &quot;There are $users users currently logged in.&quot;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>这个示例中，<code>who | wc -l</code>命令用于统计当前登录用户数，并将结果赋值给变量<code>users</code>，然后通过<code>echo</code>命令输出。</p>\n<ul>\n<li>进程替换：<strong>输入替换</strong>：<code>&lt;(command)</code> <strong>输出替换</strong>：<code>&gt;(command)</code><ul>\n<li>将指令的输出重定向到临时文件，并用临时文件名替换 &lt;( command ) </li>\n<li>它允许你使用命令的输出作为另一个命令的输入，而不需要显式地使用临时文件</li>\n</ul>\n</li>\n</ul>\n<p>例如 <code>diff &lt;(ls dir1) &lt;(ls dir2)</code><br>在这个示例中，<code>&lt;(ls dir1)</code>和<code>&lt;(ls dir2)</code>将两个<code>ls</code>命令的输出作为文件名传递给<code>diff</code>命令。</p>\n<hr>\n<h3 id=\"Shell-脚本\"><a href=\"#Shell-脚本\" class=\"headerlink\" title=\"Shell 脚本\"></a>Shell 脚本</h3><p>脚本语言：脚本语言是指不需要编译而直接由解释器逐行执行的一类编程语言。源代码在运行时由解释器动态解析和执行。例如Bash 与 python 都是脚本语言 。<br>编译语言：程序执行之前需要通过编译器将源代码转换成机器码（可执行文件）的一类编程语言。编译过程将源代码一次性转换为目标机器能够直接执行的代码。</p>\n<p> #！ Sharp-bang 符号</p>\n<ul>\n<li>放在脚本文件的开头，同一行后面跟着解释器的路径</li>\n<li>实际运行时会调用 sharp-bang 后的解释器，并将脚本文件名作为参数</li>\n<li><code>#</code> 表示注释 </li>\n<li>可以直接用 <code>./script-name</code> 执行脚本<br>一个典型的shell脚本文件以<code>#!/bin/sh</code>或<code>#!/bin/bash</code>开始，这一行称为shebang &#x2F; sharp-bang，用来指明使用哪个shell来执行脚本。<code>#!</code> 后面添加解释器的路径与名称。<br>例如名为<code>copy.py</code>的文件第一行为<code>#!/usr/bin/env python3</code>，当我们用<code>./script-name</code>运行脚本时，相当于<code>python3 copy.py</code> 。<br>后续的行则是具体的命令和逻辑。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>GAMES002-图形学研发基础工具第一课 Linux + Shell</p>","more":"<p><a href=\"https://www.bilibili.com/video/BV1cC411L7uG\">课程链接</a></p>\n<p>课程并没有教怎么装一个Linux系统</p>\n<h2 id=\"Linux基础\"><a href=\"#Linux基础\" class=\"headerlink\" title=\"Linux基础\"></a>Linux基础</h2><h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><h4 id=\"Shell-是如何工作的\"><a href=\"#Shell-是如何工作的\" class=\"headerlink\" title=\"Shell 是如何工作的\"></a>Shell 是如何工作的</h4><ul>\n<li>本质是调用程序<ul>\n<li>例如前面的 echo 实际上是系统内置的程序</li>\n</ul>\n</li>\n<li>命令行第一个词是程序名称，随后是参数<ul>\n<li>词之间用空格分隔</li>\n</ul>\n</li>\n<li>敲下回车之后会开启一个子进程运行相应程序</li>\n</ul>\n<h4 id=\"Shell-如何找到要调用的程序\"><a href=\"#Shell-如何找到要调用的程序\" class=\"headerlink\" title=\"Shell 如何找到要调用的程序\"></a>Shell 如何找到要调用的程序</h4><ul>\n<li>环境变量 PATH</li>\n<li>每一个路径就是它的搜索空间，Shell 会遍历 PATH 中的所有位置来搜索</li>\n</ul>\n<hr>\n<h3 id=\"绝对路径与相对路径\"><a href=\"#绝对路径与相对路径\" class=\"headerlink\" title=\"绝对路径与相对路径\"></a>绝对路径与相对路径</h3><ul>\n<li>绝对路径以’&#x2F;‘开头（’ &#x2F; ‘ 本身表示根目录）</li>\n<li>相对路径从当前路径出发 （显示在用户名之后，可以用pwd命令查看）</li>\n<li>特殊路径<ul>\n<li>‘ . ‘：当前路径，’ .. ‘：父路径（类似Windows里面的后退）</li>\n<li>‘ - ‘：上次到达的路径</li>\n<li>‘ ~ ‘：home所在的路径<br><strong>Linux 一切皆文件</strong>：Linux 将所有资源都视为文件来管理，包括硬件设备、网络套接字等。带来的好处就是不同种类的资源可以用同种方式管理。例如 &#x2F;sys&#x2F;class 目录下的每个文件夹代表一种设备，其中的文件则表示设备的各种参数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"重定向与管道\"><a href=\"#重定向与管道\" class=\"headerlink\" title=\"重定向与管道\"></a>重定向与管道</h3><p>Linux有三种标准I&#x2F;O流：</p>\n<ul>\n<li>标准输入（stdin）：文件描述符为0</li>\n<li>标准输出（stdout）：文件描述符为1</li>\n<li>标准错误（stderr）：文件描述符为2</li>\n<li>Shell 中的每个指令都有输入、输出流<ul>\n<li>默认输入流读取键盘输入，输出流显示到屏幕</li>\n<li>‘ &lt; ‘改变输入流， ‘ &gt; ‘改变输出流</li>\n<li>‘ &gt;&gt; ‘在文件末尾追加</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><p><code>&gt;</code>：覆盖写入 <code>2&gt;</code>：覆盖写入<code>&amp;&gt;</code>：覆盖写入<br><code>&gt;&gt;</code>：追加写入<code>2&gt;&gt;</code>：追加写入<code>&amp;&gt;&gt;</code>：追加写入<br>将命令的标准输出重定向到文件。</p>\n<h5 id=\"覆盖写入-Overwrite\"><a href=\"#覆盖写入-Overwrite\" class=\"headerlink\" title=\"覆盖写入 (Overwrite)\"></a>覆盖写入 (Overwrite)</h5><p>覆盖写入会将文件的内容替换为新的输出。如果文件已经存在，之前的内容会被删除，文件中只会保留新的内容。如果文件不存在，则会创建一个新文件。<br>例如：<br><code>echo &quot;Hello, World!&quot; &gt; file.txt</code><br>如果<code>file.txt</code>已经存在，其内容将被替换为<code>&quot;Hello, World!&quot;</code>。</p>\n<h5 id=\"追加写入-Append\"><a href=\"#追加写入-Append\" class=\"headerlink\" title=\"追加写入 (Append)\"></a>追加写入 (Append)</h5><p>追加写入不会删除文件的现有内容，而是在文件末尾添加新的输出。如果文件不存在，则会创建一个新文件。<br>将命令的输出追加写入到文件中：<br><code>echo &quot;Hello, again!&quot; &gt;&gt; file.txt</code><br>如果<code>file.txt</code>已经存在，<code>&quot;Hello, again!&quot;</code>会被添加到文件末尾，文件原有内容保持不变。</p>\n<hr>\n<h4 id=\"管道-‘-‘\"><a href=\"#管道-‘-‘\" class=\"headerlink\" title=\"管道 ‘ | ‘\"></a>管道 ‘ | ‘</h4><p>a | b，a 的输出作为 b 的输入</p>\n<p><code>cat blank.txt | grep eth</code><br><code>grep eth</code>会在该文件中查找包含<code>eth</code>的行并输出这些行</p>\n<p><code>echo something | sudo tee blank.txt</code><br><code>sudo</code> 只以管理员权限执行紧接着的那个指令<br><code>tee</code> 用于读取标准输入并将其内容同时写入标准输出和一个或多个文件。</p>\n<p><code>ls | grep &quot;pattern&quot;</code><br>这个命令会列出当前目录中的所有文件，并将结果过滤出包含<code>pattern</code>的行。</p>\n<p><code>cat file.txt | sort | uniq</code><br>将<code>cat</code>命令的输出通过管道传递给<code>sort</code>命令，再通过管道传递给<code>uniq</code>命令。<br>这个命令会读取<code>file.txt</code>的内容，将其排序，然后去除重复的行。</p>\n<hr>\n<h3 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h3><ul>\n<li>用 ‘ ls -l ‘可以查看权限位<br><img src=\"/articles/59/GAMES002_01/01.png\" alt=\"ICON\"></li>\n<li>用 ‘ chmod ‘ 修改权限位有两种方式<br><img src=\"/articles/59/GAMES002_01/02.png\" alt=\"ICON\"></li>\n<li>chmod 用户 +&#x2F;- 权限 文件名</li>\n<li>chmod 权限对应八进制数 文件名 （r&#x3D;4 w&#x3D;2 x&#x3D;1）<ul>\n<li><code>chmod 754 myfile.txt</code></li>\n</ul>\n<ol>\n<li>所有者权限 <code>rwx</code> &#x3D; 7</li>\n<li>组用户权限 <code>r-x</code> &#x3D; 5</li>\n<li>其他用户权限 <code>r--</code> &#x3D; 4</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li>赋值：变量名&#x3D;字符串<ul>\n<li>赋值只会添加 Shell 变量，关闭Shell后就会消失</li>\n<li>赋值语句前面加 export 可以添加环境变量，但是是一次性的</li>\n<li>foo &#x3D; bar 有空格是错误的<br>访问变量的内容：变量前面加上 <code>$</code> 符号。 <code>$foo</code>，将 <code>foo</code> 的值替换掉 <code>$foo</code></li>\n</ul>\n</li>\n<li>env - 查看环境变量</li>\n<li>set - 环境变量 + Shell 变量 </li>\n<li>永久添加：<ul>\n<li>将 export 赋值语句放入 home 下的 .bashrc 文件中</li>\n<li>source ~&#x2F;.bashrc<br>该文件前面有<code>.</code> ，代表它是隐藏文件，用 <code>ls -a</code> 才能看到</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"命令替换与进程替换\"><a href=\"#命令替换与进程替换\" class=\"headerlink\" title=\"命令替换与进程替换\"></a>命令替换与进程替换</h3><p>当我们希望将指令的输出结果作为参数时</p>\n<ul>\n<li>命令替换：<code>$( command )</code>将指令执行后的输出替换掉<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">users=$(who | wc -l)</span><br><span class=\"line\">echo &quot;There are $users users currently logged in.&quot;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>这个示例中，<code>who | wc -l</code>命令用于统计当前登录用户数，并将结果赋值给变量<code>users</code>，然后通过<code>echo</code>命令输出。</p>\n<ul>\n<li>进程替换：<strong>输入替换</strong>：<code>&lt;(command)</code> <strong>输出替换</strong>：<code>&gt;(command)</code><ul>\n<li>将指令的输出重定向到临时文件，并用临时文件名替换 &lt;( command ) </li>\n<li>它允许你使用命令的输出作为另一个命令的输入，而不需要显式地使用临时文件</li>\n</ul>\n</li>\n</ul>\n<p>例如 <code>diff &lt;(ls dir1) &lt;(ls dir2)</code><br>在这个示例中，<code>&lt;(ls dir1)</code>和<code>&lt;(ls dir2)</code>将两个<code>ls</code>命令的输出作为文件名传递给<code>diff</code>命令。</p>\n<hr>\n<h3 id=\"Shell-脚本\"><a href=\"#Shell-脚本\" class=\"headerlink\" title=\"Shell 脚本\"></a>Shell 脚本</h3><p>脚本语言：脚本语言是指不需要编译而直接由解释器逐行执行的一类编程语言。源代码在运行时由解释器动态解析和执行。例如Bash 与 python 都是脚本语言 。<br>编译语言：程序执行之前需要通过编译器将源代码转换成机器码（可执行文件）的一类编程语言。编译过程将源代码一次性转换为目标机器能够直接执行的代码。</p>\n<p> #！ Sharp-bang 符号</p>\n<ul>\n<li>放在脚本文件的开头，同一行后面跟着解释器的路径</li>\n<li>实际运行时会调用 sharp-bang 后的解释器，并将脚本文件名作为参数</li>\n<li><code>#</code> 表示注释 </li>\n<li>可以直接用 <code>./script-name</code> 执行脚本<br>一个典型的shell脚本文件以<code>#!/bin/sh</code>或<code>#!/bin/bash</code>开始，这一行称为shebang &#x2F; sharp-bang，用来指明使用哪个shell来执行脚本。<code>#!</code> 后面添加解释器的路径与名称。<br>例如名为<code>copy.py</code>的文件第一行为<code>#!/usr/bin/env python3</code>，当我们用<code>./script-name</code>运行脚本时，相当于<code>python3 copy.py</code> 。<br>后续的行则是具体的命令和逻辑。</li>\n</ul>"},{"title":"卡牌肉鸽开发日志01-游戏的核心玩法及预期设计","date":"2024-07-17T16:00:00.000Z","updated":"2024-07-17T16:00:00.000Z","_content":"\n大家好啊，在暑期开始之前，一直有在群里讲过自己的计划————开发一款卡牌肉鸽游戏，在经历了漫长期末周后，现在终于正式开工了！\n## 核心玩法\n卡牌肉鸽这个门类中有许多优秀的前辈，例如杀戮尖塔、Balatro等等，其中有许多优秀的设计，例如杀戮尖塔费用、抽牌、卡牌攻防之间的关系，Balatro中小丑牌调整摆放顺序影响触发顺序，这些设计让它们具有风格各异的乐趣，提供了重复游玩的价值，我会在设计游戏时参考这些内容。\n当然，一昧的模仿优秀的前辈并不能做出一款有意思的游戏，我制作的卡牌肉鸽区别于优秀前辈在于抽牌机制的设计，杀戮尖塔大概有以下几种抽牌的方式————卡牌效果、每回合开始抽牌、药水抽牌，Balatro则是有一个固定的卡牌上限每当出、弃牌时，都会抽牌直到达到上限，我的卡牌肉鸽手牌类似一条履带，有固定的卡牌上限，每此出最左处的牌时都会进行抽牌，举个例子，我出了2、3序号的牌时，不会抽牌，此时若出了序号为1的牌，便会一次性抽3张牌，基于这样的抽牌规则，卡牌效果的设计可以非常灵活，例如可以设计某张牌效果为下一次抽牌时根据抽牌数量造成高额伤害，这样便鼓励玩家做出保留大量空位的出牌策略。（灵感来源于计算机网络的滑动窗口协议）\n## 预期设计\n使用单例模式去管理游戏的内容，设计事件类，所有会改变游戏内容的玩家操作发送给事件管理器，由事件管理器进行事件的创建、更新、回收，设计对象池避免反复的创建、回收导致的性能浪费，用数据来描述逻辑，游戏内各种数值的设定通过json文件进行配置，通过随机数生成地图。\n","source":"_posts/FlyingfishFantasticfan/卡牌肉鸽开发日志01-游戏的核心玩法及预期设计.md","raw":"---\ntitle: 卡牌肉鸽开发日志01-游戏的核心玩法及预期设计\ndate: 2024-07-18\nupdated: 2024-07-18\npermalink: articles/FlyingfishFantasticfan/卡牌肉鸽开发日志01-游戏的核心玩法及预期设计/\ncategories: FlyingfishFantasticfan\ntags: [游戏开发]\n---\n\n大家好啊，在暑期开始之前，一直有在群里讲过自己的计划————开发一款卡牌肉鸽游戏，在经历了漫长期末周后，现在终于正式开工了！\n## 核心玩法\n卡牌肉鸽这个门类中有许多优秀的前辈，例如杀戮尖塔、Balatro等等，其中有许多优秀的设计，例如杀戮尖塔费用、抽牌、卡牌攻防之间的关系，Balatro中小丑牌调整摆放顺序影响触发顺序，这些设计让它们具有风格各异的乐趣，提供了重复游玩的价值，我会在设计游戏时参考这些内容。\n当然，一昧的模仿优秀的前辈并不能做出一款有意思的游戏，我制作的卡牌肉鸽区别于优秀前辈在于抽牌机制的设计，杀戮尖塔大概有以下几种抽牌的方式————卡牌效果、每回合开始抽牌、药水抽牌，Balatro则是有一个固定的卡牌上限每当出、弃牌时，都会抽牌直到达到上限，我的卡牌肉鸽手牌类似一条履带，有固定的卡牌上限，每此出最左处的牌时都会进行抽牌，举个例子，我出了2、3序号的牌时，不会抽牌，此时若出了序号为1的牌，便会一次性抽3张牌，基于这样的抽牌规则，卡牌效果的设计可以非常灵活，例如可以设计某张牌效果为下一次抽牌时根据抽牌数量造成高额伤害，这样便鼓励玩家做出保留大量空位的出牌策略。（灵感来源于计算机网络的滑动窗口协议）\n## 预期设计\n使用单例模式去管理游戏的内容，设计事件类，所有会改变游戏内容的玩家操作发送给事件管理器，由事件管理器进行事件的创建、更新、回收，设计对象池避免反复的创建、回收导致的性能浪费，用数据来描述逻辑，游戏内各种数值的设定通过json文件进行配置，通过随机数生成地图。\n","slug":"FlyingfishFantasticfan/卡牌肉鸽开发日志01-游戏的核心玩法及预期设计","published":1,"__permalink":"articles/FlyingfishFantasticfan/卡牌肉鸽开发日志01-游戏的核心玩法及预期设计/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r84p0001lcut1uwq9f37","content":"<p>大家好啊，在暑期开始之前，一直有在群里讲过自己的计划————开发一款卡牌肉鸽游戏，在经历了漫长期末周后，现在终于正式开工了！</p>\n<h2 id=\"核心玩法\"><a href=\"#核心玩法\" class=\"headerlink\" title=\"核心玩法\"></a>核心玩法</h2><p>卡牌肉鸽这个门类中有许多优秀的前辈，例如杀戮尖塔、Balatro等等，其中有许多优秀的设计，例如杀戮尖塔费用、抽牌、卡牌攻防之间的关系，Balatro中小丑牌调整摆放顺序影响触发顺序，这些设计让它们具有风格各异的乐趣，提供了重复游玩的价值，我会在设计游戏时参考这些内容。<br>当然，一昧的模仿优秀的前辈并不能做出一款有意思的游戏，我制作的卡牌肉鸽区别于优秀前辈在于抽牌机制的设计，杀戮尖塔大概有以下几种抽牌的方式————卡牌效果、每回合开始抽牌、药水抽牌，Balatro则是有一个固定的卡牌上限每当出、弃牌时，都会抽牌直到达到上限，我的卡牌肉鸽手牌类似一条履带，有固定的卡牌上限，每此出最左处的牌时都会进行抽牌，举个例子，我出了2、3序号的牌时，不会抽牌，此时若出了序号为1的牌，便会一次性抽3张牌，基于这样的抽牌规则，卡牌效果的设计可以非常灵活，例如可以设计某张牌效果为下一次抽牌时根据抽牌数量造成高额伤害，这样便鼓励玩家做出保留大量空位的出牌策略。（灵感来源于计算机网络的滑动窗口协议）</p>\n<h2 id=\"预期设计\"><a href=\"#预期设计\" class=\"headerlink\" title=\"预期设计\"></a>预期设计</h2><p>使用单例模式去管理游戏的内容，设计事件类，所有会改变游戏内容的玩家操作发送给事件管理器，由事件管理器进行事件的创建、更新、回收，设计对象池避免反复的创建、回收导致的性能浪费，用数据来描述逻辑，游戏内各种数值的设定通过json文件进行配置，通过随机数生成地图。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大家好啊，在暑期开始之前，一直有在群里讲过自己的计划————开发一款卡牌肉鸽游戏，在经历了漫长期末周后，现在终于正式开工了！</p>\n<h2 id=\"核心玩法\"><a href=\"#核心玩法\" class=\"headerlink\" title=\"核心玩法\"></a>核心玩法</h2><p>卡牌肉鸽这个门类中有许多优秀的前辈，例如杀戮尖塔、Balatro等等，其中有许多优秀的设计，例如杀戮尖塔费用、抽牌、卡牌攻防之间的关系，Balatro中小丑牌调整摆放顺序影响触发顺序，这些设计让它们具有风格各异的乐趣，提供了重复游玩的价值，我会在设计游戏时参考这些内容。<br>当然，一昧的模仿优秀的前辈并不能做出一款有意思的游戏，我制作的卡牌肉鸽区别于优秀前辈在于抽牌机制的设计，杀戮尖塔大概有以下几种抽牌的方式————卡牌效果、每回合开始抽牌、药水抽牌，Balatro则是有一个固定的卡牌上限每当出、弃牌时，都会抽牌直到达到上限，我的卡牌肉鸽手牌类似一条履带，有固定的卡牌上限，每此出最左处的牌时都会进行抽牌，举个例子，我出了2、3序号的牌时，不会抽牌，此时若出了序号为1的牌，便会一次性抽3张牌，基于这样的抽牌规则，卡牌效果的设计可以非常灵活，例如可以设计某张牌效果为下一次抽牌时根据抽牌数量造成高额伤害，这样便鼓励玩家做出保留大量空位的出牌策略。（灵感来源于计算机网络的滑动窗口协议）</p>\n<h2 id=\"预期设计\"><a href=\"#预期设计\" class=\"headerlink\" title=\"预期设计\"></a>预期设计</h2><p>使用单例模式去管理游戏的内容，设计事件类，所有会改变游戏内容的玩家操作发送给事件管理器，由事件管理器进行事件的创建、更新、回收，设计对象池避免反复的创建、回收导致的性能浪费，用数据来描述逻辑，游戏内各种数值的设定通过json文件进行配置，通过随机数生成地图。</p>\n"},{"title":"网络编程学习笔记-1","date":"2024-10-08T16:00:00.000Z","updated":"2024-10-08T16:00:00.000Z","_content":"\n国庆期间，我在B站游戏开发区知名UP主Voidmatrix的指导下对如何制作联机游戏进行了初步的学习，学习了服务器程序是如何与客户程序进行沟通，初步使用了SDL_net的TCP协议，此篇文章对学习、探索过程的按照时间顺序进行回顾。\n<!-- more -->  \n\n## 第一步-研究哈基米大冒险  \n在此之前，我只有些许计算机网络的理论知识，对于网络编程基本上一无所知，所以第一步先是研究V佬的最新的联机游戏教程-哈基米大冒险的源码，哈基米大冒险的玩法和金山打字的生死时速相同，我没有去看源码中和玩法实现相关的内容，优先去找实现联机功能的部分, 要实现联机的功能，就要让客户端之间用相同的数据去渲染画面，在服务器程序源码便可以找到这些数据  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server_data.png)  \n接着我便开始寻找程序是怎样同步数据，在速览客户端和服务器的源码后,确定了这两段代码就是实现数据同步的部分。\n- **服务器**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server.png)  \n在服务器程序中定义了客户端可以发送的请求，在接收到客户端的请求后可以解析客户端请求的信息，然后响应客户端给客户端提供信息\n>(我感觉就像定义了几个方法，然后客户端那边一调用就可以返回数据)  \n\n- **客户端**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_client.png)  \n客户端这边运行的过程总结一下:\n1. 客户端程序先会向服务器程序发送登陆请求，服务器返回玩家ID，若返回值不为-1则说明成功加入了游戏\n2. 发送请求获取文本的请求，获取打字游戏的文本\n3. 创建一个新线程，每隔一段时间发送一次同步请求，上传自己的游戏进度，并获取另外一个玩家的游戏进度。  \n\n## 第二步-制作联机版井字棋\n在研究完最重要的实现数据同步的方法后，紧接着便开始着手实践，先从最简单的内容开始做起，联机版井字棋。  \n先从差异开始进行分析，联机版井字棋和哈基米大冒险有一个区别，哈基米大冒险客户端只会修改自己的进度数据，这个进度数据不会对另外一个客户端的操作产生影响，因此进度数据只需要同步没有什么限制，而井字棋不同，已经落子的地方不能再次落子，并且落子是回合制的，一人落一次子，不能在对方的回合落子。  \n理解了以上差异后便可以开始编写代码了:\n- **服务器**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_server.png)  \n定义了**登陆**、**更新**、**落子**三个请求，登陆请求会返回给玩家它的ID，更新请求会返回游戏数据 *(一个一维数组，共存储10个数字，前九个数字是棋盘信息，0为空，1、2为玩家落子点，第十个数字是游戏阶段，当为1、2时对应玩家1、2胜利)*，在V佬的提示下，使用了JSON文件进行传输，落子请求会接收一个2位数数字，十位数是玩家ID，个位数代表落子位置，服务器会存储当前落子的玩家ID，以及整个棋盘，若玩家ID正确，且落子位置合法，便会更新棋盘并且切换玩家ID。  \n\n- **客户端**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client.png)  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client_2.png)  \n客户端这边和哈基米大冒险区别不算特别大，都是登陆、新建线程更新，主要的区别是玩家点击棋盘时会发送落子请求，携带落子位置的信息 *(不管点击的位置是不是有棋子，是不是当前落子的玩家都会发送，由服务器来处理)*。\n\n>在完成了联机版井字棋，兴冲冲的测试了几波，感觉十分良好，结果被抓出了没做平局检测（  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/noooooooooooo.png)  \n\n## 第三步-制作联机版提瓦特幸存者\n这部分内容因为最后制作的不算很好,我就大概讲一下制作的思路吧。 *(动画播放最刚开始没有想好所以没有同步，以及不知道什么地方写的有问题导致游戏操作时常会有特别大的延迟)*  \n\n- 初步思路: 我最刚开始想过服务器仅储存敌人、玩家、子弹的位置信息，然后像什么移动、击杀敌人之类的逻辑全丢在客户端当中去实现，和哈基米大冒险的设计基本一致，大概就是两个原版的提瓦特幸存者，中间用个服务器来同步数据,但是这样的设计会导致很多问题，在哈基米大冒险中不会出现数据的冲突，玩家一只会修改进度一，玩家二只会修改进度二，但是提瓦特幸存者中不一样，可能出现以下情况，玩家一被一个敌人击杀，而玩家二在这之前已经把那个敌人击杀，但是还未来得及更新服务器的数据，因此我抛弃了这样的设计。\n- 最终思路: 客户端只负责向服务器发送携带玩家当前移动的方向信息的移动请求，子弹、玩家、敌人的位置更新、碰撞全部由服务器来进行处理，客户端还要时刻向服务器发送更新请求，服务器响应时，使用JSON文件将所有敌人、子弹、玩家的位置信息提供给客户端。\n而后客户端再通过位置信息进行渲染 *(此处还应该携带一个提供时间信息的数据，客户端根据该时间进行动画渲染)*  \n\n## 第四步-SDL_net初步学习\n这一步做了个很简单东西，客户端不断的向服务器发送时间戳，服务器则在每次接收到客户端发送的数据后向所有客户端发送一个接收信息的计数。  \n更加重要的是学习了使用TCP协议传输数据和Select模型。  \n\n关于使用TCP协议进行数据传输有哪些需要注意的部分，我也写了篇博客：[使用TCP进行数据传输需要注意的问题集](https://flyingfishfantasticfan.github.io/2024/10/05/SDL_net%E5%88%9D%E4%BD%93%E9%AA%8C-%E9%87%87%E5%8F%96TCP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86/)\n  \n在这里大致介绍一下Select模型：  \n和HTTP协议每次完成请求、响应后就会断开连接不同，TCP协议的连接会持续存在，直到释放 *(实际上HTTP的步骤就是先建立个TCP连接完成请求、响应后释放TCP连接)*  \n最开始我做了个循环，先接收所有客户端的数据，再向所有客户端发送数据，但是接收信息的过程实际上是会阻塞直到连接中有可接收的数据，因此我想到了为每个客户端都开一个线程，用于接收信息，这样就避免了阻塞对程序的影响。  \n然而为每个客户端单独开一个线程其实会造成很多浪费，每个线程大多数时间都在等待数据，因此诞生许多IO多路复用技术，Select模型就是其中一个。\n在Select模型中，每个线程可以处理多个连接，当某个连接中有可用数据时，才会进行数据接收，这样就既避免了阻塞，又可以一个线程处理多个连接。\n\n---\n文章内容就这些了，十分感谢V佬的指导，我会珍惜这难得的机会努力学习技术的(ง •_•)ง\n>如果有小伙伴需要的话，源码位置：https://github.com/FlyingfishFantasticfan/net_project","source":"_posts/FlyingfishFantasticfan/网络编程学习笔记-1.md","raw":"---\ntitle: 网络编程学习笔记-1\ncategories: FlyingfishFantasticfan\ndate: 2024-10-09\nupdated: 2024-10-09\npermalink: articles/FlyingfishFantasticfan/网络编程学习笔记-1/\ntags: [游戏开发,C++,SDL,网络编程]\n---\n\n国庆期间，我在B站游戏开发区知名UP主Voidmatrix的指导下对如何制作联机游戏进行了初步的学习，学习了服务器程序是如何与客户程序进行沟通，初步使用了SDL_net的TCP协议，此篇文章对学习、探索过程的按照时间顺序进行回顾。\n<!-- more -->  \n\n## 第一步-研究哈基米大冒险  \n在此之前，我只有些许计算机网络的理论知识，对于网络编程基本上一无所知，所以第一步先是研究V佬的最新的联机游戏教程-哈基米大冒险的源码，哈基米大冒险的玩法和金山打字的生死时速相同，我没有去看源码中和玩法实现相关的内容，优先去找实现联机功能的部分, 要实现联机的功能，就要让客户端之间用相同的数据去渲染画面，在服务器程序源码便可以找到这些数据  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server_data.png)  \n接着我便开始寻找程序是怎样同步数据，在速览客户端和服务器的源码后,确定了这两段代码就是实现数据同步的部分。\n- **服务器**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server.png)  \n在服务器程序中定义了客户端可以发送的请求，在接收到客户端的请求后可以解析客户端请求的信息，然后响应客户端给客户端提供信息\n>(我感觉就像定义了几个方法，然后客户端那边一调用就可以返回数据)  \n\n- **客户端**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_client.png)  \n客户端这边运行的过程总结一下:\n1. 客户端程序先会向服务器程序发送登陆请求，服务器返回玩家ID，若返回值不为-1则说明成功加入了游戏\n2. 发送请求获取文本的请求，获取打字游戏的文本\n3. 创建一个新线程，每隔一段时间发送一次同步请求，上传自己的游戏进度，并获取另外一个玩家的游戏进度。  \n\n## 第二步-制作联机版井字棋\n在研究完最重要的实现数据同步的方法后，紧接着便开始着手实践，先从最简单的内容开始做起，联机版井字棋。  \n先从差异开始进行分析，联机版井字棋和哈基米大冒险有一个区别，哈基米大冒险客户端只会修改自己的进度数据，这个进度数据不会对另外一个客户端的操作产生影响，因此进度数据只需要同步没有什么限制，而井字棋不同，已经落子的地方不能再次落子，并且落子是回合制的，一人落一次子，不能在对方的回合落子。  \n理解了以上差异后便可以开始编写代码了:\n- **服务器**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_server.png)  \n定义了**登陆**、**更新**、**落子**三个请求，登陆请求会返回给玩家它的ID，更新请求会返回游戏数据 *(一个一维数组，共存储10个数字，前九个数字是棋盘信息，0为空，1、2为玩家落子点，第十个数字是游戏阶段，当为1、2时对应玩家1、2胜利)*，在V佬的提示下，使用了JSON文件进行传输，落子请求会接收一个2位数数字，十位数是玩家ID，个位数代表落子位置，服务器会存储当前落子的玩家ID，以及整个棋盘，若玩家ID正确，且落子位置合法，便会更新棋盘并且切换玩家ID。  \n\n- **客户端**:  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client.png)  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client_2.png)  \n客户端这边和哈基米大冒险区别不算特别大，都是登陆、新建线程更新，主要的区别是玩家点击棋盘时会发送落子请求，携带落子位置的信息 *(不管点击的位置是不是有棋子，是不是当前落子的玩家都会发送，由服务器来处理)*。\n\n>在完成了联机版井字棋，兴冲冲的测试了几波，感觉十分良好，结果被抓出了没做平局检测（  \n![](articles/FlyingfishFantasticfan/网络编程学习笔记-1/noooooooooooo.png)  \n\n## 第三步-制作联机版提瓦特幸存者\n这部分内容因为最后制作的不算很好,我就大概讲一下制作的思路吧。 *(动画播放最刚开始没有想好所以没有同步，以及不知道什么地方写的有问题导致游戏操作时常会有特别大的延迟)*  \n\n- 初步思路: 我最刚开始想过服务器仅储存敌人、玩家、子弹的位置信息，然后像什么移动、击杀敌人之类的逻辑全丢在客户端当中去实现，和哈基米大冒险的设计基本一致，大概就是两个原版的提瓦特幸存者，中间用个服务器来同步数据,但是这样的设计会导致很多问题，在哈基米大冒险中不会出现数据的冲突，玩家一只会修改进度一，玩家二只会修改进度二，但是提瓦特幸存者中不一样，可能出现以下情况，玩家一被一个敌人击杀，而玩家二在这之前已经把那个敌人击杀，但是还未来得及更新服务器的数据，因此我抛弃了这样的设计。\n- 最终思路: 客户端只负责向服务器发送携带玩家当前移动的方向信息的移动请求，子弹、玩家、敌人的位置更新、碰撞全部由服务器来进行处理，客户端还要时刻向服务器发送更新请求，服务器响应时，使用JSON文件将所有敌人、子弹、玩家的位置信息提供给客户端。\n而后客户端再通过位置信息进行渲染 *(此处还应该携带一个提供时间信息的数据，客户端根据该时间进行动画渲染)*  \n\n## 第四步-SDL_net初步学习\n这一步做了个很简单东西，客户端不断的向服务器发送时间戳，服务器则在每次接收到客户端发送的数据后向所有客户端发送一个接收信息的计数。  \n更加重要的是学习了使用TCP协议传输数据和Select模型。  \n\n关于使用TCP协议进行数据传输有哪些需要注意的部分，我也写了篇博客：[使用TCP进行数据传输需要注意的问题集](https://flyingfishfantasticfan.github.io/2024/10/05/SDL_net%E5%88%9D%E4%BD%93%E9%AA%8C-%E9%87%87%E5%8F%96TCP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86/)\n  \n在这里大致介绍一下Select模型：  \n和HTTP协议每次完成请求、响应后就会断开连接不同，TCP协议的连接会持续存在，直到释放 *(实际上HTTP的步骤就是先建立个TCP连接完成请求、响应后释放TCP连接)*  \n最开始我做了个循环，先接收所有客户端的数据，再向所有客户端发送数据，但是接收信息的过程实际上是会阻塞直到连接中有可接收的数据，因此我想到了为每个客户端都开一个线程，用于接收信息，这样就避免了阻塞对程序的影响。  \n然而为每个客户端单独开一个线程其实会造成很多浪费，每个线程大多数时间都在等待数据，因此诞生许多IO多路复用技术，Select模型就是其中一个。\n在Select模型中，每个线程可以处理多个连接，当某个连接中有可用数据时，才会进行数据接收，这样就既避免了阻塞，又可以一个线程处理多个连接。\n\n---\n文章内容就这些了，十分感谢V佬的指导，我会珍惜这难得的机会努力学习技术的(ง •_•)ง\n>如果有小伙伴需要的话，源码位置：https://github.com/FlyingfishFantasticfan/net_project","slug":"FlyingfishFantasticfan/网络编程学习笔记-1","published":1,"__permalink":"articles/FlyingfishFantasticfan/网络编程学习笔记-1/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r8510004lcutf22j0obd","content":"<p>国庆期间，我在B站游戏开发区知名UP主Voidmatrix的指导下对如何制作联机游戏进行了初步的学习，学习了服务器程序是如何与客户程序进行沟通，初步使用了SDL_net的TCP协议，此篇文章对学习、探索过程的按照时间顺序进行回顾。</p>\n<span id=\"more\"></span>  \n\n<h2 id=\"第一步-研究哈基米大冒险\"><a href=\"#第一步-研究哈基米大冒险\" class=\"headerlink\" title=\"第一步-研究哈基米大冒险\"></a>第一步-研究哈基米大冒险</h2><p>在此之前，我只有些许计算机网络的理论知识，对于网络编程基本上一无所知，所以第一步先是研究V佬的最新的联机游戏教程-哈基米大冒险的源码，哈基米大冒险的玩法和金山打字的生死时速相同，我没有去看源码中和玩法实现相关的内容，优先去找实现联机功能的部分, 要实现联机的功能，就要让客户端之间用相同的数据去渲染画面，在服务器程序源码便可以找到这些数据<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_server_data.png\"><br>接着我便开始寻找程序是怎样同步数据，在速览客户端和服务器的源码后,确定了这两段代码就是实现数据同步的部分。</p>\n<ul>\n<li><p><strong>服务器</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_server.png\"><br>在服务器程序中定义了客户端可以发送的请求，在接收到客户端的请求后可以解析客户端请求的信息，然后响应客户端给客户端提供信息</p>\n<blockquote>\n<p>(我感觉就像定义了几个方法，然后客户端那边一调用就可以返回数据)  </p>\n</blockquote>\n</li>\n<li><p><strong>客户端</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_client.png\"><br>客户端这边运行的过程总结一下:</p>\n</li>\n</ul>\n<ol>\n<li>客户端程序先会向服务器程序发送登陆请求，服务器返回玩家ID，若返回值不为-1则说明成功加入了游戏</li>\n<li>发送请求获取文本的请求，获取打字游戏的文本</li>\n<li>创建一个新线程，每隔一段时间发送一次同步请求，上传自己的游戏进度，并获取另外一个玩家的游戏进度。</li>\n</ol>\n<h2 id=\"第二步-制作联机版井字棋\"><a href=\"#第二步-制作联机版井字棋\" class=\"headerlink\" title=\"第二步-制作联机版井字棋\"></a>第二步-制作联机版井字棋</h2><p>在研究完最重要的实现数据同步的方法后，紧接着便开始着手实践，先从最简单的内容开始做起，联机版井字棋。<br>先从差异开始进行分析，联机版井字棋和哈基米大冒险有一个区别，哈基米大冒险客户端只会修改自己的进度数据，这个进度数据不会对另外一个客户端的操作产生影响，因此进度数据只需要同步没有什么限制，而井字棋不同，已经落子的地方不能再次落子，并且落子是回合制的，一人落一次子，不能在对方的回合落子。<br>理解了以上差异后便可以开始编写代码了:</p>\n<ul>\n<li><p><strong>服务器</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_server.png\"><br>定义了<strong>登陆</strong>、<strong>更新</strong>、<strong>落子</strong>三个请求，登陆请求会返回给玩家它的ID，更新请求会返回游戏数据 *(一个一维数组，共存储10个数字，前九个数字是棋盘信息，0为空，1、2为玩家落子点，第十个数字是游戏阶段，当为1、2时对应玩家1、2胜利)*，在V佬的提示下，使用了JSON文件进行传输，落子请求会接收一个2位数数字，十位数是玩家ID，个位数代表落子位置，服务器会存储当前落子的玩家ID，以及整个棋盘，若玩家ID正确，且落子位置合法，便会更新棋盘并且切换玩家ID。  </p>\n</li>\n<li><p><strong>客户端</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_client.png\"><br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_client_2.png\"><br>客户端这边和哈基米大冒险区别不算特别大，都是登陆、新建线程更新，主要的区别是玩家点击棋盘时会发送落子请求，携带落子位置的信息 *(不管点击的位置是不是有棋子，是不是当前落子的玩家都会发送，由服务器来处理)*。</p>\n</li>\n</ul>\n<blockquote>\n<p>在完成了联机版井字棋，兴冲冲的测试了几波，感觉十分良好，结果被抓出了没做平局检测（<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/noooooooooooo.png\">  </p>\n</blockquote>\n<h2 id=\"第三步-制作联机版提瓦特幸存者\"><a href=\"#第三步-制作联机版提瓦特幸存者\" class=\"headerlink\" title=\"第三步-制作联机版提瓦特幸存者\"></a>第三步-制作联机版提瓦特幸存者</h2><p>这部分内容因为最后制作的不算很好,我就大概讲一下制作的思路吧。 <em>(动画播放最刚开始没有想好所以没有同步，以及不知道什么地方写的有问题导致游戏操作时常会有特别大的延迟)</em>  </p>\n<ul>\n<li>初步思路: 我最刚开始想过服务器仅储存敌人、玩家、子弹的位置信息，然后像什么移动、击杀敌人之类的逻辑全丢在客户端当中去实现，和哈基米大冒险的设计基本一致，大概就是两个原版的提瓦特幸存者，中间用个服务器来同步数据,但是这样的设计会导致很多问题，在哈基米大冒险中不会出现数据的冲突，玩家一只会修改进度一，玩家二只会修改进度二，但是提瓦特幸存者中不一样，可能出现以下情况，玩家一被一个敌人击杀，而玩家二在这之前已经把那个敌人击杀，但是还未来得及更新服务器的数据，因此我抛弃了这样的设计。</li>\n<li>最终思路: 客户端只负责向服务器发送携带玩家当前移动的方向信息的移动请求，子弹、玩家、敌人的位置更新、碰撞全部由服务器来进行处理，客户端还要时刻向服务器发送更新请求，服务器响应时，使用JSON文件将所有敌人、子弹、玩家的位置信息提供给客户端。<br>而后客户端再通过位置信息进行渲染 <em>(此处还应该携带一个提供时间信息的数据，客户端根据该时间进行动画渲染)</em></li>\n</ul>\n<h2 id=\"第四步-SDL-net初步学习\"><a href=\"#第四步-SDL-net初步学习\" class=\"headerlink\" title=\"第四步-SDL_net初步学习\"></a>第四步-SDL_net初步学习</h2><p>这一步做了个很简单东西，客户端不断的向服务器发送时间戳，服务器则在每次接收到客户端发送的数据后向所有客户端发送一个接收信息的计数。<br>更加重要的是学习了使用TCP协议传输数据和Select模型。  </p>\n<p>关于使用TCP协议进行数据传输有哪些需要注意的部分，我也写了篇博客：<a href=\"https://flyingfishfantasticfan.github.io/2024/10/05/SDL_net%E5%88%9D%E4%BD%93%E9%AA%8C-%E9%87%87%E5%8F%96TCP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86/\">使用TCP进行数据传输需要注意的问题集</a></p>\n<p>在这里大致介绍一下Select模型：<br>和HTTP协议每次完成请求、响应后就会断开连接不同，TCP协议的连接会持续存在，直到释放 <em>(实际上HTTP的步骤就是先建立个TCP连接完成请求、响应后释放TCP连接)</em><br>最开始我做了个循环，先接收所有客户端的数据，再向所有客户端发送数据，但是接收信息的过程实际上是会阻塞直到连接中有可接收的数据，因此我想到了为每个客户端都开一个线程，用于接收信息，这样就避免了阻塞对程序的影响。<br>然而为每个客户端单独开一个线程其实会造成很多浪费，每个线程大多数时间都在等待数据，因此诞生许多IO多路复用技术，Select模型就是其中一个。<br>在Select模型中，每个线程可以处理多个连接，当某个连接中有可用数据时，才会进行数据接收，这样就既避免了阻塞，又可以一个线程处理多个连接。</p>\n<hr>\n<p>文章内容就这些了，十分感谢V佬的指导，我会珍惜这难得的机会努力学习技术的(ง •_•)ง</p>\n<blockquote>\n<p>如果有小伙伴需要的话，源码位置：<a href=\"https://github.com/FlyingfishFantasticfan/net_project\">https://github.com/FlyingfishFantasticfan/net_project</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>国庆期间，我在B站游戏开发区知名UP主Voidmatrix的指导下对如何制作联机游戏进行了初步的学习，学习了服务器程序是如何与客户程序进行沟通，初步使用了SDL_net的TCP协议，此篇文章对学习、探索过程的按照时间顺序进行回顾。</p>","more":"<h2 id=\"第一步-研究哈基米大冒险\"><a href=\"#第一步-研究哈基米大冒险\" class=\"headerlink\" title=\"第一步-研究哈基米大冒险\"></a>第一步-研究哈基米大冒险</h2><p>在此之前，我只有些许计算机网络的理论知识，对于网络编程基本上一无所知，所以第一步先是研究V佬的最新的联机游戏教程-哈基米大冒险的源码，哈基米大冒险的玩法和金山打字的生死时速相同，我没有去看源码中和玩法实现相关的内容，优先去找实现联机功能的部分, 要实现联机的功能，就要让客户端之间用相同的数据去渲染画面，在服务器程序源码便可以找到这些数据<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_server_data.png\"><br>接着我便开始寻找程序是怎样同步数据，在速览客户端和服务器的源码后,确定了这两段代码就是实现数据同步的部分。</p>\n<ul>\n<li><p><strong>服务器</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_server.png\"><br>在服务器程序中定义了客户端可以发送的请求，在接收到客户端的请求后可以解析客户端请求的信息，然后响应客户端给客户端提供信息</p>\n<blockquote>\n<p>(我感觉就像定义了几个方法，然后客户端那边一调用就可以返回数据)  </p>\n</blockquote>\n</li>\n<li><p><strong>客户端</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/hachimi_client.png\"><br>客户端这边运行的过程总结一下:</p>\n</li>\n</ul>\n<ol>\n<li>客户端程序先会向服务器程序发送登陆请求，服务器返回玩家ID，若返回值不为-1则说明成功加入了游戏</li>\n<li>发送请求获取文本的请求，获取打字游戏的文本</li>\n<li>创建一个新线程，每隔一段时间发送一次同步请求，上传自己的游戏进度，并获取另外一个玩家的游戏进度。</li>\n</ol>\n<h2 id=\"第二步-制作联机版井字棋\"><a href=\"#第二步-制作联机版井字棋\" class=\"headerlink\" title=\"第二步-制作联机版井字棋\"></a>第二步-制作联机版井字棋</h2><p>在研究完最重要的实现数据同步的方法后，紧接着便开始着手实践，先从最简单的内容开始做起，联机版井字棋。<br>先从差异开始进行分析，联机版井字棋和哈基米大冒险有一个区别，哈基米大冒险客户端只会修改自己的进度数据，这个进度数据不会对另外一个客户端的操作产生影响，因此进度数据只需要同步没有什么限制，而井字棋不同，已经落子的地方不能再次落子，并且落子是回合制的，一人落一次子，不能在对方的回合落子。<br>理解了以上差异后便可以开始编写代码了:</p>\n<ul>\n<li><p><strong>服务器</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_server.png\"><br>定义了<strong>登陆</strong>、<strong>更新</strong>、<strong>落子</strong>三个请求，登陆请求会返回给玩家它的ID，更新请求会返回游戏数据 *(一个一维数组，共存储10个数字，前九个数字是棋盘信息，0为空，1、2为玩家落子点，第十个数字是游戏阶段，当为1、2时对应玩家1、2胜利)*，在V佬的提示下，使用了JSON文件进行传输，落子请求会接收一个2位数数字，十位数是玩家ID，个位数代表落子位置，服务器会存储当前落子的玩家ID，以及整个棋盘，若玩家ID正确，且落子位置合法，便会更新棋盘并且切换玩家ID。  </p>\n</li>\n<li><p><strong>客户端</strong>:<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_client.png\"><br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/jing_client_2.png\"><br>客户端这边和哈基米大冒险区别不算特别大，都是登陆、新建线程更新，主要的区别是玩家点击棋盘时会发送落子请求，携带落子位置的信息 *(不管点击的位置是不是有棋子，是不是当前落子的玩家都会发送，由服务器来处理)*。</p>\n</li>\n</ul>\n<blockquote>\n<p>在完成了联机版井字棋，兴冲冲的测试了几波，感觉十分良好，结果被抓出了没做平局检测（<br><img src=\"/articles/FlyingfishFantasticfan/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/noooooooooooo.png\">  </p>\n</blockquote>\n<h2 id=\"第三步-制作联机版提瓦特幸存者\"><a href=\"#第三步-制作联机版提瓦特幸存者\" class=\"headerlink\" title=\"第三步-制作联机版提瓦特幸存者\"></a>第三步-制作联机版提瓦特幸存者</h2><p>这部分内容因为最后制作的不算很好,我就大概讲一下制作的思路吧。 <em>(动画播放最刚开始没有想好所以没有同步，以及不知道什么地方写的有问题导致游戏操作时常会有特别大的延迟)</em>  </p>\n<ul>\n<li>初步思路: 我最刚开始想过服务器仅储存敌人、玩家、子弹的位置信息，然后像什么移动、击杀敌人之类的逻辑全丢在客户端当中去实现，和哈基米大冒险的设计基本一致，大概就是两个原版的提瓦特幸存者，中间用个服务器来同步数据,但是这样的设计会导致很多问题，在哈基米大冒险中不会出现数据的冲突，玩家一只会修改进度一，玩家二只会修改进度二，但是提瓦特幸存者中不一样，可能出现以下情况，玩家一被一个敌人击杀，而玩家二在这之前已经把那个敌人击杀，但是还未来得及更新服务器的数据，因此我抛弃了这样的设计。</li>\n<li>最终思路: 客户端只负责向服务器发送携带玩家当前移动的方向信息的移动请求，子弹、玩家、敌人的位置更新、碰撞全部由服务器来进行处理，客户端还要时刻向服务器发送更新请求，服务器响应时，使用JSON文件将所有敌人、子弹、玩家的位置信息提供给客户端。<br>而后客户端再通过位置信息进行渲染 <em>(此处还应该携带一个提供时间信息的数据，客户端根据该时间进行动画渲染)</em></li>\n</ul>\n<h2 id=\"第四步-SDL-net初步学习\"><a href=\"#第四步-SDL-net初步学习\" class=\"headerlink\" title=\"第四步-SDL_net初步学习\"></a>第四步-SDL_net初步学习</h2><p>这一步做了个很简单东西，客户端不断的向服务器发送时间戳，服务器则在每次接收到客户端发送的数据后向所有客户端发送一个接收信息的计数。<br>更加重要的是学习了使用TCP协议传输数据和Select模型。  </p>\n<p>关于使用TCP协议进行数据传输有哪些需要注意的部分，我也写了篇博客：<a href=\"https://flyingfishfantasticfan.github.io/2024/10/05/SDL_net%E5%88%9D%E4%BD%93%E9%AA%8C-%E9%87%87%E5%8F%96TCP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E9%9B%86/\">使用TCP进行数据传输需要注意的问题集</a></p>\n<p>在这里大致介绍一下Select模型：<br>和HTTP协议每次完成请求、响应后就会断开连接不同，TCP协议的连接会持续存在，直到释放 <em>(实际上HTTP的步骤就是先建立个TCP连接完成请求、响应后释放TCP连接)</em><br>最开始我做了个循环，先接收所有客户端的数据，再向所有客户端发送数据，但是接收信息的过程实际上是会阻塞直到连接中有可接收的数据，因此我想到了为每个客户端都开一个线程，用于接收信息，这样就避免了阻塞对程序的影响。<br>然而为每个客户端单独开一个线程其实会造成很多浪费，每个线程大多数时间都在等待数据，因此诞生许多IO多路复用技术，Select模型就是其中一个。<br>在Select模型中，每个线程可以处理多个连接，当某个连接中有可用数据时，才会进行数据接收，这样就既避免了阻塞，又可以一个线程处理多个连接。</p>\n<hr>\n<p>文章内容就这些了，十分感谢V佬的指导，我会珍惜这难得的机会努力学习技术的(ง •_•)ง</p>\n<blockquote>\n<p>如果有小伙伴需要的话，源码位置：<a href=\"https://github.com/FlyingfishFantasticfan/net_project\">https://github.com/FlyingfishFantasticfan/net_project</a></p>\n</blockquote>"},{"title":"植物明星大乱斗血包道具","date":"2024-06-08T16:00:00.000Z","update":"2024-06-08T16:00:00.000Z","_content":"\n植物明星大乱斗血包道具制作，简单的*bullet*类延展设计\n菜鸟的游戏学习实践记录O.O\n\n<!-- more -->\n\n### 先来看看血包的游戏内展示\n<div style=\"text-align:center\">\n\n![ICON](articles/Kritace/植物明星大乱斗血包道具/血包实例图.png)\n\n</div>\n其中那个红色的小球，就是血包，吃了之后可以加30hp。\n\n### **具体思路及代码设计**\n#### **1.私有属性与接口设计**\n```cpp\n\\\\ hp_ball.h\n\nclass HpBall\n{\npublic:\n\tHpBall() = default;\n\t~HpBall() = default;\n\n\tvoid on_draw(const Camera& camera);\n\tvoid on_update(int delta);\n\tbool check_if_exceeds_screen();         // 判断血包是否处于屏幕外\n\tvoid on_collision(Player*& player);     // 血包与角色碰撞后的加血逻辑\n\tbool check_collision(Player*& player);  // 血包与角色是否碰撞\n\tbool check_can_remove() const;          // 血包是否可被移除\n\nprivate:\n\tVector2 position;\n\tVector2 size;\n\tVector2 velocity;\n\n\tint add_hp = 30;\n\tbool can_remove = false;\n\t\n\tPlayerID target_id = PlayerID::P1;      // 与血包发生碰撞的角色ID\n\tTimer timer_hp_ball_remove;             // 血包自动消失的计时器\n}; \n```\n由于我们需要知道与血包碰撞的角色ID，同时还要对该角色的hp进行修改操作，所以不得不来到*player*类中增加接口：\n```cpp\n// player.h\n\npublic:\n\tvoid add_hp(int add) { hp = min(100, hp + add); }\n\tPlayerID& get_playerID() { return id; }\n```\n#### **2.血包的生命周期管理**\n*hp_ball*类与*bullet*类十分相似，因此我们可以仿照*bullet*的生命周期，设计一个全局vector：\n```cpp\n// main.cpp\n\nstd::vector<HpBall*> hp_ball_list;\n```\n但是，与*bullet*类不同的是，*hp_ball*类的生成并不归*player*管，而应该由更上层的模块进行管理，为避免过多的全局变量，生成与删除*hp_ball*的工作我们都交给*game_scene*：\n```cpp\n// game_scene.h\n\nprivate:\n    Timer timer_create_hp_ball;                     // 用于定时循环重复生成新的血包\n\tbool can_hp_ball_create = true;                 // 血包是否可被生成\n\npublic:\n    // on_enter中\n\t\ttimer_create_hp_ball.set_wait_time(4000);   // 生成血包的间隔时间\n\t\ttimer_create_hp_ball.set_one_shot(false);   // 血包会重复生成\n\t\ttimer_create_hp_ball.set_callback([&]()     \n\t\t\t{\n\t\t\t\tcan_hp_ball_create = true;\n\t\t\t});                                     // 血包消失后，立即设置为可生成状态\n\n    // on_update中\n\t\ttimer_create_hp_ball.on_update(delta);\n\t\tif (can_hp_ball_create)\n\t\t{\n\t\t\tHpBall* hp_ball = new HpBall();\n\t\t\thp_ball_list.push_back(hp_ball);\n\t\t\tcan_hp_ball_create = false;\n\t\t}\n\n        // 与bullet相同\n\t\thp_ball_list.erase(std::remove_if(\n\t\t\thp_ball_list.begin(), hp_ball_list.end(),\n\t\t\t[](const HpBall* hp_ball)\n\t\t\t{\n\t\t\t\tbool deletable = hp_ball->check_can_remove();\n\t\t\t\tif (deletable) delete hp_ball;\n\t\t\t\treturn deletable;\n\t\t\t}),\n\t\t\thp_ball_list.end());\n\n\t\tfor (HpBall* hp_ball : hp_ball_list)\n\t\t\thp_ball->on_update(delta);\n\n    // on_draw中\n    \tfor (HpBall* hp_ball : hp_ball_list)\n\t\t    hp_ball->on_draw(camera);\n```\n#### **3.随机生成血包位置**\n众所那个周知，使用\n```cpp\nsrand((int)time(0));\nrand();\n```\n就可以生成每次都不一样的随机数，但如果粗暴地将这一套放入循环内，或*HpBall*的构造函数中，就会惊讶地发现，每次小球生成的位置居然是一样的，虽然每次运行后小球的位置会有所改变，但小球在整局游戏中，都只会在这个位置生成了，非常boring。（原理应该是随机数种子在生成时被固定了？我太菜了还没有完全搞懂sos）\n\n总之，解决方法是这样的：\n```cpp\n// main.cpp\n\nsrand((int)time(0)); // 将这句放入main()语句中\n```\n然后就可以在*HpBall*中使用构造函数随机生成x轴位置了，每次实例化*HpBall*都会拥有一个随机的x坐标\n```cpp\n// hp_ball.h\n\n\tHpBall()\n\t{\n\t\tsize.x = 70, size.y = 70;\n\t\tposition.x = rand() % getwidth();\n\t\tposition.y = 35;\n\t\tvelocity.y = 0.3f, velocity.x = 0;\n\n\t\ttimer_hp_ball_remove.set_wait_time(5000);\n\t\ttimer_hp_ball_remove.set_one_shot(true);\n\t\ttimer_hp_ball_remove.set_callback([&]()\n\t\t\t{\n\t\t\t\tcan_remove = true;\n\t\t\t});\n\t}\n```\n### **完整的*HpBall*代码实现**\n```cpp\n// hp_ball.h\n\n#ifndef _HP_BALL_H_\n#define _HP_BALL_H_\n\n#include \"easyx.h\"\n#include \"vector2.h\"\n#include \"player_id.h\"\n#include \"player.h\"\n\n#include <time.h>\n#include <stdlib.h>\n#include <functional>\n#include <vector>\n\nextern Player* player_1;\nextern Player* player_2;\n\nclass HpBall\n{\npublic:\n\tHpBall()\n\t{\n\t\tsize.x = 70, size.y = 70;\n\t\tposition.x = rand() % getwidth();\n\t\tposition.y = 35;\n\t\tvelocity.y = 0.3f, velocity.x = 0;\n\n\t\ttimer_hp_ball_remove.set_wait_time(5000);\n\t\ttimer_hp_ball_remove.set_one_shot(true);\n\t\ttimer_hp_ball_remove.set_callback([&]()\n\t\t\t{\n\t\t\t\tcan_remove = true;\n\t\t\t});\n\t}\n\n\t~HpBall() = default;\n\n\tvoid on_draw(const Camera& camera) \n\t{\n\t\tsetlinecolor(RGB(255, 155, 50));\t//\t绘制血包边框\n\t\tsetfillcolor(RGB(200, 75, 10));\t\t//\t绘制血包颜色\n\t\tfillcircle(position.x, position.y, 35);\t\n\t}\n\n\tvoid on_update(int delta)\n\t{\n\t\tposition += velocity * (float)delta;\n\n\t\tif (check_if_exceeds_screen())\n\t\t\tcan_remove = true;\n\n\t\ttimer_hp_ball_remove.on_update(delta);\n\n\t\ton_collision(player_1);\n\t\ton_collision(player_2);\n\t}\n\n\tbool check_if_exceeds_screen()\t\t// 判断血包是否处于屏幕外\n\t{\n\t\treturn (position.x + size.x <= 0 || position.x >= getwidth()\n\t\t\t|| position.y + size.y <= 0 || position.y >= getheight());\n\t}\n\n\tvoid on_collision(Player*& player)\n\t{\n\t\tif (check_collision(player))\n\t\t{\n\t\t\ttarget_id = player->get_playerID();\n\t\t\tif (target_id == PlayerID::P1)\n\t\t\t\tplayer_1->add_hp(add_hp);\n\t\t\telse\n\t\t\t\tplayer_2->add_hp(add_hp);\n\t\t\t\n\t\t\tcan_remove = true;\n\t\t}\n\t}\n\n\tbool check_collision(Player*& player)\n\t{\n\t\treturn this->position.x + this->size.x / 2 >= player->get_position().x\n\t\t\t&& this->position.x + this->size.x / 2 <= player->get_position().x + player->get_size().x\n\t\t\t&& this->position.y + this->size.y / 2 >= player->get_position().y\n\t\t\t&& this->position.y + this->size.y / 2 <= player->get_position().y + player->get_size().y;\n\t}\n\n\tbool check_can_remove() const\n\t{\n\t\treturn can_remove;\n\t}\n\nprivate:\n\tVector2 position;\n\tVector2 size;\n\tVector2 velocity;\n\n\tint add_hp = 30;\n\tbool can_remove = false;\n\t\n\tPlayerID target_id = PlayerID::P1;\n\tTimer timer_hp_ball_remove;\n};\n\n#endif // !_HP_BALL_H_\n```\n除了*hp_ball.h*外，*game_scene*与*main*、*player*类都有改动，以及相互extern的操作，所以以上并非全部的实现代码。\n\n#### **碎碎念**\n其实*HpBall*应该完全可以通过继承*Bullet*类来实现，修改一下*Bullet*类便可以更完美地实现解耦，日后我也会继续进行改进。\n\n其实我是一名经济学大二的学生哈哈哈哈哈，但制作游戏真的太好玩了，也十分谢谢大V老师启发并满足了我学习的欲望，这也是我第一篇学习记录，希望可以成为一个美好的开端吧。\n*Best Wishes To Everyone*\n\n##### **最新消息**\n大V老师直播做了个我的高级版，私密马赛，发晚了:no_mouth:\n","source":"_posts/Kritace/植物明星大乱斗血包道具.md","raw":"---\ntitle: 植物明星大乱斗血包道具\ndate: 2024-06-09\nupdate: 2024-06-09\npermalink: articles/Kritace/植物明星大乱斗血包道具/\ncategories: Kritace\ntags: [学习心得]\n---\n\n植物明星大乱斗血包道具制作，简单的*bullet*类延展设计\n菜鸟的游戏学习实践记录O.O\n\n<!-- more -->\n\n### 先来看看血包的游戏内展示\n<div style=\"text-align:center\">\n\n![ICON](articles/Kritace/植物明星大乱斗血包道具/血包实例图.png)\n\n</div>\n其中那个红色的小球，就是血包，吃了之后可以加30hp。\n\n### **具体思路及代码设计**\n#### **1.私有属性与接口设计**\n```cpp\n\\\\ hp_ball.h\n\nclass HpBall\n{\npublic:\n\tHpBall() = default;\n\t~HpBall() = default;\n\n\tvoid on_draw(const Camera& camera);\n\tvoid on_update(int delta);\n\tbool check_if_exceeds_screen();         // 判断血包是否处于屏幕外\n\tvoid on_collision(Player*& player);     // 血包与角色碰撞后的加血逻辑\n\tbool check_collision(Player*& player);  // 血包与角色是否碰撞\n\tbool check_can_remove() const;          // 血包是否可被移除\n\nprivate:\n\tVector2 position;\n\tVector2 size;\n\tVector2 velocity;\n\n\tint add_hp = 30;\n\tbool can_remove = false;\n\t\n\tPlayerID target_id = PlayerID::P1;      // 与血包发生碰撞的角色ID\n\tTimer timer_hp_ball_remove;             // 血包自动消失的计时器\n}; \n```\n由于我们需要知道与血包碰撞的角色ID，同时还要对该角色的hp进行修改操作，所以不得不来到*player*类中增加接口：\n```cpp\n// player.h\n\npublic:\n\tvoid add_hp(int add) { hp = min(100, hp + add); }\n\tPlayerID& get_playerID() { return id; }\n```\n#### **2.血包的生命周期管理**\n*hp_ball*类与*bullet*类十分相似，因此我们可以仿照*bullet*的生命周期，设计一个全局vector：\n```cpp\n// main.cpp\n\nstd::vector<HpBall*> hp_ball_list;\n```\n但是，与*bullet*类不同的是，*hp_ball*类的生成并不归*player*管，而应该由更上层的模块进行管理，为避免过多的全局变量，生成与删除*hp_ball*的工作我们都交给*game_scene*：\n```cpp\n// game_scene.h\n\nprivate:\n    Timer timer_create_hp_ball;                     // 用于定时循环重复生成新的血包\n\tbool can_hp_ball_create = true;                 // 血包是否可被生成\n\npublic:\n    // on_enter中\n\t\ttimer_create_hp_ball.set_wait_time(4000);   // 生成血包的间隔时间\n\t\ttimer_create_hp_ball.set_one_shot(false);   // 血包会重复生成\n\t\ttimer_create_hp_ball.set_callback([&]()     \n\t\t\t{\n\t\t\t\tcan_hp_ball_create = true;\n\t\t\t});                                     // 血包消失后，立即设置为可生成状态\n\n    // on_update中\n\t\ttimer_create_hp_ball.on_update(delta);\n\t\tif (can_hp_ball_create)\n\t\t{\n\t\t\tHpBall* hp_ball = new HpBall();\n\t\t\thp_ball_list.push_back(hp_ball);\n\t\t\tcan_hp_ball_create = false;\n\t\t}\n\n        // 与bullet相同\n\t\thp_ball_list.erase(std::remove_if(\n\t\t\thp_ball_list.begin(), hp_ball_list.end(),\n\t\t\t[](const HpBall* hp_ball)\n\t\t\t{\n\t\t\t\tbool deletable = hp_ball->check_can_remove();\n\t\t\t\tif (deletable) delete hp_ball;\n\t\t\t\treturn deletable;\n\t\t\t}),\n\t\t\thp_ball_list.end());\n\n\t\tfor (HpBall* hp_ball : hp_ball_list)\n\t\t\thp_ball->on_update(delta);\n\n    // on_draw中\n    \tfor (HpBall* hp_ball : hp_ball_list)\n\t\t    hp_ball->on_draw(camera);\n```\n#### **3.随机生成血包位置**\n众所那个周知，使用\n```cpp\nsrand((int)time(0));\nrand();\n```\n就可以生成每次都不一样的随机数，但如果粗暴地将这一套放入循环内，或*HpBall*的构造函数中，就会惊讶地发现，每次小球生成的位置居然是一样的，虽然每次运行后小球的位置会有所改变，但小球在整局游戏中，都只会在这个位置生成了，非常boring。（原理应该是随机数种子在生成时被固定了？我太菜了还没有完全搞懂sos）\n\n总之，解决方法是这样的：\n```cpp\n// main.cpp\n\nsrand((int)time(0)); // 将这句放入main()语句中\n```\n然后就可以在*HpBall*中使用构造函数随机生成x轴位置了，每次实例化*HpBall*都会拥有一个随机的x坐标\n```cpp\n// hp_ball.h\n\n\tHpBall()\n\t{\n\t\tsize.x = 70, size.y = 70;\n\t\tposition.x = rand() % getwidth();\n\t\tposition.y = 35;\n\t\tvelocity.y = 0.3f, velocity.x = 0;\n\n\t\ttimer_hp_ball_remove.set_wait_time(5000);\n\t\ttimer_hp_ball_remove.set_one_shot(true);\n\t\ttimer_hp_ball_remove.set_callback([&]()\n\t\t\t{\n\t\t\t\tcan_remove = true;\n\t\t\t});\n\t}\n```\n### **完整的*HpBall*代码实现**\n```cpp\n// hp_ball.h\n\n#ifndef _HP_BALL_H_\n#define _HP_BALL_H_\n\n#include \"easyx.h\"\n#include \"vector2.h\"\n#include \"player_id.h\"\n#include \"player.h\"\n\n#include <time.h>\n#include <stdlib.h>\n#include <functional>\n#include <vector>\n\nextern Player* player_1;\nextern Player* player_2;\n\nclass HpBall\n{\npublic:\n\tHpBall()\n\t{\n\t\tsize.x = 70, size.y = 70;\n\t\tposition.x = rand() % getwidth();\n\t\tposition.y = 35;\n\t\tvelocity.y = 0.3f, velocity.x = 0;\n\n\t\ttimer_hp_ball_remove.set_wait_time(5000);\n\t\ttimer_hp_ball_remove.set_one_shot(true);\n\t\ttimer_hp_ball_remove.set_callback([&]()\n\t\t\t{\n\t\t\t\tcan_remove = true;\n\t\t\t});\n\t}\n\n\t~HpBall() = default;\n\n\tvoid on_draw(const Camera& camera) \n\t{\n\t\tsetlinecolor(RGB(255, 155, 50));\t//\t绘制血包边框\n\t\tsetfillcolor(RGB(200, 75, 10));\t\t//\t绘制血包颜色\n\t\tfillcircle(position.x, position.y, 35);\t\n\t}\n\n\tvoid on_update(int delta)\n\t{\n\t\tposition += velocity * (float)delta;\n\n\t\tif (check_if_exceeds_screen())\n\t\t\tcan_remove = true;\n\n\t\ttimer_hp_ball_remove.on_update(delta);\n\n\t\ton_collision(player_1);\n\t\ton_collision(player_2);\n\t}\n\n\tbool check_if_exceeds_screen()\t\t// 判断血包是否处于屏幕外\n\t{\n\t\treturn (position.x + size.x <= 0 || position.x >= getwidth()\n\t\t\t|| position.y + size.y <= 0 || position.y >= getheight());\n\t}\n\n\tvoid on_collision(Player*& player)\n\t{\n\t\tif (check_collision(player))\n\t\t{\n\t\t\ttarget_id = player->get_playerID();\n\t\t\tif (target_id == PlayerID::P1)\n\t\t\t\tplayer_1->add_hp(add_hp);\n\t\t\telse\n\t\t\t\tplayer_2->add_hp(add_hp);\n\t\t\t\n\t\t\tcan_remove = true;\n\t\t}\n\t}\n\n\tbool check_collision(Player*& player)\n\t{\n\t\treturn this->position.x + this->size.x / 2 >= player->get_position().x\n\t\t\t&& this->position.x + this->size.x / 2 <= player->get_position().x + player->get_size().x\n\t\t\t&& this->position.y + this->size.y / 2 >= player->get_position().y\n\t\t\t&& this->position.y + this->size.y / 2 <= player->get_position().y + player->get_size().y;\n\t}\n\n\tbool check_can_remove() const\n\t{\n\t\treturn can_remove;\n\t}\n\nprivate:\n\tVector2 position;\n\tVector2 size;\n\tVector2 velocity;\n\n\tint add_hp = 30;\n\tbool can_remove = false;\n\t\n\tPlayerID target_id = PlayerID::P1;\n\tTimer timer_hp_ball_remove;\n};\n\n#endif // !_HP_BALL_H_\n```\n除了*hp_ball.h*外，*game_scene*与*main*、*player*类都有改动，以及相互extern的操作，所以以上并非全部的实现代码。\n\n#### **碎碎念**\n其实*HpBall*应该完全可以通过继承*Bullet*类来实现，修改一下*Bullet*类便可以更完美地实现解耦，日后我也会继续进行改进。\n\n其实我是一名经济学大二的学生哈哈哈哈哈，但制作游戏真的太好玩了，也十分谢谢大V老师启发并满足了我学习的欲望，这也是我第一篇学习记录，希望可以成为一个美好的开端吧。\n*Best Wishes To Everyone*\n\n##### **最新消息**\n大V老师直播做了个我的高级版，私密马赛，发晚了:no_mouth:\n","slug":"Kritace/植物明星大乱斗血包道具","published":1,"updated":"2024-06-21T04:01:45.551Z","__permalink":"articles/Kritace/植物明星大乱斗血包道具/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r8560006lcuthxc79ecm","content":"<p>植物明星大乱斗血包道具制作，简单的<em>bullet</em>类延展设计<br>菜鸟的游戏学习实践记录O.O</p>\n<span id=\"more\"></span>\n\n<h3 id=\"先来看看血包的游戏内展示\"><a href=\"#先来看看血包的游戏内展示\" class=\"headerlink\" title=\"先来看看血包的游戏内展示\"></a>先来看看血包的游戏内展示</h3><div style=\"text-align:center\">\n\n<p><img src=\"/articles/Kritace/%E6%A4%8D%E7%89%A9%E6%98%8E%E6%98%9F%E5%A4%A7%E4%B9%B1%E6%96%97%E8%A1%80%E5%8C%85%E9%81%93%E5%85%B7/%E8%A1%80%E5%8C%85%E5%AE%9E%E4%BE%8B%E5%9B%BE.png\" alt=\"ICON\"></p>\n</div>\n其中那个红色的小球，就是血包，吃了之后可以加30hp。\n\n<h3 id=\"具体思路及代码设计\"><a href=\"#具体思路及代码设计\" class=\"headerlink\" title=\"具体思路及代码设计\"></a><strong>具体思路及代码设计</strong></h3><h4 id=\"1-私有属性与接口设计\"><a href=\"#1-私有属性与接口设计\" class=\"headerlink\" title=\"1.私有属性与接口设计\"></a><strong>1.私有属性与接口设计</strong></h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\ hp_ball.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HpBall</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span></span>;         <span class=\"comment\">// 判断血包是否处于屏幕外</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collision</span><span class=\"params\">(Player*&amp; player)</span></span>;     <span class=\"comment\">// 血包与角色碰撞后的加血逻辑</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(Player*&amp; player)</span></span>;  <span class=\"comment\">// 血包与角色是否碰撞</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;          <span class=\"comment\">// 血包是否可被移除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position;</span><br><span class=\"line\">\tVector2 size;</span><br><span class=\"line\">\tVector2 velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> add_hp = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;      <span class=\"comment\">// 与血包发生碰撞的角色ID</span></span><br><span class=\"line\">\tTimer timer_hp_ball_remove;             <span class=\"comment\">// 血包自动消失的计时器</span></span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>由于我们需要知道与血包碰撞的角色ID，同时还要对该角色的hp进行修改操作，所以不得不来到<em>player</em>类中增加接口：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// player.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_hp</span><span class=\"params\">(<span class=\"type\">int</span> add)</span> </span>&#123; hp = <span class=\"built_in\">min</span>(<span class=\"number\">100</span>, hp + add); &#125;</span><br><span class=\"line\">\t<span class=\"function\">PlayerID&amp; <span class=\"title\">get_playerID</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> id; &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-血包的生命周期管理\"><a href=\"#2-血包的生命周期管理\" class=\"headerlink\" title=\"2.血包的生命周期管理\"></a><strong>2.血包的生命周期管理</strong></h4><p><em>hp_ball</em>类与<em>bullet</em>类十分相似，因此我们可以仿照<em>bullet</em>的生命周期，设计一个全局vector：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;HpBall*&gt; hp_ball_list;</span><br></pre></td></tr></table></figure>\n<p>但是，与<em>bullet</em>类不同的是，<em>hp_ball</em>类的生成并不归<em>player</em>管，而应该由更上层的模块进行管理，为避免过多的全局变量，生成与删除<em>hp_ball</em>的工作我们都交给<em>game_scene</em>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// game_scene.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Timer timer_create_hp_ball;                     <span class=\"comment\">// 用于定时循环重复生成新的血包</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_hp_ball_create = <span class=\"literal\">true</span>;                 <span class=\"comment\">// 血包是否可被生成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// on_enter中</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">4000</span>);   <span class=\"comment\">// 生成血包的间隔时间</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">false</span>);   <span class=\"comment\">// 血包会重复生成</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_callback</span>([&amp;]()     </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_hp_ball_create = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);                                     <span class=\"comment\">// 血包消失后，立即设置为可生成状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// on_update中</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (can_hp_ball_create)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tHpBall* hp_ball = <span class=\"keyword\">new</span> <span class=\"built_in\">HpBall</span>();</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">push_back</span>(hp_ball);</span><br><span class=\"line\">\t\t\tcan_hp_ball_create = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 与bullet相同</span></span><br><span class=\"line\">\t\thp_ball_list.<span class=\"built_in\">erase</span>(std::<span class=\"built_in\">remove_if</span>(</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">begin</span>(), hp_ball_list.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">\t\t\t[](<span class=\"type\">const</span> HpBall* hp_ball)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">bool</span> deletable = hp_ball-&gt;<span class=\"built_in\">check_can_remove</span>();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (deletable) <span class=\"keyword\">delete</span> hp_ball;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> deletable;</span><br><span class=\"line\">\t\t\t&#125;),</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (HpBall* hp_ball : hp_ball_list)</span><br><span class=\"line\">\t\t\thp_ball-&gt;<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// on_draw中</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (HpBall* hp_ball : hp_ball_list)</span><br><span class=\"line\">\t\t    hp_ball-&gt;<span class=\"built_in\">on_draw</span>(camera);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-随机生成血包位置\"><a href=\"#3-随机生成血包位置\" class=\"headerlink\" title=\"3.随机生成血包位置\"></a><strong>3.随机生成血包位置</strong></h4><p>众所那个周知，使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"type\">int</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"built_in\">rand</span>();</span><br></pre></td></tr></table></figure>\n<p>就可以生成每次都不一样的随机数，但如果粗暴地将这一套放入循环内，或<em>HpBall</em>的构造函数中，就会惊讶地发现，每次小球生成的位置居然是一样的，虽然每次运行后小球的位置会有所改变，但小球在整局游戏中，都只会在这个位置生成了，非常boring。（原理应该是随机数种子在生成时被固定了？我太菜了还没有完全搞懂sos）</p>\n<p>总之，解决方法是这样的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"type\">int</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">// 将这句放入main()语句中</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以在<em>HpBall</em>中使用构造函数随机生成x轴位置了，每次实例化<em>HpBall</em>都会拥有一个随机的x坐标</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hp_ball.h</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">70</span>, size.y = <span class=\"number\">70</span>;</span><br><span class=\"line\">\t\tposition.x = <span class=\"built_in\">rand</span>() % <span class=\"built_in\">getwidth</span>();</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">35</span>;</span><br><span class=\"line\">\t\tvelocity.y = <span class=\"number\">0.3f</span>, velocity.x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_callback</span>([&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完整的HpBall代码实现\"><a href=\"#完整的HpBall代码实现\" class=\"headerlink\" title=\"完整的HpBall代码实现\"></a><strong>完整的<em>HpBall</em>代码实现</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hp_ball.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _HP_BALL_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _HP_BALL_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;easyx.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;vector2.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player_id.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> Player* player_1;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> Player* player_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HpBall</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">70</span>, size.y = <span class=\"number\">70</span>;</span><br><span class=\"line\">\t\tposition.x = <span class=\"built_in\">rand</span>() % <span class=\"built_in\">getwidth</span>();</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">35</span>;</span><br><span class=\"line\">\t\tvelocity.y = <span class=\"number\">0.3f</span>, velocity.x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_callback</span>([&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span> </span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setlinecolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">155</span>, <span class=\"number\">50</span>));\t<span class=\"comment\">//\t绘制血包边框</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">setfillcolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">200</span>, <span class=\"number\">75</span>, <span class=\"number\">10</span>));\t\t<span class=\"comment\">//\t绘制血包颜色</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fillcircle</span>(position.x, position.y, <span class=\"number\">35</span>);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition += velocity * (<span class=\"type\">float</span>)delta;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_if_exceeds_screen</span>())</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">on_collision</span>(player_1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">on_collision</span>(player_2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span>\t\t<span class=\"comment\">// 判断血包是否处于屏幕外</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (position.x + size.x &lt;= <span class=\"number\">0</span> || position.x &gt;= <span class=\"built_in\">getwidth</span>()</span><br><span class=\"line\">\t\t\t|| position.y + size.y &lt;= <span class=\"number\">0</span> || position.y &gt;= <span class=\"built_in\">getheight</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collision</span><span class=\"params\">(Player*&amp; player)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_collision</span>(player))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttarget_id = player-&gt;<span class=\"built_in\">get_playerID</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (target_id == PlayerID::P1)</span><br><span class=\"line\">\t\t\t\tplayer_1-&gt;<span class=\"built_in\">add_hp</span>(add_hp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tplayer_2-&gt;<span class=\"built_in\">add_hp</span>(add_hp);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(Player*&amp; player)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &gt;= player-&gt;<span class=\"built_in\">get_position</span>().x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &lt;= player-&gt;<span class=\"built_in\">get_position</span>().x + player-&gt;<span class=\"built_in\">get_size</span>().x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &gt;= player-&gt;<span class=\"built_in\">get_position</span>().y</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &lt;= player-&gt;<span class=\"built_in\">get_position</span>().y + player-&gt;<span class=\"built_in\">get_size</span>().y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> can_remove;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position;</span><br><span class=\"line\">\tVector2 size;</span><br><span class=\"line\">\tVector2 velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> add_hp = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;</span><br><span class=\"line\">\tTimer timer_hp_ball_remove;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_HP_BALL_H_</span></span></span><br></pre></td></tr></table></figure>\n<p>除了<em>hp_ball.h</em>外，<em>game_scene</em>与<em>main</em>、<em>player</em>类都有改动，以及相互extern的操作，所以以上并非全部的实现代码。</p>\n<h4 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a><strong>碎碎念</strong></h4><p>其实<em>HpBall</em>应该完全可以通过继承<em>Bullet</em>类来实现，修改一下<em>Bullet</em>类便可以更完美地实现解耦，日后我也会继续进行改进。</p>\n<p>其实我是一名经济学大二的学生哈哈哈哈哈，但制作游戏真的太好玩了，也十分谢谢大V老师启发并满足了我学习的欲望，这也是我第一篇学习记录，希望可以成为一个美好的开端吧。<br><em>Best Wishes To Everyone</em></p>\n<h5 id=\"最新消息\"><a href=\"#最新消息\" class=\"headerlink\" title=\"最新消息\"></a><strong>最新消息</strong></h5><p>大V老师直播做了个我的高级版，私密马赛，发晚了:no_mouth:</p>\n","site":{"data":{}},"excerpt":"<p>植物明星大乱斗血包道具制作，简单的<em>bullet</em>类延展设计<br>菜鸟的游戏学习实践记录O.O</p>","more":"<h3 id=\"先来看看血包的游戏内展示\"><a href=\"#先来看看血包的游戏内展示\" class=\"headerlink\" title=\"先来看看血包的游戏内展示\"></a>先来看看血包的游戏内展示</h3><div style=\"text-align:center\">\n\n<p><img src=\"/articles/Kritace/%E6%A4%8D%E7%89%A9%E6%98%8E%E6%98%9F%E5%A4%A7%E4%B9%B1%E6%96%97%E8%A1%80%E5%8C%85%E9%81%93%E5%85%B7/%E8%A1%80%E5%8C%85%E5%AE%9E%E4%BE%8B%E5%9B%BE.png\" alt=\"ICON\"></p>\n</div>\n其中那个红色的小球，就是血包，吃了之后可以加30hp。\n\n<h3 id=\"具体思路及代码设计\"><a href=\"#具体思路及代码设计\" class=\"headerlink\" title=\"具体思路及代码设计\"></a><strong>具体思路及代码设计</strong></h3><h4 id=\"1-私有属性与接口设计\"><a href=\"#1-私有属性与接口设计\" class=\"headerlink\" title=\"1.私有属性与接口设计\"></a><strong>1.私有属性与接口设计</strong></h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\ hp_ball.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HpBall</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span></span>;         <span class=\"comment\">// 判断血包是否处于屏幕外</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collision</span><span class=\"params\">(Player*&amp; player)</span></span>;     <span class=\"comment\">// 血包与角色碰撞后的加血逻辑</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(Player*&amp; player)</span></span>;  <span class=\"comment\">// 血包与角色是否碰撞</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;          <span class=\"comment\">// 血包是否可被移除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position;</span><br><span class=\"line\">\tVector2 size;</span><br><span class=\"line\">\tVector2 velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> add_hp = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;      <span class=\"comment\">// 与血包发生碰撞的角色ID</span></span><br><span class=\"line\">\tTimer timer_hp_ball_remove;             <span class=\"comment\">// 血包自动消失的计时器</span></span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>由于我们需要知道与血包碰撞的角色ID，同时还要对该角色的hp进行修改操作，所以不得不来到<em>player</em>类中增加接口：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// player.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_hp</span><span class=\"params\">(<span class=\"type\">int</span> add)</span> </span>&#123; hp = <span class=\"built_in\">min</span>(<span class=\"number\">100</span>, hp + add); &#125;</span><br><span class=\"line\">\t<span class=\"function\">PlayerID&amp; <span class=\"title\">get_playerID</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> id; &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-血包的生命周期管理\"><a href=\"#2-血包的生命周期管理\" class=\"headerlink\" title=\"2.血包的生命周期管理\"></a><strong>2.血包的生命周期管理</strong></h4><p><em>hp_ball</em>类与<em>bullet</em>类十分相似，因此我们可以仿照<em>bullet</em>的生命周期，设计一个全局vector：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;HpBall*&gt; hp_ball_list;</span><br></pre></td></tr></table></figure>\n<p>但是，与<em>bullet</em>类不同的是，<em>hp_ball</em>类的生成并不归<em>player</em>管，而应该由更上层的模块进行管理，为避免过多的全局变量，生成与删除<em>hp_ball</em>的工作我们都交给<em>game_scene</em>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// game_scene.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Timer timer_create_hp_ball;                     <span class=\"comment\">// 用于定时循环重复生成新的血包</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_hp_ball_create = <span class=\"literal\">true</span>;                 <span class=\"comment\">// 血包是否可被生成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// on_enter中</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">4000</span>);   <span class=\"comment\">// 生成血包的间隔时间</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">false</span>);   <span class=\"comment\">// 血包会重复生成</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">set_callback</span>([&amp;]()     </span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_hp_ball_create = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);                                     <span class=\"comment\">// 血包消失后，立即设置为可生成状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// on_update中</span></span><br><span class=\"line\">\t\ttimer_create_hp_ball.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (can_hp_ball_create)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tHpBall* hp_ball = <span class=\"keyword\">new</span> <span class=\"built_in\">HpBall</span>();</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">push_back</span>(hp_ball);</span><br><span class=\"line\">\t\t\tcan_hp_ball_create = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 与bullet相同</span></span><br><span class=\"line\">\t\thp_ball_list.<span class=\"built_in\">erase</span>(std::<span class=\"built_in\">remove_if</span>(</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">begin</span>(), hp_ball_list.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">\t\t\t[](<span class=\"type\">const</span> HpBall* hp_ball)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">bool</span> deletable = hp_ball-&gt;<span class=\"built_in\">check_can_remove</span>();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (deletable) <span class=\"keyword\">delete</span> hp_ball;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> deletable;</span><br><span class=\"line\">\t\t\t&#125;),</span><br><span class=\"line\">\t\t\thp_ball_list.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (HpBall* hp_ball : hp_ball_list)</span><br><span class=\"line\">\t\t\thp_ball-&gt;<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// on_draw中</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (HpBall* hp_ball : hp_ball_list)</span><br><span class=\"line\">\t\t    hp_ball-&gt;<span class=\"built_in\">on_draw</span>(camera);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-随机生成血包位置\"><a href=\"#3-随机生成血包位置\" class=\"headerlink\" title=\"3.随机生成血包位置\"></a><strong>3.随机生成血包位置</strong></h4><p>众所那个周知，使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"type\">int</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"built_in\">rand</span>();</span><br></pre></td></tr></table></figure>\n<p>就可以生成每次都不一样的随机数，但如果粗暴地将这一套放入循环内，或<em>HpBall</em>的构造函数中，就会惊讶地发现，每次小球生成的位置居然是一样的，虽然每次运行后小球的位置会有所改变，但小球在整局游戏中，都只会在这个位置生成了，非常boring。（原理应该是随机数种子在生成时被固定了？我太菜了还没有完全搞懂sos）</p>\n<p>总之，解决方法是这样的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">srand</span>((<span class=\"type\">int</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">// 将这句放入main()语句中</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以在<em>HpBall</em>中使用构造函数随机生成x轴位置了，每次实例化<em>HpBall</em>都会拥有一个随机的x坐标</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hp_ball.h</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">70</span>, size.y = <span class=\"number\">70</span>;</span><br><span class=\"line\">\t\tposition.x = <span class=\"built_in\">rand</span>() % <span class=\"built_in\">getwidth</span>();</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">35</span>;</span><br><span class=\"line\">\t\tvelocity.y = <span class=\"number\">0.3f</span>, velocity.x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_callback</span>([&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完整的HpBall代码实现\"><a href=\"#完整的HpBall代码实现\" class=\"headerlink\" title=\"完整的HpBall代码实现\"></a><strong>完整的<em>HpBall</em>代码实现</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hp_ball.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _HP_BALL_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _HP_BALL_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;easyx.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;vector2.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player_id.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> Player* player_1;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> Player* player_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HpBall</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">HpBall</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">70</span>, size.y = <span class=\"number\">70</span>;</span><br><span class=\"line\">\t\tposition.x = <span class=\"built_in\">rand</span>() % <span class=\"built_in\">getwidth</span>();</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">35</span>;</span><br><span class=\"line\">\t\tvelocity.y = <span class=\"number\">0.3f</span>, velocity.x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">set_callback</span>([&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">HpBall</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span> </span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setlinecolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">155</span>, <span class=\"number\">50</span>));\t<span class=\"comment\">//\t绘制血包边框</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">setfillcolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">200</span>, <span class=\"number\">75</span>, <span class=\"number\">10</span>));\t\t<span class=\"comment\">//\t绘制血包颜色</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fillcircle</span>(position.x, position.y, <span class=\"number\">35</span>);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition += velocity * (<span class=\"type\">float</span>)delta;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_if_exceeds_screen</span>())</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_hp_ball_remove.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">on_collision</span>(player_1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">on_collision</span>(player_2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span>\t\t<span class=\"comment\">// 判断血包是否处于屏幕外</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (position.x + size.x &lt;= <span class=\"number\">0</span> || position.x &gt;= <span class=\"built_in\">getwidth</span>()</span><br><span class=\"line\">\t\t\t|| position.y + size.y &lt;= <span class=\"number\">0</span> || position.y &gt;= <span class=\"built_in\">getheight</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collision</span><span class=\"params\">(Player*&amp; player)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_collision</span>(player))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttarget_id = player-&gt;<span class=\"built_in\">get_playerID</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (target_id == PlayerID::P1)</span><br><span class=\"line\">\t\t\t\tplayer_1-&gt;<span class=\"built_in\">add_hp</span>(add_hp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tplayer_2-&gt;<span class=\"built_in\">add_hp</span>(add_hp);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(Player*&amp; player)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &gt;= player-&gt;<span class=\"built_in\">get_position</span>().x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &lt;= player-&gt;<span class=\"built_in\">get_position</span>().x + player-&gt;<span class=\"built_in\">get_size</span>().x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &gt;= player-&gt;<span class=\"built_in\">get_position</span>().y</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &lt;= player-&gt;<span class=\"built_in\">get_position</span>().y + player-&gt;<span class=\"built_in\">get_size</span>().y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> can_remove;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position;</span><br><span class=\"line\">\tVector2 size;</span><br><span class=\"line\">\tVector2 velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> add_hp = <span class=\"number\">30</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;</span><br><span class=\"line\">\tTimer timer_hp_ball_remove;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_HP_BALL_H_</span></span></span><br></pre></td></tr></table></figure>\n<p>除了<em>hp_ball.h</em>外，<em>game_scene</em>与<em>main</em>、<em>player</em>类都有改动，以及相互extern的操作，所以以上并非全部的实现代码。</p>\n<h4 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a><strong>碎碎念</strong></h4><p>其实<em>HpBall</em>应该完全可以通过继承<em>Bullet</em>类来实现，修改一下<em>Bullet</em>类便可以更完美地实现解耦，日后我也会继续进行改进。</p>\n<p>其实我是一名经济学大二的学生哈哈哈哈哈，但制作游戏真的太好玩了，也十分谢谢大V老师启发并满足了我学习的欲望，这也是我第一篇学习记录，希望可以成为一个美好的开端吧。<br><em>Best Wishes To Everyone</em></p>\n<h5 id=\"最新消息\"><a href=\"#最新消息\" class=\"headerlink\" title=\"最新消息\"></a><strong>最新消息</strong></h5><p>大V老师直播做了个我的高级版，私密马赛，发晚了:no_mouth:</p>"},{"title":"植物明星大乱斗系列视频——勘误","date":"2024-06-01T16:00:00.000Z","updated":"2024-07-08T16:00:00.000Z","_content":"本文收录并校对植物明星大乱斗系列视频中出现的错误\n[从零开始的植物明星大乱斗系列视频](https://space.bilibili.com/25864506/channel/collectiondetail?sid=2277932&ctype=0)\n<!-- More -->\n## 错误\n该部分收录已确定的错误  \n1. 在resources文件夹中  \n![winner_bar.png](articles/YeMinglv/video_corrigendum/winner_bar.png)  \n\"winnner_bar.png\"拼写错误，应重命名为\"winner_bar.png\"\n\n\n2. 在[资源加载和动画类实现](https://www.bilibili.com/video/BV1ej421Z77V)01:27中  \n![img_flipped](articles/YeMinglv/video_corrigendum/img_flipped.png)\n\"img_flpipped\"拼写错误，应重命名为\"img_flipped\"\n\n\n3. 在[玩家子弹发射和角色技能实现](https://www.bilibili.com/video/BV1km421M79S)12:00中\n![timer_spwan_pea_ex](articles/YeMinglv/video_corrigendum/timer_spawn_pea_ex.png)  \n\"timer_spwan_pea_ex\"拼写错误，应重命名为\"timer_spawn_pea_ex\"\n\n\n4. 在[玩家子弹发射和角色技能实现](https://www.bilibili.com/video/BV1km421M79S)12:08中\n![raw](articles/YeMinglv/video_corrigendum/raw.png)\nSunflowerPlayer构造函数缺少头顶文本动画，左右特殊攻击动画的部分语句，应添加\n![modify](articles/YeMinglv/video_corrigendum/modify.png)\n实际上这部分添加内容在08:53中出现过\n## 警告\n该部分收录内容可能并非错误\n1. resources文件夹中sun_explode_ex.mp3和sun_ex_explode系列图片命名不同  \n我把sun_explode_ex.mp3以及main.cpp、sun_bullet_ex.h中使用的别名统一修改为sun_ex_explode\n![main.cpp](articles/YeMinglv/video_corrigendum/main.png)\n![sun_bullet_ex.h](articles/YeMinglv/video_corrigendum/sun_bullet_ex.png)","source":"_posts/YeMinglv/植物明星大乱斗系列视频——勘误.md","raw":"---\ntitle: 植物明星大乱斗系列视频——勘误\ndate: 2024-06-02\nupdated: 2024-07-09\npermalink: articles/YeMinglv/video_corrigendum/\ncategories: YeMinglv\ntags: [勘误]\n---\n本文收录并校对植物明星大乱斗系列视频中出现的错误\n[从零开始的植物明星大乱斗系列视频](https://space.bilibili.com/25864506/channel/collectiondetail?sid=2277932&ctype=0)\n<!-- More -->\n## 错误\n该部分收录已确定的错误  \n1. 在resources文件夹中  \n![winner_bar.png](articles/YeMinglv/video_corrigendum/winner_bar.png)  \n\"winnner_bar.png\"拼写错误，应重命名为\"winner_bar.png\"\n\n\n2. 在[资源加载和动画类实现](https://www.bilibili.com/video/BV1ej421Z77V)01:27中  \n![img_flipped](articles/YeMinglv/video_corrigendum/img_flipped.png)\n\"img_flpipped\"拼写错误，应重命名为\"img_flipped\"\n\n\n3. 在[玩家子弹发射和角色技能实现](https://www.bilibili.com/video/BV1km421M79S)12:00中\n![timer_spwan_pea_ex](articles/YeMinglv/video_corrigendum/timer_spawn_pea_ex.png)  \n\"timer_spwan_pea_ex\"拼写错误，应重命名为\"timer_spawn_pea_ex\"\n\n\n4. 在[玩家子弹发射和角色技能实现](https://www.bilibili.com/video/BV1km421M79S)12:08中\n![raw](articles/YeMinglv/video_corrigendum/raw.png)\nSunflowerPlayer构造函数缺少头顶文本动画，左右特殊攻击动画的部分语句，应添加\n![modify](articles/YeMinglv/video_corrigendum/modify.png)\n实际上这部分添加内容在08:53中出现过\n## 警告\n该部分收录内容可能并非错误\n1. resources文件夹中sun_explode_ex.mp3和sun_ex_explode系列图片命名不同  \n我把sun_explode_ex.mp3以及main.cpp、sun_bullet_ex.h中使用的别名统一修改为sun_ex_explode\n![main.cpp](articles/YeMinglv/video_corrigendum/main.png)\n![sun_bullet_ex.h](articles/YeMinglv/video_corrigendum/sun_bullet_ex.png)","slug":"YeMinglv/植物明星大乱斗系列视频——勘误","published":1,"__permalink":"articles/YeMinglv/video_corrigendum/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r8580007lcut8j9rbh60","content":"<p>本文收录并校对植物明星大乱斗系列视频中出现的错误<br><a href=\"https://space.bilibili.com/25864506/channel/collectiondetail?sid=2277932&ctype=0\">从零开始的植物明星大乱斗系列视频</a></p>\n<span id=\"more\"></span>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>该部分收录已确定的错误  </p>\n<ol>\n<li><p>在resources文件夹中<br><img src=\"/articles/YeMinglv/video_corrigendum/winner_bar.png\" alt=\"winner_bar.png\"><br>“winnner_bar.png”拼写错误，应重命名为”winner_bar.png”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1ej421Z77V\">资源加载和动画类实现</a>01:27中<br><img src=\"/articles/YeMinglv/video_corrigendum/img_flipped.png\" alt=\"img_flipped\"><br>“img_flpipped”拼写错误，应重命名为”img_flipped”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1km421M79S\">玩家子弹发射和角色技能实现</a>12:00中<br><img src=\"/articles/YeMinglv/video_corrigendum/timer_spawn_pea_ex.png\" alt=\"timer_spwan_pea_ex\"><br>“timer_spwan_pea_ex”拼写错误，应重命名为”timer_spawn_pea_ex”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1km421M79S\">玩家子弹发射和角色技能实现</a>12:08中<br><img src=\"/articles/YeMinglv/video_corrigendum/raw.png\" alt=\"raw\"><br>SunflowerPlayer构造函数缺少头顶文本动画，左右特殊攻击动画的部分语句，应添加<br><img src=\"/articles/YeMinglv/video_corrigendum/modify.png\" alt=\"modify\"><br>实际上这部分添加内容在08:53中出现过</p>\n</li>\n</ol>\n<h2 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h2><p>该部分收录内容可能并非错误</p>\n<ol>\n<li>resources文件夹中sun_explode_ex.mp3和sun_ex_explode系列图片命名不同<br>我把sun_explode_ex.mp3以及main.cpp、sun_bullet_ex.h中使用的别名统一修改为sun_ex_explode<br><img src=\"/articles/YeMinglv/video_corrigendum/main.png\" alt=\"main.cpp\"><br><img src=\"/articles/YeMinglv/video_corrigendum/sun_bullet_ex.png\" alt=\"sun_bullet_ex.h\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文收录并校对植物明星大乱斗系列视频中出现的错误<br><a href=\"https://space.bilibili.com/25864506/channel/collectiondetail?sid=2277932&ctype=0\">从零开始的植物明星大乱斗系列视频</a></p>","more":"<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>该部分收录已确定的错误  </p>\n<ol>\n<li><p>在resources文件夹中<br><img src=\"/articles/YeMinglv/video_corrigendum/winner_bar.png\" alt=\"winner_bar.png\"><br>“winnner_bar.png”拼写错误，应重命名为”winner_bar.png”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1ej421Z77V\">资源加载和动画类实现</a>01:27中<br><img src=\"/articles/YeMinglv/video_corrigendum/img_flipped.png\" alt=\"img_flipped\"><br>“img_flpipped”拼写错误，应重命名为”img_flipped”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1km421M79S\">玩家子弹发射和角色技能实现</a>12:00中<br><img src=\"/articles/YeMinglv/video_corrigendum/timer_spawn_pea_ex.png\" alt=\"timer_spwan_pea_ex\"><br>“timer_spwan_pea_ex”拼写错误，应重命名为”timer_spawn_pea_ex”</p>\n</li>\n<li><p>在<a href=\"https://www.bilibili.com/video/BV1km421M79S\">玩家子弹发射和角色技能实现</a>12:08中<br><img src=\"/articles/YeMinglv/video_corrigendum/raw.png\" alt=\"raw\"><br>SunflowerPlayer构造函数缺少头顶文本动画，左右特殊攻击动画的部分语句，应添加<br><img src=\"/articles/YeMinglv/video_corrigendum/modify.png\" alt=\"modify\"><br>实际上这部分添加内容在08:53中出现过</p>\n</li>\n</ol>\n<h2 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h2><p>该部分收录内容可能并非错误</p>\n<ol>\n<li>resources文件夹中sun_explode_ex.mp3和sun_ex_explode系列图片命名不同<br>我把sun_explode_ex.mp3以及main.cpp、sun_bullet_ex.h中使用的别名统一修改为sun_ex_explode<br><img src=\"/articles/YeMinglv/video_corrigendum/main.png\" alt=\"main.cpp\"><br><img src=\"/articles/YeMinglv/video_corrigendum/sun_bullet_ex.png\" alt=\"sun_bullet_ex.h\"></li>\n</ol>"},{"title":"2D 游戏光照分析","date":"2024-08-23T16:00:00.000Z","updated":"2024-08-23T16:00:00.000Z","author":"Margoo","mathjax":true,"_content":"\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/cover.png)\n\n</div>\n\n本文将会介绍一个我正在制作的项目 PaperCraft 中有关游戏 2D 光照的实现. 提供一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 本文将会提供一种可能的 SKSL（Skia Shader Language）代码来实现该方法.\n\n<!-- More -->\n\n## Ⅰ、基础知识简介\n\nSDF（Signed distance function），有符号距离函数.是一个多元函数（具体几元取决于研究对象所处的维度），本文记作 $\\varphi\\left(\\boldsymbol{x}\\right)$.其返回一个值，该值为点 $\\boldsymbol{x}$ 到目标几何体的最短距离.不同的几何体有不同的 SDF 函数.例如圆的 SDF 为 $\\varphi\\left(\\boldsymbol{x}\\right)=\\left|\\left|\\boldsymbol{x}-\\boldsymbol{p}\\right|\\right|_n-R$.其中 $R$ 为圆的半径.若 $\\varphi\\left(\\boldsymbol{x}\\right)<0$ 则说明点在圆内；若 $\\varphi\\left(\\boldsymbol{x}\\right)=0$ 则说明点在圆上；若 $\\varphi\\left(\\boldsymbol{x}\\right)>0$ 则说明点在园外.本文不提供任何几何体的 SDF 函数推导过程，读者若有兴趣可自行查找相关资料.\n\n法线贴图（Normal Texture），是一种凹凸贴图（Bump Map）.可以表示物体的表面细节（如凹凸、划痕）.一个常见的法线贴图如下所示：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/normal_texture.png)\n\n</div>\n\n事实上，法线贴图就是将法向量 $\\boldsymbol{n}=\\left(x,y,z\\right)$ 映射到了 RGB 空间中；由于 $n_i\\in\\left[-1,1\\right]$，于是就存在如下映射关系：\n\n$$\\boldsymbol{C}=0.5\\boldsymbol{n}+0.5$$\n\n因此，可以将物体表面粗糙的法向量 $\\boldsymbol{n}$ 全部映射到 RGB 空间中，并储存为图片。在渲染中，我们可以用这一低成本的方法实现物体表面粗糙平面的渲染。得到更好的细节。事实上，如果放大文章封面：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/normal_result.png)\n\n</div>\n\n你可以清晰地看到法线贴图的效果，红石块和石块表面看起来来凹凸不平，极具立体感。\n\n关于法线贴图和 SDF 的详细描述，请分别参考 [LearnOpenGL - 法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/) 和 [知乎 Jacks0n - Rendering (Signed) Distance Function](https://zhuanlan.zhihu.com/p/345227118).\n\n## Ⅱ、渲染管线概述\n\n下图简单直观地展示了本方法的渲染管线：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/pipeline.png)\n\n</div>\n\n这里再给出这几个步骤的简述：\n\n1. 基础场景渲染\n\n    该流程使用原始贴图渲染出未经光照的原始地图.\n\n2. 法线场景渲染\n\n    该流程使用法线贴图渲染出未经光照的原始地图.\n\n3. 光照贴图渲染\n\n    该流程将会基于 SDF 函数计算出原始光照蒙版贴图.\n\n4. 辉光处理\n\n    该流程基于高斯模糊，对阶段三生成的光线蒙版贴图进行辉光处理.\n\n5. 混合\n\n    该步骤将会将步骤一、二、四得到的结果混合并计算出最终结果.\n\n下文将会详细讲述步骤三至五.\n\n## Ⅲ、基于 SDF 的蒙版光照计算\n\n根据现实生活中的经验，可以发现，一个发光的物体照亮的区域形成一个圆圈.且先保持强度不变再衰减，具体示意图如下：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/light.png)\n\n</div>\n\n那么便可以通过 SDF 模拟该过程：\n\n假设某点处的光源强度 $\\boldsymbol{I}=\\left(x,y,z\\right)$（其中 $x,y,z\\in\\left[0,1\\right]$，$1$ 为最亮，$0$ 为最暗）\n\n我们假设有一个光源 $A$，颜色为 $C$，其光强为 $I_A$， SDF 函数为 $\\varphi_A\\left(\\boldsymbol{x}\\right)$，衰减半径为小 $r$.$\\boldsymbol{R}$ 为一满足在 $\\boldsymbol{P}$ 方向上使得 $\\varphi_A\\left(\\boldsymbol{R}\\right)=0$ 的一点，则 $A$ 在 $\\boldsymbol{P}$ 处的辐射度 $\\boldsymbol{L_{A,P}}$ 可以为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation1.svg)\n\n</div>\n\n注意（1）中 $\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R+r}{r}C$ 实际上是由：$\\left(1-\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R}{r}\\right)C$ 推到得到的.显然，有 $\\boldsymbol{I}_x\\in\\left[0,1\\right]$，因此，我们可以考虑，使用一个非线性插值 $D\\left(\\boldsymbol{x}\\right)$ 函数来对平滑光照衰减.特别地，我们需要确保 $D\\left(0\\right)=0$、$D\\left(1\\right)=1$. 此处采用 $D\\left(x\\right)=\\sqrt[3]{x}$ 作为衰减平滑函数。\n\n根据在 1986 年由 James T.Kajiya 提出的渲染方程：\n\n$$L_O\\left(\\vec{v}\\right)=L_e\\left(\\vec{v}\\right)+\\int_{\\Omega}f\\left(\\vec{l_i}, \\vec{v}\\right)L_i\\left(\\vec{l_i}\\right)\\left(\\vec{n}\\cdot\\vec{l_i}\\right)\\text{d}\\vec{l_i}$$\n\n这里我们无需过多关注这个公式本身（如果你想了解这个公式，可以参考 James T.Kajiya 的论文 *The Rendering Equation*），在 2D 平面中，我们可以认为所有光线都将射入摄像机，且任意点上收到的光照，等于所有光线辐射度的总和，可以将球面积分改写成很简洁的形式：\n\n$$L_O\\left(\\vec{v}\\right)=\\int^{2\\pi}_{0}L\\left(\\vec{v}, \\theta\\right)\\text{d}\\theta$$\n\n其中 $L\\left(\\vec{v}, \\theta\\right)$ 表示 $\\theta$ 方向上受到的光亮。然而，由于我们的光源是确定的，在不考虑阴影渲染的情况下，我们可以认为有：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation2.svg)\n\n</div>\n\n之所以是在不考虑阴影的情况下才有上述等式成立，是因为当有一个物体遮挡时，光线就并不总是可以完全照射到指定点处。这时就要考虑可能的辐射度衰减。\n\n因此，假设有 $n$ 个光源 $\\{A_n\\}$，则 $\\boldsymbol{P}$ 点处的辐射度 $\\boldsymbol{L}$ 则为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation3.svg)\n\n</div>\n\n\n此处给出一个可能的 SKSL 着色器实现：\n\n```GLSL\n// The light type of the shader\n//      If LightType < 10. = Ellipse\n//      Else = Rectangle\nuniform float LightType;\n// The X position of the light\nuniform float2 Center;\n// The radius of the light source object\nuniform float Radius;\n// The range of the light source\nuniform float ValidRadius;\n// The light brighteness level of the light source\nuniform float Intensity;\n// The color of the light source\nuniform float3 Color;\n\n// The texture shader for background texture\nuniform shader BackgroundTexture;\n\n// The SDF of ellipse\nfloat EllipseSDF(in vec2 R, in float Radius) {\n    return length(R) - Radius;\n}\n// The SDF of rectangle\nfloat RectangleSDF(in vec2 R, in float Radius) {\n    vec2 Box    = vec2(Radius, Radius);\n    vec2 Delta  = abs(R) - Box;\n    return length(max(Delta, vec2(0.))) + min(max(Delta.x, Delta.y), 0.0);\n}\n// The phi interpolation function\nfloat Phi(in float Value) {\n    return 1.0 - pow(Value, 0.3);\n}\n\n// Calculate the light brightness contribution from the SDF\nvec3 SDFContribution(in float Distance, in float Intensity, in float ValidRadius, in vec3 Color) {\n    vec3 col = vec3(0., 0., 0.);\n    if (Distance <= 0.0) {\n        float D = Intensity + 1.;\n        col = Color * D;\n    }\n    else if (Distance <= ValidRadius) {\n        float F = (Distance / ValidRadius);\n        float D = Phi(F) * (Intensity + 1.);\n        col = vec3(Color[0] * D, Color[1] * D, Color[2] * D);\n    }\n\n    return col;\n}\n// Sample the coord light from a ellipse object\nvec3 SampleEllipse(in vec2  Center,\n                   in vec3  Color,\n                   in float Radius,\n                   in float ValidRadius,\n                   in float Intensity,\n                   in vec2  Coord) {\n    vec2 R = Center - Coord;\n\n    float sdf = EllipseSDF(R, Radius);\n    return SDFContribution(sdf, Intensity, ValidRadius, Color);\n}\n// Sample the coord light from a rectangle object\nvec3 SampleRectangle(in vec2  Center,\n                     in vec3  Color,\n                     in float Radius,\n                     in float ValidRadius,\n                     in float Intensity,\n                     in vec2  Coord) {\n    vec2 R = Center - Coord;\n\n    float sdf = RectangleSDF(R, Radius);\n    return SDFContribution(sdf, Intensity, ValidRadius, Color);\n}\n\n// Fix the gamma value\nvec3 GammaFixed(in vec3 R) {\n    return vec3(pow(R[0], 0.9), pow(R[1], 0.9), pow(R[2], 0.9));\n}\n\nvec4 main(in vec2 fragCoord) {\n    vec4 fragColor = BackgroundTexture.eval(fragCoord);\n    if (LightType < 10.) fragColor += vec4(SampleEllipse(Center, Color, Radius, ValidRadius, Intensity, fragCoord), 1.);\n    else fragColor += vec4(SampleRectangle(Center, Color, Radius, ValidRadius, Intensity, fragCoord), 1.);\n\n\treturn fragColor;\n}\n```\n\n## Ⅳ、辉光处理\n\n尽管在章节 Ⅲ 中已经引入了光照平滑函数 $D\\left(x\\right)$ 来尽可能地让光照平滑自然，但如下图所示，如果要让光照足够的自然，最好还是模拟现实中发光物体的“辉光”效果：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/bloom.png)\n\n</div>\n\n为了实现辉光效果，一个可行的思路就是通过高斯模糊来对原来的蒙蔽光照贴图进行处理.\n\n高斯模糊使用到了二阶正态分布，通过在目标点指定半径大小内计算每个点相当对于该点的权重 $w_{x,y}$ 来实现模糊效果：\n\n$$w_{x,y}=f(x, y) = \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}} e^{-\\frac{1}{2(1-\\rho^2)}\\left[\\frac{(x-\\mu_1)^2}{\\sigma_1^2} - 2\\rho\\frac{(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2} + \\frac{(y-\\mu_2)^2}{\\sigma_2^2}\\right]}$$\n\n关于高斯模糊的详细描述，请参考[维基百科](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A).\n\n一个可能的辉光 SKSL 实现代码如下：\n\n```GLSL\nuniform shader BackgroundTexture;\n\nfloat pow2(in float x) {\n    return ((x) * (x));\n}\n\nconst float pi      = 3.14159265358979323846;\nconst float samples = 30;\nconst float sigma   = samples * 0.25;\n\nfloat gaussian(float2 i) {\n    return 1.0 / (2.0 * pi * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec4 main(float2 coord) {\n    vec4  color = vec4(0.0);\n    float accum = 0.0;\n\n    for (float x = -samples / 2; x <= samples / 2; ++x) {\n        for (float y = -samples / 2; y <= samples / 2; ++y) {\n            float2 offset   = float2(float(x), float(y));\n            float weight    = gaussian(offset);\n            color           += BackgroundTexture.eval(coord + offset) * weight;\n            accum           += weight;\n        }\n    }\n\n    color /= accum;\n    return color;\n}\n```\n\n## Ⅵ、混合\n\n在最后阶段中，我们需要将前几个步骤得到的结果混合起来，完成光照渲染。混合公式为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation4.svg)\n\n</div>\n\n实际上就是把 $m$ 个颜色的 r，g，b 数值相乘后组成新的颜色。事实上，这相当于 PhotoShop 中的 “正片叠底”效果。\n\n可能的 SKSL 实现代码如下：\n\n```GLSL\nuniform shader LightMask;\nuniform shader Normal;\nuniform shader Origin;\n\nvec4 main(in vec2 fragCoord) {\n    return 1.5 * Normal.eval(fragCoord) * LightMask.eval(fragCoord) * Origin.eval(fragCoord);\n}\n```\n\n\n## Ⅶ、总结\n\n本文提供了一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 事实上，如果优化得当，该方法在 CPU 上依然可以使用。因为本方法并不考虑阴影遮挡，因此可以说只要光源是确定（即全为静态光源）就可以考虑采用该方法预先进行光线烘培。即使是需要动态光源，在确保光源本身属性不变的情况下，依然可以预先渲染蒙版光源。\n\n本方法的很多渲染并不一定需要实时进行，这也是为什么在 CPU 上实现这个方法成为了可能。","source":"_posts/Margoo/2d-light.md","raw":"---\ntitle: 2D 游戏光照分析\ndate: 2024-08-24\nupdated: 2024-08-24\nauthor: Margoo\npermalink: articles/Margoo/2d-light/\nmathjax: true\ncategories: Margoo\ntags: [Math, Computer Graphics, Lighting]\n---\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/cover.png)\n\n</div>\n\n本文将会介绍一个我正在制作的项目 PaperCraft 中有关游戏 2D 光照的实现. 提供一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 本文将会提供一种可能的 SKSL（Skia Shader Language）代码来实现该方法.\n\n<!-- More -->\n\n## Ⅰ、基础知识简介\n\nSDF（Signed distance function），有符号距离函数.是一个多元函数（具体几元取决于研究对象所处的维度），本文记作 $\\varphi\\left(\\boldsymbol{x}\\right)$.其返回一个值，该值为点 $\\boldsymbol{x}$ 到目标几何体的最短距离.不同的几何体有不同的 SDF 函数.例如圆的 SDF 为 $\\varphi\\left(\\boldsymbol{x}\\right)=\\left|\\left|\\boldsymbol{x}-\\boldsymbol{p}\\right|\\right|_n-R$.其中 $R$ 为圆的半径.若 $\\varphi\\left(\\boldsymbol{x}\\right)<0$ 则说明点在圆内；若 $\\varphi\\left(\\boldsymbol{x}\\right)=0$ 则说明点在圆上；若 $\\varphi\\left(\\boldsymbol{x}\\right)>0$ 则说明点在园外.本文不提供任何几何体的 SDF 函数推导过程，读者若有兴趣可自行查找相关资料.\n\n法线贴图（Normal Texture），是一种凹凸贴图（Bump Map）.可以表示物体的表面细节（如凹凸、划痕）.一个常见的法线贴图如下所示：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/normal_texture.png)\n\n</div>\n\n事实上，法线贴图就是将法向量 $\\boldsymbol{n}=\\left(x,y,z\\right)$ 映射到了 RGB 空间中；由于 $n_i\\in\\left[-1,1\\right]$，于是就存在如下映射关系：\n\n$$\\boldsymbol{C}=0.5\\boldsymbol{n}+0.5$$\n\n因此，可以将物体表面粗糙的法向量 $\\boldsymbol{n}$ 全部映射到 RGB 空间中，并储存为图片。在渲染中，我们可以用这一低成本的方法实现物体表面粗糙平面的渲染。得到更好的细节。事实上，如果放大文章封面：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/normal_result.png)\n\n</div>\n\n你可以清晰地看到法线贴图的效果，红石块和石块表面看起来来凹凸不平，极具立体感。\n\n关于法线贴图和 SDF 的详细描述，请分别参考 [LearnOpenGL - 法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/) 和 [知乎 Jacks0n - Rendering (Signed) Distance Function](https://zhuanlan.zhihu.com/p/345227118).\n\n## Ⅱ、渲染管线概述\n\n下图简单直观地展示了本方法的渲染管线：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/pipeline.png)\n\n</div>\n\n这里再给出这几个步骤的简述：\n\n1. 基础场景渲染\n\n    该流程使用原始贴图渲染出未经光照的原始地图.\n\n2. 法线场景渲染\n\n    该流程使用法线贴图渲染出未经光照的原始地图.\n\n3. 光照贴图渲染\n\n    该流程将会基于 SDF 函数计算出原始光照蒙版贴图.\n\n4. 辉光处理\n\n    该流程基于高斯模糊，对阶段三生成的光线蒙版贴图进行辉光处理.\n\n5. 混合\n\n    该步骤将会将步骤一、二、四得到的结果混合并计算出最终结果.\n\n下文将会详细讲述步骤三至五.\n\n## Ⅲ、基于 SDF 的蒙版光照计算\n\n根据现实生活中的经验，可以发现，一个发光的物体照亮的区域形成一个圆圈.且先保持强度不变再衰减，具体示意图如下：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/light.png)\n\n</div>\n\n那么便可以通过 SDF 模拟该过程：\n\n假设某点处的光源强度 $\\boldsymbol{I}=\\left(x,y,z\\right)$（其中 $x,y,z\\in\\left[0,1\\right]$，$1$ 为最亮，$0$ 为最暗）\n\n我们假设有一个光源 $A$，颜色为 $C$，其光强为 $I_A$， SDF 函数为 $\\varphi_A\\left(\\boldsymbol{x}\\right)$，衰减半径为小 $r$.$\\boldsymbol{R}$ 为一满足在 $\\boldsymbol{P}$ 方向上使得 $\\varphi_A\\left(\\boldsymbol{R}\\right)=0$ 的一点，则 $A$ 在 $\\boldsymbol{P}$ 处的辐射度 $\\boldsymbol{L_{A,P}}$ 可以为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation1.svg)\n\n</div>\n\n注意（1）中 $\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R+r}{r}C$ 实际上是由：$\\left(1-\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R}{r}\\right)C$ 推到得到的.显然，有 $\\boldsymbol{I}_x\\in\\left[0,1\\right]$，因此，我们可以考虑，使用一个非线性插值 $D\\left(\\boldsymbol{x}\\right)$ 函数来对平滑光照衰减.特别地，我们需要确保 $D\\left(0\\right)=0$、$D\\left(1\\right)=1$. 此处采用 $D\\left(x\\right)=\\sqrt[3]{x}$ 作为衰减平滑函数。\n\n根据在 1986 年由 James T.Kajiya 提出的渲染方程：\n\n$$L_O\\left(\\vec{v}\\right)=L_e\\left(\\vec{v}\\right)+\\int_{\\Omega}f\\left(\\vec{l_i}, \\vec{v}\\right)L_i\\left(\\vec{l_i}\\right)\\left(\\vec{n}\\cdot\\vec{l_i}\\right)\\text{d}\\vec{l_i}$$\n\n这里我们无需过多关注这个公式本身（如果你想了解这个公式，可以参考 James T.Kajiya 的论文 *The Rendering Equation*），在 2D 平面中，我们可以认为所有光线都将射入摄像机，且任意点上收到的光照，等于所有光线辐射度的总和，可以将球面积分改写成很简洁的形式：\n\n$$L_O\\left(\\vec{v}\\right)=\\int^{2\\pi}_{0}L\\left(\\vec{v}, \\theta\\right)\\text{d}\\theta$$\n\n其中 $L\\left(\\vec{v}, \\theta\\right)$ 表示 $\\theta$ 方向上受到的光亮。然而，由于我们的光源是确定的，在不考虑阴影渲染的情况下，我们可以认为有：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation2.svg)\n\n</div>\n\n之所以是在不考虑阴影的情况下才有上述等式成立，是因为当有一个物体遮挡时，光线就并不总是可以完全照射到指定点处。这时就要考虑可能的辐射度衰减。\n\n因此，假设有 $n$ 个光源 $\\{A_n\\}$，则 $\\boldsymbol{P}$ 点处的辐射度 $\\boldsymbol{L}$ 则为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation3.svg)\n\n</div>\n\n\n此处给出一个可能的 SKSL 着色器实现：\n\n```GLSL\n// The light type of the shader\n//      If LightType < 10. = Ellipse\n//      Else = Rectangle\nuniform float LightType;\n// The X position of the light\nuniform float2 Center;\n// The radius of the light source object\nuniform float Radius;\n// The range of the light source\nuniform float ValidRadius;\n// The light brighteness level of the light source\nuniform float Intensity;\n// The color of the light source\nuniform float3 Color;\n\n// The texture shader for background texture\nuniform shader BackgroundTexture;\n\n// The SDF of ellipse\nfloat EllipseSDF(in vec2 R, in float Radius) {\n    return length(R) - Radius;\n}\n// The SDF of rectangle\nfloat RectangleSDF(in vec2 R, in float Radius) {\n    vec2 Box    = vec2(Radius, Radius);\n    vec2 Delta  = abs(R) - Box;\n    return length(max(Delta, vec2(0.))) + min(max(Delta.x, Delta.y), 0.0);\n}\n// The phi interpolation function\nfloat Phi(in float Value) {\n    return 1.0 - pow(Value, 0.3);\n}\n\n// Calculate the light brightness contribution from the SDF\nvec3 SDFContribution(in float Distance, in float Intensity, in float ValidRadius, in vec3 Color) {\n    vec3 col = vec3(0., 0., 0.);\n    if (Distance <= 0.0) {\n        float D = Intensity + 1.;\n        col = Color * D;\n    }\n    else if (Distance <= ValidRadius) {\n        float F = (Distance / ValidRadius);\n        float D = Phi(F) * (Intensity + 1.);\n        col = vec3(Color[0] * D, Color[1] * D, Color[2] * D);\n    }\n\n    return col;\n}\n// Sample the coord light from a ellipse object\nvec3 SampleEllipse(in vec2  Center,\n                   in vec3  Color,\n                   in float Radius,\n                   in float ValidRadius,\n                   in float Intensity,\n                   in vec2  Coord) {\n    vec2 R = Center - Coord;\n\n    float sdf = EllipseSDF(R, Radius);\n    return SDFContribution(sdf, Intensity, ValidRadius, Color);\n}\n// Sample the coord light from a rectangle object\nvec3 SampleRectangle(in vec2  Center,\n                     in vec3  Color,\n                     in float Radius,\n                     in float ValidRadius,\n                     in float Intensity,\n                     in vec2  Coord) {\n    vec2 R = Center - Coord;\n\n    float sdf = RectangleSDF(R, Radius);\n    return SDFContribution(sdf, Intensity, ValidRadius, Color);\n}\n\n// Fix the gamma value\nvec3 GammaFixed(in vec3 R) {\n    return vec3(pow(R[0], 0.9), pow(R[1], 0.9), pow(R[2], 0.9));\n}\n\nvec4 main(in vec2 fragCoord) {\n    vec4 fragColor = BackgroundTexture.eval(fragCoord);\n    if (LightType < 10.) fragColor += vec4(SampleEllipse(Center, Color, Radius, ValidRadius, Intensity, fragCoord), 1.);\n    else fragColor += vec4(SampleRectangle(Center, Color, Radius, ValidRadius, Intensity, fragCoord), 1.);\n\n\treturn fragColor;\n}\n```\n\n## Ⅳ、辉光处理\n\n尽管在章节 Ⅲ 中已经引入了光照平滑函数 $D\\left(x\\right)$ 来尽可能地让光照平滑自然，但如下图所示，如果要让光照足够的自然，最好还是模拟现实中发光物体的“辉光”效果：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/bloom.png)\n\n</div>\n\n为了实现辉光效果，一个可行的思路就是通过高斯模糊来对原来的蒙蔽光照贴图进行处理.\n\n高斯模糊使用到了二阶正态分布，通过在目标点指定半径大小内计算每个点相当对于该点的权重 $w_{x,y}$ 来实现模糊效果：\n\n$$w_{x,y}=f(x, y) = \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}} e^{-\\frac{1}{2(1-\\rho^2)}\\left[\\frac{(x-\\mu_1)^2}{\\sigma_1^2} - 2\\rho\\frac{(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2} + \\frac{(y-\\mu_2)^2}{\\sigma_2^2}\\right]}$$\n\n关于高斯模糊的详细描述，请参考[维基百科](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A).\n\n一个可能的辉光 SKSL 实现代码如下：\n\n```GLSL\nuniform shader BackgroundTexture;\n\nfloat pow2(in float x) {\n    return ((x) * (x));\n}\n\nconst float pi      = 3.14159265358979323846;\nconst float samples = 30;\nconst float sigma   = samples * 0.25;\n\nfloat gaussian(float2 i) {\n    return 1.0 / (2.0 * pi * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec4 main(float2 coord) {\n    vec4  color = vec4(0.0);\n    float accum = 0.0;\n\n    for (float x = -samples / 2; x <= samples / 2; ++x) {\n        for (float y = -samples / 2; y <= samples / 2; ++y) {\n            float2 offset   = float2(float(x), float(y));\n            float weight    = gaussian(offset);\n            color           += BackgroundTexture.eval(coord + offset) * weight;\n            accum           += weight;\n        }\n    }\n\n    color /= accum;\n    return color;\n}\n```\n\n## Ⅵ、混合\n\n在最后阶段中，我们需要将前几个步骤得到的结果混合起来，完成光照渲染。混合公式为：\n\n<div align=\"center\">\n\n![](articles/Margoo/2d-light/equation4.svg)\n\n</div>\n\n实际上就是把 $m$ 个颜色的 r，g，b 数值相乘后组成新的颜色。事实上，这相当于 PhotoShop 中的 “正片叠底”效果。\n\n可能的 SKSL 实现代码如下：\n\n```GLSL\nuniform shader LightMask;\nuniform shader Normal;\nuniform shader Origin;\n\nvec4 main(in vec2 fragCoord) {\n    return 1.5 * Normal.eval(fragCoord) * LightMask.eval(fragCoord) * Origin.eval(fragCoord);\n}\n```\n\n\n## Ⅶ、总结\n\n本文提供了一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 事实上，如果优化得当，该方法在 CPU 上依然可以使用。因为本方法并不考虑阴影遮挡，因此可以说只要光源是确定（即全为静态光源）就可以考虑采用该方法预先进行光线烘培。即使是需要动态光源，在确保光源本身属性不变的情况下，依然可以预先渲染蒙版光源。\n\n本方法的很多渲染并不一定需要实时进行，这也是为什么在 CPU 上实现这个方法成为了可能。","slug":"Margoo/2d-light","published":1,"__permalink":"articles/Margoo/2d-light/","_id":"cm2e5r85b000clcut232yd8a2","comments":1,"layout":"post","photos":[],"link":"","content":"<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/cover.png\"></p>\n</div>\n\n<p>本文将会介绍一个我正在制作的项目 PaperCraft 中有关游戏 2D 光照的实现. 提供一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 本文将会提供一种可能的 SKSL（Skia Shader Language）代码来实现该方法.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Ⅰ、基础知识简介\"><a href=\"#Ⅰ、基础知识简介\" class=\"headerlink\" title=\"Ⅰ、基础知识简介\"></a>Ⅰ、基础知识简介</h2><p>SDF（Signed distance function），有符号距离函数.是一个多元函数（具体几元取决于研究对象所处的维度），本文记作 $\\varphi\\left(\\boldsymbol{x}\\right)$.其返回一个值，该值为点 $\\boldsymbol{x}$ 到目标几何体的最短距离.不同的几何体有不同的 SDF 函数.例如圆的 SDF 为 $\\varphi\\left(\\boldsymbol{x}\\right)&#x3D;\\left|\\left|\\boldsymbol{x}-\\boldsymbol{p}\\right|\\right|_n-R$.其中 $R$ 为圆的半径.若 $\\varphi\\left(\\boldsymbol{x}\\right)&lt;0$ 则说明点在圆内；若 $\\varphi\\left(\\boldsymbol{x}\\right)&#x3D;0$ 则说明点在圆上；若 $\\varphi\\left(\\boldsymbol{x}\\right)&gt;0$ 则说明点在园外.本文不提供任何几何体的 SDF 函数推导过程，读者若有兴趣可自行查找相关资料.</p>\n<p>法线贴图（Normal Texture），是一种凹凸贴图（Bump Map）.可以表示物体的表面细节（如凹凸、划痕）.一个常见的法线贴图如下所示：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/normal_texture.png\"></p>\n</div>\n\n<p>事实上，法线贴图就是将法向量 $\\boldsymbol{n}&#x3D;\\left(x,y,z\\right)$ 映射到了 RGB 空间中；由于 $n_i\\in\\left[-1,1\\right]$，于是就存在如下映射关系：</p>\n<p>$$\\boldsymbol{C}&#x3D;0.5\\boldsymbol{n}+0.5$$</p>\n<p>因此，可以将物体表面粗糙的法向量 $\\boldsymbol{n}$ 全部映射到 RGB 空间中，并储存为图片。在渲染中，我们可以用这一低成本的方法实现物体表面粗糙平面的渲染。得到更好的细节。事实上，如果放大文章封面：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/normal_result.png\"></p>\n</div>\n\n<p>你可以清晰地看到法线贴图的效果，红石块和石块表面看起来来凹凸不平，极具立体感。</p>\n<p>关于法线贴图和 SDF 的详细描述，请分别参考 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">LearnOpenGL - 法线贴图</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/345227118\">知乎 Jacks0n - Rendering (Signed) Distance Function</a>.</p>\n<h2 id=\"Ⅱ、渲染管线概述\"><a href=\"#Ⅱ、渲染管线概述\" class=\"headerlink\" title=\"Ⅱ、渲染管线概述\"></a>Ⅱ、渲染管线概述</h2><p>下图简单直观地展示了本方法的渲染管线：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/pipeline.png\"></p>\n</div>\n\n<p>这里再给出这几个步骤的简述：</p>\n<ol>\n<li><p>基础场景渲染</p>\n<p> 该流程使用原始贴图渲染出未经光照的原始地图.</p>\n</li>\n<li><p>法线场景渲染</p>\n<p> 该流程使用法线贴图渲染出未经光照的原始地图.</p>\n</li>\n<li><p>光照贴图渲染</p>\n<p> 该流程将会基于 SDF 函数计算出原始光照蒙版贴图.</p>\n</li>\n<li><p>辉光处理</p>\n<p> 该流程基于高斯模糊，对阶段三生成的光线蒙版贴图进行辉光处理.</p>\n</li>\n<li><p>混合</p>\n<p> 该步骤将会将步骤一、二、四得到的结果混合并计算出最终结果.</p>\n</li>\n</ol>\n<p>下文将会详细讲述步骤三至五.</p>\n<h2 id=\"Ⅲ、基于-SDF-的蒙版光照计算\"><a href=\"#Ⅲ、基于-SDF-的蒙版光照计算\" class=\"headerlink\" title=\"Ⅲ、基于 SDF 的蒙版光照计算\"></a>Ⅲ、基于 SDF 的蒙版光照计算</h2><p>根据现实生活中的经验，可以发现，一个发光的物体照亮的区域形成一个圆圈.且先保持强度不变再衰减，具体示意图如下：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/light.png\"></p>\n</div>\n\n<p>那么便可以通过 SDF 模拟该过程：</p>\n<p>假设某点处的光源强度 $\\boldsymbol{I}&#x3D;\\left(x,y,z\\right)$（其中 $x,y,z\\in\\left[0,1\\right]$，$1$ 为最亮，$0$ 为最暗）</p>\n<p>我们假设有一个光源 $A$，颜色为 $C$，其光强为 $I_A$， SDF 函数为 $\\varphi_A\\left(\\boldsymbol{x}\\right)$，衰减半径为小 $r$.$\\boldsymbol{R}$ 为一满足在 $\\boldsymbol{P}$ 方向上使得 $\\varphi_A\\left(\\boldsymbol{R}\\right)&#x3D;0$ 的一点，则 $A$ 在 $\\boldsymbol{P}$ 处的辐射度 $\\boldsymbol{L_{A,P}}$ 可以为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation1.svg\"></p>\n</div>\n\n<p>注意（1）中 $\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R+r}{r}C$ 实际上是由：$\\left(1-\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R}{r}\\right)C$ 推到得到的.显然，有 $\\boldsymbol{I}_x\\in\\left[0,1\\right]$，因此，我们可以考虑，使用一个非线性插值 $D\\left(\\boldsymbol{x}\\right)$ 函数来对平滑光照衰减.特别地，我们需要确保 $D\\left(0\\right)&#x3D;0$、$D\\left(1\\right)&#x3D;1$. 此处采用 $D\\left(x\\right)&#x3D;\\sqrt[3]{x}$ 作为衰减平滑函数。</p>\n<p>根据在 1986 年由 James T.Kajiya 提出的渲染方程：</p>\n<p>$$L_O\\left(\\vec{v}\\right)&#x3D;L_e\\left(\\vec{v}\\right)+\\int_{\\Omega}f\\left(\\vec{l_i}, \\vec{v}\\right)L_i\\left(\\vec{l_i}\\right)\\left(\\vec{n}\\cdot\\vec{l_i}\\right)\\text{d}\\vec{l_i}$$</p>\n<p>这里我们无需过多关注这个公式本身（如果你想了解这个公式，可以参考 James T.Kajiya 的论文 <em>The Rendering Equation</em>），在 2D 平面中，我们可以认为所有光线都将射入摄像机，且任意点上收到的光照，等于所有光线辐射度的总和，可以将球面积分改写成很简洁的形式：</p>\n<p>$$L_O\\left(\\vec{v}\\right)&#x3D;\\int^{2\\pi}_{0}L\\left(\\vec{v}, \\theta\\right)\\text{d}\\theta$$</p>\n<p>其中 $L\\left(\\vec{v}, \\theta\\right)$ 表示 $\\theta$ 方向上受到的光亮。然而，由于我们的光源是确定的，在不考虑阴影渲染的情况下，我们可以认为有：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation2.svg\"></p>\n</div>\n\n<p>之所以是在不考虑阴影的情况下才有上述等式成立，是因为当有一个物体遮挡时，光线就并不总是可以完全照射到指定点处。这时就要考虑可能的辐射度衰减。</p>\n<p>因此，假设有 $n$ 个光源 ${A_n}$，则 $\\boldsymbol{P}$ 点处的辐射度 $\\boldsymbol{L}$ 则为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation3.svg\"></p>\n</div>\n\n\n<p>此处给出一个可能的 SKSL 着色器实现：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The light type of the shader</span></span><br><span class=\"line\"><span class=\"comment\">//      If LightType &lt; 10. = Ellipse</span></span><br><span class=\"line\"><span class=\"comment\">//      Else = Rectangle</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> LightType;</span><br><span class=\"line\"><span class=\"comment\">// The X position of the light</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> float2 Center;</span><br><span class=\"line\"><span class=\"comment\">// The radius of the light source object</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> Radius;</span><br><span class=\"line\"><span class=\"comment\">// The range of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> ValidRadius;</span><br><span class=\"line\"><span class=\"comment\">// The light brighteness level of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> Intensity;</span><br><span class=\"line\"><span class=\"comment\">// The color of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> float3 Color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The texture shader for background texture</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader BackgroundTexture;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SDF of ellipse</span></span><br><span class=\"line\"><span class=\"type\">float</span> EllipseSDF(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> R, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">length</span>(R) - Radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The SDF of rectangle</span></span><br><span class=\"line\"><span class=\"type\">float</span> RectangleSDF(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> R, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> Box    = <span class=\"type\">vec2</span>(Radius, Radius);</span><br><span class=\"line\">    <span class=\"type\">vec2</span> Delta  = <span class=\"built_in\">abs</span>(R) - Box;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">length</span>(<span class=\"built_in\">max</span>(Delta, <span class=\"type\">vec2</span>(<span class=\"number\">0.</span>))) + <span class=\"built_in\">min</span>(<span class=\"built_in\">max</span>(Delta.x, Delta.y), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The phi interpolation function</span></span><br><span class=\"line\"><span class=\"type\">float</span> Phi(<span class=\"keyword\">in</span> <span class=\"type\">float</span> Value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> - <span class=\"built_in\">pow</span>(Value, <span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Calculate the light brightness contribution from the SDF</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SDFContribution(<span class=\"keyword\">in</span> <span class=\"type\">float</span> Distance, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity, <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius, <span class=\"keyword\">in</span> <span class=\"type\">vec3</span> Color) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> col = <span class=\"type\">vec3</span>(<span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Distance &lt;= <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> D = Intensity + <span class=\"number\">1.</span>;</span><br><span class=\"line\">        col = Color * D;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Distance &lt;= ValidRadius) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> F = (Distance / ValidRadius);</span><br><span class=\"line\">        <span class=\"type\">float</span> D = Phi(F) * (Intensity + <span class=\"number\">1.</span>);</span><br><span class=\"line\">        col = <span class=\"type\">vec3</span>(Color[<span class=\"number\">0</span>] * D, Color[<span class=\"number\">1</span>] * D, Color[<span class=\"number\">2</span>] * D);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> col;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Sample the coord light from a ellipse object</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SampleEllipse(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Center,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">vec3</span>  Color,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> R = Center - Coord;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> sdf = EllipseSDF(R, Radius);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDFContribution(sdf, Intensity, ValidRadius, Color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Sample the coord light from a rectangle object</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SampleRectangle(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Center,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">vec3</span>  Color,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> R = Center - Coord;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> sdf = RectangleSDF(R, Radius);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDFContribution(sdf, Intensity, ValidRadius, Color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fix the gamma value</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> GammaFixed(<span class=\"keyword\">in</span> <span class=\"type\">vec3</span> R) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">vec3</span>(<span class=\"built_in\">pow</span>(R[<span class=\"number\">0</span>], <span class=\"number\">0.9</span>), <span class=\"built_in\">pow</span>(R[<span class=\"number\">1</span>], <span class=\"number\">0.9</span>), <span class=\"built_in\">pow</span>(R[<span class=\"number\">2</span>], <span class=\"number\">0.9</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> fragCoord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span> fragColor = BackgroundTexture.eval(fragCoord);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LightType &lt; <span class=\"number\">10.</span>) fragColor += <span class=\"type\">vec4</span>(SampleEllipse(Center, Color, Radius, ValidRadius, Intensity, fragCoord), <span class=\"number\">1.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> fragColor += <span class=\"type\">vec4</span>(SampleRectangle(Center, Color, Radius, ValidRadius, Intensity, fragCoord), <span class=\"number\">1.</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fragColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ⅳ、辉光处理\"><a href=\"#Ⅳ、辉光处理\" class=\"headerlink\" title=\"Ⅳ、辉光处理\"></a>Ⅳ、辉光处理</h2><p>尽管在章节 Ⅲ 中已经引入了光照平滑函数 $D\\left(x\\right)$ 来尽可能地让光照平滑自然，但如下图所示，如果要让光照足够的自然，最好还是模拟现实中发光物体的“辉光”效果：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/bloom.png\"></p>\n</div>\n\n<p>为了实现辉光效果，一个可行的思路就是通过高斯模糊来对原来的蒙蔽光照贴图进行处理.</p>\n<p>高斯模糊使用到了二阶正态分布，通过在目标点指定半径大小内计算每个点相当对于该点的权重 $w_{x,y}$ 来实现模糊效果：</p>\n<p>$$w_{x,y}&#x3D;f(x, y) &#x3D; \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}} e^{-\\frac{1}{2(1-\\rho^2)}\\left[\\frac{(x-\\mu_1)^2}{\\sigma_1^2} - 2\\rho\\frac{(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2} + \\frac{(y-\\mu_2)^2}{\\sigma_2^2}\\right]}$$</p>\n<p>关于高斯模糊的详细描述，请参考<a href=\"https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A\">维基百科</a>.</p>\n<p>一个可能的辉光 SKSL 实现代码如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> shader BackgroundTexture;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> pow2(<span class=\"keyword\">in</span> <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((x) * (x));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> pi      = <span class=\"number\">3.14159265358979323846</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> samples = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> sigma   = samples * <span class=\"number\">0.25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> gaussian(float2 i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> / (<span class=\"number\">2.0</span> * pi * pow2(sigma)) * <span class=\"built_in\">exp</span>(-((pow2(i.x) + pow2(i.y)) / (<span class=\"number\">2.0</span> * pow2(sigma))));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(float2 coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span>  color = <span class=\"type\">vec4</span>(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> accum = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">float</span> x = -samples / <span class=\"number\">2</span>; x &lt;= samples / <span class=\"number\">2</span>; ++x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">float</span> y = -samples / <span class=\"number\">2</span>; y &lt;= samples / <span class=\"number\">2</span>; ++y) &#123;</span><br><span class=\"line\">            float2 <span class=\"keyword\">offset</span>   = float2(<span class=\"type\">float</span>(x), <span class=\"type\">float</span>(y));</span><br><span class=\"line\">            <span class=\"type\">float</span> weight    = gaussian(<span class=\"keyword\">offset</span>);</span><br><span class=\"line\">            color           += BackgroundTexture.eval(coord + <span class=\"keyword\">offset</span>) * weight;</span><br><span class=\"line\">            accum           += weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    color /= accum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ⅵ、混合\"><a href=\"#Ⅵ、混合\" class=\"headerlink\" title=\"Ⅵ、混合\"></a>Ⅵ、混合</h2><p>在最后阶段中，我们需要将前几个步骤得到的结果混合起来，完成光照渲染。混合公式为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation4.svg\"></p>\n</div>\n\n<p>实际上就是把 $m$ 个颜色的 r，g，b 数值相乘后组成新的颜色。事实上，这相当于 PhotoShop 中的 “正片叠底”效果。</p>\n<p>可能的 SKSL 实现代码如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> shader LightMask;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader Normal;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader Origin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> fragCoord) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.5</span> * Normal.eval(fragCoord) * LightMask.eval(fragCoord) * Origin.eval(fragCoord);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ⅶ、总结\"><a href=\"#Ⅶ、总结\" class=\"headerlink\" title=\"Ⅶ、总结\"></a>Ⅶ、总结</h2><p>本文提供了一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 事实上，如果优化得当，该方法在 CPU 上依然可以使用。因为本方法并不考虑阴影遮挡，因此可以说只要光源是确定（即全为静态光源）就可以考虑采用该方法预先进行光线烘培。即使是需要动态光源，在确保光源本身属性不变的情况下，依然可以预先渲染蒙版光源。</p>\n<p>本方法的很多渲染并不一定需要实时进行，这也是为什么在 CPU 上实现这个方法成为了可能。</p>\n","site":{"data":{}},"excerpt":"<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/cover.png\"></p>\n</div>\n\n<p>本文将会介绍一个我正在制作的项目 PaperCraft 中有关游戏 2D 光照的实现. 提供一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 本文将会提供一种可能的 SKSL（Skia Shader Language）代码来实现该方法.</p>","more":"<h2 id=\"Ⅰ、基础知识简介\"><a href=\"#Ⅰ、基础知识简介\" class=\"headerlink\" title=\"Ⅰ、基础知识简介\"></a>Ⅰ、基础知识简介</h2><p>SDF（Signed distance function），有符号距离函数.是一个多元函数（具体几元取决于研究对象所处的维度），本文记作 $\\varphi\\left(\\boldsymbol{x}\\right)$.其返回一个值，该值为点 $\\boldsymbol{x}$ 到目标几何体的最短距离.不同的几何体有不同的 SDF 函数.例如圆的 SDF 为 $\\varphi\\left(\\boldsymbol{x}\\right)&#x3D;\\left|\\left|\\boldsymbol{x}-\\boldsymbol{p}\\right|\\right|_n-R$.其中 $R$ 为圆的半径.若 $\\varphi\\left(\\boldsymbol{x}\\right)&lt;0$ 则说明点在圆内；若 $\\varphi\\left(\\boldsymbol{x}\\right)&#x3D;0$ 则说明点在圆上；若 $\\varphi\\left(\\boldsymbol{x}\\right)&gt;0$ 则说明点在园外.本文不提供任何几何体的 SDF 函数推导过程，读者若有兴趣可自行查找相关资料.</p>\n<p>法线贴图（Normal Texture），是一种凹凸贴图（Bump Map）.可以表示物体的表面细节（如凹凸、划痕）.一个常见的法线贴图如下所示：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/normal_texture.png\"></p>\n</div>\n\n<p>事实上，法线贴图就是将法向量 $\\boldsymbol{n}&#x3D;\\left(x,y,z\\right)$ 映射到了 RGB 空间中；由于 $n_i\\in\\left[-1,1\\right]$，于是就存在如下映射关系：</p>\n<p>$$\\boldsymbol{C}&#x3D;0.5\\boldsymbol{n}+0.5$$</p>\n<p>因此，可以将物体表面粗糙的法向量 $\\boldsymbol{n}$ 全部映射到 RGB 空间中，并储存为图片。在渲染中，我们可以用这一低成本的方法实现物体表面粗糙平面的渲染。得到更好的细节。事实上，如果放大文章封面：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/normal_result.png\"></p>\n</div>\n\n<p>你可以清晰地看到法线贴图的效果，红石块和石块表面看起来来凹凸不平，极具立体感。</p>\n<p>关于法线贴图和 SDF 的详细描述，请分别参考 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">LearnOpenGL - 法线贴图</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/345227118\">知乎 Jacks0n - Rendering (Signed) Distance Function</a>.</p>\n<h2 id=\"Ⅱ、渲染管线概述\"><a href=\"#Ⅱ、渲染管线概述\" class=\"headerlink\" title=\"Ⅱ、渲染管线概述\"></a>Ⅱ、渲染管线概述</h2><p>下图简单直观地展示了本方法的渲染管线：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/pipeline.png\"></p>\n</div>\n\n<p>这里再给出这几个步骤的简述：</p>\n<ol>\n<li><p>基础场景渲染</p>\n<p> 该流程使用原始贴图渲染出未经光照的原始地图.</p>\n</li>\n<li><p>法线场景渲染</p>\n<p> 该流程使用法线贴图渲染出未经光照的原始地图.</p>\n</li>\n<li><p>光照贴图渲染</p>\n<p> 该流程将会基于 SDF 函数计算出原始光照蒙版贴图.</p>\n</li>\n<li><p>辉光处理</p>\n<p> 该流程基于高斯模糊，对阶段三生成的光线蒙版贴图进行辉光处理.</p>\n</li>\n<li><p>混合</p>\n<p> 该步骤将会将步骤一、二、四得到的结果混合并计算出最终结果.</p>\n</li>\n</ol>\n<p>下文将会详细讲述步骤三至五.</p>\n<h2 id=\"Ⅲ、基于-SDF-的蒙版光照计算\"><a href=\"#Ⅲ、基于-SDF-的蒙版光照计算\" class=\"headerlink\" title=\"Ⅲ、基于 SDF 的蒙版光照计算\"></a>Ⅲ、基于 SDF 的蒙版光照计算</h2><p>根据现实生活中的经验，可以发现，一个发光的物体照亮的区域形成一个圆圈.且先保持强度不变再衰减，具体示意图如下：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/light.png\"></p>\n</div>\n\n<p>那么便可以通过 SDF 模拟该过程：</p>\n<p>假设某点处的光源强度 $\\boldsymbol{I}&#x3D;\\left(x,y,z\\right)$（其中 $x,y,z\\in\\left[0,1\\right]$，$1$ 为最亮，$0$ 为最暗）</p>\n<p>我们假设有一个光源 $A$，颜色为 $C$，其光强为 $I_A$， SDF 函数为 $\\varphi_A\\left(\\boldsymbol{x}\\right)$，衰减半径为小 $r$.$\\boldsymbol{R}$ 为一满足在 $\\boldsymbol{P}$ 方向上使得 $\\varphi_A\\left(\\boldsymbol{R}\\right)&#x3D;0$ 的一点，则 $A$ 在 $\\boldsymbol{P}$ 处的辐射度 $\\boldsymbol{L_{A,P}}$ 可以为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation1.svg\"></p>\n</div>\n\n<p>注意（1）中 $\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R+r}{r}C$ 实际上是由：$\\left(1-\\frac{\\varphi_A\\left(\\boldsymbol{P}\\right)-R}{r}\\right)C$ 推到得到的.显然，有 $\\boldsymbol{I}_x\\in\\left[0,1\\right]$，因此，我们可以考虑，使用一个非线性插值 $D\\left(\\boldsymbol{x}\\right)$ 函数来对平滑光照衰减.特别地，我们需要确保 $D\\left(0\\right)&#x3D;0$、$D\\left(1\\right)&#x3D;1$. 此处采用 $D\\left(x\\right)&#x3D;\\sqrt[3]{x}$ 作为衰减平滑函数。</p>\n<p>根据在 1986 年由 James T.Kajiya 提出的渲染方程：</p>\n<p>$$L_O\\left(\\vec{v}\\right)&#x3D;L_e\\left(\\vec{v}\\right)+\\int_{\\Omega}f\\left(\\vec{l_i}, \\vec{v}\\right)L_i\\left(\\vec{l_i}\\right)\\left(\\vec{n}\\cdot\\vec{l_i}\\right)\\text{d}\\vec{l_i}$$</p>\n<p>这里我们无需过多关注这个公式本身（如果你想了解这个公式，可以参考 James T.Kajiya 的论文 <em>The Rendering Equation</em>），在 2D 平面中，我们可以认为所有光线都将射入摄像机，且任意点上收到的光照，等于所有光线辐射度的总和，可以将球面积分改写成很简洁的形式：</p>\n<p>$$L_O\\left(\\vec{v}\\right)&#x3D;\\int^{2\\pi}_{0}L\\left(\\vec{v}, \\theta\\right)\\text{d}\\theta$$</p>\n<p>其中 $L\\left(\\vec{v}, \\theta\\right)$ 表示 $\\theta$ 方向上受到的光亮。然而，由于我们的光源是确定的，在不考虑阴影渲染的情况下，我们可以认为有：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation2.svg\"></p>\n</div>\n\n<p>之所以是在不考虑阴影的情况下才有上述等式成立，是因为当有一个物体遮挡时，光线就并不总是可以完全照射到指定点处。这时就要考虑可能的辐射度衰减。</p>\n<p>因此，假设有 $n$ 个光源 ${A_n}$，则 $\\boldsymbol{P}$ 点处的辐射度 $\\boldsymbol{L}$ 则为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation3.svg\"></p>\n</div>\n\n\n<p>此处给出一个可能的 SKSL 着色器实现：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The light type of the shader</span></span><br><span class=\"line\"><span class=\"comment\">//      If LightType &lt; 10. = Ellipse</span></span><br><span class=\"line\"><span class=\"comment\">//      Else = Rectangle</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> LightType;</span><br><span class=\"line\"><span class=\"comment\">// The X position of the light</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> float2 Center;</span><br><span class=\"line\"><span class=\"comment\">// The radius of the light source object</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> Radius;</span><br><span class=\"line\"><span class=\"comment\">// The range of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> ValidRadius;</span><br><span class=\"line\"><span class=\"comment\">// The light brighteness level of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> Intensity;</span><br><span class=\"line\"><span class=\"comment\">// The color of the light source</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> float3 Color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The texture shader for background texture</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader BackgroundTexture;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The SDF of ellipse</span></span><br><span class=\"line\"><span class=\"type\">float</span> EllipseSDF(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> R, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">length</span>(R) - Radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The SDF of rectangle</span></span><br><span class=\"line\"><span class=\"type\">float</span> RectangleSDF(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> R, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> Box    = <span class=\"type\">vec2</span>(Radius, Radius);</span><br><span class=\"line\">    <span class=\"type\">vec2</span> Delta  = <span class=\"built_in\">abs</span>(R) - Box;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">length</span>(<span class=\"built_in\">max</span>(Delta, <span class=\"type\">vec2</span>(<span class=\"number\">0.</span>))) + <span class=\"built_in\">min</span>(<span class=\"built_in\">max</span>(Delta.x, Delta.y), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// The phi interpolation function</span></span><br><span class=\"line\"><span class=\"type\">float</span> Phi(<span class=\"keyword\">in</span> <span class=\"type\">float</span> Value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> - <span class=\"built_in\">pow</span>(Value, <span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Calculate the light brightness contribution from the SDF</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SDFContribution(<span class=\"keyword\">in</span> <span class=\"type\">float</span> Distance, <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity, <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius, <span class=\"keyword\">in</span> <span class=\"type\">vec3</span> Color) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> col = <span class=\"type\">vec3</span>(<span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Distance &lt;= <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> D = Intensity + <span class=\"number\">1.</span>;</span><br><span class=\"line\">        col = Color * D;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Distance &lt;= ValidRadius) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> F = (Distance / ValidRadius);</span><br><span class=\"line\">        <span class=\"type\">float</span> D = Phi(F) * (Intensity + <span class=\"number\">1.</span>);</span><br><span class=\"line\">        col = <span class=\"type\">vec3</span>(Color[<span class=\"number\">0</span>] * D, Color[<span class=\"number\">1</span>] * D, Color[<span class=\"number\">2</span>] * D);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> col;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Sample the coord light from a ellipse object</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SampleEllipse(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Center,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">vec3</span>  Color,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity,</span><br><span class=\"line\">                   <span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> R = Center - Coord;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> sdf = EllipseSDF(R, Radius);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDFContribution(sdf, Intensity, ValidRadius, Color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Sample the coord light from a rectangle object</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> SampleRectangle(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Center,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">vec3</span>  Color,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> Radius,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> ValidRadius,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">float</span> Intensity,</span><br><span class=\"line\">                     <span class=\"keyword\">in</span> <span class=\"type\">vec2</span>  Coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> R = Center - Coord;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> sdf = RectangleSDF(R, Radius);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SDFContribution(sdf, Intensity, ValidRadius, Color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fix the gamma value</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> GammaFixed(<span class=\"keyword\">in</span> <span class=\"type\">vec3</span> R) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">vec3</span>(<span class=\"built_in\">pow</span>(R[<span class=\"number\">0</span>], <span class=\"number\">0.9</span>), <span class=\"built_in\">pow</span>(R[<span class=\"number\">1</span>], <span class=\"number\">0.9</span>), <span class=\"built_in\">pow</span>(R[<span class=\"number\">2</span>], <span class=\"number\">0.9</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> fragCoord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span> fragColor = BackgroundTexture.eval(fragCoord);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LightType &lt; <span class=\"number\">10.</span>) fragColor += <span class=\"type\">vec4</span>(SampleEllipse(Center, Color, Radius, ValidRadius, Intensity, fragCoord), <span class=\"number\">1.</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> fragColor += <span class=\"type\">vec4</span>(SampleRectangle(Center, Color, Radius, ValidRadius, Intensity, fragCoord), <span class=\"number\">1.</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fragColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ⅳ、辉光处理\"><a href=\"#Ⅳ、辉光处理\" class=\"headerlink\" title=\"Ⅳ、辉光处理\"></a>Ⅳ、辉光处理</h2><p>尽管在章节 Ⅲ 中已经引入了光照平滑函数 $D\\left(x\\right)$ 来尽可能地让光照平滑自然，但如下图所示，如果要让光照足够的自然，最好还是模拟现实中发光物体的“辉光”效果：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/bloom.png\"></p>\n</div>\n\n<p>为了实现辉光效果，一个可行的思路就是通过高斯模糊来对原来的蒙蔽光照贴图进行处理.</p>\n<p>高斯模糊使用到了二阶正态分布，通过在目标点指定半径大小内计算每个点相当对于该点的权重 $w_{x,y}$ 来实现模糊效果：</p>\n<p>$$w_{x,y}&#x3D;f(x, y) &#x3D; \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}} e^{-\\frac{1}{2(1-\\rho^2)}\\left[\\frac{(x-\\mu_1)^2}{\\sigma_1^2} - 2\\rho\\frac{(x-\\mu_1)(y-\\mu_2)}{\\sigma_1\\sigma_2} + \\frac{(y-\\mu_2)^2}{\\sigma_2^2}\\right]}$$</p>\n<p>关于高斯模糊的详细描述，请参考<a href=\"https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A\">维基百科</a>.</p>\n<p>一个可能的辉光 SKSL 实现代码如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> shader BackgroundTexture;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> pow2(<span class=\"keyword\">in</span> <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((x) * (x));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> pi      = <span class=\"number\">3.14159265358979323846</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> samples = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">float</span> sigma   = samples * <span class=\"number\">0.25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> gaussian(float2 i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> / (<span class=\"number\">2.0</span> * pi * pow2(sigma)) * <span class=\"built_in\">exp</span>(-((pow2(i.x) + pow2(i.y)) / (<span class=\"number\">2.0</span> * pow2(sigma))));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(float2 coord) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span>  color = <span class=\"type\">vec4</span>(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> accum = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">float</span> x = -samples / <span class=\"number\">2</span>; x &lt;= samples / <span class=\"number\">2</span>; ++x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">float</span> y = -samples / <span class=\"number\">2</span>; y &lt;= samples / <span class=\"number\">2</span>; ++y) &#123;</span><br><span class=\"line\">            float2 <span class=\"keyword\">offset</span>   = float2(<span class=\"type\">float</span>(x), <span class=\"type\">float</span>(y));</span><br><span class=\"line\">            <span class=\"type\">float</span> weight    = gaussian(<span class=\"keyword\">offset</span>);</span><br><span class=\"line\">            color           += BackgroundTexture.eval(coord + <span class=\"keyword\">offset</span>) * weight;</span><br><span class=\"line\">            accum           += weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    color /= accum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ⅵ、混合\"><a href=\"#Ⅵ、混合\" class=\"headerlink\" title=\"Ⅵ、混合\"></a>Ⅵ、混合</h2><p>在最后阶段中，我们需要将前几个步骤得到的结果混合起来，完成光照渲染。混合公式为：</p>\n<div align=\"center\">\n\n<p><img src=\"/articles/Margoo/2d-light/equation4.svg\"></p>\n</div>\n\n<p>实际上就是把 $m$ 个颜色的 r，g，b 数值相乘后组成新的颜色。事实上，这相当于 PhotoShop 中的 “正片叠底”效果。</p>\n<p>可能的 SKSL 实现代码如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> shader LightMask;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader Normal;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> shader Origin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">vec4</span> main(<span class=\"keyword\">in</span> <span class=\"type\">vec2</span> fragCoord) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.5</span> * Normal.eval(fragCoord) * LightMask.eval(fragCoord) * Origin.eval(fragCoord);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ⅶ、总结\"><a href=\"#Ⅶ、总结\" class=\"headerlink\" title=\"Ⅶ、总结\"></a>Ⅶ、总结</h2><p>本文提供了一个低成本的基于有符号距离场可用于实时 2D 光照渲染的可行思路. 事实上，如果优化得当，该方法在 CPU 上依然可以使用。因为本方法并不考虑阴影遮挡，因此可以说只要光源是确定（即全为静态光源）就可以考虑采用该方法预先进行光线烘培。即使是需要动态光源，在确保光源本身属性不变的情况下，依然可以预先渲染蒙版光源。</p>\n<p>本方法的很多渲染并不一定需要实时进行，这也是为什么在 CPU 上实现这个方法成为了可能。</p>"},{"title":"PBR 理论","date":"2024-06-09T16:00:00.000Z","update":"2024-06-09T16:00:00.000Z","_content":"\n欢迎大家关注原文作者 hsz！原文地址：https://www.hszsoft.com/2024/04/30/pbr-theory/\n\n# 简介\n\nPBR(Physically Based Rendering)，基于物理的渲染，指的是一些基于现实的物理原理所构成的渲染技术的集合，而非单一的某一种光照算法。\n\n本文主要依据 LearnOpenGL 上的 PBR 理论篇，但在其中文版文章中有一些翻译问题，并且在理解上有一定难度，博主在这里对其进行了一定的简化。\n\n<!-- More -->\n\n# 为什么需要 PBR\n\n我们为什么需要 PBR？回想我一下们在 Phone 算法中的材质：\n\n```glsl\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;    \n    float shininess;\n}; \n```\n\nLearnOpenGL 的作者给出了一些 [特定的数据](http://devernay.free.fr/cours/opengl/materials.html) 让你调整出想要的材质的感觉。这四个参数非常不直观，它们为什么是这些值？\n\n我们需要一套新的 `描述材质` 参数，它的含义应该符合人的直觉，诸如 `粗糙度`、`金属度` 这样的参数。这些参数望文生义，我们很容易就能想象出来随着它的变化，材质应该会变成什么样。\n\n粗糙度慢慢变大的话，它会表现的像下面这个样子：\n\n![roughness](articles/hszSoft/pbr-theory/roughness.gif)\n\n金属度慢慢变大的话，它会表现的像下面这个样子：\n\n![metallic](articles/hszSoft/pbr-theory/metallic.gif)\n\n就粗糙度的变化而言的话，我们已经可以想象出来，粗糙度越大，specular 和 shininess 都会相应地减小，diffuse 也会有相应的变化。那么，这里应该有一些处理 diffuse 和 specular 随着粗糙度的值的变化而变化的公式。这些公式的是怎么来的？\n\n`基于` 物理而来，我之所以要强调这个词，是因为现代计算机的算力有限，我们无法完全按照现实生活的物理公式来计算的。我们要讨论的算法得到的都是一些近似结果，但它们有着非常高的效率。\n\n# PBR 理论\n\n前面提到过 PBR 并非一种单一的光照算法，根据其实现的不同，它有很多种 `工作流`（在输入参数上有区别），比较常用的有金属/粗糙度(Metal/Roughness)工作流和镜面反射/光泽度(Specular/Glossiness)工作流。\n\n不管如何，它们都要满足下面这些条件：\n\n+ 基于微平面的表面模型\n+ 能量守恒\n+ 应用基于物理的双向反射分布函数\n\n博主的这篇文章会对金属/粗糙度(Metal/Roughness)工作流进行讲解。\n\n## 微平面理论 (Microfacets Theory)\n\n这个理论认为没有平面是完全光滑的。由于微平面微小到无法用像素级别的量级对其进行区分，因此我们可以假设一个 Roughness(粗糙度) 参数，用 `统计学` 的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着 `半程向量` 方向的比例。\n\n粗糙度介于 0 到 1，刚才我们看到的变化类似于这样：\n\n![roughness](articles/hszSoft/pbr-theory/ndf.png)\n\n## 能量守恒 (Energy Conservation)\n\n出射光线的能量永远不能超过入射光线的能量（发光面除外）。随着粗糙度的上升，镜面反射区域会变大，反射亮度会下降。如果每个像素的镜面反射强度都一样，就违背了这个定律。这也是刚才我们看到的光滑平面的反射更强烈而粗糙平面的反射更昏暗的原因。\n\n当一束光碰到一个表面时，会分离成 `反射` 部分和 `折射` 部分。反射部分就是我们常说的镜面(Specular)光照，而折射部分就是我们所说的漫反射(Diffuse)光照。为什么折射部分是漫反射光照呢？因为我们这里做了个假设，折射光进入物体后的情况会很复杂，它会像这样：\n\n![surface_reaction](articles/hszSoft/pbr-theory/surface-reaction.png)\n\n我们只考虑在物体的表面附近反射出来的，它们也就构成了漫反射光。对于那些深入了物体表面的部分，我们假设它们全部被吸收。现实的情况是确实有一部分光可能会在比较远的比方再次反射出来，一些被称为 `次表面散射(Subsurface Scattering)技术` 的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。\n\n那我们不难想出，反射和折射二者是 `互斥` 的关系，所以一般会有以下的计算：\n\n```glsl\nfloat kS = calculateSpecularComponent(...); // 反射/镜面部分\nfloat kD = 1.0 - ks;                        // 折射/漫反射部分\n```\n\n不过，对于 `金属` 表面，所有的折射光都会被直接吸收而不会散开，只留下镜面反射光。金属度越高的表面，其原本的颜色越少，周围环境的颜色越多，所以会增加一点东西：\n\n```glsl\nfloat kS = calculateSpecularComponent(...);\nfloat3 k_d = (1.0 - k_s) * (1.0 - metallic);\n```\n\n说了这么多，接下来就可以看看这两个理论是如何被应用的了。\n\n## 双向反射分布函数 (BRDF)\n\n这个名字看着非常高上大，并且是 PBR 的核心，让我们来慢慢理解。\n\n首先，BRDF 是一个函数，它接受 `入射光方向向量`、`出射光方向向量` 作为输入，所以是 `双向`，实际上还有法向量 n，不过在公式中我们一般认为它是已知的。然后，它接受我们刚才说的 `粗糙度` 和 `金属度` 之类的参数，最后返回这束光线对这个片段贡献的 RGB 颜色。在使用中，我们在片段着色器中遍历会影响到这个片段的灯光，并且将其值累加起来。\n\n> 不过法向量 n 的计算实际上还是比较麻烦的，它需要计算切线空间，详细内容可以看 LearnOpenGL 中的 [法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/)。\n\n不难发现，其实 Phone 模型就是一个 BRDF，不过问题在于它并不遵循物理规则。回想一下我们在 [多光源](https://learnopengl-cn.github.io/02%20Lighting/06%20Multiple%20lights/) 中的代码：\n\n```glsl\nvoid main()\n{    \n    // properties\n    vec3 norm = normalize(Normal);\n    vec3 viewDir = normalize(viewPos - FragPos);\n    \n    // phase 1: directional lighting\n    vec3 result = CalcDirLight(dirLight, norm, viewDir);\n    // phase 2: point lights\n    for(int i = 0; i < NR_POINT_LIGHTS; i++)\n        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    \n    // phase 3: spot light\n    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n    \n    FragColor = vec4(result, 1.0);\n}\n```\n\n这里的 `CalDirLight`、`CalPointLight`、`CalSpotLight` 都是 BRDF，我们之前直接通过累加来计算其贡献值，PBR 中我们计算也是靠这样进行累加。这里其实有 `积分` 的行为，不过现在暂时不用了解，我们会在后面的 `IBL` 中讲解它（反射率方程），而现在只需要知道正是因为积分，所以公式中会存在 `标准化` 的步骤。\n\n现在我们需要一个遵循物理规则的 BRDF，这也有很多种实现，我们可以使用一种被称为 `Cook-Torrance BRDF` 的模型。Cook-Torrance BRDF 兼有漫反射和镜面反射两个部分：\n\n![brdf](articles/hszSoft/pbr-theory/ct-brdf.png)\n\n公式的左侧表示的是 lambertian 反射，用于表示漫反射的部分，用如下公式来表示：\n\n![lambertian](articles/hszSoft/pbr-theory/lambertian.png)\n\nlambertian 中的 c 表示材质表面颜色，在我们的工作流中对应着 albedo 纹理，除以 π 是为了对漫反射光进行 `标准化`。\n\n公式的右侧是其镜面反射的部分，它的形式如下：\n\n![cook-torrance](articles/hszSoft/pbr-theory/cook-torrance.png)\n\n和前面一样，分母依旧是用来进行 `标准化` 的。这里的字母 D、F、G 分别代表法线分布函数(Normal `D`istribution Function)，菲涅尔方程(`F`resnel Rquation)和几何函数(`G`eometry Function)。\n\n+ `法线分布函数`：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。\n\n+ `几何函数`：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。\n\n+ `菲涅尔方程`：菲涅尔方程描述的是在不同的观察角度下被反射的光线所占的百分比。它一般就等于 Cook-Torrance BRDF 中的那个 kd。\n\n在我们的实现中，前两者通过 `粗糙度` 计算出一个 float 值，而菲涅尔方程主要通过 `金属度` 计算出一个类型为 vec3 的颜色值。\n\n### 法线分布函数\n\n法线分布函数从统计学上近似表示材质表面法向量与半程向量取向一致的比率。目前有很多种 NDF 都可以根据一些粗糙度参数估算微平面的总体取向度。\n\nNDF 接受 `法向量`、`半程向量`、`粗糙度` 为参数，返回一个 float 值。这里我们使用 Trowbridge-Reitz GGX：\n\n![trowbridge-reitz-ggx](articles/hszSoft/pbr-theory/trowbridge-reitz-ggx.png)\n\n在公式中 h 表示我们的半程向量，而 α 表示表面的粗糙度。\n\n当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF 最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与 h 向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。\n\n![roughness](articles/hszSoft/pbr-theory/ndf.png)\n\n它的 GLSL 代码实现如下：\n\n```glsl\nfloat D_GGX_TR(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n```\n\n### 几何函数\n\n几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量，最终导致材质表面整体显得更加灰暗。\n\n![geometry-shadowing](articles/hszSoft/pbr-theory/geometry-shadowing.png)\n\n它接受 `观察方向向量`、`光线方向向量`、`法向量`、`粗糙度` 作为输入，最终返回一个 float 值。粗糙度越高的表面其微平面间相互遮蔽的概率就越高，这个 float 值就越小，这里我们使用 GGX 与 Schlick-Beckmann `近似` 的结合体，即 Schlick-GGX：\n\n![schlick-ggx](articles/hszSoft/pbr-theory/schlick-ggx.png)\n\n这里 k 是 α 的 `重映射`，取决于我们要使用的是针对直接光照还是针对 IBL 光照的几何函数，我们暂时只介绍直接光照的重映射：\n\n![direct-remapping](articles/hszSoft/pbr-theory/direct-remapping.png)\n\n材质表面自成阴影的分布情况同时和 `观察方向` 与 `光线方向` 有关，在刚才那张微平面的图中，我们可以注意到有些光线因为我们的观察方向比较特别而形成遮挡，我们称之为 `几何遮蔽(Geometry Obstruction)`，有些则和我们的观察方向无关，光线入射进来的时候就已经被遮挡了，我们称之为 `几何阴影(Geometry Shadowing)`。为了同时考虑二者的影响，我们使用 `史密斯法` 来进行计算：\n\n![smith-method](articles/hszSoft/pbr-theory/smith-method.png)\n\n其中，Gsub 即为我们的 Schlick-GGX，如此计算，随着粗糙度的提高，材质表面的视觉效果如下：\n\n![geometry](articles/hszSoft/pbr-theory/geometry.png)\n\n使用 GLSL 编写的实现如下：\n\n```glsl\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n```\n\n### 菲涅尔方程\n\n菲涅尔方程描述的是被反射的光线对比被折射的光线的比率，这个比率会随着我们观察角度的不同而不同。我们正是利用这个方程计算出 `反射光线(fs)` 的部分，并进一步得到光线剩余的能量计算出 `折射光线(fd)` 的部分。它会影响我们看到的 specular 部分的颜色和强度，接下来请看原理。\n\n当垂直观察时，任何材质表面都有一个 `基础反射率`，但是我们的观察角度慢慢与材质表面趋近于平行时，所有反光都会变得明显起来。想象一下，如果你站在湖边低头看脚下的水，你会发现水是透明的，反射并不强烈；如果你看远处的湖面，你会发现它们的反射特别强烈。如果从理想的 90° 进行观察，理论上所有平面都能完全反射光线。这种现象体现在了菲涅尔方程里，不过它的本体过于复杂，好在我们可以用 `Fresnel-Schlick` 近似法求得近似解：\n\n![fresnel-schlick](articles/hszSoft/pbr-theory/fresnel-schlick.png)\n\n这个方程接受 `F0 (color)`、`观察方向向量`、`半程向量` 作为输入，最后返回一个 vec3 颜色值。其中，F0 表示垂直观察一个材质表面时的反射率，即基础反射率，它是一个颜色值，它可以通过材质的 `折射率` 预计算得出。经过这个方程的计算后，我们观察一个球体表面时可以注意到，我们越是朝球体边缘上看，反光越强：\n\n![fresnel](articles/hszSoft/pbr-theory/fresnel.png)\n\n那为什么 F0 是一个 color 值而不是一个 float 值呢？你可以在现实中进行观察，对于非金属表面，它的高光是灯光的颜色，但如果是金属表面的话，它的高光会带一点它本来的颜色。比如对于黄金的话，它的高光也是金色的。\n\n那么，既然说到 F0 应该进行预计算，那么我们应该怎么算呢？对于非金属材质，我们可以使用这个公式：\n\n![calculate-reflectivity](articles/hszSoft/pbr-theory/calculate-reflectivity.png)\n\n之所以可以用它来计算，是因为这里忽略掉了非金属材质的 `消光系数`，因为它相当小，而金属材质的消光系数是不能忽略的。\n\n那这意味着我们要对金属和非金属使用两套不同的公式来预计算出其 F0 吗？这有点麻烦，所以让我们来观察一下不同材质的基础反射率：\n\n![material-base-reflectivity](articles/hszSoft/pbr-theory/material-base-reflectivity.png)\n\n在这里可以看到，所有非金属材质表面的基础反射率都不会高于 0.17，这实际上是`例外情况`而非普遍情况，对于它们，我们可以用 (0.04, 0.04, 0.04) 就可以得到足够好的结果了。然后，对于金属材质，我们需要添加一点其表面的纹理颜色来补充，这是因为金属表面会吸收所有的折射光线而没有漫反射，我们一般是这样实现的：\n\n```glsl\nvec3 F0 = vec3(0.04);\nF0      = mix(F0, surfaceColor.rgb, metalness);\n```\n\n这里引入了一个新的值，即 `金属度(metalness)`，用于描述一个材质表面是金属还是非金属的，也就是，它的 specular 是否带有原本材质的颜色。\n\n理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在 0.0 至 1.0 之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/沙状粒子/刮痕的金属表面。通过对这些小的类非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。\n\n最后把我们插值得到的 F0 输入到 Fresnel-Schlick 的函数中即可，它的代码实现如下：\n\n```glsl\nvec3 SchlickFresnel(float HdotV, vec3 F0)\n{\n    float m = clamp(1 - HdotV, 0, 1);\n    float m2 = m * m;\n    float m5 = m2 * m2 * m; // pow(m,5)\n    return F0 + (1.0 - F0) * m5;\n}\n```\n\n# PBR 工作流\n\n在得到 BRDF 后，我们就已经可以计算 PBR 了，可以暂时不用在意 `渲染方程` 的存在。\n\n在我们实际的工作流中，这些材质的参数是通过纹理输入进来的，使用纹理我们可以逐个片段的来控制每个表面上特定的点对于光线是如何相应的。\n\n下面是一个比较经典的 PBR 渲染管线的纹理列表，还有它最终的视觉输出：\n\n![textures](articles/hszSoft/pbr-theory/textures.png)\n\n其中，从左到右：\n\n+ 反照率(Albedo)：指定材质的 `表面颜色` 或 `基础反射率`，这和我们之前使用的漫反射纹理很像，但漫反射的图像中常常包含一些细小的阴影和裂纹，而在 PBR 中这些东西会保存在别的纹理中。\n\n+ 法线(Normal)：详见 LearnOpenGL 的 [法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/)，它可以逐片段指定独特的法线制造出起伏不平的假象，在模型的定点数较低的情况下丰富细节。\n\n+ 金属度(Metallic)：指定该纹素是否是金属质地的，根据引擎设置的不同，美术师可以将其编写为灰度值或1、0这样的二元值。\n\n+ 粗糙度(Roughness)：指定某一个纹素有多粗糙，有些引擎采用的是 `光滑度(Smoothness)` 贴图，在采样时用 (1.0 - smoothness) 后就可以转换为粗糙度了。\n\n+ 环境光遮罩(Ambient Occlusion)：指定了一个额外的阴影因子，反照率纹理上砖块的裂缝部分没有任何阴影信息，而 AO 贴图就会把它们指定出来。\n\n这个 AO 并没有在前面提到过，在实现中，它并不在 BRDF 的计算中进行，目前直接光照的值都会累加在 `Lo` 中，而最后的颜色值是这样计算的：\n\n```glsl\nvec3 ambient = vec3(0.03) * albedo * ao;\nvec3 color = ambient + Lo;\n```\n\n这里我们暂时使用 0.03 来表示环境光的强度，而想要得到更好的视觉效果，就需要看之后说到的 IBL 了。\n\n# PBR 应用代码\n\n刚才在介绍 BRDF 时博主贴出了 Phone 模型的代码，那么接下来我们来看看 PBR 的片段着色器中代码是什么样子的，接下来，我们假设场景中有四个灯光：\n\n```glsl\nvec3 ReflectanceEquation(vec3 N, vec3 V, vec3 L, vec3 albedo, vec3 radiance, float roughness, float metallic)\n{\n    roughness = max(roughness, 0.05);\n\n    vec3 H = normalize(L + V);\n    float NdotL = max(dot(N, L), 0);\n    float NdotV = max(dot(N, V), 0);\n    float NdotH = max(dot(N, H), 0);\n    float HdotV = max(dot(H, V), 0);\n\n    float F0 = mix(vec3(0.04), albedo, metallic);\n\n    float D = DistributionGGX(NdotH, roughness);\n    float F = FresnelSchlick(NdotV, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n\n    vec3 k_s = F;\n    vec3 k_d = (vec3(1.0) - k_s) * (1.0 - metallic);\n    \n    vec3 f_diffuse = albedo / PI;\n    vec3 f_specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.0001);\n\n    return (k_d * f_diffuse + f_specular) * radiance * NdotL;\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\t\t\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 N = GetNormalFromMap();\n    vec3 V = normalize(camPos - WorldPos);\n\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 \n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i) \n    {\n        vec3 radiance = lightColors[i];\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n\n        // calculate per-light attenuation\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n\n        Lo += ReflectanceEquation(N, V, L, albedo, radiance, roughness, metallic) * attenuation;\n    }   \n    \n    // ambient lighting (note that the next IBL tutorial will replace \n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    \n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2)); \n\n    FragColor = vec4(color, 1.0);\n}\n```\n\n这份代码中我们在场景中添加了四个点光源，并且根据距离计算了它的衰减。\n\n把反射率方程 ReflectanceEquation 封装好之后，这份代码实际上和 Phone 看起来就会比较像了，不过需要注意一下结尾的把结果映射到 [HDR](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/) 和 [伽马矫正](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/) 的步骤，在这里不做过多赘述。 \n\n# 结语\n\n其实可以看到，PBR 最重要的东西便在于它的这个 BRDF，我们除了可以使用 Metallic-Roughness 来描述材质以外，行业内比较主流的方案还有 Specular-Glossiness 材质，这两种方案各有优缺点。实际上，只要愿意，我们可以用各种各样的参数去定义一个材质的属性，不过，迪士尼曾就这件事提出了它们自己的原则，即 Disney Principled BRDF，内容如下：\n\n+ 应使用直观的参数，而不是物理类的晦涩参数（更符合艺术家的直觉）\n+ 参数应尽可能少\n+ 参数在其合理范围内应该为 0 到 1\n+ 允许参数在有意义时超出正常的合理范围\n+ 所有参数组合应尽可能健壮和合理\n\n以这些理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了一个颜色参数 (baseColor) 和下面描述的十个标量参数：\n\n+ baseColor（固有色）：表面颜色，通常由纹理贴图提供。\n+ subsurface（次表面）：使用次表面近似控制漫反射形状。\n+ metallic（金属度）：金属（0 = 电介质，1 =金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。\n+ specular（镜面反射强度）：入射镜面反射量。用于取代折射率。\n+ specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（basecolor）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。\n+ roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。\n+ anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性。）\n+ sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。\n+ sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。\n+ clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。\n+ clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 = “缎面（satin）”外观，1 = “光泽（gloss）”外观。\n\n![disney-principled-brdf](articles/hszSoft/pbr-theory/disney-principled-brdf.png)\n\n# 引用文章\n\nLearnOpenGL PBR 理论\nhttps://learnopengl-cn.github.io/07%20PBR/01%20Theory/\n\nLearnOpenGL PBR 光照\nhttps://learnopengl-cn.github.io/07%20PBR/02%20Lighting/\n\n菲涅尔方程（Fresnel Equation）\nhttps://zhuanlan.zhihu.com/p/375746359\n\n草履虫都能看懂的 PBR 讲解\nhttps://zhuanlan.zhihu.com/p/137013668\n\n几何光学下的光线传播——光的反射、折射、菲涅耳公式\nhttps://zhuanlan.zhihu.com/p/480405520\n\n基于物理的渲染（PBR）白皮书 | 迪士尼原则的BRDF与BSDF相关总结\nhttps://cloud.tencent.com/developer/article/1427571","source":"_posts/hszSoft/pbr-theory.md","raw":"---\ntitle: PBR 理论\ndate: 2024-06-10\nupdate: 2024-06-10\ntags: [pbr, hszSoft]\npermalink: articles/hszSoft/pbr-theory/\ncategories: hszSoft\n---\n\n欢迎大家关注原文作者 hsz！原文地址：https://www.hszsoft.com/2024/04/30/pbr-theory/\n\n# 简介\n\nPBR(Physically Based Rendering)，基于物理的渲染，指的是一些基于现实的物理原理所构成的渲染技术的集合，而非单一的某一种光照算法。\n\n本文主要依据 LearnOpenGL 上的 PBR 理论篇，但在其中文版文章中有一些翻译问题，并且在理解上有一定难度，博主在这里对其进行了一定的简化。\n\n<!-- More -->\n\n# 为什么需要 PBR\n\n我们为什么需要 PBR？回想我一下们在 Phone 算法中的材质：\n\n```glsl\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;    \n    float shininess;\n}; \n```\n\nLearnOpenGL 的作者给出了一些 [特定的数据](http://devernay.free.fr/cours/opengl/materials.html) 让你调整出想要的材质的感觉。这四个参数非常不直观，它们为什么是这些值？\n\n我们需要一套新的 `描述材质` 参数，它的含义应该符合人的直觉，诸如 `粗糙度`、`金属度` 这样的参数。这些参数望文生义，我们很容易就能想象出来随着它的变化，材质应该会变成什么样。\n\n粗糙度慢慢变大的话，它会表现的像下面这个样子：\n\n![roughness](articles/hszSoft/pbr-theory/roughness.gif)\n\n金属度慢慢变大的话，它会表现的像下面这个样子：\n\n![metallic](articles/hszSoft/pbr-theory/metallic.gif)\n\n就粗糙度的变化而言的话，我们已经可以想象出来，粗糙度越大，specular 和 shininess 都会相应地减小，diffuse 也会有相应的变化。那么，这里应该有一些处理 diffuse 和 specular 随着粗糙度的值的变化而变化的公式。这些公式的是怎么来的？\n\n`基于` 物理而来，我之所以要强调这个词，是因为现代计算机的算力有限，我们无法完全按照现实生活的物理公式来计算的。我们要讨论的算法得到的都是一些近似结果，但它们有着非常高的效率。\n\n# PBR 理论\n\n前面提到过 PBR 并非一种单一的光照算法，根据其实现的不同，它有很多种 `工作流`（在输入参数上有区别），比较常用的有金属/粗糙度(Metal/Roughness)工作流和镜面反射/光泽度(Specular/Glossiness)工作流。\n\n不管如何，它们都要满足下面这些条件：\n\n+ 基于微平面的表面模型\n+ 能量守恒\n+ 应用基于物理的双向反射分布函数\n\n博主的这篇文章会对金属/粗糙度(Metal/Roughness)工作流进行讲解。\n\n## 微平面理论 (Microfacets Theory)\n\n这个理论认为没有平面是完全光滑的。由于微平面微小到无法用像素级别的量级对其进行区分，因此我们可以假设一个 Roughness(粗糙度) 参数，用 `统计学` 的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着 `半程向量` 方向的比例。\n\n粗糙度介于 0 到 1，刚才我们看到的变化类似于这样：\n\n![roughness](articles/hszSoft/pbr-theory/ndf.png)\n\n## 能量守恒 (Energy Conservation)\n\n出射光线的能量永远不能超过入射光线的能量（发光面除外）。随着粗糙度的上升，镜面反射区域会变大，反射亮度会下降。如果每个像素的镜面反射强度都一样，就违背了这个定律。这也是刚才我们看到的光滑平面的反射更强烈而粗糙平面的反射更昏暗的原因。\n\n当一束光碰到一个表面时，会分离成 `反射` 部分和 `折射` 部分。反射部分就是我们常说的镜面(Specular)光照，而折射部分就是我们所说的漫反射(Diffuse)光照。为什么折射部分是漫反射光照呢？因为我们这里做了个假设，折射光进入物体后的情况会很复杂，它会像这样：\n\n![surface_reaction](articles/hszSoft/pbr-theory/surface-reaction.png)\n\n我们只考虑在物体的表面附近反射出来的，它们也就构成了漫反射光。对于那些深入了物体表面的部分，我们假设它们全部被吸收。现实的情况是确实有一部分光可能会在比较远的比方再次反射出来，一些被称为 `次表面散射(Subsurface Scattering)技术` 的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。\n\n那我们不难想出，反射和折射二者是 `互斥` 的关系，所以一般会有以下的计算：\n\n```glsl\nfloat kS = calculateSpecularComponent(...); // 反射/镜面部分\nfloat kD = 1.0 - ks;                        // 折射/漫反射部分\n```\n\n不过，对于 `金属` 表面，所有的折射光都会被直接吸收而不会散开，只留下镜面反射光。金属度越高的表面，其原本的颜色越少，周围环境的颜色越多，所以会增加一点东西：\n\n```glsl\nfloat kS = calculateSpecularComponent(...);\nfloat3 k_d = (1.0 - k_s) * (1.0 - metallic);\n```\n\n说了这么多，接下来就可以看看这两个理论是如何被应用的了。\n\n## 双向反射分布函数 (BRDF)\n\n这个名字看着非常高上大，并且是 PBR 的核心，让我们来慢慢理解。\n\n首先，BRDF 是一个函数，它接受 `入射光方向向量`、`出射光方向向量` 作为输入，所以是 `双向`，实际上还有法向量 n，不过在公式中我们一般认为它是已知的。然后，它接受我们刚才说的 `粗糙度` 和 `金属度` 之类的参数，最后返回这束光线对这个片段贡献的 RGB 颜色。在使用中，我们在片段着色器中遍历会影响到这个片段的灯光，并且将其值累加起来。\n\n> 不过法向量 n 的计算实际上还是比较麻烦的，它需要计算切线空间，详细内容可以看 LearnOpenGL 中的 [法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/)。\n\n不难发现，其实 Phone 模型就是一个 BRDF，不过问题在于它并不遵循物理规则。回想一下我们在 [多光源](https://learnopengl-cn.github.io/02%20Lighting/06%20Multiple%20lights/) 中的代码：\n\n```glsl\nvoid main()\n{    \n    // properties\n    vec3 norm = normalize(Normal);\n    vec3 viewDir = normalize(viewPos - FragPos);\n    \n    // phase 1: directional lighting\n    vec3 result = CalcDirLight(dirLight, norm, viewDir);\n    // phase 2: point lights\n    for(int i = 0; i < NR_POINT_LIGHTS; i++)\n        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    \n    // phase 3: spot light\n    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n    \n    FragColor = vec4(result, 1.0);\n}\n```\n\n这里的 `CalDirLight`、`CalPointLight`、`CalSpotLight` 都是 BRDF，我们之前直接通过累加来计算其贡献值，PBR 中我们计算也是靠这样进行累加。这里其实有 `积分` 的行为，不过现在暂时不用了解，我们会在后面的 `IBL` 中讲解它（反射率方程），而现在只需要知道正是因为积分，所以公式中会存在 `标准化` 的步骤。\n\n现在我们需要一个遵循物理规则的 BRDF，这也有很多种实现，我们可以使用一种被称为 `Cook-Torrance BRDF` 的模型。Cook-Torrance BRDF 兼有漫反射和镜面反射两个部分：\n\n![brdf](articles/hszSoft/pbr-theory/ct-brdf.png)\n\n公式的左侧表示的是 lambertian 反射，用于表示漫反射的部分，用如下公式来表示：\n\n![lambertian](articles/hszSoft/pbr-theory/lambertian.png)\n\nlambertian 中的 c 表示材质表面颜色，在我们的工作流中对应着 albedo 纹理，除以 π 是为了对漫反射光进行 `标准化`。\n\n公式的右侧是其镜面反射的部分，它的形式如下：\n\n![cook-torrance](articles/hszSoft/pbr-theory/cook-torrance.png)\n\n和前面一样，分母依旧是用来进行 `标准化` 的。这里的字母 D、F、G 分别代表法线分布函数(Normal `D`istribution Function)，菲涅尔方程(`F`resnel Rquation)和几何函数(`G`eometry Function)。\n\n+ `法线分布函数`：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。\n\n+ `几何函数`：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。\n\n+ `菲涅尔方程`：菲涅尔方程描述的是在不同的观察角度下被反射的光线所占的百分比。它一般就等于 Cook-Torrance BRDF 中的那个 kd。\n\n在我们的实现中，前两者通过 `粗糙度` 计算出一个 float 值，而菲涅尔方程主要通过 `金属度` 计算出一个类型为 vec3 的颜色值。\n\n### 法线分布函数\n\n法线分布函数从统计学上近似表示材质表面法向量与半程向量取向一致的比率。目前有很多种 NDF 都可以根据一些粗糙度参数估算微平面的总体取向度。\n\nNDF 接受 `法向量`、`半程向量`、`粗糙度` 为参数，返回一个 float 值。这里我们使用 Trowbridge-Reitz GGX：\n\n![trowbridge-reitz-ggx](articles/hszSoft/pbr-theory/trowbridge-reitz-ggx.png)\n\n在公式中 h 表示我们的半程向量，而 α 表示表面的粗糙度。\n\n当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF 最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与 h 向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。\n\n![roughness](articles/hszSoft/pbr-theory/ndf.png)\n\n它的 GLSL 代码实现如下：\n\n```glsl\nfloat D_GGX_TR(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n```\n\n### 几何函数\n\n几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量，最终导致材质表面整体显得更加灰暗。\n\n![geometry-shadowing](articles/hszSoft/pbr-theory/geometry-shadowing.png)\n\n它接受 `观察方向向量`、`光线方向向量`、`法向量`、`粗糙度` 作为输入，最终返回一个 float 值。粗糙度越高的表面其微平面间相互遮蔽的概率就越高，这个 float 值就越小，这里我们使用 GGX 与 Schlick-Beckmann `近似` 的结合体，即 Schlick-GGX：\n\n![schlick-ggx](articles/hszSoft/pbr-theory/schlick-ggx.png)\n\n这里 k 是 α 的 `重映射`，取决于我们要使用的是针对直接光照还是针对 IBL 光照的几何函数，我们暂时只介绍直接光照的重映射：\n\n![direct-remapping](articles/hszSoft/pbr-theory/direct-remapping.png)\n\n材质表面自成阴影的分布情况同时和 `观察方向` 与 `光线方向` 有关，在刚才那张微平面的图中，我们可以注意到有些光线因为我们的观察方向比较特别而形成遮挡，我们称之为 `几何遮蔽(Geometry Obstruction)`，有些则和我们的观察方向无关，光线入射进来的时候就已经被遮挡了，我们称之为 `几何阴影(Geometry Shadowing)`。为了同时考虑二者的影响，我们使用 `史密斯法` 来进行计算：\n\n![smith-method](articles/hszSoft/pbr-theory/smith-method.png)\n\n其中，Gsub 即为我们的 Schlick-GGX，如此计算，随着粗糙度的提高，材质表面的视觉效果如下：\n\n![geometry](articles/hszSoft/pbr-theory/geometry.png)\n\n使用 GLSL 编写的实现如下：\n\n```glsl\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n```\n\n### 菲涅尔方程\n\n菲涅尔方程描述的是被反射的光线对比被折射的光线的比率，这个比率会随着我们观察角度的不同而不同。我们正是利用这个方程计算出 `反射光线(fs)` 的部分，并进一步得到光线剩余的能量计算出 `折射光线(fd)` 的部分。它会影响我们看到的 specular 部分的颜色和强度，接下来请看原理。\n\n当垂直观察时，任何材质表面都有一个 `基础反射率`，但是我们的观察角度慢慢与材质表面趋近于平行时，所有反光都会变得明显起来。想象一下，如果你站在湖边低头看脚下的水，你会发现水是透明的，反射并不强烈；如果你看远处的湖面，你会发现它们的反射特别强烈。如果从理想的 90° 进行观察，理论上所有平面都能完全反射光线。这种现象体现在了菲涅尔方程里，不过它的本体过于复杂，好在我们可以用 `Fresnel-Schlick` 近似法求得近似解：\n\n![fresnel-schlick](articles/hszSoft/pbr-theory/fresnel-schlick.png)\n\n这个方程接受 `F0 (color)`、`观察方向向量`、`半程向量` 作为输入，最后返回一个 vec3 颜色值。其中，F0 表示垂直观察一个材质表面时的反射率，即基础反射率，它是一个颜色值，它可以通过材质的 `折射率` 预计算得出。经过这个方程的计算后，我们观察一个球体表面时可以注意到，我们越是朝球体边缘上看，反光越强：\n\n![fresnel](articles/hszSoft/pbr-theory/fresnel.png)\n\n那为什么 F0 是一个 color 值而不是一个 float 值呢？你可以在现实中进行观察，对于非金属表面，它的高光是灯光的颜色，但如果是金属表面的话，它的高光会带一点它本来的颜色。比如对于黄金的话，它的高光也是金色的。\n\n那么，既然说到 F0 应该进行预计算，那么我们应该怎么算呢？对于非金属材质，我们可以使用这个公式：\n\n![calculate-reflectivity](articles/hszSoft/pbr-theory/calculate-reflectivity.png)\n\n之所以可以用它来计算，是因为这里忽略掉了非金属材质的 `消光系数`，因为它相当小，而金属材质的消光系数是不能忽略的。\n\n那这意味着我们要对金属和非金属使用两套不同的公式来预计算出其 F0 吗？这有点麻烦，所以让我们来观察一下不同材质的基础反射率：\n\n![material-base-reflectivity](articles/hszSoft/pbr-theory/material-base-reflectivity.png)\n\n在这里可以看到，所有非金属材质表面的基础反射率都不会高于 0.17，这实际上是`例外情况`而非普遍情况，对于它们，我们可以用 (0.04, 0.04, 0.04) 就可以得到足够好的结果了。然后，对于金属材质，我们需要添加一点其表面的纹理颜色来补充，这是因为金属表面会吸收所有的折射光线而没有漫反射，我们一般是这样实现的：\n\n```glsl\nvec3 F0 = vec3(0.04);\nF0      = mix(F0, surfaceColor.rgb, metalness);\n```\n\n这里引入了一个新的值，即 `金属度(metalness)`，用于描述一个材质表面是金属还是非金属的，也就是，它的 specular 是否带有原本材质的颜色。\n\n理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在 0.0 至 1.0 之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/沙状粒子/刮痕的金属表面。通过对这些小的类非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。\n\n最后把我们插值得到的 F0 输入到 Fresnel-Schlick 的函数中即可，它的代码实现如下：\n\n```glsl\nvec3 SchlickFresnel(float HdotV, vec3 F0)\n{\n    float m = clamp(1 - HdotV, 0, 1);\n    float m2 = m * m;\n    float m5 = m2 * m2 * m; // pow(m,5)\n    return F0 + (1.0 - F0) * m5;\n}\n```\n\n# PBR 工作流\n\n在得到 BRDF 后，我们就已经可以计算 PBR 了，可以暂时不用在意 `渲染方程` 的存在。\n\n在我们实际的工作流中，这些材质的参数是通过纹理输入进来的，使用纹理我们可以逐个片段的来控制每个表面上特定的点对于光线是如何相应的。\n\n下面是一个比较经典的 PBR 渲染管线的纹理列表，还有它最终的视觉输出：\n\n![textures](articles/hszSoft/pbr-theory/textures.png)\n\n其中，从左到右：\n\n+ 反照率(Albedo)：指定材质的 `表面颜色` 或 `基础反射率`，这和我们之前使用的漫反射纹理很像，但漫反射的图像中常常包含一些细小的阴影和裂纹，而在 PBR 中这些东西会保存在别的纹理中。\n\n+ 法线(Normal)：详见 LearnOpenGL 的 [法线贴图](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/)，它可以逐片段指定独特的法线制造出起伏不平的假象，在模型的定点数较低的情况下丰富细节。\n\n+ 金属度(Metallic)：指定该纹素是否是金属质地的，根据引擎设置的不同，美术师可以将其编写为灰度值或1、0这样的二元值。\n\n+ 粗糙度(Roughness)：指定某一个纹素有多粗糙，有些引擎采用的是 `光滑度(Smoothness)` 贴图，在采样时用 (1.0 - smoothness) 后就可以转换为粗糙度了。\n\n+ 环境光遮罩(Ambient Occlusion)：指定了一个额外的阴影因子，反照率纹理上砖块的裂缝部分没有任何阴影信息，而 AO 贴图就会把它们指定出来。\n\n这个 AO 并没有在前面提到过，在实现中，它并不在 BRDF 的计算中进行，目前直接光照的值都会累加在 `Lo` 中，而最后的颜色值是这样计算的：\n\n```glsl\nvec3 ambient = vec3(0.03) * albedo * ao;\nvec3 color = ambient + Lo;\n```\n\n这里我们暂时使用 0.03 来表示环境光的强度，而想要得到更好的视觉效果，就需要看之后说到的 IBL 了。\n\n# PBR 应用代码\n\n刚才在介绍 BRDF 时博主贴出了 Phone 模型的代码，那么接下来我们来看看 PBR 的片段着色器中代码是什么样子的，接下来，我们假设场景中有四个灯光：\n\n```glsl\nvec3 ReflectanceEquation(vec3 N, vec3 V, vec3 L, vec3 albedo, vec3 radiance, float roughness, float metallic)\n{\n    roughness = max(roughness, 0.05);\n\n    vec3 H = normalize(L + V);\n    float NdotL = max(dot(N, L), 0);\n    float NdotV = max(dot(N, V), 0);\n    float NdotH = max(dot(N, H), 0);\n    float HdotV = max(dot(H, V), 0);\n\n    float F0 = mix(vec3(0.04), albedo, metallic);\n\n    float D = DistributionGGX(NdotH, roughness);\n    float F = FresnelSchlick(NdotV, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n\n    vec3 k_s = F;\n    vec3 k_d = (vec3(1.0) - k_s) * (1.0 - metallic);\n    \n    vec3 f_diffuse = albedo / PI;\n    vec3 f_specular = (D * F * G) / (4.0 * NdotV * NdotL + 0.0001);\n\n    return (k_d * f_diffuse + f_specular) * radiance * NdotL;\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{\t\t\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n\n    vec3 N = GetNormalFromMap();\n    vec3 V = normalize(camPos - WorldPos);\n\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 \n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i) \n    {\n        vec3 radiance = lightColors[i];\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n\n        // calculate per-light attenuation\n        float distance = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n\n        Lo += ReflectanceEquation(N, V, L, albedo, radiance, roughness, metallic) * attenuation;\n    }   \n    \n    // ambient lighting (note that the next IBL tutorial will replace \n    // this ambient lighting with environment lighting).\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    \n    vec3 color = ambient + Lo;\n\n    // HDR tonemapping\n    color = color / (color + vec3(1.0));\n    // gamma correct\n    color = pow(color, vec3(1.0/2.2)); \n\n    FragColor = vec4(color, 1.0);\n}\n```\n\n这份代码中我们在场景中添加了四个点光源，并且根据距离计算了它的衰减。\n\n把反射率方程 ReflectanceEquation 封装好之后，这份代码实际上和 Phone 看起来就会比较像了，不过需要注意一下结尾的把结果映射到 [HDR](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/) 和 [伽马矫正](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/) 的步骤，在这里不做过多赘述。 \n\n# 结语\n\n其实可以看到，PBR 最重要的东西便在于它的这个 BRDF，我们除了可以使用 Metallic-Roughness 来描述材质以外，行业内比较主流的方案还有 Specular-Glossiness 材质，这两种方案各有优缺点。实际上，只要愿意，我们可以用各种各样的参数去定义一个材质的属性，不过，迪士尼曾就这件事提出了它们自己的原则，即 Disney Principled BRDF，内容如下：\n\n+ 应使用直观的参数，而不是物理类的晦涩参数（更符合艺术家的直觉）\n+ 参数应尽可能少\n+ 参数在其合理范围内应该为 0 到 1\n+ 允许参数在有意义时超出正常的合理范围\n+ 所有参数组合应尽可能健壮和合理\n\n以这些理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了一个颜色参数 (baseColor) 和下面描述的十个标量参数：\n\n+ baseColor（固有色）：表面颜色，通常由纹理贴图提供。\n+ subsurface（次表面）：使用次表面近似控制漫反射形状。\n+ metallic（金属度）：金属（0 = 电介质，1 =金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。\n+ specular（镜面反射强度）：入射镜面反射量。用于取代折射率。\n+ specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（basecolor）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。\n+ roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。\n+ anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性。）\n+ sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。\n+ sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。\n+ clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。\n+ clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 = “缎面（satin）”外观，1 = “光泽（gloss）”外观。\n\n![disney-principled-brdf](articles/hszSoft/pbr-theory/disney-principled-brdf.png)\n\n# 引用文章\n\nLearnOpenGL PBR 理论\nhttps://learnopengl-cn.github.io/07%20PBR/01%20Theory/\n\nLearnOpenGL PBR 光照\nhttps://learnopengl-cn.github.io/07%20PBR/02%20Lighting/\n\n菲涅尔方程（Fresnel Equation）\nhttps://zhuanlan.zhihu.com/p/375746359\n\n草履虫都能看懂的 PBR 讲解\nhttps://zhuanlan.zhihu.com/p/137013668\n\n几何光学下的光线传播——光的反射、折射、菲涅耳公式\nhttps://zhuanlan.zhihu.com/p/480405520\n\n基于物理的渲染（PBR）白皮书 | 迪士尼原则的BRDF与BSDF相关总结\nhttps://cloud.tencent.com/developer/article/1427571","slug":"hszSoft/pbr-theory","published":1,"updated":"2024-06-21T04:01:45.566Z","__permalink":"articles/hszSoft/pbr-theory/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85c000flcuth70q0sln","content":"<p>欢迎大家关注原文作者 hsz！原文地址：<a href=\"https://www.hszsoft.com/2024/04/30/pbr-theory/\">https://www.hszsoft.com/2024/04/30/pbr-theory/</a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>PBR(Physically Based Rendering)，基于物理的渲染，指的是一些基于现实的物理原理所构成的渲染技术的集合，而非单一的某一种光照算法。</p>\n<p>本文主要依据 LearnOpenGL 上的 PBR 理论篇，但在其中文版文章中有一些翻译问题，并且在理解上有一定难度，博主在这里对其进行了一定的简化。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"为什么需要-PBR\"><a href=\"#为什么需要-PBR\" class=\"headerlink\" title=\"为什么需要 PBR\"></a>为什么需要 PBR</h1><p>我们为什么需要 PBR？回想我一下们在 Phone 算法中的材质：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Material &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> ambient;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> diffuse;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> specular;    </span><br><span class=\"line\">    <span class=\"type\">float</span> shininess;</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>LearnOpenGL 的作者给出了一些 <a href=\"http://devernay.free.fr/cours/opengl/materials.html\">特定的数据</a> 让你调整出想要的材质的感觉。这四个参数非常不直观，它们为什么是这些值？</p>\n<p>我们需要一套新的 <code>描述材质</code> 参数，它的含义应该符合人的直觉，诸如 <code>粗糙度</code>、<code>金属度</code> 这样的参数。这些参数望文生义，我们很容易就能想象出来随着它的变化，材质应该会变成什么样。</p>\n<p>粗糙度慢慢变大的话，它会表现的像下面这个样子：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/roughness.gif\" alt=\"roughness\"></p>\n<p>金属度慢慢变大的话，它会表现的像下面这个样子：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/metallic.gif\" alt=\"metallic\"></p>\n<p>就粗糙度的变化而言的话，我们已经可以想象出来，粗糙度越大，specular 和 shininess 都会相应地减小，diffuse 也会有相应的变化。那么，这里应该有一些处理 diffuse 和 specular 随着粗糙度的值的变化而变化的公式。这些公式的是怎么来的？</p>\n<p><code>基于</code> 物理而来，我之所以要强调这个词，是因为现代计算机的算力有限，我们无法完全按照现实生活的物理公式来计算的。我们要讨论的算法得到的都是一些近似结果，但它们有着非常高的效率。</p>\n<h1 id=\"PBR-理论\"><a href=\"#PBR-理论\" class=\"headerlink\" title=\"PBR 理论\"></a>PBR 理论</h1><p>前面提到过 PBR 并非一种单一的光照算法，根据其实现的不同，它有很多种 <code>工作流</code>（在输入参数上有区别），比较常用的有金属&#x2F;粗糙度(Metal&#x2F;Roughness)工作流和镜面反射&#x2F;光泽度(Specular&#x2F;Glossiness)工作流。</p>\n<p>不管如何，它们都要满足下面这些条件：</p>\n<ul>\n<li>基于微平面的表面模型</li>\n<li>能量守恒</li>\n<li>应用基于物理的双向反射分布函数</li>\n</ul>\n<p>博主的这篇文章会对金属&#x2F;粗糙度(Metal&#x2F;Roughness)工作流进行讲解。</p>\n<h2 id=\"微平面理论-Microfacets-Theory\"><a href=\"#微平面理论-Microfacets-Theory\" class=\"headerlink\" title=\"微平面理论 (Microfacets Theory)\"></a>微平面理论 (Microfacets Theory)</h2><p>这个理论认为没有平面是完全光滑的。由于微平面微小到无法用像素级别的量级对其进行区分，因此我们可以假设一个 Roughness(粗糙度) 参数，用 <code>统计学</code> 的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着 <code>半程向量</code> 方向的比例。</p>\n<p>粗糙度介于 0 到 1，刚才我们看到的变化类似于这样：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ndf.png\" alt=\"roughness\"></p>\n<h2 id=\"能量守恒-Energy-Conservation\"><a href=\"#能量守恒-Energy-Conservation\" class=\"headerlink\" title=\"能量守恒 (Energy Conservation)\"></a>能量守恒 (Energy Conservation)</h2><p>出射光线的能量永远不能超过入射光线的能量（发光面除外）。随着粗糙度的上升，镜面反射区域会变大，反射亮度会下降。如果每个像素的镜面反射强度都一样，就违背了这个定律。这也是刚才我们看到的光滑平面的反射更强烈而粗糙平面的反射更昏暗的原因。</p>\n<p>当一束光碰到一个表面时，会分离成 <code>反射</code> 部分和 <code>折射</code> 部分。反射部分就是我们常说的镜面(Specular)光照，而折射部分就是我们所说的漫反射(Diffuse)光照。为什么折射部分是漫反射光照呢？因为我们这里做了个假设，折射光进入物体后的情况会很复杂，它会像这样：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/surface-reaction.png\" alt=\"surface_reaction\"></p>\n<p>我们只考虑在物体的表面附近反射出来的，它们也就构成了漫反射光。对于那些深入了物体表面的部分，我们假设它们全部被吸收。现实的情况是确实有一部分光可能会在比较远的比方再次反射出来，一些被称为 <code>次表面散射(Subsurface Scattering)技术</code> 的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。</p>\n<p>那我们不难想出，反射和折射二者是 <code>互斥</code> 的关系，所以一般会有以下的计算：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> kS = calculateSpecularComponent(...); <span class=\"comment\">// 反射/镜面部分</span></span><br><span class=\"line\"><span class=\"type\">float</span> kD = <span class=\"number\">1.0</span> - ks;                        <span class=\"comment\">// 折射/漫反射部分</span></span><br></pre></td></tr></table></figure>\n\n<p>不过，对于 <code>金属</code> 表面，所有的折射光都会被直接吸收而不会散开，只留下镜面反射光。金属度越高的表面，其原本的颜色越少，周围环境的颜色越多，所以会增加一点东西：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> kS = calculateSpecularComponent(...);</span><br><span class=\"line\">float3 k_d = (<span class=\"number\">1.0</span> - k_s) * (<span class=\"number\">1.0</span> - metallic);</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，接下来就可以看看这两个理论是如何被应用的了。</p>\n<h2 id=\"双向反射分布函数-BRDF\"><a href=\"#双向反射分布函数-BRDF\" class=\"headerlink\" title=\"双向反射分布函数 (BRDF)\"></a>双向反射分布函数 (BRDF)</h2><p>这个名字看着非常高上大，并且是 PBR 的核心，让我们来慢慢理解。</p>\n<p>首先，BRDF 是一个函数，它接受 <code>入射光方向向量</code>、<code>出射光方向向量</code> 作为输入，所以是 <code>双向</code>，实际上还有法向量 n，不过在公式中我们一般认为它是已知的。然后，它接受我们刚才说的 <code>粗糙度</code> 和 <code>金属度</code> 之类的参数，最后返回这束光线对这个片段贡献的 RGB 颜色。在使用中，我们在片段着色器中遍历会影响到这个片段的灯光，并且将其值累加起来。</p>\n<blockquote>\n<p>不过法向量 n 的计算实际上还是比较麻烦的，它需要计算切线空间，详细内容可以看 LearnOpenGL 中的 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">法线贴图</a>。</p>\n</blockquote>\n<p>不难发现，其实 Phone 模型就是一个 BRDF，不过问题在于它并不遵循物理规则。回想一下我们在 <a href=\"https://learnopengl-cn.github.io/02%20Lighting/06%20Multiple%20lights/\">多光源</a> 中的代码：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"comment\">// properties</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> norm = <span class=\"built_in\">normalize</span>(Normal);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> viewDir = <span class=\"built_in\">normalize</span>(viewPos - FragPos);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// phase 1: directional lighting</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class=\"line\">    <span class=\"comment\">// phase 2: point lights</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class=\"line\">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    </span><br><span class=\"line\">    <span class=\"comment\">// phase 3: spot light</span></span><br><span class=\"line\">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span><br><span class=\"line\">    </span><br><span class=\"line\">    FragColor = <span class=\"type\">vec4</span>(result, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>CalDirLight</code>、<code>CalPointLight</code>、<code>CalSpotLight</code> 都是 BRDF，我们之前直接通过累加来计算其贡献值，PBR 中我们计算也是靠这样进行累加。这里其实有 <code>积分</code> 的行为，不过现在暂时不用了解，我们会在后面的 <code>IBL</code> 中讲解它（反射率方程），而现在只需要知道正是因为积分，所以公式中会存在 <code>标准化</code> 的步骤。</p>\n<p>现在我们需要一个遵循物理规则的 BRDF，这也有很多种实现，我们可以使用一种被称为 <code>Cook-Torrance BRDF</code> 的模型。Cook-Torrance BRDF 兼有漫反射和镜面反射两个部分：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ct-brdf.png\" alt=\"brdf\"></p>\n<p>公式的左侧表示的是 lambertian 反射，用于表示漫反射的部分，用如下公式来表示：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/lambertian.png\" alt=\"lambertian\"></p>\n<p>lambertian 中的 c 表示材质表面颜色，在我们的工作流中对应着 albedo 纹理，除以 π 是为了对漫反射光进行 <code>标准化</code>。</p>\n<p>公式的右侧是其镜面反射的部分，它的形式如下：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/cook-torrance.png\" alt=\"cook-torrance\"></p>\n<p>和前面一样，分母依旧是用来进行 <code>标准化</code> 的。这里的字母 D、F、G 分别代表法线分布函数(Normal <code>D</code>istribution Function)，菲涅尔方程(<code>F</code>resnel Rquation)和几何函数(<code>G</code>eometry Function)。</p>\n<ul>\n<li><p><code>法线分布函数</code>：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。</p>\n</li>\n<li><p><code>几何函数</code>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</p>\n</li>\n<li><p><code>菲涅尔方程</code>：菲涅尔方程描述的是在不同的观察角度下被反射的光线所占的百分比。它一般就等于 Cook-Torrance BRDF 中的那个 kd。</p>\n</li>\n</ul>\n<p>在我们的实现中，前两者通过 <code>粗糙度</code> 计算出一个 float 值，而菲涅尔方程主要通过 <code>金属度</code> 计算出一个类型为 vec3 的颜色值。</p>\n<h3 id=\"法线分布函数\"><a href=\"#法线分布函数\" class=\"headerlink\" title=\"法线分布函数\"></a>法线分布函数</h3><p>法线分布函数从统计学上近似表示材质表面法向量与半程向量取向一致的比率。目前有很多种 NDF 都可以根据一些粗糙度参数估算微平面的总体取向度。</p>\n<p>NDF 接受 <code>法向量</code>、<code>半程向量</code>、<code>粗糙度</code> 为参数，返回一个 float 值。这里我们使用 Trowbridge-Reitz GGX：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/trowbridge-reitz-ggx.png\" alt=\"trowbridge-reitz-ggx\"></p>\n<p>在公式中 h 表示我们的半程向量，而 α 表示表面的粗糙度。</p>\n<p>当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF 最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与 h 向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ndf.png\" alt=\"roughness\"></p>\n<p>它的 GLSL 代码实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> D_GGX_TR(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> H, <span class=\"type\">float</span> a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> a2     = a*a;</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH  = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, H), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH2 = NdotH*NdotH;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> nom    = a2;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom  = (NdotH2 * (a2 - <span class=\"number\">1.0</span>) + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    denom        = PI * denom * denom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几何函数\"><a href=\"#几何函数\" class=\"headerlink\" title=\"几何函数\"></a>几何函数</h3><p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量，最终导致材质表面整体显得更加灰暗。</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/geometry-shadowing.png\" alt=\"geometry-shadowing\"></p>\n<p>它接受 <code>观察方向向量</code>、<code>光线方向向量</code>、<code>法向量</code>、<code>粗糙度</code> 作为输入，最终返回一个 float 值。粗糙度越高的表面其微平面间相互遮蔽的概率就越高，这个 float 值就越小，这里我们使用 GGX 与 Schlick-Beckmann <code>近似</code> 的结合体，即 Schlick-GGX：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/schlick-ggx.png\" alt=\"schlick-ggx\"></p>\n<p>这里 k 是 α 的 <code>重映射</code>，取决于我们要使用的是针对直接光照还是针对 IBL 光照的几何函数，我们暂时只介绍直接光照的重映射：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/direct-remapping.png\" alt=\"direct-remapping\"></p>\n<p>材质表面自成阴影的分布情况同时和 <code>观察方向</code> 与 <code>光线方向</code> 有关，在刚才那张微平面的图中，我们可以注意到有些光线因为我们的观察方向比较特别而形成遮挡，我们称之为 <code>几何遮蔽(Geometry Obstruction)</code>，有些则和我们的观察方向无关，光线入射进来的时候就已经被遮挡了，我们称之为 <code>几何阴影(Geometry Shadowing)</code>。为了同时考虑二者的影响，我们使用 <code>史密斯法</code> 来进行计算：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/smith-method.png\" alt=\"smith-method\"></p>\n<p>其中，Gsub 即为我们的 Schlick-GGX，如此计算，随着粗糙度的提高，材质表面的视觉效果如下：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/geometry.png\" alt=\"geometry\"></p>\n<p>使用 GLSL 编写的实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> GeometrySchlickGGX(<span class=\"type\">float</span> NdotV, <span class=\"type\">float</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> nom   = NdotV;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom = NdotV * (<span class=\"number\">1.0</span> - k) + k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> GeometrySmith(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> V, <span class=\"type\">vec3</span> L, <span class=\"type\">float</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, V), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx1 = GeometrySchlickGGX(NdotV, k);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx2 = GeometrySchlickGGX(NdotL, k);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ggx1 * ggx2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菲涅尔方程\"><a href=\"#菲涅尔方程\" class=\"headerlink\" title=\"菲涅尔方程\"></a>菲涅尔方程</h3><p>菲涅尔方程描述的是被反射的光线对比被折射的光线的比率，这个比率会随着我们观察角度的不同而不同。我们正是利用这个方程计算出 <code>反射光线(fs)</code> 的部分，并进一步得到光线剩余的能量计算出 <code>折射光线(fd)</code> 的部分。它会影响我们看到的 specular 部分的颜色和强度，接下来请看原理。</p>\n<p>当垂直观察时，任何材质表面都有一个 <code>基础反射率</code>，但是我们的观察角度慢慢与材质表面趋近于平行时，所有反光都会变得明显起来。想象一下，如果你站在湖边低头看脚下的水，你会发现水是透明的，反射并不强烈；如果你看远处的湖面，你会发现它们的反射特别强烈。如果从理想的 90° 进行观察，理论上所有平面都能完全反射光线。这种现象体现在了菲涅尔方程里，不过它的本体过于复杂，好在我们可以用 <code>Fresnel-Schlick</code> 近似法求得近似解：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/fresnel-schlick.png\" alt=\"fresnel-schlick\"></p>\n<p>这个方程接受 <code>F0 (color)</code>、<code>观察方向向量</code>、<code>半程向量</code> 作为输入，最后返回一个 vec3 颜色值。其中，F0 表示垂直观察一个材质表面时的反射率，即基础反射率，它是一个颜色值，它可以通过材质的 <code>折射率</code> 预计算得出。经过这个方程的计算后，我们观察一个球体表面时可以注意到，我们越是朝球体边缘上看，反光越强：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/fresnel.png\" alt=\"fresnel\"></p>\n<p>那为什么 F0 是一个 color 值而不是一个 float 值呢？你可以在现实中进行观察，对于非金属表面，它的高光是灯光的颜色，但如果是金属表面的话，它的高光会带一点它本来的颜色。比如对于黄金的话，它的高光也是金色的。</p>\n<p>那么，既然说到 F0 应该进行预计算，那么我们应该怎么算呢？对于非金属材质，我们可以使用这个公式：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/calculate-reflectivity.png\" alt=\"calculate-reflectivity\"></p>\n<p>之所以可以用它来计算，是因为这里忽略掉了非金属材质的 <code>消光系数</code>，因为它相当小，而金属材质的消光系数是不能忽略的。</p>\n<p>那这意味着我们要对金属和非金属使用两套不同的公式来预计算出其 F0 吗？这有点麻烦，所以让我们来观察一下不同材质的基础反射率：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/material-base-reflectivity.png\" alt=\"material-base-reflectivity\"></p>\n<p>在这里可以看到，所有非金属材质表面的基础反射率都不会高于 0.17，这实际上是<code>例外情况</code>而非普遍情况，对于它们，我们可以用 (0.04, 0.04, 0.04) 就可以得到足够好的结果了。然后，对于金属材质，我们需要添加一点其表面的纹理颜色来补充，这是因为金属表面会吸收所有的折射光线而没有漫反射，我们一般是这样实现的：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> F0 = <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>);</span><br><span class=\"line\">F0      = <span class=\"built_in\">mix</span>(F0, surfaceColor.rgb, metalness);</span><br></pre></td></tr></table></figure>\n\n<p>这里引入了一个新的值，即 <code>金属度(metalness)</code>，用于描述一个材质表面是金属还是非金属的，也就是，它的 specular 是否带有原本材质的颜色。</p>\n<p>理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在 0.0 至 1.0 之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙&#x2F;沙状粒子&#x2F;刮痕的金属表面。通过对这些小的类非金属粒子&#x2F;刮痕调整金属度值，我们可以获得非常好看的视觉效果。</p>\n<p>最后把我们插值得到的 F0 输入到 Fresnel-Schlick 的函数中即可，它的代码实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> SchlickFresnel(<span class=\"type\">float</span> HdotV, <span class=\"type\">vec3</span> F0)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> m = <span class=\"built_in\">clamp</span>(<span class=\"number\">1</span> - HdotV, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> m2 = m * m;</span><br><span class=\"line\">    <span class=\"type\">float</span> m5 = m2 * m2 * m; <span class=\"comment\">// pow(m,5)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> F0 + (<span class=\"number\">1.0</span> - F0) * m5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"PBR-工作流\"><a href=\"#PBR-工作流\" class=\"headerlink\" title=\"PBR 工作流\"></a>PBR 工作流</h1><p>在得到 BRDF 后，我们就已经可以计算 PBR 了，可以暂时不用在意 <code>渲染方程</code> 的存在。</p>\n<p>在我们实际的工作流中，这些材质的参数是通过纹理输入进来的，使用纹理我们可以逐个片段的来控制每个表面上特定的点对于光线是如何相应的。</p>\n<p>下面是一个比较经典的 PBR 渲染管线的纹理列表，还有它最终的视觉输出：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/textures.png\" alt=\"textures\"></p>\n<p>其中，从左到右：</p>\n<ul>\n<li><p>反照率(Albedo)：指定材质的 <code>表面颜色</code> 或 <code>基础反射率</code>，这和我们之前使用的漫反射纹理很像，但漫反射的图像中常常包含一些细小的阴影和裂纹，而在 PBR 中这些东西会保存在别的纹理中。</p>\n</li>\n<li><p>法线(Normal)：详见 LearnOpenGL 的 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">法线贴图</a>，它可以逐片段指定独特的法线制造出起伏不平的假象，在模型的定点数较低的情况下丰富细节。</p>\n</li>\n<li><p>金属度(Metallic)：指定该纹素是否是金属质地的，根据引擎设置的不同，美术师可以将其编写为灰度值或1、0这样的二元值。</p>\n</li>\n<li><p>粗糙度(Roughness)：指定某一个纹素有多粗糙，有些引擎采用的是 <code>光滑度(Smoothness)</code> 贴图，在采样时用 (1.0 - smoothness) 后就可以转换为粗糙度了。</p>\n</li>\n<li><p>环境光遮罩(Ambient Occlusion)：指定了一个额外的阴影因子，反照率纹理上砖块的裂缝部分没有任何阴影信息，而 AO 贴图就会把它们指定出来。</p>\n</li>\n</ul>\n<p>这个 AO 并没有在前面提到过，在实现中，它并不在 BRDF 的计算中进行，目前直接光照的值都会累加在 <code>Lo</code> 中，而最后的颜色值是这样计算的：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> ambient = <span class=\"type\">vec3</span>(<span class=\"number\">0.03</span>) * albedo * ao;</span><br><span class=\"line\"><span class=\"type\">vec3</span> color = ambient + Lo;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们暂时使用 0.03 来表示环境光的强度，而想要得到更好的视觉效果，就需要看之后说到的 IBL 了。</p>\n<h1 id=\"PBR-应用代码\"><a href=\"#PBR-应用代码\" class=\"headerlink\" title=\"PBR 应用代码\"></a>PBR 应用代码</h1><p>刚才在介绍 BRDF 时博主贴出了 Phone 模型的代码，那么接下来我们来看看 PBR 的片段着色器中代码是什么样子的，接下来，我们假设场景中有四个灯光：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> ReflectanceEquation(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> V, <span class=\"type\">vec3</span> L, <span class=\"type\">vec3</span> albedo, <span class=\"type\">vec3</span> radiance, <span class=\"type\">float</span> roughness, <span class=\"type\">float</span> metallic)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    roughness = <span class=\"built_in\">max</span>(roughness, <span class=\"number\">0.05</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> H = <span class=\"built_in\">normalize</span>(L + V);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, V), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, H), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> HdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(H, V), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> F0 = <span class=\"built_in\">mix</span>(<span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>), albedo, metallic);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> D = DistributionGGX(NdotH, roughness);</span><br><span class=\"line\">    <span class=\"type\">float</span> F = FresnelSchlick(NdotV, F0);</span><br><span class=\"line\">    <span class=\"type\">float</span> G = GeometrySmith(NdotV, NdotL, roughness);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> k_s = F;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> k_d = (<span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>) - k_s) * (<span class=\"number\">1.0</span> - metallic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> f_diffuse = albedo / PI;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> f_specular = (D * F * G) / (<span class=\"number\">4.0</span> * NdotV * NdotL + <span class=\"number\">0.0001</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (k_d * f_diffuse + f_specular) * radiance * NdotL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;\t\t</span><br><span class=\"line\">    <span class=\"type\">vec3</span> albedo     = <span class=\"built_in\">pow</span>(<span class=\"built_in\">texture</span>(albedoMap, TexCoords).rgb, <span class=\"type\">vec3</span>(<span class=\"number\">2.2</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> metallic  = <span class=\"built_in\">texture</span>(metallicMap, TexCoords).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> roughness = <span class=\"built_in\">texture</span>(roughnessMap, TexCoords).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> ao        = <span class=\"built_in\">texture</span>(aoMap, TexCoords).r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> N = GetNormalFromMap();</span><br><span class=\"line\">    <span class=\"type\">vec3</span> V = <span class=\"built_in\">normalize</span>(camPos - WorldPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 </span></span><br><span class=\"line\">    <span class=\"comment\">// of 0.04 and if it&#x27;s a metal, use the albedo color as F0 (metallic workflow)    </span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> F0 = <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>); </span><br><span class=\"line\">    F0 = <span class=\"built_in\">mix</span>(F0, albedo, metallic);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reflectance equation</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> Lo = <span class=\"type\">vec3</span>(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">vec3</span> radiance = lightColors[i];</span><br><span class=\"line\">        <span class=\"type\">vec3</span> L = <span class=\"built_in\">normalize</span>(lightPositions[i] - WorldPos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// calculate per-light attenuation</span></span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(lightPositions[i] - WorldPos);</span><br><span class=\"line\">        <span class=\"type\">float</span> attenuation = <span class=\"number\">1.0</span> / (<span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Lo += ReflectanceEquation(N, V, L, albedo, radiance, roughness, metallic) * attenuation;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ambient lighting (note that the next IBL tutorial will replace </span></span><br><span class=\"line\">    <span class=\"comment\">// this ambient lighting with environment lighting).</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> ambient = <span class=\"type\">vec3</span>(<span class=\"number\">0.03</span>) * albedo * ao;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> color = ambient + Lo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// HDR tonemapping</span></span><br><span class=\"line\">    color = color / (color + <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>));</span><br><span class=\"line\">    <span class=\"comment\">// gamma correct</span></span><br><span class=\"line\">    color = <span class=\"built_in\">pow</span>(color, <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>/<span class=\"number\">2.2</span>)); </span><br><span class=\"line\"></span><br><span class=\"line\">    FragColor = <span class=\"type\">vec4</span>(color, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这份代码中我们在场景中添加了四个点光源，并且根据距离计算了它的衰减。</p>\n<p>把反射率方程 ReflectanceEquation 封装好之后，这份代码实际上和 Phone 看起来就会比较像了，不过需要注意一下结尾的把结果映射到 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/\">HDR</a> 和 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/\">伽马矫正</a> 的步骤，在这里不做过多赘述。 </p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>其实可以看到，PBR 最重要的东西便在于它的这个 BRDF，我们除了可以使用 Metallic-Roughness 来描述材质以外，行业内比较主流的方案还有 Specular-Glossiness 材质，这两种方案各有优缺点。实际上，只要愿意，我们可以用各种各样的参数去定义一个材质的属性，不过，迪士尼曾就这件事提出了它们自己的原则，即 Disney Principled BRDF，内容如下：</p>\n<ul>\n<li>应使用直观的参数，而不是物理类的晦涩参数（更符合艺术家的直觉）</li>\n<li>参数应尽可能少</li>\n<li>参数在其合理范围内应该为 0 到 1</li>\n<li>允许参数在有意义时超出正常的合理范围</li>\n<li>所有参数组合应尽可能健壮和合理</li>\n</ul>\n<p>以这些理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了一个颜色参数 (baseColor) 和下面描述的十个标量参数：</p>\n<ul>\n<li>baseColor（固有色）：表面颜色，通常由纹理贴图提供。</li>\n<li>subsurface（次表面）：使用次表面近似控制漫反射形状。</li>\n<li>metallic（金属度）：金属（0 &#x3D; 电介质，1 &#x3D;金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。</li>\n<li>specular（镜面反射强度）：入射镜面反射量。用于取代折射率。</li>\n<li>specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（basecolor）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。</li>\n<li>roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。</li>\n<li>anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 &#x3D;各向同性，1 &#x3D;最大各向异性。）</li>\n<li>sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。</li>\n<li>sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。</li>\n<li>clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。</li>\n<li>clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 &#x3D; “缎面（satin）”外观，1 &#x3D; “光泽（gloss）”外观。</li>\n</ul>\n<p><img src=\"/articles/hszSoft/pbr-theory/disney-principled-brdf.png\" alt=\"disney-principled-brdf\"></p>\n<h1 id=\"引用文章\"><a href=\"#引用文章\" class=\"headerlink\" title=\"引用文章\"></a>引用文章</h1><p>LearnOpenGL PBR 理论<br><a href=\"https://learnopengl-cn.github.io/07%20PBR/01%20Theory/\">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></p>\n<p>LearnOpenGL PBR 光照<br><a href=\"https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/\">https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/</a></p>\n<p>菲涅尔方程（Fresnel Equation）<br><a href=\"https://zhuanlan.zhihu.com/p/375746359\">https://zhuanlan.zhihu.com/p/375746359</a></p>\n<p>草履虫都能看懂的 PBR 讲解<br><a href=\"https://zhuanlan.zhihu.com/p/137013668\">https://zhuanlan.zhihu.com/p/137013668</a></p>\n<p>几何光学下的光线传播——光的反射、折射、菲涅耳公式<br><a href=\"https://zhuanlan.zhihu.com/p/480405520\">https://zhuanlan.zhihu.com/p/480405520</a></p>\n<p>基于物理的渲染（PBR）白皮书 | 迪士尼原则的BRDF与BSDF相关总结<br><a href=\"https://cloud.tencent.com/developer/article/1427571\">https://cloud.tencent.com/developer/article/1427571</a></p>\n","site":{"data":{}},"excerpt":"<p>欢迎大家关注原文作者 hsz！原文地址：<a href=\"https://www.hszsoft.com/2024/04/30/pbr-theory/\">https://www.hszsoft.com/2024/04/30/pbr-theory/</a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>PBR(Physically Based Rendering)，基于物理的渲染，指的是一些基于现实的物理原理所构成的渲染技术的集合，而非单一的某一种光照算法。</p>\n<p>本文主要依据 LearnOpenGL 上的 PBR 理论篇，但在其中文版文章中有一些翻译问题，并且在理解上有一定难度，博主在这里对其进行了一定的简化。</p>","more":"<h1 id=\"为什么需要-PBR\"><a href=\"#为什么需要-PBR\" class=\"headerlink\" title=\"为什么需要 PBR\"></a>为什么需要 PBR</h1><p>我们为什么需要 PBR？回想我一下们在 Phone 算法中的材质：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Material &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> ambient;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> diffuse;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> specular;    </span><br><span class=\"line\">    <span class=\"type\">float</span> shininess;</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>LearnOpenGL 的作者给出了一些 <a href=\"http://devernay.free.fr/cours/opengl/materials.html\">特定的数据</a> 让你调整出想要的材质的感觉。这四个参数非常不直观，它们为什么是这些值？</p>\n<p>我们需要一套新的 <code>描述材质</code> 参数，它的含义应该符合人的直觉，诸如 <code>粗糙度</code>、<code>金属度</code> 这样的参数。这些参数望文生义，我们很容易就能想象出来随着它的变化，材质应该会变成什么样。</p>\n<p>粗糙度慢慢变大的话，它会表现的像下面这个样子：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/roughness.gif\" alt=\"roughness\"></p>\n<p>金属度慢慢变大的话，它会表现的像下面这个样子：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/metallic.gif\" alt=\"metallic\"></p>\n<p>就粗糙度的变化而言的话，我们已经可以想象出来，粗糙度越大，specular 和 shininess 都会相应地减小，diffuse 也会有相应的变化。那么，这里应该有一些处理 diffuse 和 specular 随着粗糙度的值的变化而变化的公式。这些公式的是怎么来的？</p>\n<p><code>基于</code> 物理而来，我之所以要强调这个词，是因为现代计算机的算力有限，我们无法完全按照现实生活的物理公式来计算的。我们要讨论的算法得到的都是一些近似结果，但它们有着非常高的效率。</p>\n<h1 id=\"PBR-理论\"><a href=\"#PBR-理论\" class=\"headerlink\" title=\"PBR 理论\"></a>PBR 理论</h1><p>前面提到过 PBR 并非一种单一的光照算法，根据其实现的不同，它有很多种 <code>工作流</code>（在输入参数上有区别），比较常用的有金属&#x2F;粗糙度(Metal&#x2F;Roughness)工作流和镜面反射&#x2F;光泽度(Specular&#x2F;Glossiness)工作流。</p>\n<p>不管如何，它们都要满足下面这些条件：</p>\n<ul>\n<li>基于微平面的表面模型</li>\n<li>能量守恒</li>\n<li>应用基于物理的双向反射分布函数</li>\n</ul>\n<p>博主的这篇文章会对金属&#x2F;粗糙度(Metal&#x2F;Roughness)工作流进行讲解。</p>\n<h2 id=\"微平面理论-Microfacets-Theory\"><a href=\"#微平面理论-Microfacets-Theory\" class=\"headerlink\" title=\"微平面理论 (Microfacets Theory)\"></a>微平面理论 (Microfacets Theory)</h2><p>这个理论认为没有平面是完全光滑的。由于微平面微小到无法用像素级别的量级对其进行区分，因此我们可以假设一个 Roughness(粗糙度) 参数，用 <code>统计学</code> 的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着 <code>半程向量</code> 方向的比例。</p>\n<p>粗糙度介于 0 到 1，刚才我们看到的变化类似于这样：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ndf.png\" alt=\"roughness\"></p>\n<h2 id=\"能量守恒-Energy-Conservation\"><a href=\"#能量守恒-Energy-Conservation\" class=\"headerlink\" title=\"能量守恒 (Energy Conservation)\"></a>能量守恒 (Energy Conservation)</h2><p>出射光线的能量永远不能超过入射光线的能量（发光面除外）。随着粗糙度的上升，镜面反射区域会变大，反射亮度会下降。如果每个像素的镜面反射强度都一样，就违背了这个定律。这也是刚才我们看到的光滑平面的反射更强烈而粗糙平面的反射更昏暗的原因。</p>\n<p>当一束光碰到一个表面时，会分离成 <code>反射</code> 部分和 <code>折射</code> 部分。反射部分就是我们常说的镜面(Specular)光照，而折射部分就是我们所说的漫反射(Diffuse)光照。为什么折射部分是漫反射光照呢？因为我们这里做了个假设，折射光进入物体后的情况会很复杂，它会像这样：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/surface-reaction.png\" alt=\"surface_reaction\"></p>\n<p>我们只考虑在物体的表面附近反射出来的，它们也就构成了漫反射光。对于那些深入了物体表面的部分，我们假设它们全部被吸收。现实的情况是确实有一部分光可能会在比较远的比方再次反射出来，一些被称为 <code>次表面散射(Subsurface Scattering)技术</code> 的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。</p>\n<p>那我们不难想出，反射和折射二者是 <code>互斥</code> 的关系，所以一般会有以下的计算：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> kS = calculateSpecularComponent(...); <span class=\"comment\">// 反射/镜面部分</span></span><br><span class=\"line\"><span class=\"type\">float</span> kD = <span class=\"number\">1.0</span> - ks;                        <span class=\"comment\">// 折射/漫反射部分</span></span><br></pre></td></tr></table></figure>\n\n<p>不过，对于 <code>金属</code> 表面，所有的折射光都会被直接吸收而不会散开，只留下镜面反射光。金属度越高的表面，其原本的颜色越少，周围环境的颜色越多，所以会增加一点东西：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> kS = calculateSpecularComponent(...);</span><br><span class=\"line\">float3 k_d = (<span class=\"number\">1.0</span> - k_s) * (<span class=\"number\">1.0</span> - metallic);</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，接下来就可以看看这两个理论是如何被应用的了。</p>\n<h2 id=\"双向反射分布函数-BRDF\"><a href=\"#双向反射分布函数-BRDF\" class=\"headerlink\" title=\"双向反射分布函数 (BRDF)\"></a>双向反射分布函数 (BRDF)</h2><p>这个名字看着非常高上大，并且是 PBR 的核心，让我们来慢慢理解。</p>\n<p>首先，BRDF 是一个函数，它接受 <code>入射光方向向量</code>、<code>出射光方向向量</code> 作为输入，所以是 <code>双向</code>，实际上还有法向量 n，不过在公式中我们一般认为它是已知的。然后，它接受我们刚才说的 <code>粗糙度</code> 和 <code>金属度</code> 之类的参数，最后返回这束光线对这个片段贡献的 RGB 颜色。在使用中，我们在片段着色器中遍历会影响到这个片段的灯光，并且将其值累加起来。</p>\n<blockquote>\n<p>不过法向量 n 的计算实际上还是比较麻烦的，它需要计算切线空间，详细内容可以看 LearnOpenGL 中的 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">法线贴图</a>。</p>\n</blockquote>\n<p>不难发现，其实 Phone 模型就是一个 BRDF，不过问题在于它并不遵循物理规则。回想一下我们在 <a href=\"https://learnopengl-cn.github.io/02%20Lighting/06%20Multiple%20lights/\">多光源</a> 中的代码：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">    <span class=\"comment\">// properties</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> norm = <span class=\"built_in\">normalize</span>(Normal);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> viewDir = <span class=\"built_in\">normalize</span>(viewPos - FragPos);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// phase 1: directional lighting</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class=\"line\">    <span class=\"comment\">// phase 2: point lights</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class=\"line\">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    </span><br><span class=\"line\">    <span class=\"comment\">// phase 3: spot light</span></span><br><span class=\"line\">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span><br><span class=\"line\">    </span><br><span class=\"line\">    FragColor = <span class=\"type\">vec4</span>(result, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>CalDirLight</code>、<code>CalPointLight</code>、<code>CalSpotLight</code> 都是 BRDF，我们之前直接通过累加来计算其贡献值，PBR 中我们计算也是靠这样进行累加。这里其实有 <code>积分</code> 的行为，不过现在暂时不用了解，我们会在后面的 <code>IBL</code> 中讲解它（反射率方程），而现在只需要知道正是因为积分，所以公式中会存在 <code>标准化</code> 的步骤。</p>\n<p>现在我们需要一个遵循物理规则的 BRDF，这也有很多种实现，我们可以使用一种被称为 <code>Cook-Torrance BRDF</code> 的模型。Cook-Torrance BRDF 兼有漫反射和镜面反射两个部分：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ct-brdf.png\" alt=\"brdf\"></p>\n<p>公式的左侧表示的是 lambertian 反射，用于表示漫反射的部分，用如下公式来表示：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/lambertian.png\" alt=\"lambertian\"></p>\n<p>lambertian 中的 c 表示材质表面颜色，在我们的工作流中对应着 albedo 纹理，除以 π 是为了对漫反射光进行 <code>标准化</code>。</p>\n<p>公式的右侧是其镜面反射的部分，它的形式如下：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/cook-torrance.png\" alt=\"cook-torrance\"></p>\n<p>和前面一样，分母依旧是用来进行 <code>标准化</code> 的。这里的字母 D、F、G 分别代表法线分布函数(Normal <code>D</code>istribution Function)，菲涅尔方程(<code>F</code>resnel Rquation)和几何函数(<code>G</code>eometry Function)。</p>\n<ul>\n<li><p><code>法线分布函数</code>：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。</p>\n</li>\n<li><p><code>几何函数</code>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</p>\n</li>\n<li><p><code>菲涅尔方程</code>：菲涅尔方程描述的是在不同的观察角度下被反射的光线所占的百分比。它一般就等于 Cook-Torrance BRDF 中的那个 kd。</p>\n</li>\n</ul>\n<p>在我们的实现中，前两者通过 <code>粗糙度</code> 计算出一个 float 值，而菲涅尔方程主要通过 <code>金属度</code> 计算出一个类型为 vec3 的颜色值。</p>\n<h3 id=\"法线分布函数\"><a href=\"#法线分布函数\" class=\"headerlink\" title=\"法线分布函数\"></a>法线分布函数</h3><p>法线分布函数从统计学上近似表示材质表面法向量与半程向量取向一致的比率。目前有很多种 NDF 都可以根据一些粗糙度参数估算微平面的总体取向度。</p>\n<p>NDF 接受 <code>法向量</code>、<code>半程向量</code>、<code>粗糙度</code> 为参数，返回一个 float 值。这里我们使用 Trowbridge-Reitz GGX：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/trowbridge-reitz-ggx.png\" alt=\"trowbridge-reitz-ggx\"></p>\n<p>在公式中 h 表示我们的半程向量，而 α 表示表面的粗糙度。</p>\n<p>当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF 最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与 h 向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/ndf.png\" alt=\"roughness\"></p>\n<p>它的 GLSL 代码实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> D_GGX_TR(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> H, <span class=\"type\">float</span> a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> a2     = a*a;</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH  = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, H), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH2 = NdotH*NdotH;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> nom    = a2;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom  = (NdotH2 * (a2 - <span class=\"number\">1.0</span>) + <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    denom        = PI * denom * denom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"几何函数\"><a href=\"#几何函数\" class=\"headerlink\" title=\"几何函数\"></a>几何函数</h3><p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量，最终导致材质表面整体显得更加灰暗。</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/geometry-shadowing.png\" alt=\"geometry-shadowing\"></p>\n<p>它接受 <code>观察方向向量</code>、<code>光线方向向量</code>、<code>法向量</code>、<code>粗糙度</code> 作为输入，最终返回一个 float 值。粗糙度越高的表面其微平面间相互遮蔽的概率就越高，这个 float 值就越小，这里我们使用 GGX 与 Schlick-Beckmann <code>近似</code> 的结合体，即 Schlick-GGX：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/schlick-ggx.png\" alt=\"schlick-ggx\"></p>\n<p>这里 k 是 α 的 <code>重映射</code>，取决于我们要使用的是针对直接光照还是针对 IBL 光照的几何函数，我们暂时只介绍直接光照的重映射：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/direct-remapping.png\" alt=\"direct-remapping\"></p>\n<p>材质表面自成阴影的分布情况同时和 <code>观察方向</code> 与 <code>光线方向</code> 有关，在刚才那张微平面的图中，我们可以注意到有些光线因为我们的观察方向比较特别而形成遮挡，我们称之为 <code>几何遮蔽(Geometry Obstruction)</code>，有些则和我们的观察方向无关，光线入射进来的时候就已经被遮挡了，我们称之为 <code>几何阴影(Geometry Shadowing)</code>。为了同时考虑二者的影响，我们使用 <code>史密斯法</code> 来进行计算：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/smith-method.png\" alt=\"smith-method\"></p>\n<p>其中，Gsub 即为我们的 Schlick-GGX，如此计算，随着粗糙度的提高，材质表面的视觉效果如下：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/geometry.png\" alt=\"geometry\"></p>\n<p>使用 GLSL 编写的实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> GeometrySchlickGGX(<span class=\"type\">float</span> NdotV, <span class=\"type\">float</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> nom   = NdotV;</span><br><span class=\"line\">    <span class=\"type\">float</span> denom = NdotV * (<span class=\"number\">1.0</span> - k) + k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nom / denom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> GeometrySmith(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> V, <span class=\"type\">vec3</span> L, <span class=\"type\">float</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, V), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx1 = GeometrySchlickGGX(NdotV, k);</span><br><span class=\"line\">    <span class=\"type\">float</span> ggx2 = GeometrySchlickGGX(NdotL, k);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ggx1 * ggx2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菲涅尔方程\"><a href=\"#菲涅尔方程\" class=\"headerlink\" title=\"菲涅尔方程\"></a>菲涅尔方程</h3><p>菲涅尔方程描述的是被反射的光线对比被折射的光线的比率，这个比率会随着我们观察角度的不同而不同。我们正是利用这个方程计算出 <code>反射光线(fs)</code> 的部分，并进一步得到光线剩余的能量计算出 <code>折射光线(fd)</code> 的部分。它会影响我们看到的 specular 部分的颜色和强度，接下来请看原理。</p>\n<p>当垂直观察时，任何材质表面都有一个 <code>基础反射率</code>，但是我们的观察角度慢慢与材质表面趋近于平行时，所有反光都会变得明显起来。想象一下，如果你站在湖边低头看脚下的水，你会发现水是透明的，反射并不强烈；如果你看远处的湖面，你会发现它们的反射特别强烈。如果从理想的 90° 进行观察，理论上所有平面都能完全反射光线。这种现象体现在了菲涅尔方程里，不过它的本体过于复杂，好在我们可以用 <code>Fresnel-Schlick</code> 近似法求得近似解：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/fresnel-schlick.png\" alt=\"fresnel-schlick\"></p>\n<p>这个方程接受 <code>F0 (color)</code>、<code>观察方向向量</code>、<code>半程向量</code> 作为输入，最后返回一个 vec3 颜色值。其中，F0 表示垂直观察一个材质表面时的反射率，即基础反射率，它是一个颜色值，它可以通过材质的 <code>折射率</code> 预计算得出。经过这个方程的计算后，我们观察一个球体表面时可以注意到，我们越是朝球体边缘上看，反光越强：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/fresnel.png\" alt=\"fresnel\"></p>\n<p>那为什么 F0 是一个 color 值而不是一个 float 值呢？你可以在现实中进行观察，对于非金属表面，它的高光是灯光的颜色，但如果是金属表面的话，它的高光会带一点它本来的颜色。比如对于黄金的话，它的高光也是金色的。</p>\n<p>那么，既然说到 F0 应该进行预计算，那么我们应该怎么算呢？对于非金属材质，我们可以使用这个公式：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/calculate-reflectivity.png\" alt=\"calculate-reflectivity\"></p>\n<p>之所以可以用它来计算，是因为这里忽略掉了非金属材质的 <code>消光系数</code>，因为它相当小，而金属材质的消光系数是不能忽略的。</p>\n<p>那这意味着我们要对金属和非金属使用两套不同的公式来预计算出其 F0 吗？这有点麻烦，所以让我们来观察一下不同材质的基础反射率：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/material-base-reflectivity.png\" alt=\"material-base-reflectivity\"></p>\n<p>在这里可以看到，所有非金属材质表面的基础反射率都不会高于 0.17，这实际上是<code>例外情况</code>而非普遍情况，对于它们，我们可以用 (0.04, 0.04, 0.04) 就可以得到足够好的结果了。然后，对于金属材质，我们需要添加一点其表面的纹理颜色来补充，这是因为金属表面会吸收所有的折射光线而没有漫反射，我们一般是这样实现的：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> F0 = <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>);</span><br><span class=\"line\">F0      = <span class=\"built_in\">mix</span>(F0, surfaceColor.rgb, metalness);</span><br></pre></td></tr></table></figure>\n\n<p>这里引入了一个新的值，即 <code>金属度(metalness)</code>，用于描述一个材质表面是金属还是非金属的，也就是，它的 specular 是否带有原本材质的颜色。</p>\n<p>理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在 0.0 至 1.0 之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙&#x2F;沙状粒子&#x2F;刮痕的金属表面。通过对这些小的类非金属粒子&#x2F;刮痕调整金属度值，我们可以获得非常好看的视觉效果。</p>\n<p>最后把我们插值得到的 F0 输入到 Fresnel-Schlick 的函数中即可，它的代码实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> SchlickFresnel(<span class=\"type\">float</span> HdotV, <span class=\"type\">vec3</span> F0)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> m = <span class=\"built_in\">clamp</span>(<span class=\"number\">1</span> - HdotV, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> m2 = m * m;</span><br><span class=\"line\">    <span class=\"type\">float</span> m5 = m2 * m2 * m; <span class=\"comment\">// pow(m,5)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> F0 + (<span class=\"number\">1.0</span> - F0) * m5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"PBR-工作流\"><a href=\"#PBR-工作流\" class=\"headerlink\" title=\"PBR 工作流\"></a>PBR 工作流</h1><p>在得到 BRDF 后，我们就已经可以计算 PBR 了，可以暂时不用在意 <code>渲染方程</code> 的存在。</p>\n<p>在我们实际的工作流中，这些材质的参数是通过纹理输入进来的，使用纹理我们可以逐个片段的来控制每个表面上特定的点对于光线是如何相应的。</p>\n<p>下面是一个比较经典的 PBR 渲染管线的纹理列表，还有它最终的视觉输出：</p>\n<p><img src=\"/articles/hszSoft/pbr-theory/textures.png\" alt=\"textures\"></p>\n<p>其中，从左到右：</p>\n<ul>\n<li><p>反照率(Albedo)：指定材质的 <code>表面颜色</code> 或 <code>基础反射率</code>，这和我们之前使用的漫反射纹理很像，但漫反射的图像中常常包含一些细小的阴影和裂纹，而在 PBR 中这些东西会保存在别的纹理中。</p>\n</li>\n<li><p>法线(Normal)：详见 LearnOpenGL 的 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/\">法线贴图</a>，它可以逐片段指定独特的法线制造出起伏不平的假象，在模型的定点数较低的情况下丰富细节。</p>\n</li>\n<li><p>金属度(Metallic)：指定该纹素是否是金属质地的，根据引擎设置的不同，美术师可以将其编写为灰度值或1、0这样的二元值。</p>\n</li>\n<li><p>粗糙度(Roughness)：指定某一个纹素有多粗糙，有些引擎采用的是 <code>光滑度(Smoothness)</code> 贴图，在采样时用 (1.0 - smoothness) 后就可以转换为粗糙度了。</p>\n</li>\n<li><p>环境光遮罩(Ambient Occlusion)：指定了一个额外的阴影因子，反照率纹理上砖块的裂缝部分没有任何阴影信息，而 AO 贴图就会把它们指定出来。</p>\n</li>\n</ul>\n<p>这个 AO 并没有在前面提到过，在实现中，它并不在 BRDF 的计算中进行，目前直接光照的值都会累加在 <code>Lo</code> 中，而最后的颜色值是这样计算的：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> ambient = <span class=\"type\">vec3</span>(<span class=\"number\">0.03</span>) * albedo * ao;</span><br><span class=\"line\"><span class=\"type\">vec3</span> color = ambient + Lo;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们暂时使用 0.03 来表示环境光的强度，而想要得到更好的视觉效果，就需要看之后说到的 IBL 了。</p>\n<h1 id=\"PBR-应用代码\"><a href=\"#PBR-应用代码\" class=\"headerlink\" title=\"PBR 应用代码\"></a>PBR 应用代码</h1><p>刚才在介绍 BRDF 时博主贴出了 Phone 模型的代码，那么接下来我们来看看 PBR 的片段着色器中代码是什么样子的，接下来，我们假设场景中有四个灯光：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> ReflectanceEquation(<span class=\"type\">vec3</span> N, <span class=\"type\">vec3</span> V, <span class=\"type\">vec3</span> L, <span class=\"type\">vec3</span> albedo, <span class=\"type\">vec3</span> radiance, <span class=\"type\">float</span> roughness, <span class=\"type\">float</span> metallic)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    roughness = <span class=\"built_in\">max</span>(roughness, <span class=\"number\">0.05</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> H = <span class=\"built_in\">normalize</span>(L + V);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotL = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, L), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, V), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> NdotH = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(N, H), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> HdotV = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(H, V), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> F0 = <span class=\"built_in\">mix</span>(<span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>), albedo, metallic);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> D = DistributionGGX(NdotH, roughness);</span><br><span class=\"line\">    <span class=\"type\">float</span> F = FresnelSchlick(NdotV, F0);</span><br><span class=\"line\">    <span class=\"type\">float</span> G = GeometrySmith(NdotV, NdotL, roughness);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> k_s = F;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> k_d = (<span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>) - k_s) * (<span class=\"number\">1.0</span> - metallic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> f_diffuse = albedo / PI;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> f_specular = (D * F * G) / (<span class=\"number\">4.0</span> * NdotV * NdotL + <span class=\"number\">0.0001</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (k_d * f_diffuse + f_specular) * radiance * NdotL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;\t\t</span><br><span class=\"line\">    <span class=\"type\">vec3</span> albedo     = <span class=\"built_in\">pow</span>(<span class=\"built_in\">texture</span>(albedoMap, TexCoords).rgb, <span class=\"type\">vec3</span>(<span class=\"number\">2.2</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> metallic  = <span class=\"built_in\">texture</span>(metallicMap, TexCoords).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> roughness = <span class=\"built_in\">texture</span>(roughnessMap, TexCoords).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> ao        = <span class=\"built_in\">texture</span>(aoMap, TexCoords).r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vec3</span> N = GetNormalFromMap();</span><br><span class=\"line\">    <span class=\"type\">vec3</span> V = <span class=\"built_in\">normalize</span>(camPos - WorldPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 </span></span><br><span class=\"line\">    <span class=\"comment\">// of 0.04 and if it&#x27;s a metal, use the albedo color as F0 (metallic workflow)    </span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> F0 = <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>); </span><br><span class=\"line\">    F0 = <span class=\"built_in\">mix</span>(F0, albedo, metallic);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reflectance equation</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> Lo = <span class=\"type\">vec3</span>(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">vec3</span> radiance = lightColors[i];</span><br><span class=\"line\">        <span class=\"type\">vec3</span> L = <span class=\"built_in\">normalize</span>(lightPositions[i] - WorldPos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// calculate per-light attenuation</span></span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(lightPositions[i] - WorldPos);</span><br><span class=\"line\">        <span class=\"type\">float</span> attenuation = <span class=\"number\">1.0</span> / (<span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Lo += ReflectanceEquation(N, V, L, albedo, radiance, roughness, metallic) * attenuation;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ambient lighting (note that the next IBL tutorial will replace </span></span><br><span class=\"line\">    <span class=\"comment\">// this ambient lighting with environment lighting).</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> ambient = <span class=\"type\">vec3</span>(<span class=\"number\">0.03</span>) * albedo * ao;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> color = ambient + Lo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// HDR tonemapping</span></span><br><span class=\"line\">    color = color / (color + <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>));</span><br><span class=\"line\">    <span class=\"comment\">// gamma correct</span></span><br><span class=\"line\">    color = <span class=\"built_in\">pow</span>(color, <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>/<span class=\"number\">2.2</span>)); </span><br><span class=\"line\"></span><br><span class=\"line\">    FragColor = <span class=\"type\">vec4</span>(color, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这份代码中我们在场景中添加了四个点光源，并且根据距离计算了它的衰减。</p>\n<p>把反射率方程 ReflectanceEquation 封装好之后，这份代码实际上和 Phone 看起来就会比较像了，不过需要注意一下结尾的把结果映射到 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/\">HDR</a> 和 <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/\">伽马矫正</a> 的步骤，在这里不做过多赘述。 </p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>其实可以看到，PBR 最重要的东西便在于它的这个 BRDF，我们除了可以使用 Metallic-Roughness 来描述材质以外，行业内比较主流的方案还有 Specular-Glossiness 材质，这两种方案各有优缺点。实际上，只要愿意，我们可以用各种各样的参数去定义一个材质的属性，不过，迪士尼曾就这件事提出了它们自己的原则，即 Disney Principled BRDF，内容如下：</p>\n<ul>\n<li>应使用直观的参数，而不是物理类的晦涩参数（更符合艺术家的直觉）</li>\n<li>参数应尽可能少</li>\n<li>参数在其合理范围内应该为 0 到 1</li>\n<li>允许参数在有意义时超出正常的合理范围</li>\n<li>所有参数组合应尽可能健壮和合理</li>\n</ul>\n<p>以这些理念为基础，迪士尼动画工作室对每个参数的添加进行了把关，最终得到了一个颜色参数 (baseColor) 和下面描述的十个标量参数：</p>\n<ul>\n<li>baseColor（固有色）：表面颜色，通常由纹理贴图提供。</li>\n<li>subsurface（次表面）：使用次表面近似控制漫反射形状。</li>\n<li>metallic（金属度）：金属（0 &#x3D; 电介质，1 &#x3D;金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。</li>\n<li>specular（镜面反射强度）：入射镜面反射量。用于取代折射率。</li>\n<li>specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（basecolor）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。</li>\n<li>roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。</li>\n<li>anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 &#x3D;各向同性，1 &#x3D;最大各向异性。）</li>\n<li>sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。</li>\n<li>sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。</li>\n<li>clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。</li>\n<li>clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 &#x3D; “缎面（satin）”外观，1 &#x3D; “光泽（gloss）”外观。</li>\n</ul>\n<p><img src=\"/articles/hszSoft/pbr-theory/disney-principled-brdf.png\" alt=\"disney-principled-brdf\"></p>\n<h1 id=\"引用文章\"><a href=\"#引用文章\" class=\"headerlink\" title=\"引用文章\"></a>引用文章</h1><p>LearnOpenGL PBR 理论<br><a href=\"https://learnopengl-cn.github.io/07%20PBR/01%20Theory/\">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></p>\n<p>LearnOpenGL PBR 光照<br><a href=\"https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/\">https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/</a></p>\n<p>菲涅尔方程（Fresnel Equation）<br><a href=\"https://zhuanlan.zhihu.com/p/375746359\">https://zhuanlan.zhihu.com/p/375746359</a></p>\n<p>草履虫都能看懂的 PBR 讲解<br><a href=\"https://zhuanlan.zhihu.com/p/137013668\">https://zhuanlan.zhihu.com/p/137013668</a></p>\n<p>几何光学下的光线传播——光的反射、折射、菲涅耳公式<br><a href=\"https://zhuanlan.zhihu.com/p/480405520\">https://zhuanlan.zhihu.com/p/480405520</a></p>\n<p>基于物理的渲染（PBR）白皮书 | 迪士尼原则的BRDF与BSDF相关总结<br><a href=\"https://cloud.tencent.com/developer/article/1427571\">https://cloud.tencent.com/developer/article/1427571</a></p>"},{"title":"数据结构：常见排序算法解析","date":"2024-06-14T16:00:00.000Z","_content":"\n因为我经常忘记各种排序算法的思路，所以我写了这篇文章。文章中使用了结构体数组来完成排序，已经完成了快排、希尔等多种排序方法。其中，我采用了 `arr[0] = {}` 这样的方式来置空数组，并将其作为哨兵来使用。\n\n<!-- more -->\n\n## 排序算法\n\n（1）直接插入排序；\n（2）折半插入排序；\n（3）冒泡排序；\n（4）简单选择排序。\n（5）希尔排序；\n（6）快速排序。\n\n首先我先定义一下排序需要用到的...ababab\n\n```cpp\nstruct Student {\n    string name;\n    int score;\n};\n\n//打印排序后的数组\nvoid printStudents(const Student students[], int size) {\n    for(int i = 1; i < size; i++) {\n        cout << \"姓名：\" << students[i].name << \"  成绩：\" << students[i].score << endl;\n    }\n    cout << endl;\n}\n\n\nint main() {\n    Student students[] = {\n    {},\n    {\"aaa\", 87},\n    {\"bbb\", 76},\n    {\"ccc\", 92},\n    {\"ddd\", 64},\n    {\"eee\", 55},\n    {\"fff\", 78},\n    {\"ggg\", 100},\n    {\"hhh\", 43},\n    };\n \n    int size = sizeof(students) / sizeof(students[1]);\n    printStudents(students, size);\n \n// insert(students, size);\n// binary(students, size);\n// bubble(students, size);\n// selection(students, size);\n \n \n \n// quickSort(students, 1, size);\n// cout << \"快速排序：\" << endl;\n// printStudents(students, size);\n\n    shell(students, size, size); \n \n    return 0;\n}\n```\n\n***\n\n### 直接插入排序\n\n#### 算法步骤\n\n首先取第一个元素假设这个范围内有序（升序），\n接着扩大这个范围，由1到n,\n始终保持范围内有序，最终完成排序。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid insert(Student students[], int size) {\n\n    //这里假设前i-1个元素有序\n    for(int i = 2; i < size; i++) {\n    //中转变量，存储即将进入有序区域的数据\n\n        Student tmp = students[i];\n        int j = i-1;\n\n        //这里 j = 0 时，students[j].score > tmp.score 必定为false\n        while(j >= 0 && students[j].score > tmp.score) {\n            students[j + 1] = students[j];\n            j--;\n        }\n\n        students[j + 1] = tmp;\n    }\n   cout << \"直接插入排序：\" << endl;\n    printStudents(students, size);\n}\n```\n\n#### 算法分析\n\n##### a.算法性能\n\n时间复杂度：平均（O(n^2)）\n空间复杂度：额外空间复杂度是 ( O(1) )\n\n##### b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)\n\n直接插入排序是稳定的排序算法，因此如果原始数组中存在相同值的元素，在排序后它们的相对顺序不会改变。\n\n##### c.适用性\n\n相比较于其他 ( O(n^2) ) 的排序算法（如冒泡排序和选择排序），直接插入排序在一般情况下效率更高，特别是在数据部分有序的情况下。\n然而，对于大规模数据或需要快速排序的情况，更高效的排序算法（如快速排序、归并排序等 ( O(n \\log n) ) 的算法）更为合适。\n\n##### d.总结\n\n直接插入排序虽然简单，但其性能上不如快速排序等 ( O(n \\log n) ) 级别的排序算法。然而，它易于实现，在小规模数据或者数据接近有序时，可以是一个不错的选择。\n\n****\n### 折半插入排序算法\n#### 算法步骤\n\n折半插入排序与直接插入排序类似，但在寻找插入位置时采用了二分查找的方式，以提高查找插入位置的效率。\n\n```cpp\nvoid binary(Student students[], int size) {\n    for(int i = 2; i < size; i++) {\n        Student tmp = students[i];\n        int left = 1;\n        int right = i-1;\n\n        while(left <= right) {\n         //这样可以防止溢出，虽然这里用不到吧\n            int mid = left + (right - left) / 2;\n            if(students[mid].score > tmp.score) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n  //虽然这样查找的比较快，但是还是要遍历\n        for(int j = i; j > left; j--) {  \n            students[j] = students[j-1]; \n        }\n        students[left] = tmp;\n    }\n    cout << \"折半插入排序：\" << endl;\n    printStudents(students, size);\n}\n```\n\n#### 算法分析\n\n##### a. 算法性能\n\n时间复杂度：平均情况下 ( O(n^2) )，虽然查找插入位置的过程利用了二分查找，但插入操作仍然是 ( O(n) )。\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n折半插入排序同样是稳定的排序算法，相同元素的相对位置不会改变。\n\n##### c. 适用性\n\n折半插入排序适用于需要**稳定排序**且**对空间复杂度有要求**的场景，特别是**当直接插入排序在查找插入位置上效率较低**时，折半插入排序可以提供更好的性能。\n\n##### d. 总结\n\n折半插入排序相比直接插入排序，在查找插入位置时能够更快地定位，但整体的时间复杂度仍然是 ( O(n^2) )，因此对于大规模数据或需要更高效排序算法的情况，应考虑使用 ( O(n \\log n) ) 级别的排序算法，如快速排序或归并排序。\n\n****\n### 冒泡排序算法\n#### 算法步骤\n\n从第一个元素开始，依次比较相邻的两个元素，如果顺序不对则交换它们。\n继续对每一对相邻元素进行同样的操作，直到最后一个元素。\n重复以上步骤，每次都将未排序部分中最大的元素\"浮\"到最后，直到整个序列有序。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=2&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid bubble(Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tfor(int j = 1; j < size - i; j++) {\n\t\t\tif(students[j].score > students[j+1].score) {\n\t\t\t\tswap(students[j], students[j+1]);\n\t\t\t}\n\t\t}\n//\t\tprintStudents(students, size);\n\t}\n\tcout << \"冒泡排序：\" << endl;\n\tprintStudents(students, size);\n}\n\n```\n#### 算法分析\n\n##### a. 算法性能\n\n时间复杂度：O(n^2)\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n冒泡排序是稳定的排序算法。在比较相邻元素时，如果他们的值相等，则不进行交换，因此相等的元素在排序后的相对位置保持不变。\n##### c. 总结\n\n由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。\n\n****\n### 简单选择排序\n#### 算法步骤\n\n首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置\n然后，再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾\n以此类推，直到所有元素均排序完毕\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=3&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid selection(Student students[], int size) {\n\tfor(int i = 1; i < size - 1; i++) {\n\t\tint min_score = i;\n\t\tfor(int j = i+1; j < size; j++) {\n\t\t\tif(students[min_score].score > students[j].score) {\n\t\t\t\tmin_score = j;\n\t\t\t}\n\t\t}\n\t\tswap(students[i], students[min_score]);\t\n\t}\n\tcout << \"简单选择排序：\" << endl;\n\tprintStudents(students, size);\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：O(n^2)\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n简单选择排序是不稳定的排序算法。在寻找最小（或最大）元素的过程中，如果有多个相等的元素，那么可能会破坏它们之间的相对顺序。\n##### c. 总结\n\n由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。\n\n****\n### 希尔排序\n#### 算法步骤\n\n**选择增量序列**：希尔排序的关键在于选择合适的增量序列（也称为间隔序列），初始时，选择一个增量h（通常选择数组长度的一半，即 h = n / 2，n为数组长度），然后逐步减小增量。\n\n**分组排序**：对于当前的增量h，将待排序的数组分成h个长度为n/h的子数组（如果n不能被h整除，则最后一个子数组的长度会小于n/h）。\n对每个子数组进行直接插入排序。此时，由于每个子数组中的元素间隔为h，因此只需要考虑每隔h个元素的比较和移动。\n\n**逐步减小增量**：在完成一轮分组排序后，减小增量h的值（如 h = h / 2），并重复步骤2，直到h变为1。\n\n**最后排序**：当h变为1时，整个数组被分为n个长度为1的子数组（即每个元素自成一组）。此时，再对整个数组进行一次直接插入排序，即可得到完全有序的数组。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=20&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid shell(Student students[], int size, int n) {\n\t// 逐步缩小间隔直到间隔为1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 使用间隔进行插入排序\n        for (int i = gap; i < n; i++) {\n            Student tmp = students[i];\n            int j;\n            // 在当前间隔内进行插入排序·\n            for (j = i; j >= gap && students[j - gap].score > tmp.score; j -= gap) {\n                students[j] = students[j - gap];\n            }\n            students[j] = tmp;\n        }\n    }\n    cout << \"希尔排序：\" << endl;\n\tprintStudents(students, size);\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：希尔排序的时间复杂度很难准确计算，因为它与数据序列的初始状态以及增量序列的选择都有关。\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n希尔排序是不稳定的排序算法。在增量大于1的排序过程中，相同元素的相对位置可能会发生变化\n##### c. 总结\n\n希尔排序在实际应用中并不常见，因为它通常不如快速排序、归并排序等算法高效。希尔排序的优点是代码实现简单，且在某些特定情况下（如数据基本有序时）效率较高。\n\n****\n### 快速排序\n#### 算法步骤\n\n**选择基准（Pivot）**：从待排序的序列中选取一个元素作为基准（pivot），通常选择序列的第一个或最后一个元素，或者随机选择。\n\n**分割过程（Partition）**：将待排序的序列重新排列，所有比基准值小的元素放在基准的前面，所有比基准值大的元素放在基准的后面。在这个分割过程之后，基准元素处于序列的中间位置（左侧的所有元素都比它小，右侧的所有元素都比它大）。这个过程称为一次划分（Partition）。\n\n**递归处理**：递归地对基准元素左右两侧的子序列进行快速排序，直到每个子序列的长度为1（即已经有序），递归结束。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=13&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nint quick(Student students[], int left, int right) {\n\tStudent tmp = students[left];\n\twhile(left < right) {\n\t\twhile(left < right && students[right].score >= tmp.score)\n\t\t\tright--;\n\t\tstudents[left] = students[right];\n\t\t\n\t\twhile(left < right && students[left].score <= tmp.score)\n\t\t\tleft++;\n\t\tstudents[right] = students[left];\n\t}\n\tstudents[left] = tmp;\n\treturn left;\n}\n\nvoid quickSort(Student students[], int left, int right) {\n\tif(left < right) {\n\t\tint pi = quick(students, left, right);\n\t\tquickSort(students, left, pi - 1);\n\t\tquickSort(students, pi + 1, right);\n\t}\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：O(n log n)\n空间复杂度：额外空间复杂度为 O(log n)。\n\n##### b. 稳定性\n\n快速排序是不稳定的排序算法，即相等的元素在排序后可能会改变它们的相对顺序。\n##### c. 总结\n\n快速排序算法由于其高效性和广泛的适用性，在多个领域都有着广泛的应用。\n\n### 代码全貌\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Student {\n\tstring name;\n\tint score;\n};\n\nvoid printStudents(const Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tcout << \"姓名：\" << students[i].name << \"  成绩：\" << students[i].score << endl;\n\t}\n\tcout << endl;\n}\n\nvoid insert(Student students[], int size) {\n\tfor(int i = 2; i < size; i++) {\n\t\tStudent tmp = students[i];\n\t\tint j = i-1;\n\t\twhile(j >= 0 && students[j].score > tmp.score) {\n\t\t\tstudents[j + 1] = students[j];\n\t\t\tj--;\n\t\t}\n\t\tstudents[j + 1] = tmp;\n\t}\n\tcout << \"直接插入排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid binary(Student students[], int size) {\n    for(int i = 2; i < size; i++) {\n        Student tmp = students[i];\n        int left = 1;\n        int right = i-1;\n\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(students[mid].score > tmp.score) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        for(int j = i; j > left; j--) {  \n            students[j] = students[j-1]; \n        }\n        students[left] = tmp;\n    }\n    cout << \"折半插入排序：\" << endl;\n    printStudents(students, size);\n}\n\nvoid bubble(Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tfor(int j = 1; j < size - i; j++) {\n\t\t\tif(students[j].score > students[j+1].score) {\n\t\t\t\tswap(students[j], students[j+1]);\n\t\t\t}\n\t\t}\n//\t\tprintStudents(students, size);\n\t}\n\tcout << \"冒泡排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid selection(Student students[], int size) {\n\tfor(int i = 1; i < size - 1; i++) {\n\t\tint min_score = i;\n\t\tfor(int j = i+1; j < size; j++) {\n\t\t\tif(students[min_score].score > students[j].score) {\n\t\t\t\tmin_score = j;\n\t\t\t}\n\t\t}\n\t\tswap(students[i], students[min_score]);\t\n\t}\n\tcout << \"简单选择排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid shell(Student students[], int size, int n) {\n\t// 逐步缩小间隔直到间隔为1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 使用间隔进行插入排序\n        for (int i = gap; i < n; i++) {\n            Student tmp = students[i];\n            int j;\n            // 在当前间隔内进行插入排序\n            for (j = i; j >= gap && students[j - gap].score > tmp.score; j -= gap) {\n                students[j] = students[j - gap];\n            }\n            students[j] = tmp;\n        }\n    }\n    cout << \"希尔排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nint quick(Student students[], int left, int right) {\n\tStudent tmp = students[left];\n\twhile(left < right) {\n\t\twhile(left < right && students[right].score >= tmp.score)\n\t\t\tright--;\n\t\tstudents[left] = students[right];\n\t\t\n\t\twhile(left < right && students[left].score <= tmp.score)\n\t\t\tleft++;\n\t\tstudents[right] = students[left];\n\t}\n\tstudents[left] = tmp;\n\treturn left;\n}\n\nvoid quickSort(Student students[], int left, int right) {\n\tif(left < right) {\n\t\tint pi = quick(students, left, right);\n\t\tquickSort(students, left, pi - 1);\n\t\tquickSort(students, pi + 1, right);\n\t}\n}\n\nint main() {\n\tStudent students[] = {\n\t{},\n\t{\"aaa\", 87},\n\t{\"bbb\", 76},\n\t{\"ccc\", 92},\n\t{\"ddd\", 64},\n\t{\"eee\", 55},\n\t{\"fff\", 78},\n\t{\"ggg\", 100},\n\t{\"hhh\", 43},\n\t};\n\t\n\tint size = sizeof(students) / sizeof(students[1]);\n\tprintStudents(students, size);\n\t\n//\tinsert(students, size);\n//\tbinary(students, size);\n//\tbubble(students, size);\n//\tselection(students, size);\n\t\n\t\n\t\n//\tquickSort(students, 1, size);\n//\tcout << \"快速排序：\" << endl;\n//\tprintStudents(students, size);\n\n\tshell(students, size, size);\t\n\t\n\treturn 0;\n}\n```\n","source":"_posts/shuo-liu16/数据结构：常见排序算法解析.md","raw":"---\ntitle: 数据结构：常见排序算法解析\n# author: shuo-liu\ndate: 2024-6-15\npermalink: articles/shuo-liu16/数据结构：常见排序算法解析/\ncategories: shuo-liu16\ntags:\n  - 数据结构\n  - 排序算法\n  - C++\n---\n\n因为我经常忘记各种排序算法的思路，所以我写了这篇文章。文章中使用了结构体数组来完成排序，已经完成了快排、希尔等多种排序方法。其中，我采用了 `arr[0] = {}` 这样的方式来置空数组，并将其作为哨兵来使用。\n\n<!-- more -->\n\n## 排序算法\n\n（1）直接插入排序；\n（2）折半插入排序；\n（3）冒泡排序；\n（4）简单选择排序。\n（5）希尔排序；\n（6）快速排序。\n\n首先我先定义一下排序需要用到的...ababab\n\n```cpp\nstruct Student {\n    string name;\n    int score;\n};\n\n//打印排序后的数组\nvoid printStudents(const Student students[], int size) {\n    for(int i = 1; i < size; i++) {\n        cout << \"姓名：\" << students[i].name << \"  成绩：\" << students[i].score << endl;\n    }\n    cout << endl;\n}\n\n\nint main() {\n    Student students[] = {\n    {},\n    {\"aaa\", 87},\n    {\"bbb\", 76},\n    {\"ccc\", 92},\n    {\"ddd\", 64},\n    {\"eee\", 55},\n    {\"fff\", 78},\n    {\"ggg\", 100},\n    {\"hhh\", 43},\n    };\n \n    int size = sizeof(students) / sizeof(students[1]);\n    printStudents(students, size);\n \n// insert(students, size);\n// binary(students, size);\n// bubble(students, size);\n// selection(students, size);\n \n \n \n// quickSort(students, 1, size);\n// cout << \"快速排序：\" << endl;\n// printStudents(students, size);\n\n    shell(students, size, size); \n \n    return 0;\n}\n```\n\n***\n\n### 直接插入排序\n\n#### 算法步骤\n\n首先取第一个元素假设这个范围内有序（升序），\n接着扩大这个范围，由1到n,\n始终保持范围内有序，最终完成排序。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid insert(Student students[], int size) {\n\n    //这里假设前i-1个元素有序\n    for(int i = 2; i < size; i++) {\n    //中转变量，存储即将进入有序区域的数据\n\n        Student tmp = students[i];\n        int j = i-1;\n\n        //这里 j = 0 时，students[j].score > tmp.score 必定为false\n        while(j >= 0 && students[j].score > tmp.score) {\n            students[j + 1] = students[j];\n            j--;\n        }\n\n        students[j + 1] = tmp;\n    }\n   cout << \"直接插入排序：\" << endl;\n    printStudents(students, size);\n}\n```\n\n#### 算法分析\n\n##### a.算法性能\n\n时间复杂度：平均（O(n^2)）\n空间复杂度：额外空间复杂度是 ( O(1) )\n\n##### b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)\n\n直接插入排序是稳定的排序算法，因此如果原始数组中存在相同值的元素，在排序后它们的相对顺序不会改变。\n\n##### c.适用性\n\n相比较于其他 ( O(n^2) ) 的排序算法（如冒泡排序和选择排序），直接插入排序在一般情况下效率更高，特别是在数据部分有序的情况下。\n然而，对于大规模数据或需要快速排序的情况，更高效的排序算法（如快速排序、归并排序等 ( O(n \\log n) ) 的算法）更为合适。\n\n##### d.总结\n\n直接插入排序虽然简单，但其性能上不如快速排序等 ( O(n \\log n) ) 级别的排序算法。然而，它易于实现，在小规模数据或者数据接近有序时，可以是一个不错的选择。\n\n****\n### 折半插入排序算法\n#### 算法步骤\n\n折半插入排序与直接插入排序类似，但在寻找插入位置时采用了二分查找的方式，以提高查找插入位置的效率。\n\n```cpp\nvoid binary(Student students[], int size) {\n    for(int i = 2; i < size; i++) {\n        Student tmp = students[i];\n        int left = 1;\n        int right = i-1;\n\n        while(left <= right) {\n         //这样可以防止溢出，虽然这里用不到吧\n            int mid = left + (right - left) / 2;\n            if(students[mid].score > tmp.score) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n  //虽然这样查找的比较快，但是还是要遍历\n        for(int j = i; j > left; j--) {  \n            students[j] = students[j-1]; \n        }\n        students[left] = tmp;\n    }\n    cout << \"折半插入排序：\" << endl;\n    printStudents(students, size);\n}\n```\n\n#### 算法分析\n\n##### a. 算法性能\n\n时间复杂度：平均情况下 ( O(n^2) )，虽然查找插入位置的过程利用了二分查找，但插入操作仍然是 ( O(n) )。\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n折半插入排序同样是稳定的排序算法，相同元素的相对位置不会改变。\n\n##### c. 适用性\n\n折半插入排序适用于需要**稳定排序**且**对空间复杂度有要求**的场景，特别是**当直接插入排序在查找插入位置上效率较低**时，折半插入排序可以提供更好的性能。\n\n##### d. 总结\n\n折半插入排序相比直接插入排序，在查找插入位置时能够更快地定位，但整体的时间复杂度仍然是 ( O(n^2) )，因此对于大规模数据或需要更高效排序算法的情况，应考虑使用 ( O(n \\log n) ) 级别的排序算法，如快速排序或归并排序。\n\n****\n### 冒泡排序算法\n#### 算法步骤\n\n从第一个元素开始，依次比较相邻的两个元素，如果顺序不对则交换它们。\n继续对每一对相邻元素进行同样的操作，直到最后一个元素。\n重复以上步骤，每次都将未排序部分中最大的元素\"浮\"到最后，直到整个序列有序。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=2&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid bubble(Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tfor(int j = 1; j < size - i; j++) {\n\t\t\tif(students[j].score > students[j+1].score) {\n\t\t\t\tswap(students[j], students[j+1]);\n\t\t\t}\n\t\t}\n//\t\tprintStudents(students, size);\n\t}\n\tcout << \"冒泡排序：\" << endl;\n\tprintStudents(students, size);\n}\n\n```\n#### 算法分析\n\n##### a. 算法性能\n\n时间复杂度：O(n^2)\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n冒泡排序是稳定的排序算法。在比较相邻元素时，如果他们的值相等，则不进行交换，因此相等的元素在排序后的相对位置保持不变。\n##### c. 总结\n\n由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。\n\n****\n### 简单选择排序\n#### 算法步骤\n\n首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置\n然后，再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾\n以此类推，直到所有元素均排序完毕\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=3&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid selection(Student students[], int size) {\n\tfor(int i = 1; i < size - 1; i++) {\n\t\tint min_score = i;\n\t\tfor(int j = i+1; j < size; j++) {\n\t\t\tif(students[min_score].score > students[j].score) {\n\t\t\t\tmin_score = j;\n\t\t\t}\n\t\t}\n\t\tswap(students[i], students[min_score]);\t\n\t}\n\tcout << \"简单选择排序：\" << endl;\n\tprintStudents(students, size);\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：O(n^2)\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n简单选择排序是不稳定的排序算法。在寻找最小（或最大）元素的过程中，如果有多个相等的元素，那么可能会破坏它们之间的相对顺序。\n##### c. 总结\n\n由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。\n\n****\n### 希尔排序\n#### 算法步骤\n\n**选择增量序列**：希尔排序的关键在于选择合适的增量序列（也称为间隔序列），初始时，选择一个增量h（通常选择数组长度的一半，即 h = n / 2，n为数组长度），然后逐步减小增量。\n\n**分组排序**：对于当前的增量h，将待排序的数组分成h个长度为n/h的子数组（如果n不能被h整除，则最后一个子数组的长度会小于n/h）。\n对每个子数组进行直接插入排序。此时，由于每个子数组中的元素间隔为h，因此只需要考虑每隔h个元素的比较和移动。\n\n**逐步减小增量**：在完成一轮分组排序后，减小增量h的值（如 h = h / 2），并重复步骤2，直到h变为1。\n\n**最后排序**：当h变为1时，整个数组被分为n个长度为1的子数组（即每个元素自成一组）。此时，再对整个数组进行一次直接插入排序，即可得到完全有序的数组。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=20&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nvoid shell(Student students[], int size, int n) {\n\t// 逐步缩小间隔直到间隔为1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 使用间隔进行插入排序\n        for (int i = gap; i < n; i++) {\n            Student tmp = students[i];\n            int j;\n            // 在当前间隔内进行插入排序·\n            for (j = i; j >= gap && students[j - gap].score > tmp.score; j -= gap) {\n                students[j] = students[j - gap];\n            }\n            students[j] = tmp;\n        }\n    }\n    cout << \"希尔排序：\" << endl;\n\tprintStudents(students, size);\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：希尔排序的时间复杂度很难准确计算，因为它与数据序列的初始状态以及增量序列的选择都有关。\n空间复杂度：额外空间复杂度为 ( O(1) )\n\n##### b. 稳定性\n\n希尔排序是不稳定的排序算法。在增量大于1的排序过程中，相同元素的相对位置可能会发生变化\n##### c. 总结\n\n希尔排序在实际应用中并不常见，因为它通常不如快速排序、归并排序等算法高效。希尔排序的优点是代码实现简单，且在某些特定情况下（如数据基本有序时）效率较高。\n\n****\n### 快速排序\n#### 算法步骤\n\n**选择基准（Pivot）**：从待排序的序列中选取一个元素作为基准（pivot），通常选择序列的第一个或最后一个元素，或者随机选择。\n\n**分割过程（Partition）**：将待排序的序列重新排列，所有比基准值小的元素放在基准的前面，所有比基准值大的元素放在基准的后面。在这个分割过程之后，基准元素处于序列的中间位置（左侧的所有元素都比它小，右侧的所有元素都比它大）。这个过程称为一次划分（Partition）。\n\n**递归处理**：递归地对基准元素左右两侧的子序列进行快速排序，直到每个子序列的长度为1（即已经有序），递归结束。\n\n[动画演示链接](https://www.bilibili.com/video/BV1CY4y1t7TZ?p=13&vd_source=552d8dff5a9194c361aac3f70e8ffeee)\n\n```cpp\nint quick(Student students[], int left, int right) {\n\tStudent tmp = students[left];\n\twhile(left < right) {\n\t\twhile(left < right && students[right].score >= tmp.score)\n\t\t\tright--;\n\t\tstudents[left] = students[right];\n\t\t\n\t\twhile(left < right && students[left].score <= tmp.score)\n\t\t\tleft++;\n\t\tstudents[right] = students[left];\n\t}\n\tstudents[left] = tmp;\n\treturn left;\n}\n\nvoid quickSort(Student students[], int left, int right) {\n\tif(left < right) {\n\t\tint pi = quick(students, left, right);\n\t\tquickSort(students, left, pi - 1);\n\t\tquickSort(students, pi + 1, right);\n\t}\n}\n```\n#### 算法分析\n##### a. 算法性能\n\n时间复杂度：O(n log n)\n空间复杂度：额外空间复杂度为 O(log n)。\n\n##### b. 稳定性\n\n快速排序是不稳定的排序算法，即相等的元素在排序后可能会改变它们的相对顺序。\n##### c. 总结\n\n快速排序算法由于其高效性和广泛的适用性，在多个领域都有着广泛的应用。\n\n### 代码全貌\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Student {\n\tstring name;\n\tint score;\n};\n\nvoid printStudents(const Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tcout << \"姓名：\" << students[i].name << \"  成绩：\" << students[i].score << endl;\n\t}\n\tcout << endl;\n}\n\nvoid insert(Student students[], int size) {\n\tfor(int i = 2; i < size; i++) {\n\t\tStudent tmp = students[i];\n\t\tint j = i-1;\n\t\twhile(j >= 0 && students[j].score > tmp.score) {\n\t\t\tstudents[j + 1] = students[j];\n\t\t\tj--;\n\t\t}\n\t\tstudents[j + 1] = tmp;\n\t}\n\tcout << \"直接插入排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid binary(Student students[], int size) {\n    for(int i = 2; i < size; i++) {\n        Student tmp = students[i];\n        int left = 1;\n        int right = i-1;\n\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(students[mid].score > tmp.score) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        for(int j = i; j > left; j--) {  \n            students[j] = students[j-1]; \n        }\n        students[left] = tmp;\n    }\n    cout << \"折半插入排序：\" << endl;\n    printStudents(students, size);\n}\n\nvoid bubble(Student students[], int size) {\n\tfor(int i = 1; i < size; i++) {\n\t\tfor(int j = 1; j < size - i; j++) {\n\t\t\tif(students[j].score > students[j+1].score) {\n\t\t\t\tswap(students[j], students[j+1]);\n\t\t\t}\n\t\t}\n//\t\tprintStudents(students, size);\n\t}\n\tcout << \"冒泡排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid selection(Student students[], int size) {\n\tfor(int i = 1; i < size - 1; i++) {\n\t\tint min_score = i;\n\t\tfor(int j = i+1; j < size; j++) {\n\t\t\tif(students[min_score].score > students[j].score) {\n\t\t\t\tmin_score = j;\n\t\t\t}\n\t\t}\n\t\tswap(students[i], students[min_score]);\t\n\t}\n\tcout << \"简单选择排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nvoid shell(Student students[], int size, int n) {\n\t// 逐步缩小间隔直到间隔为1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 使用间隔进行插入排序\n        for (int i = gap; i < n; i++) {\n            Student tmp = students[i];\n            int j;\n            // 在当前间隔内进行插入排序\n            for (j = i; j >= gap && students[j - gap].score > tmp.score; j -= gap) {\n                students[j] = students[j - gap];\n            }\n            students[j] = tmp;\n        }\n    }\n    cout << \"希尔排序：\" << endl;\n\tprintStudents(students, size);\n}\n\nint quick(Student students[], int left, int right) {\n\tStudent tmp = students[left];\n\twhile(left < right) {\n\t\twhile(left < right && students[right].score >= tmp.score)\n\t\t\tright--;\n\t\tstudents[left] = students[right];\n\t\t\n\t\twhile(left < right && students[left].score <= tmp.score)\n\t\t\tleft++;\n\t\tstudents[right] = students[left];\n\t}\n\tstudents[left] = tmp;\n\treturn left;\n}\n\nvoid quickSort(Student students[], int left, int right) {\n\tif(left < right) {\n\t\tint pi = quick(students, left, right);\n\t\tquickSort(students, left, pi - 1);\n\t\tquickSort(students, pi + 1, right);\n\t}\n}\n\nint main() {\n\tStudent students[] = {\n\t{},\n\t{\"aaa\", 87},\n\t{\"bbb\", 76},\n\t{\"ccc\", 92},\n\t{\"ddd\", 64},\n\t{\"eee\", 55},\n\t{\"fff\", 78},\n\t{\"ggg\", 100},\n\t{\"hhh\", 43},\n\t};\n\t\n\tint size = sizeof(students) / sizeof(students[1]);\n\tprintStudents(students, size);\n\t\n//\tinsert(students, size);\n//\tbinary(students, size);\n//\tbubble(students, size);\n//\tselection(students, size);\n\t\n\t\n\t\n//\tquickSort(students, 1, size);\n//\tcout << \"快速排序：\" << endl;\n//\tprintStudents(students, size);\n\n\tshell(students, size, size);\t\n\t\n\treturn 0;\n}\n```\n","slug":"shuo-liu16/数据结构：常见排序算法解析","published":1,"updated":"2024-07-13T15:04:17.490Z","__permalink":"articles/shuo-liu16/数据结构：常见排序算法解析/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85e000ilcutan833u8n","content":"<p>因为我经常忘记各种排序算法的思路，所以我写了这篇文章。文章中使用了结构体数组来完成排序，已经完成了快排、希尔等多种排序方法。其中，我采用了 <code>arr[0] = &#123;&#125;</code> 这样的方式来置空数组，并将其作为哨兵来使用。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><p>（1）直接插入排序；<br>（2）折半插入排序；<br>（3）冒泡排序；<br>（4）简单选择排序。<br>（5）希尔排序；<br>（6）快速排序。</p>\n<p>首先我先定义一下排序需要用到的…ababab</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打印排序后的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudents</span><span class=\"params\">(<span class=\"type\">const</span> Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; students[i].name &lt;&lt; <span class=\"string\">&quot;  成绩：&quot;</span> &lt;&lt; students[i].score &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Student students[] = &#123;</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"number\">87</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;bbb&quot;</span>, <span class=\"number\">76</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"number\">92</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ddd&quot;</span>, <span class=\"number\">64</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;eee&quot;</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;fff&quot;</span>, <span class=\"number\">78</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ggg&quot;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;hhh&quot;</span>, <span class=\"number\">43</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(students) / <span class=\"built_in\">sizeof</span>(students[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// insert(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// binary(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// bubble(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// selection(students, size);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// quickSort(students, 1, size);</span></span><br><span class=\"line\"><span class=\"comment\">// cout &lt;&lt; &quot;快速排序：&quot; &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">// printStudents(students, size);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">shell</span>(students, size, size); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><h4 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>首先取第一个元素假设这个范围内有序（升序），<br>接着扩大这个范围，由1到n,<br>始终保持范围内有序，最终完成排序。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里假设前i-1个元素有序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//中转变量，存储即将进入有序区域的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//这里 j = 0 时，students[j].score &gt; tmp.score 必定为false</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; students[j].score &gt; tmp.score) &#123;</span><br><span class=\"line\">            students[j + <span class=\"number\">1</span>] = students[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        students[j + <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;直接插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能\"><a href=\"#a-算法性能\" class=\"headerlink\" title=\"a.算法性能\"></a>a.算法性能</h5><p>时间复杂度：平均（O(n^2)）<br>空间复杂度：额外空间复杂度是 ( O(1) )</p>\n<h5 id=\"b-稳定性-稳定性是指排序过程中相同元素的相对位置不变\"><a href=\"#b-稳定性-稳定性是指排序过程中相同元素的相对位置不变\" class=\"headerlink\" title=\"b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)\"></a>b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)</h5><p>直接插入排序是稳定的排序算法，因此如果原始数组中存在相同值的元素，在排序后它们的相对顺序不会改变。</p>\n<h5 id=\"c-适用性\"><a href=\"#c-适用性\" class=\"headerlink\" title=\"c.适用性\"></a>c.适用性</h5><p>相比较于其他 ( O(n^2) ) 的排序算法（如冒泡排序和选择排序），直接插入排序在一般情况下效率更高，特别是在数据部分有序的情况下。<br>然而，对于大规模数据或需要快速排序的情况，更高效的排序算法（如快速排序、归并排序等 ( O(n \\log n) ) 的算法）更为合适。</p>\n<h5 id=\"d-总结\"><a href=\"#d-总结\" class=\"headerlink\" title=\"d.总结\"></a>d.总结</h5><p>直接插入排序虽然简单，但其性能上不如快速排序等 ( O(n \\log n) ) 级别的排序算法。然而，它易于实现，在小规模数据或者数据接近有序时，可以是一个不错的选择。</p>\n<hr>\n<h3 id=\"折半插入排序算法\"><a href=\"#折半插入排序算法\" class=\"headerlink\" title=\"折半插入排序算法\"></a>折半插入排序算法</h3><h4 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>折半插入排序与直接插入排序类似，但在寻找插入位置时采用了二分查找的方式，以提高查找插入位置的效率。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">binary</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//这样可以防止溢出，虽然这里用不到吧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(students[mid].score &gt; tmp.score) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  <span class=\"comment\">//虽然这样查找的比较快，但是还是要遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &gt; left; j--) &#123;  </span><br><span class=\"line\">            students[j] = students[j<span class=\"number\">-1</span>]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        students[left] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;折半插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-1\"><a href=\"#a-算法性能-1\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：平均情况下 ( O(n^2) )，虽然查找插入位置的过程利用了二分查找，但插入操作仍然是 ( O(n) )。<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性\"><a href=\"#b-稳定性\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>折半插入排序同样是稳定的排序算法，相同元素的相对位置不会改变。</p>\n<h5 id=\"c-适用性-1\"><a href=\"#c-适用性-1\" class=\"headerlink\" title=\"c. 适用性\"></a>c. 适用性</h5><p>折半插入排序适用于需要<strong>稳定排序</strong>且<strong>对空间复杂度有要求</strong>的场景，特别是<strong>当直接插入排序在查找插入位置上效率较低</strong>时，折半插入排序可以提供更好的性能。</p>\n<h5 id=\"d-总结-1\"><a href=\"#d-总结-1\" class=\"headerlink\" title=\"d. 总结\"></a>d. 总结</h5><p>折半插入排序相比直接插入排序，在查找插入位置时能够更快地定位，但整体的时间复杂度仍然是 ( O(n^2) )，因此对于大规模数据或需要更高效排序算法的情况，应考虑使用 ( O(n \\log n) ) 级别的排序算法，如快速排序或归并排序。</p>\n<hr>\n<h3 id=\"冒泡排序算法\"><a href=\"#冒泡排序算法\" class=\"headerlink\" title=\"冒泡排序算法\"></a>冒泡排序算法</h3><h4 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>从第一个元素开始，依次比较相邻的两个元素，如果顺序不对则交换它们。<br>继续对每一对相邻元素进行同样的操作，直到最后一个元素。<br>重复以上步骤，每次都将未排序部分中最大的元素”浮”到最后，直到整个序列有序。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=2&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubble</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; size - i; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[j].score &gt; students[j+<span class=\"number\">1</span>].score) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(students[j], students[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintStudents(students, size);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;冒泡排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-2\"><a href=\"#a-算法性能-2\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n^2)<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-1\"><a href=\"#b-稳定性-1\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>冒泡排序是稳定的排序算法。在比较相邻元素时，如果他们的值相等，则不进行交换，因此相等的元素在排序后的相对位置保持不变。</p>\n<h5 id=\"c-总结\"><a href=\"#c-总结\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。</p>\n<hr>\n<h3 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h3><h4 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置<br>然后，再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾<br>以此类推，直到所有元素均排序完毕</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=3&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selection</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> min_score = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[min_score].score &gt; students[j].score) &#123;</span><br><span class=\"line\">\t\t\t\tmin_score = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(students[i], students[min_score]);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;简单选择排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-3\"><a href=\"#a-算法性能-3\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n^2)<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-2\"><a href=\"#b-稳定性-2\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>简单选择排序是不稳定的排序算法。在寻找最小（或最大）元素的过程中，如果有多个相等的元素，那么可能会破坏它们之间的相对顺序。</p>\n<h5 id=\"c-总结-1\"><a href=\"#c-总结-1\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。</p>\n<hr>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p><strong>选择增量序列</strong>：希尔排序的关键在于选择合适的增量序列（也称为间隔序列），初始时，选择一个增量h（通常选择数组长度的一半，即 h &#x3D; n &#x2F; 2，n为数组长度），然后逐步减小增量。</p>\n<p><strong>分组排序</strong>：对于当前的增量h，将待排序的数组分成h个长度为n&#x2F;h的子数组（如果n不能被h整除，则最后一个子数组的长度会小于n&#x2F;h）。<br>对每个子数组进行直接插入排序。此时，由于每个子数组中的元素间隔为h，因此只需要考虑每隔h个元素的比较和移动。</p>\n<p><strong>逐步减小增量</strong>：在完成一轮分组排序后，减小增量h的值（如 h &#x3D; h &#x2F; 2），并重复步骤2，直到h变为1。</p>\n<p><strong>最后排序</strong>：当h变为1时，整个数组被分为n个长度为1的子数组（即每个元素自成一组）。此时，再对整个数组进行一次直接插入排序，即可得到完全有序的数组。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=20&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 逐步缩小间隔直到间隔为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用间隔进行插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Student tmp = students[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"comment\">// 在当前间隔内进行插入排序·</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt;= gap &amp;&amp; students[j - gap].score &gt; tmp.score; j -= gap) &#123;</span><br><span class=\"line\">                students[j] = students[j - gap];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            students[j] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;希尔排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-4\"><a href=\"#a-算法性能-4\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：希尔排序的时间复杂度很难准确计算，因为它与数据序列的初始状态以及增量序列的选择都有关。<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-3\"><a href=\"#b-稳定性-3\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>希尔排序是不稳定的排序算法。在增量大于1的排序过程中，相同元素的相对位置可能会发生变化</p>\n<h5 id=\"c-总结-2\"><a href=\"#c-总结-2\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>希尔排序在实际应用中并不常见，因为它通常不如快速排序、归并排序等算法高效。希尔排序的优点是代码实现简单，且在某些特定情况下（如数据基本有序时）效率较高。</p>\n<hr>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法步骤-5\"><a href=\"#算法步骤-5\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p><strong>选择基准（Pivot）</strong>：从待排序的序列中选取一个元素作为基准（pivot），通常选择序列的第一个或最后一个元素，或者随机选择。</p>\n<p><strong>分割过程（Partition）</strong>：将待排序的序列重新排列，所有比基准值小的元素放在基准的前面，所有比基准值大的元素放在基准的后面。在这个分割过程之后，基准元素处于序列的中间位置（左侧的所有元素都比它小，右侧的所有元素都比它大）。这个过程称为一次划分（Partition）。</p>\n<p><strong>递归处理</strong>：递归地对基准元素左右两侧的子序列进行快速排序，直到每个子序列的长度为1（即已经有序），递归结束。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=13&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">quick</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\tStudent tmp = students[left];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[right].score &gt;= tmp.score)</span><br><span class=\"line\">\t\t\tright--;</span><br><span class=\"line\">\t\tstudents[left] = students[right];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[left].score &lt;= tmp.score)</span><br><span class=\"line\">\t\t\tleft++;</span><br><span class=\"line\">\t\tstudents[right] = students[left];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstudents[left] = tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pi = <span class=\"built_in\">quick</span>(students, left, right);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, left, pi - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, pi + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-5\"><a href=\"#a-算法性能-5\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n log n)<br>空间复杂度：额外空间复杂度为 O(log n)。</p>\n<h5 id=\"b-稳定性-4\"><a href=\"#b-稳定性-4\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>快速排序是不稳定的排序算法，即相等的元素在排序后可能会改变它们的相对顺序。</p>\n<h5 id=\"c-总结-3\"><a href=\"#c-总结-3\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>快速排序算法由于其高效性和广泛的适用性，在多个领域都有着广泛的应用。</p>\n<h3 id=\"代码全貌\"><a href=\"#代码全貌\" class=\"headerlink\" title=\"代码全貌\"></a>代码全貌</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudents</span><span class=\"params\">(<span class=\"type\">const</span> Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; students[i].name &lt;&lt; <span class=\"string\">&quot;  成绩：&quot;</span> &lt;&lt; students[i].score &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\tStudent tmp = students[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; students[j].score &gt; tmp.score) &#123;</span><br><span class=\"line\">\t\t\tstudents[j + <span class=\"number\">1</span>] = students[j];</span><br><span class=\"line\">\t\t\tj--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstudents[j + <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;直接插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">binary</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(students[mid].score &gt; tmp.score) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &gt; left; j--) &#123;  </span><br><span class=\"line\">            students[j] = students[j<span class=\"number\">-1</span>]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        students[left] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;折半插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubble</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; size - i; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[j].score &gt; students[j+<span class=\"number\">1</span>].score) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(students[j], students[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintStudents(students, size);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;冒泡排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selection</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> min_score = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[min_score].score &gt; students[j].score) &#123;</span><br><span class=\"line\">\t\t\t\tmin_score = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(students[i], students[min_score]);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;简单选择排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 逐步缩小间隔直到间隔为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用间隔进行插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Student tmp = students[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"comment\">// 在当前间隔内进行插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt;= gap &amp;&amp; students[j - gap].score &gt; tmp.score; j -= gap) &#123;</span><br><span class=\"line\">                students[j] = students[j - gap];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            students[j] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;希尔排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">quick</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\tStudent tmp = students[left];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[right].score &gt;= tmp.score)</span><br><span class=\"line\">\t\t\tright--;</span><br><span class=\"line\">\t\tstudents[left] = students[right];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[left].score &lt;= tmp.score)</span><br><span class=\"line\">\t\t\tleft++;</span><br><span class=\"line\">\t\tstudents[right] = students[left];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstudents[left] = tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pi = <span class=\"built_in\">quick</span>(students, left, right);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, left, pi - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, pi + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tStudent students[] = &#123;</span><br><span class=\"line\">\t&#123;&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"number\">87</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;bbb&quot;</span>, <span class=\"number\">76</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"number\">92</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ddd&quot;</span>, <span class=\"number\">64</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;eee&quot;</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;fff&quot;</span>, <span class=\"number\">78</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ggg&quot;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;hhh&quot;</span>, <span class=\"number\">43</span>&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(students) / <span class=\"built_in\">sizeof</span>(students[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//\tinsert(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tbinary(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tbubble(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tselection(students, size);</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//\tquickSort(students, 1, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tcout &lt;&lt; &quot;快速排序：&quot; &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">//\tprintStudents(students, size);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">shell</span>(students, size, size);\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>因为我经常忘记各种排序算法的思路，所以我写了这篇文章。文章中使用了结构体数组来完成排序，已经完成了快排、希尔等多种排序方法。其中，我采用了 <code>arr[0] = &#123;&#125;</code> 这样的方式来置空数组，并将其作为哨兵来使用。</p>","more":"<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><p>（1）直接插入排序；<br>（2）折半插入排序；<br>（3）冒泡排序；<br>（4）简单选择排序。<br>（5）希尔排序；<br>（6）快速排序。</p>\n<p>首先我先定义一下排序需要用到的…ababab</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"type\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打印排序后的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudents</span><span class=\"params\">(<span class=\"type\">const</span> Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; students[i].name &lt;&lt; <span class=\"string\">&quot;  成绩：&quot;</span> &lt;&lt; students[i].score &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Student students[] = &#123;</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"number\">87</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;bbb&quot;</span>, <span class=\"number\">76</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"number\">92</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ddd&quot;</span>, <span class=\"number\">64</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;eee&quot;</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;fff&quot;</span>, <span class=\"number\">78</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ggg&quot;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;hhh&quot;</span>, <span class=\"number\">43</span>&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(students) / <span class=\"built_in\">sizeof</span>(students[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// insert(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// binary(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// bubble(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">// selection(students, size);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// quickSort(students, 1, size);</span></span><br><span class=\"line\"><span class=\"comment\">// cout &lt;&lt; &quot;快速排序：&quot; &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">// printStudents(students, size);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">shell</span>(students, size, size); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><h4 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>首先取第一个元素假设这个范围内有序（升序），<br>接着扩大这个范围，由1到n,<br>始终保持范围内有序，最终完成排序。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里假设前i-1个元素有序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//中转变量，存储即将进入有序区域的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//这里 j = 0 时，students[j].score &gt; tmp.score 必定为false</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; students[j].score &gt; tmp.score) &#123;</span><br><span class=\"line\">            students[j + <span class=\"number\">1</span>] = students[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        students[j + <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;直接插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能\"><a href=\"#a-算法性能\" class=\"headerlink\" title=\"a.算法性能\"></a>a.算法性能</h5><p>时间复杂度：平均（O(n^2)）<br>空间复杂度：额外空间复杂度是 ( O(1) )</p>\n<h5 id=\"b-稳定性-稳定性是指排序过程中相同元素的相对位置不变\"><a href=\"#b-稳定性-稳定性是指排序过程中相同元素的相对位置不变\" class=\"headerlink\" title=\"b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)\"></a>b.稳定性(稳定性是指排序过程中相同元素的相对位置不变)</h5><p>直接插入排序是稳定的排序算法，因此如果原始数组中存在相同值的元素，在排序后它们的相对顺序不会改变。</p>\n<h5 id=\"c-适用性\"><a href=\"#c-适用性\" class=\"headerlink\" title=\"c.适用性\"></a>c.适用性</h5><p>相比较于其他 ( O(n^2) ) 的排序算法（如冒泡排序和选择排序），直接插入排序在一般情况下效率更高，特别是在数据部分有序的情况下。<br>然而，对于大规模数据或需要快速排序的情况，更高效的排序算法（如快速排序、归并排序等 ( O(n \\log n) ) 的算法）更为合适。</p>\n<h5 id=\"d-总结\"><a href=\"#d-总结\" class=\"headerlink\" title=\"d.总结\"></a>d.总结</h5><p>直接插入排序虽然简单，但其性能上不如快速排序等 ( O(n \\log n) ) 级别的排序算法。然而，它易于实现，在小规模数据或者数据接近有序时，可以是一个不错的选择。</p>\n<hr>\n<h3 id=\"折半插入排序算法\"><a href=\"#折半插入排序算法\" class=\"headerlink\" title=\"折半插入排序算法\"></a>折半插入排序算法</h3><h4 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>折半插入排序与直接插入排序类似，但在寻找插入位置时采用了二分查找的方式，以提高查找插入位置的效率。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">binary</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//这样可以防止溢出，虽然这里用不到吧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(students[mid].score &gt; tmp.score) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  <span class=\"comment\">//虽然这样查找的比较快，但是还是要遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &gt; left; j--) &#123;  </span><br><span class=\"line\">            students[j] = students[j<span class=\"number\">-1</span>]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        students[left] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;折半插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-1\"><a href=\"#a-算法性能-1\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：平均情况下 ( O(n^2) )，虽然查找插入位置的过程利用了二分查找，但插入操作仍然是 ( O(n) )。<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性\"><a href=\"#b-稳定性\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>折半插入排序同样是稳定的排序算法，相同元素的相对位置不会改变。</p>\n<h5 id=\"c-适用性-1\"><a href=\"#c-适用性-1\" class=\"headerlink\" title=\"c. 适用性\"></a>c. 适用性</h5><p>折半插入排序适用于需要<strong>稳定排序</strong>且<strong>对空间复杂度有要求</strong>的场景，特别是<strong>当直接插入排序在查找插入位置上效率较低</strong>时，折半插入排序可以提供更好的性能。</p>\n<h5 id=\"d-总结-1\"><a href=\"#d-总结-1\" class=\"headerlink\" title=\"d. 总结\"></a>d. 总结</h5><p>折半插入排序相比直接插入排序，在查找插入位置时能够更快地定位，但整体的时间复杂度仍然是 ( O(n^2) )，因此对于大规模数据或需要更高效排序算法的情况，应考虑使用 ( O(n \\log n) ) 级别的排序算法，如快速排序或归并排序。</p>\n<hr>\n<h3 id=\"冒泡排序算法\"><a href=\"#冒泡排序算法\" class=\"headerlink\" title=\"冒泡排序算法\"></a>冒泡排序算法</h3><h4 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>从第一个元素开始，依次比较相邻的两个元素，如果顺序不对则交换它们。<br>继续对每一对相邻元素进行同样的操作，直到最后一个元素。<br>重复以上步骤，每次都将未排序部分中最大的元素”浮”到最后，直到整个序列有序。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=2&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubble</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; size - i; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[j].score &gt; students[j+<span class=\"number\">1</span>].score) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(students[j], students[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintStudents(students, size);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;冒泡排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-2\"><a href=\"#a-算法性能-2\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n^2)<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-1\"><a href=\"#b-稳定性-1\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>冒泡排序是稳定的排序算法。在比较相邻元素时，如果他们的值相等，则不进行交换，因此相等的元素在排序后的相对位置保持不变。</p>\n<h5 id=\"c-总结\"><a href=\"#c-总结\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。</p>\n<hr>\n<h3 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h3><h4 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p>首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置<br>然后，再从剩余未排序元素中继续寻找最小（或最大）元素，放到已排序序列的末尾<br>以此类推，直到所有元素均排序完毕</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=3&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selection</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> min_score = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[min_score].score &gt; students[j].score) &#123;</span><br><span class=\"line\">\t\t\t\tmin_score = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(students[i], students[min_score]);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;简单选择排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-3\"><a href=\"#a-算法性能-3\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n^2)<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-2\"><a href=\"#b-稳定性-2\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>简单选择排序是不稳定的排序算法。在寻找最小（或最大）元素的过程中，如果有多个相等的元素，那么可能会破坏它们之间的相对顺序。</p>\n<h5 id=\"c-总结-1\"><a href=\"#c-总结-1\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>由于其实现简单且易于理解，在一些教学场景中仍然被广泛使用。实际并不常用。</p>\n<hr>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p><strong>选择增量序列</strong>：希尔排序的关键在于选择合适的增量序列（也称为间隔序列），初始时，选择一个增量h（通常选择数组长度的一半，即 h &#x3D; n &#x2F; 2，n为数组长度），然后逐步减小增量。</p>\n<p><strong>分组排序</strong>：对于当前的增量h，将待排序的数组分成h个长度为n&#x2F;h的子数组（如果n不能被h整除，则最后一个子数组的长度会小于n&#x2F;h）。<br>对每个子数组进行直接插入排序。此时，由于每个子数组中的元素间隔为h，因此只需要考虑每隔h个元素的比较和移动。</p>\n<p><strong>逐步减小增量</strong>：在完成一轮分组排序后，减小增量h的值（如 h &#x3D; h &#x2F; 2），并重复步骤2，直到h变为1。</p>\n<p><strong>最后排序</strong>：当h变为1时，整个数组被分为n个长度为1的子数组（即每个元素自成一组）。此时，再对整个数组进行一次直接插入排序，即可得到完全有序的数组。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=20&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 逐步缩小间隔直到间隔为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用间隔进行插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Student tmp = students[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"comment\">// 在当前间隔内进行插入排序·</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt;= gap &amp;&amp; students[j - gap].score &gt; tmp.score; j -= gap) &#123;</span><br><span class=\"line\">                students[j] = students[j - gap];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            students[j] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;希尔排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-4\"><a href=\"#a-算法性能-4\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：希尔排序的时间复杂度很难准确计算，因为它与数据序列的初始状态以及增量序列的选择都有关。<br>空间复杂度：额外空间复杂度为 ( O(1) )</p>\n<h5 id=\"b-稳定性-3\"><a href=\"#b-稳定性-3\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>希尔排序是不稳定的排序算法。在增量大于1的排序过程中，相同元素的相对位置可能会发生变化</p>\n<h5 id=\"c-总结-2\"><a href=\"#c-总结-2\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>希尔排序在实际应用中并不常见，因为它通常不如快速排序、归并排序等算法高效。希尔排序的优点是代码实现简单，且在某些特定情况下（如数据基本有序时）效率较高。</p>\n<hr>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><h4 id=\"算法步骤-5\"><a href=\"#算法步骤-5\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p><strong>选择基准（Pivot）</strong>：从待排序的序列中选取一个元素作为基准（pivot），通常选择序列的第一个或最后一个元素，或者随机选择。</p>\n<p><strong>分割过程（Partition）</strong>：将待排序的序列重新排列，所有比基准值小的元素放在基准的前面，所有比基准值大的元素放在基准的后面。在这个分割过程之后，基准元素处于序列的中间位置（左侧的所有元素都比它小，右侧的所有元素都比它大）。这个过程称为一次划分（Partition）。</p>\n<p><strong>递归处理</strong>：递归地对基准元素左右两侧的子序列进行快速排序，直到每个子序列的长度为1（即已经有序），递归结束。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1CY4y1t7TZ?p=13&vd_source=552d8dff5a9194c361aac3f70e8ffeee\">动画演示链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">quick</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\tStudent tmp = students[left];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[right].score &gt;= tmp.score)</span><br><span class=\"line\">\t\t\tright--;</span><br><span class=\"line\">\t\tstudents[left] = students[right];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[left].score &lt;= tmp.score)</span><br><span class=\"line\">\t\t\tleft++;</span><br><span class=\"line\">\t\tstudents[right] = students[left];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstudents[left] = tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pi = <span class=\"built_in\">quick</span>(students, left, right);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, left, pi - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, pi + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><h5 id=\"a-算法性能-5\"><a href=\"#a-算法性能-5\" class=\"headerlink\" title=\"a. 算法性能\"></a>a. 算法性能</h5><p>时间复杂度：O(n log n)<br>空间复杂度：额外空间复杂度为 O(log n)。</p>\n<h5 id=\"b-稳定性-4\"><a href=\"#b-稳定性-4\" class=\"headerlink\" title=\"b. 稳定性\"></a>b. 稳定性</h5><p>快速排序是不稳定的排序算法，即相等的元素在排序后可能会改变它们的相对顺序。</p>\n<h5 id=\"c-总结-3\"><a href=\"#c-总结-3\" class=\"headerlink\" title=\"c. 总结\"></a>c. 总结</h5><p>快速排序算法由于其高效性和广泛的适用性，在多个领域都有着广泛的应用。</p>\n<h3 id=\"代码全貌\"><a href=\"#代码全貌\" class=\"headerlink\" title=\"代码全貌\"></a>代码全貌</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Student</span> &#123;</span><br><span class=\"line\">\tstring name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printStudents</span><span class=\"params\">(<span class=\"type\">const</span> Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; students[i].name &lt;&lt; <span class=\"string\">&quot;  成绩：&quot;</span> &lt;&lt; students[i].score &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\tStudent tmp = students[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; students[j].score &gt; tmp.score) &#123;</span><br><span class=\"line\">\t\t\tstudents[j + <span class=\"number\">1</span>] = students[j];</span><br><span class=\"line\">\t\t\tj--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstudents[j + <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;直接插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">binary</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        Student tmp = students[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = i<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(students[mid].score &gt; tmp.score) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &gt; left; j--) &#123;  </span><br><span class=\"line\">            students[j] = students[j<span class=\"number\">-1</span>]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        students[left] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;折半插入排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubble</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; size - i; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[j].score &gt; students[j+<span class=\"number\">1</span>].score) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(students[j], students[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintStudents(students, size);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;冒泡排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selection</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> min_score = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i+<span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(students[min_score].score &gt; students[j].score) &#123;</span><br><span class=\"line\">\t\t\t\tmin_score = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(students[i], students[min_score]);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;简单选择排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shell</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> size, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 逐步缩小间隔直到间隔为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用间隔进行插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Student tmp = students[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"comment\">// 在当前间隔内进行插入排序</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i; j &gt;= gap &amp;&amp; students[j - gap].score &gt; tmp.score; j -= gap) &#123;</span><br><span class=\"line\">                students[j] = students[j - gap];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            students[j] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;希尔排序：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">quick</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\tStudent tmp = students[left];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[right].score &gt;= tmp.score)</span><br><span class=\"line\">\t\t\tright--;</span><br><span class=\"line\">\t\tstudents[left] = students[right];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt; right &amp;&amp; students[left].score &lt;= tmp.score)</span><br><span class=\"line\">\t\t\tleft++;</span><br><span class=\"line\">\t\tstudents[right] = students[left];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstudents[left] = tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(Student students[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pi = <span class=\"built_in\">quick</span>(students, left, right);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, left, pi - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">quickSort</span>(students, pi + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tStudent students[] = &#123;</span><br><span class=\"line\">\t&#123;&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"number\">87</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;bbb&quot;</span>, <span class=\"number\">76</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"number\">92</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ddd&quot;</span>, <span class=\"number\">64</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;eee&quot;</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;fff&quot;</span>, <span class=\"number\">78</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;ggg&quot;</span>, <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"string\">&quot;hhh&quot;</span>, <span class=\"number\">43</span>&#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(students) / <span class=\"built_in\">sizeof</span>(students[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printStudents</span>(students, size);</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//\tinsert(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tbinary(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tbubble(students, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tselection(students, size);</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//\tquickSort(students, 1, size);</span></span><br><span class=\"line\"><span class=\"comment\">//\tcout &lt;&lt; &quot;快速排序：&quot; &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">//\tprintStudents(students, size);</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">shell</span>(students, size, size);\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"基于SDL的一些实用工具（一）：Camera以及SDL_RenderCopy_Camera函数","date":"2024-06-25T16:00:00.000Z","update":"2024-06-25T16:00:00.000Z","_content":"\n看了大V老师的SDL课程之后，突然心血来潮，抛弃了EasyX而投向了SDL的怀抱中。\n过程总是困难重重，所以少不了轮子的制造。\n**基于SDL的一些实用工具** 是一个大的合集，可能会有后续更新。\n\n那么这次的内容就是在SDL中实现Camera的基础操作，以及实现有关Camera的SDL_RenderCopy_Camera函数。\n\n<!-- More -->\n\n## 一、Camera\n\n首先，实现一个 **Camera** 类，我们需要先实现描述摄像机位置的**Vector2**类。\n\n我们定义`class Vector2`，并定义public变量`double x`和`double y`：\n\n```cpp\nclass Vector2\n{\npublic:\n    double x = 0.0;\n    double y = 0.0;\n\npublic:\n    Vector2() = default;\n    ~Vector2() = default;\n\n    Vector2(double x, double y) : x(x), y(y) { }\n};\n```\n\n随后重载二维向量的基本运算符号，定义模长，标准化等成员函数：\n\n```cpp\n\nVector2 operator+(const Vector2& vec) const\n{\n\treturn Vector2(x + vec.x, y + vec.y);\n}\n\nvoid operator+=(const Vector2& vec)\n{\n\tx += vec.x, y += vec.y;\n}\n\nVector2 operator-(const Vector2& vec) const\n{\n\treturn Vector2(x - vec.x, y - vec.y);\n}\n\nvoid operator-=(const Vector2& vec)\n{\n\tx -= vec.x, y -= vec.y;\n}\n\ndouble operator*(const Vector2& vec) const\n{\n\treturn x * vec.x + y * vec.y;\n}\n\nVector2 operator*(double val) const\n{\n\treturn Vector2(x * val, y * val);\n}\n\nvoid operator*=(double val)\n{\n\tx *= val, y *= val;\n}\n\nbool operator==(const Vector2& vec) const\n{\n\treturn x == vec.x && y == vec.y;\n}\n\nbool operator>(const Vector2& vec) const\n{\n\treturn length() > vec.length();\n}\n\nbool operator<(const Vector2& vec) const\n{\n\treturn length() < vec.length();\n}\n\ndouble length() const\n{\n\treturn sqrt(x * x + y * y);\n}\n\nVector2 normalize() const\n{\n\tdouble len = length();\n\n\tif (len == 0)\n\t\treturn Vector2(0, 0);\n\n\treturn Vector2(x / len, y / len);\n}\n\nbool approx_zero() const\n{\n\treturn length() < 0.0001;\n}\n\n```\n\n至此，我们需要的的 **Vector2** 类已经基本实现，接下来便是 **Camera** 类的实现：\n\n首先，在私有变量中定义 `Vector2 position` 变量，用于记录摄像机的位置，定义 `get_position` 函数用于获得摄像机的位置，定义 `reset` 函数用于重置摄像机的位置。\n\n```cpp\n\nclass Camera\n{\npublic:\n    Camera() = default;\n    ~Camera() = default;\n\n    const Vector2& get_position() const\n    {\n        return position;\n    }\n\n    void reset() \n    {\n        position.x = 0.0, position.y = 0.0;\n    }\n\nprivate:\n    Vector2 position = { 0.0,0.0 };\n};\n\n```\n\n我们的摄像机最最最基本的功能便已经实现，接下来便是如何使用摄像机来渲染所在位置的画面。\n\n## 二、SDL_RenderCopy_Camera\n\n想要使用摄像机的功能，渲染摄像机所在位置的画面，我们需要了解相对坐标系的概念：\n\n<div style=\"text-align:center\">\n\n**窗口坐标系 = 世界坐标系 - 摄像机坐标系**\n\n</div>\n\n\n这一概念曾在植物全明星的视频中提及到。\n了解了这一点，我们就可以开始着手SDL_RenderCopy_Camera函数了。\n该函数接受五个参数：\n\n```cpp\n\nvoid SDL_RenderCopy_Camera(\n    const Camera& camera,       // 使用的摄像机\n    SDL_Renderer* renderer,     // 渲染器\n    SDL_Texture* texture,       // 要渲染的纹理\n    const SDL_Rect* srcrect,    // 选择的纹理区域\n    const SDL_Rect* dstrect,    // 渲染目标的位置\n)\n\n```\n\n我们需要考虑特殊情况，当 **dstrect** 为 **nullptr** 时，我们让目标位置为(-pos_camera.x, -pos_camera.y)，非特殊情况下，目标位置为(dstrect->x - pos_camera.x, dstrect->y - pos_camera.y)。由此，可得以下代码：\n\n```cpp\n\nvoid SDL_RenderCopy_Camera(\n\tconst Camera& camera,\n\tSDL_Renderer* renderer,\n\tSDL_Texture* texture,\n\tconst SDL_Rect* srcrect,\n\tconst SDL_Rect* dstrect\n)\n{\n\tconst Vector2& pos_camera = camera.get_position();\n\tSDL_Rect rect;\n\tif (dstrect == nullptr)\n\t{\n\t\trect.x = -pos_camera.x;\n\t\trect.y = -pos_camera.y;\n\t}\n\telse\n\t{\n\t\trect.x = (dstrect->x - pos_camera.x);\n\t\trect.y = (dstrect->y - pos_camera.y);\n\t}\n\tSDL_QueryTexture(texture, NULL, NULL, &rect.w, &rect.h);\n\n\tSDL_RenderCopy(renderer, texture, srcrect, &rect);\n}\n\n```\n\n以上，便是全部的 **Camera** 以及 **SDL_RenderCopy_Camera** 的基础操作。\n当然，我们可以加一些细节，比如加入一个 **Timer** 类，令摄像机实现屏幕震动的效果，当然，在植物全明星中，大V老师已经详细的进行了讲解，在此不过多赘述，直接上代码。\n\n**Timer** 类：\n```cpp\n\nclass Timer\n{\npublic:\n\tTimer() = default;\n\t~Timer() = default;\n\n\tvoid restart()\n\t{\n\t\tpass_time = 0;\n\t\tshotted = false;\n\t}\n\n\tvoid set_wait_time(double val)\n\t{\n\t\twait_time = val;\n\t}\n\n\tvoid set_one_shot(bool flag)\n\t{\n\t\tone_shot = flag;\n\t}\n\n\tvoid set_on_timeout(std::function<void()> on_timeout)\n\t{\n\t\tthis->on_timeout = on_timeout;\n\t}\n\n\tvoid pause()\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\n\t{\n\t\tpaused = false;\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\tif (paused) return;\n\n\t\tpass_time += delta;\n\t\tif (pass_time >= wait_time)\n\t\t{\n\t\t\tbool can_shot = (!one_shot || (one_shot && !shotted));\n\t\t\tshotted = true;\n\t\t\tif (can_shot && on_timeout)\n\t\t\t\ton_timeout();\n\n\t\t\tpass_time -= wait_time;\n\t\t}\n\t}\n\nprivate:\n\tdouble pass_time = 0;\n\tdouble wait_time = 0;\n\tbool paused = false;\n\tbool shotted = false;\n\tbool one_shot = false;\n\tstd::function<void()> on_timeout;\n\n};\n\n```\n\n**Camera** 类：\n```cpp\n\nclass Camera\n{\npublic:\n\tCamera()\n\t{\n\t\ttimer_shake.set_one_shot(true);\n\t\ttimer_shake.set_on_timeout(\n\t\t\t[&]()\n\t\t\t{\n\t\t\t\tis_shaking = false;\n\t\t\t\treset();\n\t\t\t}\n\t\t);\n\t}\n\n\t~Camera() = default;\n\n\tconst Vector2& get_position() const\n\t{\n\t\treturn position;\n\t}\n\n\tvoid reset()\n\t{\n\t\tposition.x = 0;\n\t\tposition.y = 0;\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\ttimer_shake.on_update(delta);\n\n\t\tif (is_shaking)\n\t\t{\n\t\t\tposition.x = (-50 + rand() % 100) / 50.0f * shaking_strength;\n\t\t\tposition.y = (-50 + rand() % 100) / 50.0f * shaking_strength;\n\t\t}\n\t}\n\n\tvoid shake(float strength, int duration)\n\t{\n\t\tis_shaking = true;\n\t\tshaking_strength = strength;\n\n\t\ttimer_shake.set_wait_time(duration);\n\t\ttimer_shake.restart();\n\t}\n\nprivate:\n\tVector2 position = { 0,0 };\t\t// 摄像机位置\n\tTimer timer_shake;\t\t\t\t// 摄像机抖动定时器\n\tbool is_shaking = false;\t\t// 摄像机是否正在抖动\n\tfloat shaking_strength = 0;\t\t// 摄像机抖动幅度\n};\n\n```\n\nby——suang","source":"_posts/suang/SDL_utils_1.md","raw":"---\ntitle: 基于SDL的一些实用工具（一）：Camera以及SDL_RenderCopy_Camera函数\ndate: 2024-06-26\nupdate: 2024-06-26\npermalink: articles/suang/SDL_utils_1/\ncategories: suang\ntags: [c++, SDL]\n---\n\n看了大V老师的SDL课程之后，突然心血来潮，抛弃了EasyX而投向了SDL的怀抱中。\n过程总是困难重重，所以少不了轮子的制造。\n**基于SDL的一些实用工具** 是一个大的合集，可能会有后续更新。\n\n那么这次的内容就是在SDL中实现Camera的基础操作，以及实现有关Camera的SDL_RenderCopy_Camera函数。\n\n<!-- More -->\n\n## 一、Camera\n\n首先，实现一个 **Camera** 类，我们需要先实现描述摄像机位置的**Vector2**类。\n\n我们定义`class Vector2`，并定义public变量`double x`和`double y`：\n\n```cpp\nclass Vector2\n{\npublic:\n    double x = 0.0;\n    double y = 0.0;\n\npublic:\n    Vector2() = default;\n    ~Vector2() = default;\n\n    Vector2(double x, double y) : x(x), y(y) { }\n};\n```\n\n随后重载二维向量的基本运算符号，定义模长，标准化等成员函数：\n\n```cpp\n\nVector2 operator+(const Vector2& vec) const\n{\n\treturn Vector2(x + vec.x, y + vec.y);\n}\n\nvoid operator+=(const Vector2& vec)\n{\n\tx += vec.x, y += vec.y;\n}\n\nVector2 operator-(const Vector2& vec) const\n{\n\treturn Vector2(x - vec.x, y - vec.y);\n}\n\nvoid operator-=(const Vector2& vec)\n{\n\tx -= vec.x, y -= vec.y;\n}\n\ndouble operator*(const Vector2& vec) const\n{\n\treturn x * vec.x + y * vec.y;\n}\n\nVector2 operator*(double val) const\n{\n\treturn Vector2(x * val, y * val);\n}\n\nvoid operator*=(double val)\n{\n\tx *= val, y *= val;\n}\n\nbool operator==(const Vector2& vec) const\n{\n\treturn x == vec.x && y == vec.y;\n}\n\nbool operator>(const Vector2& vec) const\n{\n\treturn length() > vec.length();\n}\n\nbool operator<(const Vector2& vec) const\n{\n\treturn length() < vec.length();\n}\n\ndouble length() const\n{\n\treturn sqrt(x * x + y * y);\n}\n\nVector2 normalize() const\n{\n\tdouble len = length();\n\n\tif (len == 0)\n\t\treturn Vector2(0, 0);\n\n\treturn Vector2(x / len, y / len);\n}\n\nbool approx_zero() const\n{\n\treturn length() < 0.0001;\n}\n\n```\n\n至此，我们需要的的 **Vector2** 类已经基本实现，接下来便是 **Camera** 类的实现：\n\n首先，在私有变量中定义 `Vector2 position` 变量，用于记录摄像机的位置，定义 `get_position` 函数用于获得摄像机的位置，定义 `reset` 函数用于重置摄像机的位置。\n\n```cpp\n\nclass Camera\n{\npublic:\n    Camera() = default;\n    ~Camera() = default;\n\n    const Vector2& get_position() const\n    {\n        return position;\n    }\n\n    void reset() \n    {\n        position.x = 0.0, position.y = 0.0;\n    }\n\nprivate:\n    Vector2 position = { 0.0,0.0 };\n};\n\n```\n\n我们的摄像机最最最基本的功能便已经实现，接下来便是如何使用摄像机来渲染所在位置的画面。\n\n## 二、SDL_RenderCopy_Camera\n\n想要使用摄像机的功能，渲染摄像机所在位置的画面，我们需要了解相对坐标系的概念：\n\n<div style=\"text-align:center\">\n\n**窗口坐标系 = 世界坐标系 - 摄像机坐标系**\n\n</div>\n\n\n这一概念曾在植物全明星的视频中提及到。\n了解了这一点，我们就可以开始着手SDL_RenderCopy_Camera函数了。\n该函数接受五个参数：\n\n```cpp\n\nvoid SDL_RenderCopy_Camera(\n    const Camera& camera,       // 使用的摄像机\n    SDL_Renderer* renderer,     // 渲染器\n    SDL_Texture* texture,       // 要渲染的纹理\n    const SDL_Rect* srcrect,    // 选择的纹理区域\n    const SDL_Rect* dstrect,    // 渲染目标的位置\n)\n\n```\n\n我们需要考虑特殊情况，当 **dstrect** 为 **nullptr** 时，我们让目标位置为(-pos_camera.x, -pos_camera.y)，非特殊情况下，目标位置为(dstrect->x - pos_camera.x, dstrect->y - pos_camera.y)。由此，可得以下代码：\n\n```cpp\n\nvoid SDL_RenderCopy_Camera(\n\tconst Camera& camera,\n\tSDL_Renderer* renderer,\n\tSDL_Texture* texture,\n\tconst SDL_Rect* srcrect,\n\tconst SDL_Rect* dstrect\n)\n{\n\tconst Vector2& pos_camera = camera.get_position();\n\tSDL_Rect rect;\n\tif (dstrect == nullptr)\n\t{\n\t\trect.x = -pos_camera.x;\n\t\trect.y = -pos_camera.y;\n\t}\n\telse\n\t{\n\t\trect.x = (dstrect->x - pos_camera.x);\n\t\trect.y = (dstrect->y - pos_camera.y);\n\t}\n\tSDL_QueryTexture(texture, NULL, NULL, &rect.w, &rect.h);\n\n\tSDL_RenderCopy(renderer, texture, srcrect, &rect);\n}\n\n```\n\n以上，便是全部的 **Camera** 以及 **SDL_RenderCopy_Camera** 的基础操作。\n当然，我们可以加一些细节，比如加入一个 **Timer** 类，令摄像机实现屏幕震动的效果，当然，在植物全明星中，大V老师已经详细的进行了讲解，在此不过多赘述，直接上代码。\n\n**Timer** 类：\n```cpp\n\nclass Timer\n{\npublic:\n\tTimer() = default;\n\t~Timer() = default;\n\n\tvoid restart()\n\t{\n\t\tpass_time = 0;\n\t\tshotted = false;\n\t}\n\n\tvoid set_wait_time(double val)\n\t{\n\t\twait_time = val;\n\t}\n\n\tvoid set_one_shot(bool flag)\n\t{\n\t\tone_shot = flag;\n\t}\n\n\tvoid set_on_timeout(std::function<void()> on_timeout)\n\t{\n\t\tthis->on_timeout = on_timeout;\n\t}\n\n\tvoid pause()\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\n\t{\n\t\tpaused = false;\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\tif (paused) return;\n\n\t\tpass_time += delta;\n\t\tif (pass_time >= wait_time)\n\t\t{\n\t\t\tbool can_shot = (!one_shot || (one_shot && !shotted));\n\t\t\tshotted = true;\n\t\t\tif (can_shot && on_timeout)\n\t\t\t\ton_timeout();\n\n\t\t\tpass_time -= wait_time;\n\t\t}\n\t}\n\nprivate:\n\tdouble pass_time = 0;\n\tdouble wait_time = 0;\n\tbool paused = false;\n\tbool shotted = false;\n\tbool one_shot = false;\n\tstd::function<void()> on_timeout;\n\n};\n\n```\n\n**Camera** 类：\n```cpp\n\nclass Camera\n{\npublic:\n\tCamera()\n\t{\n\t\ttimer_shake.set_one_shot(true);\n\t\ttimer_shake.set_on_timeout(\n\t\t\t[&]()\n\t\t\t{\n\t\t\t\tis_shaking = false;\n\t\t\t\treset();\n\t\t\t}\n\t\t);\n\t}\n\n\t~Camera() = default;\n\n\tconst Vector2& get_position() const\n\t{\n\t\treturn position;\n\t}\n\n\tvoid reset()\n\t{\n\t\tposition.x = 0;\n\t\tposition.y = 0;\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\ttimer_shake.on_update(delta);\n\n\t\tif (is_shaking)\n\t\t{\n\t\t\tposition.x = (-50 + rand() % 100) / 50.0f * shaking_strength;\n\t\t\tposition.y = (-50 + rand() % 100) / 50.0f * shaking_strength;\n\t\t}\n\t}\n\n\tvoid shake(float strength, int duration)\n\t{\n\t\tis_shaking = true;\n\t\tshaking_strength = strength;\n\n\t\ttimer_shake.set_wait_time(duration);\n\t\ttimer_shake.restart();\n\t}\n\nprivate:\n\tVector2 position = { 0,0 };\t\t// 摄像机位置\n\tTimer timer_shake;\t\t\t\t// 摄像机抖动定时器\n\tbool is_shaking = false;\t\t// 摄像机是否正在抖动\n\tfloat shaking_strength = 0;\t\t// 摄像机抖动幅度\n};\n\n```\n\nby——suang","slug":"suang/SDL_utils_1","published":1,"updated":"2024-07-13T15:04:17.490Z","__permalink":"articles/suang/SDL_utils_1/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85g000klcuta0w64lp2","content":"<p>看了大V老师的SDL课程之后，突然心血来潮，抛弃了EasyX而投向了SDL的怀抱中。<br>过程总是困难重重，所以少不了轮子的制造。<br><strong>基于SDL的一些实用工具</strong> 是一个大的合集，可能会有后续更新。</p>\n<p>那么这次的内容就是在SDL中实现Camera的基础操作，以及实现有关Camera的SDL_RenderCopy_Camera函数。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、Camera\"><a href=\"#一、Camera\" class=\"headerlink\" title=\"一、Camera\"></a>一、Camera</h2><p>首先，实现一个 <strong>Camera</strong> 类，我们需要先实现描述摄像机位置的<strong>Vector2</strong>类。</p>\n<p>我们定义<code>class Vector2</code>，并定义public变量<code>double x</code>和<code>double y</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Vector2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> x = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> y = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Vector2</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Vector2</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Vector2</span>(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>随后重载二维向量的基本运算符号，定义模长，标准化等成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x + vec.x, y + vec.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"type\">const</span> Vector2&amp; vec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx += vec.x, y += vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>-(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x - vec.x, y - vec.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>-=(<span class=\"type\">const</span> Vector2&amp; vec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx -= vec.x, y -= vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x * vec.x + y * vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>*(<span class=\"type\">double</span> val) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x * val, y * val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>*=(<span class=\"type\">double</span> val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx *= val, y *= val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x == vec.x &amp;&amp; y == vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &gt; vec.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &lt; vec.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vector2 <span class=\"title\">normalize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> len = <span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x / len, y / len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">approx_zero</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &lt; <span class=\"number\">0.0001</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>至此，我们需要的的 <strong>Vector2</strong> 类已经基本实现，接下来便是 <strong>Camera</strong> 类的实现：</p>\n<p>首先，在私有变量中定义 <code>Vector2 position</code> 变量，用于记录摄像机的位置，定义 <code>get_position</code> 函数用于获得摄像机的位置，定义 <code>reset</code> 函数用于重置摄像机的位置。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> Vector2&amp; <span class=\"title\">get_position</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        position.x = <span class=\"number\">0.0</span>, position.y = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Vector2 position = &#123; <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们的摄像机最最最基本的功能便已经实现，接下来便是如何使用摄像机来渲染所在位置的画面。</p>\n<h2 id=\"二、SDL-RenderCopy-Camera\"><a href=\"#二、SDL-RenderCopy-Camera\" class=\"headerlink\" title=\"二、SDL_RenderCopy_Camera\"></a>二、SDL_RenderCopy_Camera</h2><p>想要使用摄像机的功能，渲染摄像机所在位置的画面，我们需要了解相对坐标系的概念：</p>\n<div style=\"text-align:center\">\n\n<p><strong>窗口坐标系 &#x3D; 世界坐标系 - 摄像机坐标系</strong></p>\n</div>\n\n\n<p>这一概念曾在植物全明星的视频中提及到。<br>了解了这一点，我们就可以开始着手SDL_RenderCopy_Camera函数了。<br>该函数接受五个参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SDL_RenderCopy_Camera</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> Camera&amp; camera,       <span class=\"comment\">// 使用的摄像机</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SDL_Renderer* renderer,     <span class=\"comment\">// 渲染器</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SDL_Texture* texture,       <span class=\"comment\">// 要渲染的纹理</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> SDL_Rect* srcrect,    <span class=\"comment\">// 选择的纹理区域</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> SDL_Rect* dstrect,    <span class=\"comment\">// 渲染目标的位置</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n\n<p>我们需要考虑特殊情况，当 <strong>dstrect</strong> 为 <strong>nullptr</strong> 时，我们让目标位置为(-pos_camera.x, -pos_camera.y)，非特殊情况下，目标位置为(dstrect-&gt;x - pos_camera.x, dstrect-&gt;y - pos_camera.y)。由此，可得以下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SDL_RenderCopy_Camera</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> Camera&amp; camera,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSDL_Renderer* renderer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSDL_Texture* texture,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> SDL_Rect* srcrect,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> SDL_Rect* dstrect</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> Vector2&amp; pos_camera = camera.<span class=\"built_in\">get_position</span>();</span><br><span class=\"line\">\tSDL_Rect rect;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dstrect == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trect.x = -pos_camera.x;</span><br><span class=\"line\">\t\trect.y = -pos_camera.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trect.x = (dstrect-&gt;x - pos_camera.x);</span><br><span class=\"line\">\t\trect.y = (dstrect-&gt;y - pos_camera.y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">SDL_QueryTexture</span>(texture, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;rect.w, &amp;rect.h);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, texture, srcrect, &amp;rect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上，便是全部的 <strong>Camera</strong> 以及 <strong>SDL_RenderCopy_Camera</strong> 的基础操作。<br>当然，我们可以加一些细节，比如加入一个 <strong>Timer</strong> 类，令摄像机实现屏幕震动的效果，当然，在植物全明星中，大V老师已经详细的进行了讲解，在此不过多赘述，直接上代码。</p>\n<p><strong>Timer</strong> 类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Timer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">double</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_on_timeout</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; on_timeout)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;on_timeout = on_timeout;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpass_time += delta;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> can_shot = (!one_shot || (one_shot &amp;&amp; !shotted));</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (can_shot &amp;&amp; on_timeout)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">on_timeout</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tpass_time -= wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">double</span> pass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">double</span> wait_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; on_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>Camera</strong> 类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Camera</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_on_timeout</span>(</span><br><span class=\"line\">\t\t\t[&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tis_shaking = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">const</span> Vector2&amp; <span class=\"title\">get_position</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_shaking)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tposition.x = (<span class=\"number\">-50</span> + <span class=\"built_in\">rand</span>() % <span class=\"number\">100</span>) / <span class=\"number\">50.0f</span> * shaking_strength;</span><br><span class=\"line\">\t\t\tposition.y = (<span class=\"number\">-50</span> + <span class=\"built_in\">rand</span>() % <span class=\"number\">100</span>) / <span class=\"number\">50.0f</span> * shaking_strength;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shake</span><span class=\"params\">(<span class=\"type\">float</span> strength, <span class=\"type\">int</span> duration)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tis_shaking = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tshaking_strength = strength;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_wait_time</span>(duration);</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position = &#123; <span class=\"number\">0</span>,<span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 摄像机位置</span></span><br><span class=\"line\">\tTimer timer_shake;\t\t\t\t<span class=\"comment\">// 摄像机抖动定时器</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_shaking = <span class=\"literal\">false</span>;\t\t<span class=\"comment\">// 摄像机是否正在抖动</span></span><br><span class=\"line\">\t<span class=\"type\">float</span> shaking_strength = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 摄像机抖动幅度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>by——suang</p>\n","site":{"data":{}},"excerpt":"<p>看了大V老师的SDL课程之后，突然心血来潮，抛弃了EasyX而投向了SDL的怀抱中。<br>过程总是困难重重，所以少不了轮子的制造。<br><strong>基于SDL的一些实用工具</strong> 是一个大的合集，可能会有后续更新。</p>\n<p>那么这次的内容就是在SDL中实现Camera的基础操作，以及实现有关Camera的SDL_RenderCopy_Camera函数。</p>","more":"<h2 id=\"一、Camera\"><a href=\"#一、Camera\" class=\"headerlink\" title=\"一、Camera\"></a>一、Camera</h2><p>首先，实现一个 <strong>Camera</strong> 类，我们需要先实现描述摄像机位置的<strong>Vector2</strong>类。</p>\n<p>我们定义<code>class Vector2</code>，并定义public变量<code>double x</code>和<code>double y</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Vector2</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> x = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> y = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Vector2</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Vector2</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Vector2</span>(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>随后重载二维向量的基本运算符号，定义模长，标准化等成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x + vec.x, y + vec.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"type\">const</span> Vector2&amp; vec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx += vec.x, y += vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>-(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x - vec.x, y - vec.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>-=(<span class=\"type\">const</span> Vector2&amp; vec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx -= vec.x, y -= vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x * vec.x + y * vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vector2 <span class=\"keyword\">operator</span>*(<span class=\"type\">double</span> val) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x * val, y * val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>*=(<span class=\"type\">double</span> val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tx *= val, y *= val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x == vec.x &amp;&amp; y == vec.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &gt; vec.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Vector2&amp; vec) <span class=\"type\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &lt; vec.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vector2 <span class=\"title\">normalize</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> len = <span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Vector2</span>(x / len, y / len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">approx_zero</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">length</span>() &lt; <span class=\"number\">0.0001</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>至此，我们需要的的 <strong>Vector2</strong> 类已经基本实现，接下来便是 <strong>Camera</strong> 类的实现：</p>\n<p>首先，在私有变量中定义 <code>Vector2 position</code> 变量，用于记录摄像机的位置，定义 <code>get_position</code> 函数用于获得摄像机的位置，定义 <code>reset</code> 函数用于重置摄像机的位置。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> Vector2&amp; <span class=\"title\">get_position</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        position.x = <span class=\"number\">0.0</span>, position.y = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Vector2 position = &#123; <span class=\"number\">0.0</span>,<span class=\"number\">0.0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们的摄像机最最最基本的功能便已经实现，接下来便是如何使用摄像机来渲染所在位置的画面。</p>\n<h2 id=\"二、SDL-RenderCopy-Camera\"><a href=\"#二、SDL-RenderCopy-Camera\" class=\"headerlink\" title=\"二、SDL_RenderCopy_Camera\"></a>二、SDL_RenderCopy_Camera</h2><p>想要使用摄像机的功能，渲染摄像机所在位置的画面，我们需要了解相对坐标系的概念：</p>\n<div style=\"text-align:center\">\n\n<p><strong>窗口坐标系 &#x3D; 世界坐标系 - 摄像机坐标系</strong></p>\n</div>\n\n\n<p>这一概念曾在植物全明星的视频中提及到。<br>了解了这一点，我们就可以开始着手SDL_RenderCopy_Camera函数了。<br>该函数接受五个参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SDL_RenderCopy_Camera</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> Camera&amp; camera,       <span class=\"comment\">// 使用的摄像机</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SDL_Renderer* renderer,     <span class=\"comment\">// 渲染器</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SDL_Texture* texture,       <span class=\"comment\">// 要渲染的纹理</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> SDL_Rect* srcrect,    <span class=\"comment\">// 选择的纹理区域</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> SDL_Rect* dstrect,    <span class=\"comment\">// 渲染目标的位置</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n\n<p>我们需要考虑特殊情况，当 <strong>dstrect</strong> 为 <strong>nullptr</strong> 时，我们让目标位置为(-pos_camera.x, -pos_camera.y)，非特殊情况下，目标位置为(dstrect-&gt;x - pos_camera.x, dstrect-&gt;y - pos_camera.y)。由此，可得以下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SDL_RenderCopy_Camera</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> Camera&amp; camera,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSDL_Renderer* renderer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSDL_Texture* texture,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> SDL_Rect* srcrect,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">const</span> SDL_Rect* dstrect</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> Vector2&amp; pos_camera = camera.<span class=\"built_in\">get_position</span>();</span><br><span class=\"line\">\tSDL_Rect rect;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dstrect == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trect.x = -pos_camera.x;</span><br><span class=\"line\">\t\trect.y = -pos_camera.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trect.x = (dstrect-&gt;x - pos_camera.x);</span><br><span class=\"line\">\t\trect.y = (dstrect-&gt;y - pos_camera.y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">SDL_QueryTexture</span>(texture, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;rect.w, &amp;rect.h);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, texture, srcrect, &amp;rect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以上，便是全部的 <strong>Camera</strong> 以及 <strong>SDL_RenderCopy_Camera</strong> 的基础操作。<br>当然，我们可以加一些细节，比如加入一个 <strong>Timer</strong> 类，令摄像机实现屏幕震动的效果，当然，在植物全明星中，大V老师已经详细的进行了讲解，在此不过多赘述，直接上代码。</p>\n<p><strong>Timer</strong> 类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Timer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">double</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_on_timeout</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; on_timeout)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;on_timeout = on_timeout;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpass_time += delta;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> can_shot = (!one_shot || (one_shot &amp;&amp; !shotted));</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (can_shot &amp;&amp; on_timeout)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">on_timeout</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tpass_time -= wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">double</span> pass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">double</span> wait_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; on_timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>Camera</strong> 类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Camera</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Camera</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_on_timeout</span>(</span><br><span class=\"line\">\t\t\t[&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tis_shaking = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Camera</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">const</span> Vector2&amp; <span class=\"title\">get_position</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tposition.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_shaking)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tposition.x = (<span class=\"number\">-50</span> + <span class=\"built_in\">rand</span>() % <span class=\"number\">100</span>) / <span class=\"number\">50.0f</span> * shaking_strength;</span><br><span class=\"line\">\t\t\tposition.y = (<span class=\"number\">-50</span> + <span class=\"built_in\">rand</span>() % <span class=\"number\">100</span>) / <span class=\"number\">50.0f</span> * shaking_strength;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shake</span><span class=\"params\">(<span class=\"type\">float</span> strength, <span class=\"type\">int</span> duration)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tis_shaking = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tshaking_strength = strength;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">set_wait_time</span>(duration);</span><br><span class=\"line\">\t\ttimer_shake.<span class=\"built_in\">restart</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVector2 position = &#123; <span class=\"number\">0</span>,<span class=\"number\">0</span> &#125;;\t\t<span class=\"comment\">// 摄像机位置</span></span><br><span class=\"line\">\tTimer timer_shake;\t\t\t\t<span class=\"comment\">// 摄像机抖动定时器</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_shaking = <span class=\"literal\">false</span>;\t\t<span class=\"comment\">// 摄像机是否正在抖动</span></span><br><span class=\"line\">\t<span class=\"type\">float</span> shaking_strength = <span class=\"number\">0</span>;\t\t<span class=\"comment\">// 摄像机抖动幅度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>by——suang</p>"},{"title":"基于SDL的一些实用工具（二）：Atlas类以及Animation类的实现","date":"2024-06-26T16:00:00.000Z","update":"2024-06-26T16:00:00.000Z","_content":"\n这里是suang的**基于SDL的一些实用工具**的第二部分—— **Atlas** 和 **Animation**，以及对他们的加载、更新、渲染等操作。\n\n<div style=\"text-align:center\">\n\n![兔兔这么可爱！](articles/suang/SDL_utils_2/rabbit_hole.png)\n\n</div>\n\n<!-- More -->\n\n## 一、 Atlas\n\n首先，明确 **Atlas** 类需要的成员变量以及成员方法，我们需要一个容器去容纳我们所需要的 **Texture** ，定义私有变量 `std::vector<SDL_Texture*> tex_list`。在有了纹理的容器后，需要 `load_from_file` 函数来将所需的纹理加载到容器中，我们使用 `sprintf` 函数来实现对path模板进行操作，具体实现如下：\n\n```cpp\n\nvoid load_from_file(SDL_Renderer* renderer, std::string path_template, int num)\n{\n\ttex_list.clear();\n\ttex_list.resize(num);\n\n\tchar path_file[256];\n\tfor (int i = 0; i < num; ++i)\n\t{\n\t\tsprintf(path_file, path_template.c_str(), i + 1);\n\t\ttex_list[i] = IMG_LoadTexture(renderer, path_file);\n\t}\n}\n\n```\n\n随后，我们定义 `clear` 成员函数来清空容器，定义 `get_size` 成员函数来获取容器的大小， 定义 `get_texture` 成员函数来获取索引为 **idx** 的纹理的指针，定义 `add_texture` 成员函数来向容器中添加纹理。\n\n至此， **Atlas** 类便已经实现，完整代码如下：\n\n```cpp\n\nclass Atlas\n{\npublic:\n\tAtlas() = default;\n\n\t~Atlas() = default;\n\n\tvoid load_from_file(SDL_Renderer* renderer, std::string path_template, int num)\n\t{\n\t\ttex_list.clear();\n\t\ttex_list.resize(num);\n\n\t\tchar path_file[256];\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tsprintf(path_file, path_template.c_str(), i + 1);\n\t\t\ttex_list[i] = IMG_LoadTexture(renderer, path_file);\n\t\t}\n\t}\n\n\tvoid clear()\n\t{\n\t\ttex_list.clear();\n\t}\n\n\tsize_t get_size()\n\t{\n\t\treturn tex_list.size();\n\t}\n\n\tSDL_Texture* get_texture(size_t idx)\n\t{\n\t\tif (idx < 0 || idx >= tex_list.size())\n\t\t\treturn nullptr;\n\t\treturn tex_list[idx];\n\t}\n\n\tvoid add_texture(SDL_Texture* texture)\n\t{\n\t\ttex_list.push_back(texture);\n\t}\n\nprivate:\n\tstd::vector<SDL_Texture*> tex_list;\n};\n\n```\n\n## 二、 Animation\n\n在提瓦特幸存者、植物全明星、村庄保卫战以及我制作的俄罗斯方块中，动画都是以连续的快速播放的图片的形式存在的，都是通过视觉暂留效应来达到连续的动画效果，因此，在 **Animation** 类中，我们需要持有动画所需的图集。因此，在私有变量中定义 `Atlas* atlas`，但是千万不要忘记在使用 **Animation** 类之前对 **atlas** 进行赋值。\n\n接下来，我们定义bool类形变量 **is_loop** 来描述该动画是否为循环播放的动画、定义size_t类型变量 **idx_frame** 作为帧索引，定义Timer类 **timer** 来作为实现更新动画帧索引的计时器。\n\n定义 `reset` 成员函数来重置动画的状态至初始状态，定义 `set_atlas` 成员函数来设置动画所使用的图集，定义 `set_loop` 成员函数来设置动画是否循环播放，定义 `set_interval` 成员函数来设置动画帧与帧之间的帧间隔，也就是 **timer** 的等待时间，定义 `on_update` 成员函数来实现动画类的更新，包括对 **timer** 的更新（随着 **Animation** 类的功能增加而增加），定义 `on_render` 成员函数来实现对动画当前帧的渲染。\n\n完整实现如下：\n\n```cpp\n\nclass Animation\n{\npublic:\n\ttypedef std::function<void()> PlayCallback;\n\npublic:\n\tAnimation()\n\t{\n\t\ttimer.set_one_shot(false);\n\t\ttimer.set_on_timeout(\n\t\t\t[&]()\n\t\t\t{\n\t\t\t\tidx_frame++;\n\t\t\t\tif (idx_frame >= atlas->get_size())\n\t\t\t\t\tidx_frame = is_loop ? 0 : atlas->get_size() - 1;\n\t\t\t}\n\t\t);\n\t}\n\n\t~Animation() = default;\n\n\tvoid reset()\n\t{\n\t\ttimer.restart();\n\n\t\tidx_frame = 0;\n\t}\n\n\tvoid set_atlas(Atlas* atlas)\n\t{\n\t\treset();\n\t\tthis->atlas = atlas;\n\t}\n\n\tvoid set_loop(bool is_loop)\n\t{\n\t\tthis->is_loop = is_loop;\n\t}\n\n\tvoid set_interval(double interval)\n\t{\n\t\ttimer.set_wait_time(interval);\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\ttimer.on_update(delta);\n\t}\n\n\tvoid on_render(SDL_Renderer* renderer, const Camera& camera, const SDL_Rect* dstrect, bool flag = true)\n\t{\n\t\tif (flag)\n\t\t\tSDL_RenderCopy_Camera(camera, renderer, atlas->get_texture(idx_frame), nullptr, dstrect);\n\t\telse\n\t\t\tSDL_RenderCopy(renderer, atlas->get_texture(idx_frame), nullptr, dstrect);\n\t}\n\nprivate:\n\tTimer timer;\n\tbool is_loop = true;\n\tsize_t idx_frame = 0;\n\tAtlas* atlas = nullptr;\n\tPlayCallback on_finished;\n\tint width_frame = 0, height_frame = 0;\n\n};\n\n```\n\n其中，**Camera** 类以及 **Timer** 类在上一期**基于SDL的一些实用工具**中已经有详细的实现方法，这里不再赘叙。\n\n-  **on_render** 中的 **flag** 变量为“是否使用摄像机进行渲染”\n\n## 三、注意事项\n\n学习过大V老师的村庄保卫战的伙伴们应该有了解到 **ResourcesManager** 类中的各种 **pool**，类似于“池”一样的哈希表用于存储游戏所使用的资源，那么我们是否可以在 **ResourcesManager** 类中也定义一个存储 **Atlas** 类的 **atlas_pool** 呢？\n\n首先，我们在 **ResID** 枚举类中定义我们所要加载的图集类的ID，再为我们的存储 **Atlas** 类的哈希表定义一个别名 **AtlasPool** ，于是，在 `load_from_file`函数中，我们便可以像这样将 **Atlas** 类加载到 **atlas_pool** 中了：\n\n```cpp\n\nbool load_from_file(SDL_Renderer* renderer)\n{\n    Atlas* atlas_menu_background = new Atlas();\n\tatlas_menu_background->load_from_file(renderer, \"resources/background/menu_background_%d.png\", 10);\n\tatlas_pool[ResID::Atlas_MenuBackground] = atlas_menu_background;\n}\n\n```","source":"_posts/suang/SDL_utils_2.md","raw":"---\ntitle: 基于SDL的一些实用工具（二）：Atlas类以及Animation类的实现\ndate: 2024-06-27\nupdate: 2024-06-27\npermalink: articles/suang/SDL_utils_2/\ncategories: suang\ntags: [c++, SDL]\n---\n\n这里是suang的**基于SDL的一些实用工具**的第二部分—— **Atlas** 和 **Animation**，以及对他们的加载、更新、渲染等操作。\n\n<div style=\"text-align:center\">\n\n![兔兔这么可爱！](articles/suang/SDL_utils_2/rabbit_hole.png)\n\n</div>\n\n<!-- More -->\n\n## 一、 Atlas\n\n首先，明确 **Atlas** 类需要的成员变量以及成员方法，我们需要一个容器去容纳我们所需要的 **Texture** ，定义私有变量 `std::vector<SDL_Texture*> tex_list`。在有了纹理的容器后，需要 `load_from_file` 函数来将所需的纹理加载到容器中，我们使用 `sprintf` 函数来实现对path模板进行操作，具体实现如下：\n\n```cpp\n\nvoid load_from_file(SDL_Renderer* renderer, std::string path_template, int num)\n{\n\ttex_list.clear();\n\ttex_list.resize(num);\n\n\tchar path_file[256];\n\tfor (int i = 0; i < num; ++i)\n\t{\n\t\tsprintf(path_file, path_template.c_str(), i + 1);\n\t\ttex_list[i] = IMG_LoadTexture(renderer, path_file);\n\t}\n}\n\n```\n\n随后，我们定义 `clear` 成员函数来清空容器，定义 `get_size` 成员函数来获取容器的大小， 定义 `get_texture` 成员函数来获取索引为 **idx** 的纹理的指针，定义 `add_texture` 成员函数来向容器中添加纹理。\n\n至此， **Atlas** 类便已经实现，完整代码如下：\n\n```cpp\n\nclass Atlas\n{\npublic:\n\tAtlas() = default;\n\n\t~Atlas() = default;\n\n\tvoid load_from_file(SDL_Renderer* renderer, std::string path_template, int num)\n\t{\n\t\ttex_list.clear();\n\t\ttex_list.resize(num);\n\n\t\tchar path_file[256];\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tsprintf(path_file, path_template.c_str(), i + 1);\n\t\t\ttex_list[i] = IMG_LoadTexture(renderer, path_file);\n\t\t}\n\t}\n\n\tvoid clear()\n\t{\n\t\ttex_list.clear();\n\t}\n\n\tsize_t get_size()\n\t{\n\t\treturn tex_list.size();\n\t}\n\n\tSDL_Texture* get_texture(size_t idx)\n\t{\n\t\tif (idx < 0 || idx >= tex_list.size())\n\t\t\treturn nullptr;\n\t\treturn tex_list[idx];\n\t}\n\n\tvoid add_texture(SDL_Texture* texture)\n\t{\n\t\ttex_list.push_back(texture);\n\t}\n\nprivate:\n\tstd::vector<SDL_Texture*> tex_list;\n};\n\n```\n\n## 二、 Animation\n\n在提瓦特幸存者、植物全明星、村庄保卫战以及我制作的俄罗斯方块中，动画都是以连续的快速播放的图片的形式存在的，都是通过视觉暂留效应来达到连续的动画效果，因此，在 **Animation** 类中，我们需要持有动画所需的图集。因此，在私有变量中定义 `Atlas* atlas`，但是千万不要忘记在使用 **Animation** 类之前对 **atlas** 进行赋值。\n\n接下来，我们定义bool类形变量 **is_loop** 来描述该动画是否为循环播放的动画、定义size_t类型变量 **idx_frame** 作为帧索引，定义Timer类 **timer** 来作为实现更新动画帧索引的计时器。\n\n定义 `reset` 成员函数来重置动画的状态至初始状态，定义 `set_atlas` 成员函数来设置动画所使用的图集，定义 `set_loop` 成员函数来设置动画是否循环播放，定义 `set_interval` 成员函数来设置动画帧与帧之间的帧间隔，也就是 **timer** 的等待时间，定义 `on_update` 成员函数来实现动画类的更新，包括对 **timer** 的更新（随着 **Animation** 类的功能增加而增加），定义 `on_render` 成员函数来实现对动画当前帧的渲染。\n\n完整实现如下：\n\n```cpp\n\nclass Animation\n{\npublic:\n\ttypedef std::function<void()> PlayCallback;\n\npublic:\n\tAnimation()\n\t{\n\t\ttimer.set_one_shot(false);\n\t\ttimer.set_on_timeout(\n\t\t\t[&]()\n\t\t\t{\n\t\t\t\tidx_frame++;\n\t\t\t\tif (idx_frame >= atlas->get_size())\n\t\t\t\t\tidx_frame = is_loop ? 0 : atlas->get_size() - 1;\n\t\t\t}\n\t\t);\n\t}\n\n\t~Animation() = default;\n\n\tvoid reset()\n\t{\n\t\ttimer.restart();\n\n\t\tidx_frame = 0;\n\t}\n\n\tvoid set_atlas(Atlas* atlas)\n\t{\n\t\treset();\n\t\tthis->atlas = atlas;\n\t}\n\n\tvoid set_loop(bool is_loop)\n\t{\n\t\tthis->is_loop = is_loop;\n\t}\n\n\tvoid set_interval(double interval)\n\t{\n\t\ttimer.set_wait_time(interval);\n\t}\n\n\tvoid on_update(double delta)\n\t{\n\t\ttimer.on_update(delta);\n\t}\n\n\tvoid on_render(SDL_Renderer* renderer, const Camera& camera, const SDL_Rect* dstrect, bool flag = true)\n\t{\n\t\tif (flag)\n\t\t\tSDL_RenderCopy_Camera(camera, renderer, atlas->get_texture(idx_frame), nullptr, dstrect);\n\t\telse\n\t\t\tSDL_RenderCopy(renderer, atlas->get_texture(idx_frame), nullptr, dstrect);\n\t}\n\nprivate:\n\tTimer timer;\n\tbool is_loop = true;\n\tsize_t idx_frame = 0;\n\tAtlas* atlas = nullptr;\n\tPlayCallback on_finished;\n\tint width_frame = 0, height_frame = 0;\n\n};\n\n```\n\n其中，**Camera** 类以及 **Timer** 类在上一期**基于SDL的一些实用工具**中已经有详细的实现方法，这里不再赘叙。\n\n-  **on_render** 中的 **flag** 变量为“是否使用摄像机进行渲染”\n\n## 三、注意事项\n\n学习过大V老师的村庄保卫战的伙伴们应该有了解到 **ResourcesManager** 类中的各种 **pool**，类似于“池”一样的哈希表用于存储游戏所使用的资源，那么我们是否可以在 **ResourcesManager** 类中也定义一个存储 **Atlas** 类的 **atlas_pool** 呢？\n\n首先，我们在 **ResID** 枚举类中定义我们所要加载的图集类的ID，再为我们的存储 **Atlas** 类的哈希表定义一个别名 **AtlasPool** ，于是，在 `load_from_file`函数中，我们便可以像这样将 **Atlas** 类加载到 **atlas_pool** 中了：\n\n```cpp\n\nbool load_from_file(SDL_Renderer* renderer)\n{\n    Atlas* atlas_menu_background = new Atlas();\n\tatlas_menu_background->load_from_file(renderer, \"resources/background/menu_background_%d.png\", 10);\n\tatlas_pool[ResID::Atlas_MenuBackground] = atlas_menu_background;\n}\n\n```","slug":"suang/SDL_utils_2","published":1,"updated":"2024-07-13T15:04:17.490Z","__permalink":"articles/suang/SDL_utils_2/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85i000mlcutdimbgh9a","content":"<p>这里是suang的<strong>基于SDL的一些实用工具</strong>的第二部分—— <strong>Atlas</strong> 和 <strong>Animation</strong>，以及对他们的加载、更新、渲染等操作。</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/SDL_utils_2/rabbit_hole.png\" alt=\"兔兔这么可爱！\"></p>\n</div>\n\n<span id=\"more\"></span>\n\n<h2 id=\"一、-Atlas\"><a href=\"#一、-Atlas\" class=\"headerlink\" title=\"一、 Atlas\"></a>一、 Atlas</h2><p>首先，明确 <strong>Atlas</strong> 类需要的成员变量以及成员方法，我们需要一个容器去容纳我们所需要的 <strong>Texture</strong> ，定义私有变量 <code>std::vector&lt;SDL_Texture*&gt; tex_list</code>。在有了纹理的容器后，需要 <code>load_from_file</code> 函数来将所需的纹理加载到容器中，我们使用 <code>sprintf</code> 函数来实现对path模板进行操作，具体实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer, std::string path_template, <span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\ttex_list.<span class=\"built_in\">resize</span>(num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">char</span> path_file[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(path_file, path_template.<span class=\"built_in\">c_str</span>(), i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\ttex_list[i] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, path_file);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>随后，我们定义 <code>clear</code> 成员函数来清空容器，定义 <code>get_size</code> 成员函数来获取容器的大小， 定义 <code>get_texture</code> 成员函数来获取索引为 <strong>idx</strong> 的纹理的指针，定义 <code>add_texture</code> 成员函数来向容器中添加纹理。</p>\n<p>至此， <strong>Atlas</strong> 类便已经实现，完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Atlas</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Atlas</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Atlas</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer, std::string path_template, <span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">resize</span>(num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">char</span> path_file[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num; ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">sprintf</span>(path_file, path_template.<span class=\"built_in\">c_str</span>(), i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\ttex_list[i] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, path_file);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tex_list.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">SDL_Texture* <span class=\"title\">get_texture</span><span class=\"params\">(<span class=\"type\">size_t</span> idx)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span> || idx &gt;= tex_list.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tex_list[idx];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_texture</span><span class=\"params\">(SDL_Texture* texture)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">push_back</span>(texture);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstd::vector&lt;SDL_Texture*&gt; tex_list;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、-Animation\"><a href=\"#二、-Animation\" class=\"headerlink\" title=\"二、 Animation\"></a>二、 Animation</h2><p>在提瓦特幸存者、植物全明星、村庄保卫战以及我制作的俄罗斯方块中，动画都是以连续的快速播放的图片的形式存在的，都是通过视觉暂留效应来达到连续的动画效果，因此，在 <strong>Animation</strong> 类中，我们需要持有动画所需的图集。因此，在私有变量中定义 <code>Atlas* atlas</code>，但是千万不要忘记在使用 <strong>Animation</strong> 类之前对 <strong>atlas</strong> 进行赋值。</p>\n<p>接下来，我们定义bool类形变量 <strong>is_loop</strong> 来描述该动画是否为循环播放的动画、定义size_t类型变量 <strong>idx_frame</strong> 作为帧索引，定义Timer类 <strong>timer</strong> 来作为实现更新动画帧索引的计时器。</p>\n<p>定义 <code>reset</code> 成员函数来重置动画的状态至初始状态，定义 <code>set_atlas</code> 成员函数来设置动画所使用的图集，定义 <code>set_loop</code> 成员函数来设置动画是否循环播放，定义 <code>set_interval</code> 成员函数来设置动画帧与帧之间的帧间隔，也就是 <strong>timer</strong> 的等待时间，定义 <code>on_update</code> 成员函数来实现动画类的更新，包括对 <strong>timer</strong> 的更新（随着 <strong>Animation</strong> 类的功能增加而增加），定义 <code>on_render</code> 成员函数来实现对动画当前帧的渲染。</p>\n<p>完整实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animation</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; PlayCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Animation</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_on_timeout</span>(</span><br><span class=\"line\">\t\t\t[&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tidx_frame++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (idx_frame &gt;= atlas-&gt;<span class=\"built_in\">get_size</span>())</span><br><span class=\"line\">\t\t\t\t\tidx_frame = is_loop ? <span class=\"number\">0</span> : atlas-&gt;<span class=\"built_in\">get_size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Animation</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">restart</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tidx_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_atlas</span><span class=\"params\">(Atlas* atlas)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;atlas = atlas;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_loop</span><span class=\"params\">(<span class=\"type\">bool</span> is_loop)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;is_loop = is_loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_interval</span><span class=\"params\">(<span class=\"type\">double</span> interval)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_wait_time</span>(interval);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_render</span><span class=\"params\">(SDL_Renderer* renderer, <span class=\"type\">const</span> Camera&amp; camera, <span class=\"type\">const</span> SDL_Rect* dstrect, <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_RenderCopy_Camera</span>(camera, renderer, atlas-&gt;<span class=\"built_in\">get_texture</span>(idx_frame), <span class=\"literal\">nullptr</span>, dstrect);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, atlas-&gt;<span class=\"built_in\">get_texture</span>(idx_frame), <span class=\"literal\">nullptr</span>, dstrect);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tTimer timer;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_loop = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> idx_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tAtlas* atlas = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tPlayCallback on_finished;</span><br><span class=\"line\">\t<span class=\"type\">int</span> width_frame = <span class=\"number\">0</span>, height_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<strong>Camera</strong> 类以及 <strong>Timer</strong> 类在上一期<strong>基于SDL的一些实用工具</strong>中已经有详细的实现方法，这里不再赘叙。</p>\n<ul>\n<li><strong>on_render</strong> 中的 <strong>flag</strong> 变量为“是否使用摄像机进行渲染”</li>\n</ul>\n<h2 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h2><p>学习过大V老师的村庄保卫战的伙伴们应该有了解到 <strong>ResourcesManager</strong> 类中的各种 <strong>pool</strong>，类似于“池”一样的哈希表用于存储游戏所使用的资源，那么我们是否可以在 <strong>ResourcesManager</strong> 类中也定义一个存储 <strong>Atlas</strong> 类的 <strong>atlas_pool</strong> 呢？</p>\n<p>首先，我们在 <strong>ResID</strong> 枚举类中定义我们所要加载的图集类的ID，再为我们的存储 <strong>Atlas</strong> 类的哈希表定义一个别名 <strong>AtlasPool</strong> ，于是，在 <code>load_from_file</code>函数中，我们便可以像这样将 <strong>Atlas</strong> 类加载到 <strong>atlas_pool</strong> 中了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Atlas* atlas_menu_background = <span class=\"keyword\">new</span> <span class=\"built_in\">Atlas</span>();</span><br><span class=\"line\">\tatlas_menu_background-&gt;<span class=\"built_in\">load_from_file</span>(renderer, <span class=\"string\">&quot;resources/background/menu_background_%d.png&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tatlas_pool[ResID::Atlas_MenuBackground] = atlas_menu_background;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>这里是suang的<strong>基于SDL的一些实用工具</strong>的第二部分—— <strong>Atlas</strong> 和 <strong>Animation</strong>，以及对他们的加载、更新、渲染等操作。</p>\n<div style=\"text-align:center\">\n\n<p><img src=\"/articles/suang/SDL_utils_2/rabbit_hole.png\" alt=\"兔兔这么可爱！\"></p>\n</div>","more":"<h2 id=\"一、-Atlas\"><a href=\"#一、-Atlas\" class=\"headerlink\" title=\"一、 Atlas\"></a>一、 Atlas</h2><p>首先，明确 <strong>Atlas</strong> 类需要的成员变量以及成员方法，我们需要一个容器去容纳我们所需要的 <strong>Texture</strong> ，定义私有变量 <code>std::vector&lt;SDL_Texture*&gt; tex_list</code>。在有了纹理的容器后，需要 <code>load_from_file</code> 函数来将所需的纹理加载到容器中，我们使用 <code>sprintf</code> 函数来实现对path模板进行操作，具体实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer, std::string path_template, <span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\ttex_list.<span class=\"built_in\">resize</span>(num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">char</span> path_file[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(path_file, path_template.<span class=\"built_in\">c_str</span>(), i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\ttex_list[i] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, path_file);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>随后，我们定义 <code>clear</code> 成员函数来清空容器，定义 <code>get_size</code> 成员函数来获取容器的大小， 定义 <code>get_texture</code> 成员函数来获取索引为 <strong>idx</strong> 的纹理的指针，定义 <code>add_texture</code> 成员函数来向容器中添加纹理。</p>\n<p>至此， <strong>Atlas</strong> 类便已经实现，完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Atlas</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Atlas</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Atlas</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer, std::string path_template, <span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">resize</span>(num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">char</span> path_file[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num; ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">sprintf</span>(path_file, path_template.<span class=\"built_in\">c_str</span>(), i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\ttex_list[i] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, path_file);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">get_size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tex_list.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">SDL_Texture* <span class=\"title\">get_texture</span><span class=\"params\">(<span class=\"type\">size_t</span> idx)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span> || idx &gt;= tex_list.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tex_list[idx];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_texture</span><span class=\"params\">(SDL_Texture* texture)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttex_list.<span class=\"built_in\">push_back</span>(texture);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tstd::vector&lt;SDL_Texture*&gt; tex_list;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、-Animation\"><a href=\"#二、-Animation\" class=\"headerlink\" title=\"二、 Animation\"></a>二、 Animation</h2><p>在提瓦特幸存者、植物全明星、村庄保卫战以及我制作的俄罗斯方块中，动画都是以连续的快速播放的图片的形式存在的，都是通过视觉暂留效应来达到连续的动画效果，因此，在 <strong>Animation</strong> 类中，我们需要持有动画所需的图集。因此，在私有变量中定义 <code>Atlas* atlas</code>，但是千万不要忘记在使用 <strong>Animation</strong> 类之前对 <strong>atlas</strong> 进行赋值。</p>\n<p>接下来，我们定义bool类形变量 <strong>is_loop</strong> 来描述该动画是否为循环播放的动画、定义size_t类型变量 <strong>idx_frame</strong> 作为帧索引，定义Timer类 <strong>timer</strong> 来作为实现更新动画帧索引的计时器。</p>\n<p>定义 <code>reset</code> 成员函数来重置动画的状态至初始状态，定义 <code>set_atlas</code> 成员函数来设置动画所使用的图集，定义 <code>set_loop</code> 成员函数来设置动画是否循环播放，定义 <code>set_interval</code> 成员函数来设置动画帧与帧之间的帧间隔，也就是 <strong>timer</strong> 的等待时间，定义 <code>on_update</code> 成员函数来实现动画类的更新，包括对 <strong>timer</strong> 的更新（随着 <strong>Animation</strong> 类的功能增加而增加），定义 <code>on_render</code> 成员函数来实现对动画当前帧的渲染。</p>\n<p>完整实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animation</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> std::function&lt;<span class=\"type\">void</span>()&gt; PlayCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Animation</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_on_timeout</span>(</span><br><span class=\"line\">\t\t\t[&amp;]()</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tidx_frame++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (idx_frame &gt;= atlas-&gt;<span class=\"built_in\">get_size</span>())</span><br><span class=\"line\">\t\t\t\t\tidx_frame = is_loop ? <span class=\"number\">0</span> : atlas-&gt;<span class=\"built_in\">get_size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">Animation</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">restart</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tidx_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_atlas</span><span class=\"params\">(Atlas* atlas)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;atlas = atlas;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_loop</span><span class=\"params\">(<span class=\"type\">bool</span> is_loop)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;is_loop = is_loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_interval</span><span class=\"params\">(<span class=\"type\">double</span> interval)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">set_wait_time</span>(interval);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">double</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\ttimer.<span class=\"built_in\">on_update</span>(delta);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_render</span><span class=\"params\">(SDL_Renderer* renderer, <span class=\"type\">const</span> Camera&amp; camera, <span class=\"type\">const</span> SDL_Rect* dstrect, <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_RenderCopy_Camera</span>(camera, renderer, atlas-&gt;<span class=\"built_in\">get_texture</span>(idx_frame), <span class=\"literal\">nullptr</span>, dstrect);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">SDL_RenderCopy</span>(renderer, atlas-&gt;<span class=\"built_in\">get_texture</span>(idx_frame), <span class=\"literal\">nullptr</span>, dstrect);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tTimer timer;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_loop = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> idx_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tAtlas* atlas = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tPlayCallback on_finished;</span><br><span class=\"line\">\t<span class=\"type\">int</span> width_frame = <span class=\"number\">0</span>, height_frame = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<strong>Camera</strong> 类以及 <strong>Timer</strong> 类在上一期<strong>基于SDL的一些实用工具</strong>中已经有详细的实现方法，这里不再赘叙。</p>\n<ul>\n<li><strong>on_render</strong> 中的 <strong>flag</strong> 变量为“是否使用摄像机进行渲染”</li>\n</ul>\n<h2 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h2><p>学习过大V老师的村庄保卫战的伙伴们应该有了解到 <strong>ResourcesManager</strong> 类中的各种 <strong>pool</strong>，类似于“池”一样的哈希表用于存储游戏所使用的资源，那么我们是否可以在 <strong>ResourcesManager</strong> 类中也定义一个存储 <strong>Atlas</strong> 类的 <strong>atlas_pool</strong> 呢？</p>\n<p>首先，我们在 <strong>ResID</strong> 枚举类中定义我们所要加载的图集类的ID，再为我们的存储 <strong>Atlas</strong> 类的哈希表定义一个别名 <strong>AtlasPool</strong> ，于是，在 <code>load_from_file</code>函数中，我们便可以像这样将 <strong>Atlas</strong> 类加载到 <strong>atlas_pool</strong> 中了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">load_from_file</span><span class=\"params\">(SDL_Renderer* renderer)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Atlas* atlas_menu_background = <span class=\"keyword\">new</span> <span class=\"built_in\">Atlas</span>();</span><br><span class=\"line\">\tatlas_menu_background-&gt;<span class=\"built_in\">load_from_file</span>(renderer, <span class=\"string\">&quot;resources/background/menu_background_%d.png&quot;</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tatlas_pool[ResID::Atlas_MenuBackground] = atlas_menu_background;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"c++输入输出","date":"2024-07-12T16:00:00.000Z","updated":"2024-07-12T16:00:00.000Z","_content":"\n\n\n> 学校对于这一节并没有教，当时看也只是模仿了上面的案例，不是很懂。现在在VoidMatrix的塔防教程中看到了这方面知识点相关，就想相对了解一下\n\n~~~CPP\nstd::fstream file(path);\t\t\t\nif (!file.good())return  false;\n\nstd::stringstream str_stream;\t\t\t\nstr_stream << file.rdbuf();\t\t\t\nfile.close();\t\t\t\t\t\t\n\ncJSON* json_root = cJSON_Parse(str_stream.str().c_str());\n~~~\n\n主要弄明白这一段代码的意思。\n\n<!-- More -->\n\n---\n\nC++的输入输出主要分为三大类：\n\n1. **基于控制台的输入和输出**：从标准的输入设备（键盘）获得数据，把程序的执行结果输出到标准的输出设备（显示器）\n2. **基于文件的输入和输出**：从外储存器文件获取数据或把数据存入外储存器的文件\n3. **基于字符串的输入和输出**：从程序string类型的变量获取数据或把数据存于string类型的变量\n\n这些输入和输出都是由**c++标准库**提供的。\n\n---\n\n## 流与标准库\n\n**输入流**：输入操作中，字节从设备流向内存\n\n**输出流**：输出操作中，字节从内存流向设备\n\n\n\nC++的输入输出类主要包含在三个头文件中（注意输入输出是一个类，是一个可以实例化的对象）\n\n1. **iostream**：基于控制台的输入和输出\n2. **fstream**：基于文件的输入和输出\n3. **sstream**：基于字符串的输入和输出\n\n\n\n<div style=\"text-align:center\">\n输入输出标准库及其头文件类型\n</div>\n\n- **iostream**（头文件）\n\n1. *istream*:控制台输入流类，他的对象代表一个输入设备\n2. *ostream*:控制台输出流类，他的对象代表一个输出设备\n3. *iostream*:控制台输入输出流类，他的对象代表一个输入或输出设备，这个类是由istream和ostream共同派生\n\n- **fstream**（头文件）\n\n1. *ifstream*:输入文件流类，他的对象代表一个输入文件，由istream派生而来\n2. *ofstream*:输出文件流类，他的对象代表一个输出文件，由ostream派生而来\n3. *fstream*:输入输出文件流类，他的对象代表一个输入或输出文件，这个类是由iostream共同派生\n\n- **sstream**（头文件）\n\n1. *istringstream*:输入字符串类，由istream派生而来\n2. *ostringstrea*:输出字符串类，由ostream派生而来\n3. *stringstream*:输入输出字符串类，由iostream派生而来\n\n---\n\n##  输入和输出缓冲\n\n程序只能访问内存中的信息，而不能访问外部设备中的信息。\n\n所以外部设备的信息会先存入内存再被程序访问，程序的输出也同样会放在内存再流向外部设备\n\n内存中存放这些数据的区域被称为**输入和输出缓冲区**\n\n<img src=\"./image-20240622105847430.png\" alt=\"image-20240622105847430\" style=\"zoom: 80%;\" />\n\n以下几种情况会使缓冲区的内容被刷新\n\n1. 程序正常结束\n2. 缓冲区已满，再写入下一个值时会清空\n3. 用标准库的操作符，如endl\n4. 输入和输出流关联起来。在读入输出流时，会自动清空输入缓冲区。\n\n缓冲对象主要分为三类：\n\n**streambuf**\n\n> - `std::streambuf` 是**基类**，定义了输入输出的基本接口。\n> - `std::stringbuf` 和 `std::filebuf` 是 `std::streambuf` 的派生类，提供了具体的字符串和文件缓冲区的实现。\n> - `std::streambuf` 本身不能直接使用，需要通过其派生类（如 `std::stringbuf`、`std::filebuf`）来进行实际的输入输出操作。\n\n**filebuf**\n\n> - `std::filebuf` 是用于处理文件缓冲区的类，用于文件的读写操作。\n> - 可以将 `std::filebuf` 对象绑定到文件流上，与文件系统进行交互，实现文件数据的读写。\n> - 可以设置文件打开模式、操作文件指针等文件操作相关功能。\n\n**stringbuf**\n\n>- `std::stringbuf` 是用于处理字符串缓冲区的类，可以在内存中动态创建和修改字符串数据。\n>- 是基于内存的字符串缓冲区，在内存中管理字符串数据。\n>- 主要用于处理字符串数据的输入输出操作，可以通过 `std::stringstream` 方便地对字符串数据进行读写。\n\n---\n\n## 各个流对象以及缓冲的关系\n\n<img src=\"./Center.jpeg\" alt=\"关系图\" />\n\n1. 对于所有的流对象，不难看出都是基于虚基类ios_base派生而来，不同的流对象用于不同的输入和输出。\n2. 而每一个流对象都有个专门的类去管理缓冲区对象，完全可以通过**流对象.rdbuf()**观察其返回值。主要就是**iostream**和**stringstream**和**fstream**三个各自管理缓冲的类。\n\n\n\n<img src=\"./屏幕截图 2024-07-13 151655.png\" alt=\"屏幕截图 2024-07-13 151655\" style=\"zoom: 80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151711.png\" alt=\"屏幕截图 2024-07-13 151711\" style=\"zoom:80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151721.png\" alt=\"屏幕截图 2024-07-13 151721\" style=\"zoom: 67%;\" />\n\n\n\n\n---\n\n## 基于文件的输入和输出\n\n### 文件的概念\n\n文件是驻留在外存储器上，具有一个标识名和一组信息的集合，用于永久保存数据。\n\n与文件相关的概念：\n\n1. **数据项**：数据的基本单位，表示一个有意义的信息，如一个整型数，一个字符串。\n2. **记录**：若干个相关的数据项组成一个记录，每个记录可以堪称一个对象\n3. **文件**：记录的集合\n4. **数据库**：一组相关的文件。\n\n例如图书管理系统中，数据库包含书目文件，读者文件和其他辅助文件。书目文件中的每本书的信息构成一条记录。\n\n每条记录中的书名，作者都是数据项。\n\n\n\n### 文件和流\n\n> 对于c++来说，文件就是一个个字节序列构成，每一个文件以文件结束符（End Of File ，EOF）结束，这种文件称为流式文件。\n>\n> 可以与字符串进行类比，只不过字符串结尾是'\\0'罢了\n>\n> C++文件类型又分为二进制文件和ASCLL文件，对于ASCLL文件在读写时会在**内存表示**和**文本**之间进行转换。\n>\n> 二进制文件保存到则是数据在内存中的表示，直接交换数据，不执行任何转换。\n\n访问文件主要有以下四个步骤\n\n1. 定义一个流文件对象\n2. 打开文件（将文件和流文件对象相关联）\n3. 操作文件的数据\n4. 关闭文件\n\n#### 1.定义文件流对象\n\nC++有三个流文件类型：\n\nifstream:输入文件流，但程序从文件读入数据时，必须要定义一个ifstream类的对象与文件关联\n\n0fstream:输出文件流，但程序输出数据到文件时，必须要定义一个ofstream类的对象与文件关联\n\nfstream:输入输出文件流，fstream类的对象既可以读也可以写\n\n~~~CPP\nifstream infile；//定义了一个输入文件流对象\n~~~\n\n#### 2.打开和关闭文件\n\n文件流对象除了从istream和ostream继承下来的行为，还新增了俩个成员函数：open（打开文件），close（关闭文件），以及一个构造函数。\n\n**打开文件**是将文件流对象与外存的某一文件关联起来，为文件的读写做好准备，例如：为文件流对象准备缓冲区，记录读写位置。\n\n打开文件使用open函数（也可以定义流文件对象时通过构造函数）\n\nopen函数有俩个参数：\n\n1. 文件名（c语言风格的字符串）\n2. 文件的打开模式\n\n~~~CPP\ninflie.open(\"文件名\"，文件打开模式)；\n~~~\n\n\n\n| 文件打开模式 | 含义                                                |\n| ------------ | --------------------------------------------------- |\n| in           | 打开文件，做读操作（只适用于ifstream和fstream类）   |\n| out          | 打开文件，做写操作（只适用于ofstream和fstream类）   |\n| app          | 在文件尾后面添加（只适用于ofstream和fstream类）     |\n| ate          | 打开文件后，立即将文件定位在文件尾i（所有类都有用） |\n| trunc        | 打开文件后，清空文件（只适用于ofstream和fstream类） |\n| binary       | 以二进制模式进行输入和输入，默认为ASCLL文件         |\n\n每个文件流类都有默认的打开方式（就是自己不传入第二个参数时）:\n\n- ifstream：以in模式默认打开\n- ofstream：以out模式打开\n- fstream：以in|out（既可读也可写）模式打开\n\n~~~CPP\n#include <fstream>\n#include <ifstream>\n#include <ofstream>\n\n//打开一种是open函数，另一种就是申明的时候直接构造\nifstream infile1;\ninfile1.open(\"file1\");\t//或者infile.open(\"file1\",ifstream::in);\nifstream infile2(\"file2\");\t//或者infile2(\"file2\",ifstream::in);\n\nofstream outfile1;\noutfile1.open(\"file1\");\t//或者outfile.open(\"file1\",ifstream::out);\nofstream outfile2(\"file2\");\t//或者infile2(\"file2\",ifstream::out);\n//注意当用out打开文件的时候，会自动清空文件（要写入文件时）\noutfile1.open(\"file1\"，ofstream::app);//如果要要向file2添加数据，则需要app打开方式\n\n//有时候既需要读也需要写，就选择fstream\nfstream infile1(\"file1\",fstream::in|fstream::out);\n//fstream默认以in和out的方式打开，且这种情况下不会清空文件。\n//如果只以out或者指定了truc模式，打开都会清空文件\n~~~\n\n\n\n**TIPS**：在打开文件后的操作，有一个良好的习惯就是检查文件是否打开成功。若打开成功，则流对象会是一个非零值，反之若未成功打开，则是一个零值。\n\n~~~CPP\n//在项目中我们使用的是,fstream的函数good检查文件是否打开成功\nfile.good();\n~~~\n\n\n\n在读写操作完时有比要显式的关闭文件。\n\n~~~CPP\ninfile.close();\n~~~\n\n表示流对象与文件断开关系，不在读写数据。\n\n\n\n#### 补充：\n\n其实流对象和文件的过程其实是**缓冲对象与文件建立的过程**，**缓冲对象关联在流对象里**(后面提到的打开模式in|out啥的，其实是**针对filebuf**)\n\n所以下面的大体是可以看作一样的\n\n~~~CPP\n#include <iostream>\n#include <fstream>\n\nint main() {\n    // 创建一个 std::filebuf 对象并打开文件\n    std::filebuf filebuf;\n    filebuf.open(\"example.txt\", std::ios::out);\n    // 创建一个 std::fstream 对象并关联到 filebuf\n    std::fstream fstream;\n    fstream.rdbuf(&filebuf);\n    // 使用 fstream 写入数据到 filebuf 关联的文件\n    fstream << \"Hello, World!\";\n    // 关闭文件\n    filebuf.close();\n    return 0;\n}\n~~~\n\n~~~CPP\n#include <iostream>\n#include <fstream>\nint main() {\n    std::fstream fstream;\n    fstream.open(\"example.txt\");\n    fstream << \"Hello, World!\";\n    filebuf.close();\n    return 0;\n}\n~~~\n\n\n\n<img src=\"./image-20240713155355573.png\" alt=\"image-20240713155355573\" style=\"zoom: 67%;\" />\n\n#### 3.fstream的读取和写入\n\n对于文件的读取和写入应该是有很多方法的，不论是调用类内的函数，还是用外部getline（fstream，string）一行一行的读取或是其他，抑或是流操作符>>写入文件当前文件内指针指向的位置。日后有时间慢慢补，这里就只展示一段项目使用到的读取fstream吧\n\n~~~CPP\nstd::fstream file(path);\t\t\t//打开地图的csv文件\nstd::string str_line;\t\t//csv文件的getline都是按行读的\nwhile (std::getline(file, str_line))//每次读取file的一行，写入string对象\n{\n\t......//一行一行读取csv文件，并且写入瓦片数据\n}\n~~~\n\n---\n\n## 基于字符串的输入输出\n\n这里就只简单介绍stringstream类\n\n`std::stringstream` 是 C++ 标准库中的一个类，它提供了一个方便的方式来处理字符串和流。主要用途包括以下几个方面：\n\n1. 将其他类型转换为字符串：`std::stringstream` 可以将基本数据类型（如 `int`、`double` 等）或自定义类型转换为字符串形式。通过输入流操作符 `<<` 将数据插入到 `std::stringstream` 中，当然也可以将可以从一个字符串中提取数据，并将其转换为其他类型。然后可以通过 `str()` 函数获取到整个字符串。这种功能对于将其他类型转换为字符串输出或者进行字符串拼接非常有用。\n\n   ~~~CPP\n   #include <sstream>\n   #include <iostream>\n   #include <string>\n    \n   int main() {\n       int num = 123;\n       std::stringstream ss;\n       ss << num; // 将整数放入流中（转化为字符串存入）\n       std::string str = ss.str(); // 使用str()函数 从流中提取字符串\n       std::cout << str << std::endl; // 输出：123\n       \n       //拼接\n       ss<<num;\n       std::cout << ss.str() << std::endl; // 输出：123123\n       \n       ss.str(\"\");//清空\n       ss<<\"246\";\n       ss>>num;\t//自动将字符串转化为变量对应的类型写入变量\n       std::cout<<num;//输出123\n   }\n   ~~~\n\n2. 中间缓冲：std::stringstream 可以作为中间缓冲区来处理字符串数据。可以将不同的数据类型、格式化文本等按顺序插入到 std::stringstream 中，在最后一次性输出或处理整个字符串数据。这样可以更加灵活和高效地操作字符串内容。\n\n3. 字符串处理：通过 std::stringstream 的接口函数，可以对字符串进行各种操作，如插入、删除、替换等。这使得对字符串的处理更加方便和高效。\n\n#### 常用的读取方式\n\n~~~CPP\n#include <iostream>\n#include <sstream>\nusing namespace std;\n \nint main()\n{\n    stringstream ss(\"hello world\");\n  \n    string str;\n    // 注意： stringstream 是一个单词一个单词 ”流入“ string 的，就是以空格为停止\n    while (ss >> str)\n    {\n        cout << str << endl;\n    }\n    \n    //这个和上面一样，以空格为分割字符不断读入（get和getline的读取之后也可以整理一下）\n    //注意分隔符是字符，不是字符串\n    while(getline(ss,str,' '))\n    {\n        cout<<str<<endl;\n    }\n    \n    return 0;\n}\n \n/*\nhello \nworld\n*/\n~~~\n\n---\n\n最后就分析一下项目代码\n\n~~~CPP\nstd::fstream file(path);\t\t\t//其实文件打开就是加载到缓存（内存中的一块地方）\nif (!file.good())return  false;\n\nstd::stringstream str_stream;\t\t//创建对应的流字符串来对文件的缓存的内容读入读出，string是不可以进行流操作的\t\t\nstr_stream << file.rdbuf();\t\t\t//让对应的流字符串对象读取文件所有内容（rdbuf，其实就是readbuffer，读取缓存）\nfile.close();\t\t\t\t\t\t//读取后文件关闭\n\ncJSON* json_root = cJSON_Parse(str_stream.str().c_str());\t//paese（解析），以cJSON去解析这些数据，参数是C语言风格的字符串。\n~~~\n\n1. 以fstream对象打开文件\n\n2. 将file文件的内容写入stringstream对象\n\n   > file.rdbuf();返回的是与文件关联的缓冲对象filebuf*(指针).\n   >\n   > 应该是stringstream有重载<<运算符(关于filebuf*),可以从filebuf关联的文件中读取所有内容进入stringstream对象\n\n3. 读取后关闭文件\n\n4. 将stringstream对象转换为string,再进一步转化为char* (c语言风格字符串),最后利用cJSON库将其转化为cJSON对象,之后就可以利用其指针json_root读取json文件格式了\n\n\n\n**总结**:在我看来,在文件的格式的转化中,stringstream就相当于在转换中建立了桥梁,fstream帮忙打开文件,stringstream负责读取流文件的内容,最后再根据stringstream对象转换为string进一步char*,供cjson读取,成功获取了我们需要的json格式的内容.\n","source":"_posts/yang/c++输入与输出.md","raw":"---\ntitle: c++输入输出\ndate: 2024-07-13\nupdated: 2024-07-13\npermalink: articles/yang12342/cpp的输入与输出/\ncategories: yang12342\ntags: [c++语法]\n---\n\n\n\n> 学校对于这一节并没有教，当时看也只是模仿了上面的案例，不是很懂。现在在VoidMatrix的塔防教程中看到了这方面知识点相关，就想相对了解一下\n\n~~~CPP\nstd::fstream file(path);\t\t\t\nif (!file.good())return  false;\n\nstd::stringstream str_stream;\t\t\t\nstr_stream << file.rdbuf();\t\t\t\nfile.close();\t\t\t\t\t\t\n\ncJSON* json_root = cJSON_Parse(str_stream.str().c_str());\n~~~\n\n主要弄明白这一段代码的意思。\n\n<!-- More -->\n\n---\n\nC++的输入输出主要分为三大类：\n\n1. **基于控制台的输入和输出**：从标准的输入设备（键盘）获得数据，把程序的执行结果输出到标准的输出设备（显示器）\n2. **基于文件的输入和输出**：从外储存器文件获取数据或把数据存入外储存器的文件\n3. **基于字符串的输入和输出**：从程序string类型的变量获取数据或把数据存于string类型的变量\n\n这些输入和输出都是由**c++标准库**提供的。\n\n---\n\n## 流与标准库\n\n**输入流**：输入操作中，字节从设备流向内存\n\n**输出流**：输出操作中，字节从内存流向设备\n\n\n\nC++的输入输出类主要包含在三个头文件中（注意输入输出是一个类，是一个可以实例化的对象）\n\n1. **iostream**：基于控制台的输入和输出\n2. **fstream**：基于文件的输入和输出\n3. **sstream**：基于字符串的输入和输出\n\n\n\n<div style=\"text-align:center\">\n输入输出标准库及其头文件类型\n</div>\n\n- **iostream**（头文件）\n\n1. *istream*:控制台输入流类，他的对象代表一个输入设备\n2. *ostream*:控制台输出流类，他的对象代表一个输出设备\n3. *iostream*:控制台输入输出流类，他的对象代表一个输入或输出设备，这个类是由istream和ostream共同派生\n\n- **fstream**（头文件）\n\n1. *ifstream*:输入文件流类，他的对象代表一个输入文件，由istream派生而来\n2. *ofstream*:输出文件流类，他的对象代表一个输出文件，由ostream派生而来\n3. *fstream*:输入输出文件流类，他的对象代表一个输入或输出文件，这个类是由iostream共同派生\n\n- **sstream**（头文件）\n\n1. *istringstream*:输入字符串类，由istream派生而来\n2. *ostringstrea*:输出字符串类，由ostream派生而来\n3. *stringstream*:输入输出字符串类，由iostream派生而来\n\n---\n\n##  输入和输出缓冲\n\n程序只能访问内存中的信息，而不能访问外部设备中的信息。\n\n所以外部设备的信息会先存入内存再被程序访问，程序的输出也同样会放在内存再流向外部设备\n\n内存中存放这些数据的区域被称为**输入和输出缓冲区**\n\n<img src=\"./image-20240622105847430.png\" alt=\"image-20240622105847430\" style=\"zoom: 80%;\" />\n\n以下几种情况会使缓冲区的内容被刷新\n\n1. 程序正常结束\n2. 缓冲区已满，再写入下一个值时会清空\n3. 用标准库的操作符，如endl\n4. 输入和输出流关联起来。在读入输出流时，会自动清空输入缓冲区。\n\n缓冲对象主要分为三类：\n\n**streambuf**\n\n> - `std::streambuf` 是**基类**，定义了输入输出的基本接口。\n> - `std::stringbuf` 和 `std::filebuf` 是 `std::streambuf` 的派生类，提供了具体的字符串和文件缓冲区的实现。\n> - `std::streambuf` 本身不能直接使用，需要通过其派生类（如 `std::stringbuf`、`std::filebuf`）来进行实际的输入输出操作。\n\n**filebuf**\n\n> - `std::filebuf` 是用于处理文件缓冲区的类，用于文件的读写操作。\n> - 可以将 `std::filebuf` 对象绑定到文件流上，与文件系统进行交互，实现文件数据的读写。\n> - 可以设置文件打开模式、操作文件指针等文件操作相关功能。\n\n**stringbuf**\n\n>- `std::stringbuf` 是用于处理字符串缓冲区的类，可以在内存中动态创建和修改字符串数据。\n>- 是基于内存的字符串缓冲区，在内存中管理字符串数据。\n>- 主要用于处理字符串数据的输入输出操作，可以通过 `std::stringstream` 方便地对字符串数据进行读写。\n\n---\n\n## 各个流对象以及缓冲的关系\n\n<img src=\"./Center.jpeg\" alt=\"关系图\" />\n\n1. 对于所有的流对象，不难看出都是基于虚基类ios_base派生而来，不同的流对象用于不同的输入和输出。\n2. 而每一个流对象都有个专门的类去管理缓冲区对象，完全可以通过**流对象.rdbuf()**观察其返回值。主要就是**iostream**和**stringstream**和**fstream**三个各自管理缓冲的类。\n\n\n\n<img src=\"./屏幕截图 2024-07-13 151655.png\" alt=\"屏幕截图 2024-07-13 151655\" style=\"zoom: 80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151711.png\" alt=\"屏幕截图 2024-07-13 151711\" style=\"zoom:80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151721.png\" alt=\"屏幕截图 2024-07-13 151721\" style=\"zoom: 67%;\" />\n\n\n\n\n---\n\n## 基于文件的输入和输出\n\n### 文件的概念\n\n文件是驻留在外存储器上，具有一个标识名和一组信息的集合，用于永久保存数据。\n\n与文件相关的概念：\n\n1. **数据项**：数据的基本单位，表示一个有意义的信息，如一个整型数，一个字符串。\n2. **记录**：若干个相关的数据项组成一个记录，每个记录可以堪称一个对象\n3. **文件**：记录的集合\n4. **数据库**：一组相关的文件。\n\n例如图书管理系统中，数据库包含书目文件，读者文件和其他辅助文件。书目文件中的每本书的信息构成一条记录。\n\n每条记录中的书名，作者都是数据项。\n\n\n\n### 文件和流\n\n> 对于c++来说，文件就是一个个字节序列构成，每一个文件以文件结束符（End Of File ，EOF）结束，这种文件称为流式文件。\n>\n> 可以与字符串进行类比，只不过字符串结尾是'\\0'罢了\n>\n> C++文件类型又分为二进制文件和ASCLL文件，对于ASCLL文件在读写时会在**内存表示**和**文本**之间进行转换。\n>\n> 二进制文件保存到则是数据在内存中的表示，直接交换数据，不执行任何转换。\n\n访问文件主要有以下四个步骤\n\n1. 定义一个流文件对象\n2. 打开文件（将文件和流文件对象相关联）\n3. 操作文件的数据\n4. 关闭文件\n\n#### 1.定义文件流对象\n\nC++有三个流文件类型：\n\nifstream:输入文件流，但程序从文件读入数据时，必须要定义一个ifstream类的对象与文件关联\n\n0fstream:输出文件流，但程序输出数据到文件时，必须要定义一个ofstream类的对象与文件关联\n\nfstream:输入输出文件流，fstream类的对象既可以读也可以写\n\n~~~CPP\nifstream infile；//定义了一个输入文件流对象\n~~~\n\n#### 2.打开和关闭文件\n\n文件流对象除了从istream和ostream继承下来的行为，还新增了俩个成员函数：open（打开文件），close（关闭文件），以及一个构造函数。\n\n**打开文件**是将文件流对象与外存的某一文件关联起来，为文件的读写做好准备，例如：为文件流对象准备缓冲区，记录读写位置。\n\n打开文件使用open函数（也可以定义流文件对象时通过构造函数）\n\nopen函数有俩个参数：\n\n1. 文件名（c语言风格的字符串）\n2. 文件的打开模式\n\n~~~CPP\ninflie.open(\"文件名\"，文件打开模式)；\n~~~\n\n\n\n| 文件打开模式 | 含义                                                |\n| ------------ | --------------------------------------------------- |\n| in           | 打开文件，做读操作（只适用于ifstream和fstream类）   |\n| out          | 打开文件，做写操作（只适用于ofstream和fstream类）   |\n| app          | 在文件尾后面添加（只适用于ofstream和fstream类）     |\n| ate          | 打开文件后，立即将文件定位在文件尾i（所有类都有用） |\n| trunc        | 打开文件后，清空文件（只适用于ofstream和fstream类） |\n| binary       | 以二进制模式进行输入和输入，默认为ASCLL文件         |\n\n每个文件流类都有默认的打开方式（就是自己不传入第二个参数时）:\n\n- ifstream：以in模式默认打开\n- ofstream：以out模式打开\n- fstream：以in|out（既可读也可写）模式打开\n\n~~~CPP\n#include <fstream>\n#include <ifstream>\n#include <ofstream>\n\n//打开一种是open函数，另一种就是申明的时候直接构造\nifstream infile1;\ninfile1.open(\"file1\");\t//或者infile.open(\"file1\",ifstream::in);\nifstream infile2(\"file2\");\t//或者infile2(\"file2\",ifstream::in);\n\nofstream outfile1;\noutfile1.open(\"file1\");\t//或者outfile.open(\"file1\",ifstream::out);\nofstream outfile2(\"file2\");\t//或者infile2(\"file2\",ifstream::out);\n//注意当用out打开文件的时候，会自动清空文件（要写入文件时）\noutfile1.open(\"file1\"，ofstream::app);//如果要要向file2添加数据，则需要app打开方式\n\n//有时候既需要读也需要写，就选择fstream\nfstream infile1(\"file1\",fstream::in|fstream::out);\n//fstream默认以in和out的方式打开，且这种情况下不会清空文件。\n//如果只以out或者指定了truc模式，打开都会清空文件\n~~~\n\n\n\n**TIPS**：在打开文件后的操作，有一个良好的习惯就是检查文件是否打开成功。若打开成功，则流对象会是一个非零值，反之若未成功打开，则是一个零值。\n\n~~~CPP\n//在项目中我们使用的是,fstream的函数good检查文件是否打开成功\nfile.good();\n~~~\n\n\n\n在读写操作完时有比要显式的关闭文件。\n\n~~~CPP\ninfile.close();\n~~~\n\n表示流对象与文件断开关系，不在读写数据。\n\n\n\n#### 补充：\n\n其实流对象和文件的过程其实是**缓冲对象与文件建立的过程**，**缓冲对象关联在流对象里**(后面提到的打开模式in|out啥的，其实是**针对filebuf**)\n\n所以下面的大体是可以看作一样的\n\n~~~CPP\n#include <iostream>\n#include <fstream>\n\nint main() {\n    // 创建一个 std::filebuf 对象并打开文件\n    std::filebuf filebuf;\n    filebuf.open(\"example.txt\", std::ios::out);\n    // 创建一个 std::fstream 对象并关联到 filebuf\n    std::fstream fstream;\n    fstream.rdbuf(&filebuf);\n    // 使用 fstream 写入数据到 filebuf 关联的文件\n    fstream << \"Hello, World!\";\n    // 关闭文件\n    filebuf.close();\n    return 0;\n}\n~~~\n\n~~~CPP\n#include <iostream>\n#include <fstream>\nint main() {\n    std::fstream fstream;\n    fstream.open(\"example.txt\");\n    fstream << \"Hello, World!\";\n    filebuf.close();\n    return 0;\n}\n~~~\n\n\n\n<img src=\"./image-20240713155355573.png\" alt=\"image-20240713155355573\" style=\"zoom: 67%;\" />\n\n#### 3.fstream的读取和写入\n\n对于文件的读取和写入应该是有很多方法的，不论是调用类内的函数，还是用外部getline（fstream，string）一行一行的读取或是其他，抑或是流操作符>>写入文件当前文件内指针指向的位置。日后有时间慢慢补，这里就只展示一段项目使用到的读取fstream吧\n\n~~~CPP\nstd::fstream file(path);\t\t\t//打开地图的csv文件\nstd::string str_line;\t\t//csv文件的getline都是按行读的\nwhile (std::getline(file, str_line))//每次读取file的一行，写入string对象\n{\n\t......//一行一行读取csv文件，并且写入瓦片数据\n}\n~~~\n\n---\n\n## 基于字符串的输入输出\n\n这里就只简单介绍stringstream类\n\n`std::stringstream` 是 C++ 标准库中的一个类，它提供了一个方便的方式来处理字符串和流。主要用途包括以下几个方面：\n\n1. 将其他类型转换为字符串：`std::stringstream` 可以将基本数据类型（如 `int`、`double` 等）或自定义类型转换为字符串形式。通过输入流操作符 `<<` 将数据插入到 `std::stringstream` 中，当然也可以将可以从一个字符串中提取数据，并将其转换为其他类型。然后可以通过 `str()` 函数获取到整个字符串。这种功能对于将其他类型转换为字符串输出或者进行字符串拼接非常有用。\n\n   ~~~CPP\n   #include <sstream>\n   #include <iostream>\n   #include <string>\n    \n   int main() {\n       int num = 123;\n       std::stringstream ss;\n       ss << num; // 将整数放入流中（转化为字符串存入）\n       std::string str = ss.str(); // 使用str()函数 从流中提取字符串\n       std::cout << str << std::endl; // 输出：123\n       \n       //拼接\n       ss<<num;\n       std::cout << ss.str() << std::endl; // 输出：123123\n       \n       ss.str(\"\");//清空\n       ss<<\"246\";\n       ss>>num;\t//自动将字符串转化为变量对应的类型写入变量\n       std::cout<<num;//输出123\n   }\n   ~~~\n\n2. 中间缓冲：std::stringstream 可以作为中间缓冲区来处理字符串数据。可以将不同的数据类型、格式化文本等按顺序插入到 std::stringstream 中，在最后一次性输出或处理整个字符串数据。这样可以更加灵活和高效地操作字符串内容。\n\n3. 字符串处理：通过 std::stringstream 的接口函数，可以对字符串进行各种操作，如插入、删除、替换等。这使得对字符串的处理更加方便和高效。\n\n#### 常用的读取方式\n\n~~~CPP\n#include <iostream>\n#include <sstream>\nusing namespace std;\n \nint main()\n{\n    stringstream ss(\"hello world\");\n  \n    string str;\n    // 注意： stringstream 是一个单词一个单词 ”流入“ string 的，就是以空格为停止\n    while (ss >> str)\n    {\n        cout << str << endl;\n    }\n    \n    //这个和上面一样，以空格为分割字符不断读入（get和getline的读取之后也可以整理一下）\n    //注意分隔符是字符，不是字符串\n    while(getline(ss,str,' '))\n    {\n        cout<<str<<endl;\n    }\n    \n    return 0;\n}\n \n/*\nhello \nworld\n*/\n~~~\n\n---\n\n最后就分析一下项目代码\n\n~~~CPP\nstd::fstream file(path);\t\t\t//其实文件打开就是加载到缓存（内存中的一块地方）\nif (!file.good())return  false;\n\nstd::stringstream str_stream;\t\t//创建对应的流字符串来对文件的缓存的内容读入读出，string是不可以进行流操作的\t\t\nstr_stream << file.rdbuf();\t\t\t//让对应的流字符串对象读取文件所有内容（rdbuf，其实就是readbuffer，读取缓存）\nfile.close();\t\t\t\t\t\t//读取后文件关闭\n\ncJSON* json_root = cJSON_Parse(str_stream.str().c_str());\t//paese（解析），以cJSON去解析这些数据，参数是C语言风格的字符串。\n~~~\n\n1. 以fstream对象打开文件\n\n2. 将file文件的内容写入stringstream对象\n\n   > file.rdbuf();返回的是与文件关联的缓冲对象filebuf*(指针).\n   >\n   > 应该是stringstream有重载<<运算符(关于filebuf*),可以从filebuf关联的文件中读取所有内容进入stringstream对象\n\n3. 读取后关闭文件\n\n4. 将stringstream对象转换为string,再进一步转化为char* (c语言风格字符串),最后利用cJSON库将其转化为cJSON对象,之后就可以利用其指针json_root读取json文件格式了\n\n\n\n**总结**:在我看来,在文件的格式的转化中,stringstream就相当于在转换中建立了桥梁,fstream帮忙打开文件,stringstream负责读取流文件的内容,最后再根据stringstream对象转换为string进一步char*,供cjson读取,成功获取了我们需要的json格式的内容.\n","slug":"yang/c++输入与输出","published":1,"__permalink":"articles/yang12342/cpp的输入与输出/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85j000plcut24uwdvz4","content":"<blockquote>\n<p>学校对于这一节并没有教，当时看也只是模仿了上面的案例，不是很懂。现在在VoidMatrix的塔防教程中看到了这方面知识点相关，就想相对了解一下</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!file.<span class=\"built_in\">good</span>())<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::stringstream str_stream;\t\t\t</span><br><span class=\"line\">str_stream &lt;&lt; file.<span class=\"built_in\">rdbuf</span>();\t\t\t</span><br><span class=\"line\">file.<span class=\"built_in\">close</span>();\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">cJSON* json_root = <span class=\"built_in\">cJSON_Parse</span>(str_stream.<span class=\"built_in\">str</span>().<span class=\"built_in\">c_str</span>());</span><br></pre></td></tr></table></figure>\n\n<p>主要弄明白这一段代码的意思。</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>C++的输入输出主要分为三大类：</p>\n<ol>\n<li><strong>基于控制台的输入和输出</strong>：从标准的输入设备（键盘）获得数据，把程序的执行结果输出到标准的输出设备（显示器）</li>\n<li><strong>基于文件的输入和输出</strong>：从外储存器文件获取数据或把数据存入外储存器的文件</li>\n<li><strong>基于字符串的输入和输出</strong>：从程序string类型的变量获取数据或把数据存于string类型的变量</li>\n</ol>\n<p>这些输入和输出都是由<strong>c++标准库</strong>提供的。</p>\n<hr>\n<h2 id=\"流与标准库\"><a href=\"#流与标准库\" class=\"headerlink\" title=\"流与标准库\"></a>流与标准库</h2><p><strong>输入流</strong>：输入操作中，字节从设备流向内存</p>\n<p><strong>输出流</strong>：输出操作中，字节从内存流向设备</p>\n<p>C++的输入输出类主要包含在三个头文件中（注意输入输出是一个类，是一个可以实例化的对象）</p>\n<ol>\n<li><strong>iostream</strong>：基于控制台的输入和输出</li>\n<li><strong>fstream</strong>：基于文件的输入和输出</li>\n<li><strong>sstream</strong>：基于字符串的输入和输出</li>\n</ol>\n<div style=\"text-align:center\">\n输入输出标准库及其头文件类型\n</div>\n\n<ul>\n<li><strong>iostream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>istream</em>:控制台输入流类，他的对象代表一个输入设备</li>\n<li><em>ostream</em>:控制台输出流类，他的对象代表一个输出设备</li>\n<li><em>iostream</em>:控制台输入输出流类，他的对象代表一个输入或输出设备，这个类是由istream和ostream共同派生</li>\n</ol>\n<ul>\n<li><strong>fstream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>ifstream</em>:输入文件流类，他的对象代表一个输入文件，由istream派生而来</li>\n<li><em>ofstream</em>:输出文件流类，他的对象代表一个输出文件，由ostream派生而来</li>\n<li><em>fstream</em>:输入输出文件流类，他的对象代表一个输入或输出文件，这个类是由iostream共同派生</li>\n</ol>\n<ul>\n<li><strong>sstream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>istringstream</em>:输入字符串类，由istream派生而来</li>\n<li><em>ostringstrea</em>:输出字符串类，由ostream派生而来</li>\n<li><em>stringstream</em>:输入输出字符串类，由iostream派生而来</li>\n</ol>\n<hr>\n<h2 id=\"输入和输出缓冲\"><a href=\"#输入和输出缓冲\" class=\"headerlink\" title=\"输入和输出缓冲\"></a>输入和输出缓冲</h2><p>程序只能访问内存中的信息，而不能访问外部设备中的信息。</p>\n<p>所以外部设备的信息会先存入内存再被程序访问，程序的输出也同样会放在内存再流向外部设备</p>\n<p>内存中存放这些数据的区域被称为<strong>输入和输出缓冲区</strong></p>\n<img src=\"./image-20240622105847430.png\" alt=\"image-20240622105847430\" style=\"zoom: 80%;\" />\n\n<p>以下几种情况会使缓冲区的内容被刷新</p>\n<ol>\n<li>程序正常结束</li>\n<li>缓冲区已满，再写入下一个值时会清空</li>\n<li>用标准库的操作符，如endl</li>\n<li>输入和输出流关联起来。在读入输出流时，会自动清空输入缓冲区。</li>\n</ol>\n<p>缓冲对象主要分为三类：</p>\n<p><strong>streambuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::streambuf</code> 是<strong>基类</strong>，定义了输入输出的基本接口。</li>\n<li><code>std::stringbuf</code> 和 <code>std::filebuf</code> 是 <code>std::streambuf</code> 的派生类，提供了具体的字符串和文件缓冲区的实现。</li>\n<li><code>std::streambuf</code> 本身不能直接使用，需要通过其派生类（如 <code>std::stringbuf</code>、<code>std::filebuf</code>）来进行实际的输入输出操作。</li>\n</ul>\n</blockquote>\n<p><strong>filebuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::filebuf</code> 是用于处理文件缓冲区的类，用于文件的读写操作。</li>\n<li>可以将 <code>std::filebuf</code> 对象绑定到文件流上，与文件系统进行交互，实现文件数据的读写。</li>\n<li>可以设置文件打开模式、操作文件指针等文件操作相关功能。</li>\n</ul>\n</blockquote>\n<p><strong>stringbuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::stringbuf</code> 是用于处理字符串缓冲区的类，可以在内存中动态创建和修改字符串数据。</li>\n<li>是基于内存的字符串缓冲区，在内存中管理字符串数据。</li>\n<li>主要用于处理字符串数据的输入输出操作，可以通过 <code>std::stringstream</code> 方便地对字符串数据进行读写。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"各个流对象以及缓冲的关系\"><a href=\"#各个流对象以及缓冲的关系\" class=\"headerlink\" title=\"各个流对象以及缓冲的关系\"></a>各个流对象以及缓冲的关系</h2><img src=\"./Center.jpeg\" alt=\"关系图\" />\n\n<ol>\n<li>对于所有的流对象，不难看出都是基于虚基类ios_base派生而来，不同的流对象用于不同的输入和输出。</li>\n<li>而每一个流对象都有个专门的类去管理缓冲区对象，完全可以通过<strong>流对象.rdbuf()<strong>观察其返回值。主要就是</strong>iostream</strong>和<strong>stringstream</strong>和<strong>fstream</strong>三个各自管理缓冲的类。</li>\n</ol>\n<img src=\"./屏幕截图 2024-07-13 151655.png\" alt=\"屏幕截图 2024-07-13 151655\" style=\"zoom: 80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151711.png\" alt=\"屏幕截图 2024-07-13 151711\" style=\"zoom:80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151721.png\" alt=\"屏幕截图 2024-07-13 151721\" style=\"zoom: 67%;\" />\n\n\n\n\n<hr>\n<h2 id=\"基于文件的输入和输出\"><a href=\"#基于文件的输入和输出\" class=\"headerlink\" title=\"基于文件的输入和输出\"></a>基于文件的输入和输出</h2><h3 id=\"文件的概念\"><a href=\"#文件的概念\" class=\"headerlink\" title=\"文件的概念\"></a>文件的概念</h3><p>文件是驻留在外存储器上，具有一个标识名和一组信息的集合，用于永久保存数据。</p>\n<p>与文件相关的概念：</p>\n<ol>\n<li><strong>数据项</strong>：数据的基本单位，表示一个有意义的信息，如一个整型数，一个字符串。</li>\n<li><strong>记录</strong>：若干个相关的数据项组成一个记录，每个记录可以堪称一个对象</li>\n<li><strong>文件</strong>：记录的集合</li>\n<li><strong>数据库</strong>：一组相关的文件。</li>\n</ol>\n<p>例如图书管理系统中，数据库包含书目文件，读者文件和其他辅助文件。书目文件中的每本书的信息构成一条记录。</p>\n<p>每条记录中的书名，作者都是数据项。</p>\n<h3 id=\"文件和流\"><a href=\"#文件和流\" class=\"headerlink\" title=\"文件和流\"></a>文件和流</h3><blockquote>\n<p>对于c++来说，文件就是一个个字节序列构成，每一个文件以文件结束符（End Of File ，EOF）结束，这种文件称为流式文件。</p>\n<p>可以与字符串进行类比，只不过字符串结尾是’\\0’罢了</p>\n<p>C++文件类型又分为二进制文件和ASCLL文件，对于ASCLL文件在读写时会在<strong>内存表示</strong>和<strong>文本</strong>之间进行转换。</p>\n<p>二进制文件保存到则是数据在内存中的表示，直接交换数据，不执行任何转换。</p>\n</blockquote>\n<p>访问文件主要有以下四个步骤</p>\n<ol>\n<li>定义一个流文件对象</li>\n<li>打开文件（将文件和流文件对象相关联）</li>\n<li>操作文件的数据</li>\n<li>关闭文件</li>\n</ol>\n<h4 id=\"1-定义文件流对象\"><a href=\"#1-定义文件流对象\" class=\"headerlink\" title=\"1.定义文件流对象\"></a>1.定义文件流对象</h4><p>C++有三个流文件类型：</p>\n<p>ifstream:输入文件流，但程序从文件读入数据时，必须要定义一个ifstream类的对象与文件关联</p>\n<p>0fstream:输出文件流，但程序输出数据到文件时，必须要定义一个ofstream类的对象与文件关联</p>\n<p>fstream:输入输出文件流，fstream类的对象既可以读也可以写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream infile；<span class=\"comment\">//定义了一个输入文件流对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-打开和关闭文件\"><a href=\"#2-打开和关闭文件\" class=\"headerlink\" title=\"2.打开和关闭文件\"></a>2.打开和关闭文件</h4><p>文件流对象除了从istream和ostream继承下来的行为，还新增了俩个成员函数：open（打开文件），close（关闭文件），以及一个构造函数。</p>\n<p><strong>打开文件</strong>是将文件流对象与外存的某一文件关联起来，为文件的读写做好准备，例如：为文件流对象准备缓冲区，记录读写位置。</p>\n<p>打开文件使用open函数（也可以定义流文件对象时通过构造函数）</p>\n<p>open函数有俩个参数：</p>\n<ol>\n<li>文件名（c语言风格的字符串）</li>\n<li>文件的打开模式</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflie.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;文件名&quot;</span>，文件打开模式)；</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>文件打开模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in</td>\n<td>打开文件，做读操作（只适用于ifstream和fstream类）</td>\n</tr>\n<tr>\n<td>out</td>\n<td>打开文件，做写操作（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>app</td>\n<td>在文件尾后面添加（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>打开文件后，立即将文件定位在文件尾i（所有类都有用）</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>打开文件后，清空文件（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>以二进制模式进行输入和输入，默认为ASCLL文件</td>\n</tr>\n</tbody></table>\n<p>每个文件流类都有默认的打开方式（就是自己不传入第二个参数时）:</p>\n<ul>\n<li>ifstream：以in模式默认打开</li>\n<li>ofstream：以out模式打开</li>\n<li>fstream：以in|out（既可读也可写）模式打开</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ifstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ofstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打开一种是open函数，另一种就是申明的时候直接构造</span></span><br><span class=\"line\">ifstream infile1;</span><br><span class=\"line\">infile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>);\t<span class=\"comment\">//或者infile.open(&quot;file1&quot;,ifstream::in);</span></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">infile2</span><span class=\"params\">(<span class=\"string\">&quot;file2&quot;</span>)</span></span>;\t<span class=\"comment\">//或者infile2(&quot;file2&quot;,ifstream::in);</span></span><br><span class=\"line\"></span><br><span class=\"line\">ofstream outfile1;</span><br><span class=\"line\">outfile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>);\t<span class=\"comment\">//或者outfile.open(&quot;file1&quot;,ifstream::out);</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outfile2</span><span class=\"params\">(<span class=\"string\">&quot;file2&quot;</span>)</span></span>;\t<span class=\"comment\">//或者infile2(&quot;file2&quot;,ifstream::out);</span></span><br><span class=\"line\"><span class=\"comment\">//注意当用out打开文件的时候，会自动清空文件（要写入文件时）</span></span><br><span class=\"line\">outfile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>，ofstream::app);<span class=\"comment\">//如果要要向file2添加数据，则需要app打开方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有时候既需要读也需要写，就选择fstream</span></span><br><span class=\"line\"><span class=\"function\">fstream <span class=\"title\">infile1</span><span class=\"params\">(<span class=\"string\">&quot;file1&quot;</span>,fstream::in|fstream::out)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//fstream默认以in和out的方式打开，且这种情况下不会清空文件。</span></span><br><span class=\"line\"><span class=\"comment\">//如果只以out或者指定了truc模式，打开都会清空文件</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>TIPS</strong>：在打开文件后的操作，有一个良好的习惯就是检查文件是否打开成功。若打开成功，则流对象会是一个非零值，反之若未成功打开，则是一个零值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在项目中我们使用的是,fstream的函数good检查文件是否打开成功</span></span><br><span class=\"line\">file.<span class=\"built_in\">good</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在读写操作完时有比要显式的关闭文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n<p>表示流对象与文件断开关系，不在读写数据。</p>\n<h4 id=\"补充：\"><a href=\"#补充：\" class=\"headerlink\" title=\"补充：\"></a>补充：</h4><p>其实流对象和文件的过程其实是<strong>缓冲对象与文件建立的过程</strong>，<strong>缓冲对象关联在流对象里</strong>(后面提到的打开模式in|out啥的，其实是<strong>针对filebuf</strong>)</p>\n<p>所以下面的大体是可以看作一样的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 std::filebuf 对象并打开文件</span></span><br><span class=\"line\">    std::filebuf filebuf;</span><br><span class=\"line\">    filebuf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;example.txt&quot;</span>, std::ios::out);</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 std::fstream 对象并关联到 filebuf</span></span><br><span class=\"line\">    std::fstream fstream;</span><br><span class=\"line\">    fstream.<span class=\"built_in\">rdbuf</span>(&amp;filebuf);</span><br><span class=\"line\">    <span class=\"comment\">// 使用 fstream 写入数据到 filebuf 关联的文件</span></span><br><span class=\"line\">    fstream &lt;&lt; <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">    filebuf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::fstream fstream;</span><br><span class=\"line\">    fstream.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;example.txt&quot;</span>);</span><br><span class=\"line\">    fstream &lt;&lt; <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">    filebuf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"./image-20240713155355573.png\" alt=\"image-20240713155355573\" style=\"zoom: 67%;\" />\n\n<h4 id=\"3-fstream的读取和写入\"><a href=\"#3-fstream的读取和写入\" class=\"headerlink\" title=\"3.fstream的读取和写入\"></a>3.fstream的读取和写入</h4><p>对于文件的读取和写入应该是有很多方法的，不论是调用类内的函数，还是用外部getline（fstream，string）一行一行的读取或是其他，抑或是流操作符&gt;&gt;写入文件当前文件内指针指向的位置。日后有时间慢慢补，这里就只展示一段项目使用到的读取fstream吧</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t<span class=\"comment\">//打开地图的csv文件</span></span><br><span class=\"line\">std::string str_line;\t\t<span class=\"comment\">//csv文件的getline都是按行读的</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (std::<span class=\"built_in\">getline</span>(file, str_line))<span class=\"comment\">//每次读取file的一行，写入string对象</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......<span class=\"comment\">//一行一行读取csv文件，并且写入瓦片数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"基于字符串的输入输出\"><a href=\"#基于字符串的输入输出\" class=\"headerlink\" title=\"基于字符串的输入输出\"></a>基于字符串的输入输出</h2><p>这里就只简单介绍stringstream类</p>\n<p><code>std::stringstream</code> 是 C++ 标准库中的一个类，它提供了一个方便的方式来处理字符串和流。主要用途包括以下几个方面：</p>\n<ol>\n<li><p>将其他类型转换为字符串：<code>std::stringstream</code> 可以将基本数据类型（如 <code>int</code>、<code>double</code> 等）或自定义类型转换为字符串形式。通过输入流操作符 <code>&lt;&lt;</code> 将数据插入到 <code>std::stringstream</code> 中，当然也可以将可以从一个字符串中提取数据，并将其转换为其他类型。然后可以通过 <code>str()</code> 函数获取到整个字符串。这种功能对于将其他类型转换为字符串输出或者进行字符串拼接非常有用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; num; <span class=\"comment\">// 将整数放入流中（转化为字符串存入）</span></span><br><span class=\"line\">    std::string str = ss.<span class=\"built_in\">str</span>(); <span class=\"comment\">// 使用str()函数 从流中提取字符串</span></span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl; <span class=\"comment\">// 输出：123</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//拼接</span></span><br><span class=\"line\">    ss&lt;&lt;num;</span><br><span class=\"line\">    std::cout &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; std::endl; <span class=\"comment\">// 输出：123123</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ss.<span class=\"built_in\">str</span>(<span class=\"string\">&quot;&quot;</span>);<span class=\"comment\">//清空</span></span><br><span class=\"line\">    ss&lt;&lt;<span class=\"string\">&quot;246&quot;</span>;</span><br><span class=\"line\">    ss&gt;&gt;num;\t<span class=\"comment\">//自动将字符串转化为变量对应的类型写入变量</span></span><br><span class=\"line\">    std::cout&lt;&lt;num;<span class=\"comment\">//输出123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>中间缓冲：std::stringstream 可以作为中间缓冲区来处理字符串数据。可以将不同的数据类型、格式化文本等按顺序插入到 std::stringstream 中，在最后一次性输出或处理整个字符串数据。这样可以更加灵活和高效地操作字符串内容。</p>\n</li>\n<li><p>字符串处理：通过 std::stringstream 的接口函数，可以对字符串进行各种操作，如插入、删除、替换等。这使得对字符串的处理更加方便和高效。</p>\n</li>\n</ol>\n<h4 id=\"常用的读取方式\"><a href=\"#常用的读取方式\" class=\"headerlink\" title=\"常用的读取方式\"></a>常用的读取方式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">stringstream <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"comment\">// 注意： stringstream 是一个单词一个单词 ”流入“ string 的，就是以空格为停止</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ss &gt;&gt; str)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这个和上面一样，以空格为分割字符不断读入（get和getline的读取之后也可以整理一下）</span></span><br><span class=\"line\">    <span class=\"comment\">//注意分隔符是字符，不是字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(ss,str,<span class=\"string\">&#x27; &#x27;</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">hello </span></span><br><span class=\"line\"><span class=\"comment\">world</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>最后就分析一下项目代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t<span class=\"comment\">//其实文件打开就是加载到缓存（内存中的一块地方）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!file.<span class=\"built_in\">good</span>())<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::stringstream str_stream;\t\t<span class=\"comment\">//创建对应的流字符串来对文件的缓存的内容读入读出，string是不可以进行流操作的\t\t</span></span><br><span class=\"line\">str_stream &lt;&lt; file.<span class=\"built_in\">rdbuf</span>();\t\t\t<span class=\"comment\">//让对应的流字符串对象读取文件所有内容（rdbuf，其实就是readbuffer，读取缓存）</span></span><br><span class=\"line\">file.<span class=\"built_in\">close</span>();\t\t\t\t\t\t<span class=\"comment\">//读取后文件关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">cJSON* json_root = <span class=\"built_in\">cJSON_Parse</span>(str_stream.<span class=\"built_in\">str</span>().<span class=\"built_in\">c_str</span>());\t<span class=\"comment\">//paese（解析），以cJSON去解析这些数据，参数是C语言风格的字符串。</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>以fstream对象打开文件</p>\n</li>\n<li><p>将file文件的内容写入stringstream对象</p>\n<blockquote>\n<p>file.rdbuf();返回的是与文件关联的缓冲对象filebuf*(指针).</p>\n<p>应该是stringstream有重载&lt;&lt;运算符(关于filebuf*),可以从filebuf关联的文件中读取所有内容进入stringstream对象</p>\n</blockquote>\n</li>\n<li><p>读取后关闭文件</p>\n</li>\n<li><p>将stringstream对象转换为string,再进一步转化为char* (c语言风格字符串),最后利用cJSON库将其转化为cJSON对象,之后就可以利用其指针json_root读取json文件格式了</p>\n</li>\n</ol>\n<p><strong>总结</strong>:在我看来,在文件的格式的转化中,stringstream就相当于在转换中建立了桥梁,fstream帮忙打开文件,stringstream负责读取流文件的内容,最后再根据stringstream对象转换为string进一步char*,供cjson读取,成功获取了我们需要的json格式的内容.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>学校对于这一节并没有教，当时看也只是模仿了上面的案例，不是很懂。现在在VoidMatrix的塔防教程中看到了这方面知识点相关，就想相对了解一下</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!file.<span class=\"built_in\">good</span>())<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::stringstream str_stream;\t\t\t</span><br><span class=\"line\">str_stream &lt;&lt; file.<span class=\"built_in\">rdbuf</span>();\t\t\t</span><br><span class=\"line\">file.<span class=\"built_in\">close</span>();\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">cJSON* json_root = <span class=\"built_in\">cJSON_Parse</span>(str_stream.<span class=\"built_in\">str</span>().<span class=\"built_in\">c_str</span>());</span><br></pre></td></tr></table></figure>\n\n<p>主要弄明白这一段代码的意思。</p>","more":"<hr>\n<p>C++的输入输出主要分为三大类：</p>\n<ol>\n<li><strong>基于控制台的输入和输出</strong>：从标准的输入设备（键盘）获得数据，把程序的执行结果输出到标准的输出设备（显示器）</li>\n<li><strong>基于文件的输入和输出</strong>：从外储存器文件获取数据或把数据存入外储存器的文件</li>\n<li><strong>基于字符串的输入和输出</strong>：从程序string类型的变量获取数据或把数据存于string类型的变量</li>\n</ol>\n<p>这些输入和输出都是由<strong>c++标准库</strong>提供的。</p>\n<hr>\n<h2 id=\"流与标准库\"><a href=\"#流与标准库\" class=\"headerlink\" title=\"流与标准库\"></a>流与标准库</h2><p><strong>输入流</strong>：输入操作中，字节从设备流向内存</p>\n<p><strong>输出流</strong>：输出操作中，字节从内存流向设备</p>\n<p>C++的输入输出类主要包含在三个头文件中（注意输入输出是一个类，是一个可以实例化的对象）</p>\n<ol>\n<li><strong>iostream</strong>：基于控制台的输入和输出</li>\n<li><strong>fstream</strong>：基于文件的输入和输出</li>\n<li><strong>sstream</strong>：基于字符串的输入和输出</li>\n</ol>\n<div style=\"text-align:center\">\n输入输出标准库及其头文件类型\n</div>\n\n<ul>\n<li><strong>iostream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>istream</em>:控制台输入流类，他的对象代表一个输入设备</li>\n<li><em>ostream</em>:控制台输出流类，他的对象代表一个输出设备</li>\n<li><em>iostream</em>:控制台输入输出流类，他的对象代表一个输入或输出设备，这个类是由istream和ostream共同派生</li>\n</ol>\n<ul>\n<li><strong>fstream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>ifstream</em>:输入文件流类，他的对象代表一个输入文件，由istream派生而来</li>\n<li><em>ofstream</em>:输出文件流类，他的对象代表一个输出文件，由ostream派生而来</li>\n<li><em>fstream</em>:输入输出文件流类，他的对象代表一个输入或输出文件，这个类是由iostream共同派生</li>\n</ol>\n<ul>\n<li><strong>sstream</strong>（头文件）</li>\n</ul>\n<ol>\n<li><em>istringstream</em>:输入字符串类，由istream派生而来</li>\n<li><em>ostringstrea</em>:输出字符串类，由ostream派生而来</li>\n<li><em>stringstream</em>:输入输出字符串类，由iostream派生而来</li>\n</ol>\n<hr>\n<h2 id=\"输入和输出缓冲\"><a href=\"#输入和输出缓冲\" class=\"headerlink\" title=\"输入和输出缓冲\"></a>输入和输出缓冲</h2><p>程序只能访问内存中的信息，而不能访问外部设备中的信息。</p>\n<p>所以外部设备的信息会先存入内存再被程序访问，程序的输出也同样会放在内存再流向外部设备</p>\n<p>内存中存放这些数据的区域被称为<strong>输入和输出缓冲区</strong></p>\n<img src=\"./image-20240622105847430.png\" alt=\"image-20240622105847430\" style=\"zoom: 80%;\" />\n\n<p>以下几种情况会使缓冲区的内容被刷新</p>\n<ol>\n<li>程序正常结束</li>\n<li>缓冲区已满，再写入下一个值时会清空</li>\n<li>用标准库的操作符，如endl</li>\n<li>输入和输出流关联起来。在读入输出流时，会自动清空输入缓冲区。</li>\n</ol>\n<p>缓冲对象主要分为三类：</p>\n<p><strong>streambuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::streambuf</code> 是<strong>基类</strong>，定义了输入输出的基本接口。</li>\n<li><code>std::stringbuf</code> 和 <code>std::filebuf</code> 是 <code>std::streambuf</code> 的派生类，提供了具体的字符串和文件缓冲区的实现。</li>\n<li><code>std::streambuf</code> 本身不能直接使用，需要通过其派生类（如 <code>std::stringbuf</code>、<code>std::filebuf</code>）来进行实际的输入输出操作。</li>\n</ul>\n</blockquote>\n<p><strong>filebuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::filebuf</code> 是用于处理文件缓冲区的类，用于文件的读写操作。</li>\n<li>可以将 <code>std::filebuf</code> 对象绑定到文件流上，与文件系统进行交互，实现文件数据的读写。</li>\n<li>可以设置文件打开模式、操作文件指针等文件操作相关功能。</li>\n</ul>\n</blockquote>\n<p><strong>stringbuf</strong></p>\n<blockquote>\n<ul>\n<li><code>std::stringbuf</code> 是用于处理字符串缓冲区的类，可以在内存中动态创建和修改字符串数据。</li>\n<li>是基于内存的字符串缓冲区，在内存中管理字符串数据。</li>\n<li>主要用于处理字符串数据的输入输出操作，可以通过 <code>std::stringstream</code> 方便地对字符串数据进行读写。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"各个流对象以及缓冲的关系\"><a href=\"#各个流对象以及缓冲的关系\" class=\"headerlink\" title=\"各个流对象以及缓冲的关系\"></a>各个流对象以及缓冲的关系</h2><img src=\"./Center.jpeg\" alt=\"关系图\" />\n\n<ol>\n<li>对于所有的流对象，不难看出都是基于虚基类ios_base派生而来，不同的流对象用于不同的输入和输出。</li>\n<li>而每一个流对象都有个专门的类去管理缓冲区对象，完全可以通过<strong>流对象.rdbuf()<strong>观察其返回值。主要就是</strong>iostream</strong>和<strong>stringstream</strong>和<strong>fstream</strong>三个各自管理缓冲的类。</li>\n</ol>\n<img src=\"./屏幕截图 2024-07-13 151655.png\" alt=\"屏幕截图 2024-07-13 151655\" style=\"zoom: 80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151711.png\" alt=\"屏幕截图 2024-07-13 151711\" style=\"zoom:80%;\" />\n\n<img src=\"./屏幕截图 2024-07-13 151721.png\" alt=\"屏幕截图 2024-07-13 151721\" style=\"zoom: 67%;\" />\n\n\n\n\n<hr>\n<h2 id=\"基于文件的输入和输出\"><a href=\"#基于文件的输入和输出\" class=\"headerlink\" title=\"基于文件的输入和输出\"></a>基于文件的输入和输出</h2><h3 id=\"文件的概念\"><a href=\"#文件的概念\" class=\"headerlink\" title=\"文件的概念\"></a>文件的概念</h3><p>文件是驻留在外存储器上，具有一个标识名和一组信息的集合，用于永久保存数据。</p>\n<p>与文件相关的概念：</p>\n<ol>\n<li><strong>数据项</strong>：数据的基本单位，表示一个有意义的信息，如一个整型数，一个字符串。</li>\n<li><strong>记录</strong>：若干个相关的数据项组成一个记录，每个记录可以堪称一个对象</li>\n<li><strong>文件</strong>：记录的集合</li>\n<li><strong>数据库</strong>：一组相关的文件。</li>\n</ol>\n<p>例如图书管理系统中，数据库包含书目文件，读者文件和其他辅助文件。书目文件中的每本书的信息构成一条记录。</p>\n<p>每条记录中的书名，作者都是数据项。</p>\n<h3 id=\"文件和流\"><a href=\"#文件和流\" class=\"headerlink\" title=\"文件和流\"></a>文件和流</h3><blockquote>\n<p>对于c++来说，文件就是一个个字节序列构成，每一个文件以文件结束符（End Of File ，EOF）结束，这种文件称为流式文件。</p>\n<p>可以与字符串进行类比，只不过字符串结尾是’\\0’罢了</p>\n<p>C++文件类型又分为二进制文件和ASCLL文件，对于ASCLL文件在读写时会在<strong>内存表示</strong>和<strong>文本</strong>之间进行转换。</p>\n<p>二进制文件保存到则是数据在内存中的表示，直接交换数据，不执行任何转换。</p>\n</blockquote>\n<p>访问文件主要有以下四个步骤</p>\n<ol>\n<li>定义一个流文件对象</li>\n<li>打开文件（将文件和流文件对象相关联）</li>\n<li>操作文件的数据</li>\n<li>关闭文件</li>\n</ol>\n<h4 id=\"1-定义文件流对象\"><a href=\"#1-定义文件流对象\" class=\"headerlink\" title=\"1.定义文件流对象\"></a>1.定义文件流对象</h4><p>C++有三个流文件类型：</p>\n<p>ifstream:输入文件流，但程序从文件读入数据时，必须要定义一个ifstream类的对象与文件关联</p>\n<p>0fstream:输出文件流，但程序输出数据到文件时，必须要定义一个ofstream类的对象与文件关联</p>\n<p>fstream:输入输出文件流，fstream类的对象既可以读也可以写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream infile；<span class=\"comment\">//定义了一个输入文件流对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-打开和关闭文件\"><a href=\"#2-打开和关闭文件\" class=\"headerlink\" title=\"2.打开和关闭文件\"></a>2.打开和关闭文件</h4><p>文件流对象除了从istream和ostream继承下来的行为，还新增了俩个成员函数：open（打开文件），close（关闭文件），以及一个构造函数。</p>\n<p><strong>打开文件</strong>是将文件流对象与外存的某一文件关联起来，为文件的读写做好准备，例如：为文件流对象准备缓冲区，记录读写位置。</p>\n<p>打开文件使用open函数（也可以定义流文件对象时通过构造函数）</p>\n<p>open函数有俩个参数：</p>\n<ol>\n<li>文件名（c语言风格的字符串）</li>\n<li>文件的打开模式</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflie.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;文件名&quot;</span>，文件打开模式)；</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>文件打开模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in</td>\n<td>打开文件，做读操作（只适用于ifstream和fstream类）</td>\n</tr>\n<tr>\n<td>out</td>\n<td>打开文件，做写操作（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>app</td>\n<td>在文件尾后面添加（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>ate</td>\n<td>打开文件后，立即将文件定位在文件尾i（所有类都有用）</td>\n</tr>\n<tr>\n<td>trunc</td>\n<td>打开文件后，清空文件（只适用于ofstream和fstream类）</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>以二进制模式进行输入和输入，默认为ASCLL文件</td>\n</tr>\n</tbody></table>\n<p>每个文件流类都有默认的打开方式（就是自己不传入第二个参数时）:</p>\n<ul>\n<li>ifstream：以in模式默认打开</li>\n<li>ofstream：以out模式打开</li>\n<li>fstream：以in|out（既可读也可写）模式打开</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ifstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ofstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//打开一种是open函数，另一种就是申明的时候直接构造</span></span><br><span class=\"line\">ifstream infile1;</span><br><span class=\"line\">infile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>);\t<span class=\"comment\">//或者infile.open(&quot;file1&quot;,ifstream::in);</span></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">infile2</span><span class=\"params\">(<span class=\"string\">&quot;file2&quot;</span>)</span></span>;\t<span class=\"comment\">//或者infile2(&quot;file2&quot;,ifstream::in);</span></span><br><span class=\"line\"></span><br><span class=\"line\">ofstream outfile1;</span><br><span class=\"line\">outfile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>);\t<span class=\"comment\">//或者outfile.open(&quot;file1&quot;,ifstream::out);</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outfile2</span><span class=\"params\">(<span class=\"string\">&quot;file2&quot;</span>)</span></span>;\t<span class=\"comment\">//或者infile2(&quot;file2&quot;,ifstream::out);</span></span><br><span class=\"line\"><span class=\"comment\">//注意当用out打开文件的时候，会自动清空文件（要写入文件时）</span></span><br><span class=\"line\">outfile1.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file1&quot;</span>，ofstream::app);<span class=\"comment\">//如果要要向file2添加数据，则需要app打开方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有时候既需要读也需要写，就选择fstream</span></span><br><span class=\"line\"><span class=\"function\">fstream <span class=\"title\">infile1</span><span class=\"params\">(<span class=\"string\">&quot;file1&quot;</span>,fstream::in|fstream::out)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//fstream默认以in和out的方式打开，且这种情况下不会清空文件。</span></span><br><span class=\"line\"><span class=\"comment\">//如果只以out或者指定了truc模式，打开都会清空文件</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>TIPS</strong>：在打开文件后的操作，有一个良好的习惯就是检查文件是否打开成功。若打开成功，则流对象会是一个非零值，反之若未成功打开，则是一个零值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在项目中我们使用的是,fstream的函数good检查文件是否打开成功</span></span><br><span class=\"line\">file.<span class=\"built_in\">good</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在读写操作完时有比要显式的关闭文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n<p>表示流对象与文件断开关系，不在读写数据。</p>\n<h4 id=\"补充：\"><a href=\"#补充：\" class=\"headerlink\" title=\"补充：\"></a>补充：</h4><p>其实流对象和文件的过程其实是<strong>缓冲对象与文件建立的过程</strong>，<strong>缓冲对象关联在流对象里</strong>(后面提到的打开模式in|out啥的，其实是<strong>针对filebuf</strong>)</p>\n<p>所以下面的大体是可以看作一样的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 std::filebuf 对象并打开文件</span></span><br><span class=\"line\">    std::filebuf filebuf;</span><br><span class=\"line\">    filebuf.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;example.txt&quot;</span>, std::ios::out);</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 std::fstream 对象并关联到 filebuf</span></span><br><span class=\"line\">    std::fstream fstream;</span><br><span class=\"line\">    fstream.<span class=\"built_in\">rdbuf</span>(&amp;filebuf);</span><br><span class=\"line\">    <span class=\"comment\">// 使用 fstream 写入数据到 filebuf 关联的文件</span></span><br><span class=\"line\">    fstream &lt;&lt; <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭文件</span></span><br><span class=\"line\">    filebuf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::fstream fstream;</span><br><span class=\"line\">    fstream.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;example.txt&quot;</span>);</span><br><span class=\"line\">    fstream &lt;&lt; <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">    filebuf.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"./image-20240713155355573.png\" alt=\"image-20240713155355573\" style=\"zoom: 67%;\" />\n\n<h4 id=\"3-fstream的读取和写入\"><a href=\"#3-fstream的读取和写入\" class=\"headerlink\" title=\"3.fstream的读取和写入\"></a>3.fstream的读取和写入</h4><p>对于文件的读取和写入应该是有很多方法的，不论是调用类内的函数，还是用外部getline（fstream，string）一行一行的读取或是其他，抑或是流操作符&gt;&gt;写入文件当前文件内指针指向的位置。日后有时间慢慢补，这里就只展示一段项目使用到的读取fstream吧</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t<span class=\"comment\">//打开地图的csv文件</span></span><br><span class=\"line\">std::string str_line;\t\t<span class=\"comment\">//csv文件的getline都是按行读的</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (std::<span class=\"built_in\">getline</span>(file, str_line))<span class=\"comment\">//每次读取file的一行，写入string对象</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......<span class=\"comment\">//一行一行读取csv文件，并且写入瓦片数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"基于字符串的输入输出\"><a href=\"#基于字符串的输入输出\" class=\"headerlink\" title=\"基于字符串的输入输出\"></a>基于字符串的输入输出</h2><p>这里就只简单介绍stringstream类</p>\n<p><code>std::stringstream</code> 是 C++ 标准库中的一个类，它提供了一个方便的方式来处理字符串和流。主要用途包括以下几个方面：</p>\n<ol>\n<li><p>将其他类型转换为字符串：<code>std::stringstream</code> 可以将基本数据类型（如 <code>int</code>、<code>double</code> 等）或自定义类型转换为字符串形式。通过输入流操作符 <code>&lt;&lt;</code> 将数据插入到 <code>std::stringstream</code> 中，当然也可以将可以从一个字符串中提取数据，并将其转换为其他类型。然后可以通过 <code>str()</code> 函数获取到整个字符串。这种功能对于将其他类型转换为字符串输出或者进行字符串拼接非常有用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; num; <span class=\"comment\">// 将整数放入流中（转化为字符串存入）</span></span><br><span class=\"line\">    std::string str = ss.<span class=\"built_in\">str</span>(); <span class=\"comment\">// 使用str()函数 从流中提取字符串</span></span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl; <span class=\"comment\">// 输出：123</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//拼接</span></span><br><span class=\"line\">    ss&lt;&lt;num;</span><br><span class=\"line\">    std::cout &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; std::endl; <span class=\"comment\">// 输出：123123</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ss.<span class=\"built_in\">str</span>(<span class=\"string\">&quot;&quot;</span>);<span class=\"comment\">//清空</span></span><br><span class=\"line\">    ss&lt;&lt;<span class=\"string\">&quot;246&quot;</span>;</span><br><span class=\"line\">    ss&gt;&gt;num;\t<span class=\"comment\">//自动将字符串转化为变量对应的类型写入变量</span></span><br><span class=\"line\">    std::cout&lt;&lt;num;<span class=\"comment\">//输出123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>中间缓冲：std::stringstream 可以作为中间缓冲区来处理字符串数据。可以将不同的数据类型、格式化文本等按顺序插入到 std::stringstream 中，在最后一次性输出或处理整个字符串数据。这样可以更加灵活和高效地操作字符串内容。</p>\n</li>\n<li><p>字符串处理：通过 std::stringstream 的接口函数，可以对字符串进行各种操作，如插入、删除、替换等。这使得对字符串的处理更加方便和高效。</p>\n</li>\n</ol>\n<h4 id=\"常用的读取方式\"><a href=\"#常用的读取方式\" class=\"headerlink\" title=\"常用的读取方式\"></a>常用的读取方式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">stringstream <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"comment\">// 注意： stringstream 是一个单词一个单词 ”流入“ string 的，就是以空格为停止</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ss &gt;&gt; str)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这个和上面一样，以空格为分割字符不断读入（get和getline的读取之后也可以整理一下）</span></span><br><span class=\"line\">    <span class=\"comment\">//注意分隔符是字符，不是字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(ss,str,<span class=\"string\">&#x27; &#x27;</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">hello </span></span><br><span class=\"line\"><span class=\"comment\">world</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>最后就分析一下项目代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::fstream <span class=\"title\">file</span><span class=\"params\">(path)</span></span>;\t\t\t<span class=\"comment\">//其实文件打开就是加载到缓存（内存中的一块地方）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!file.<span class=\"built_in\">good</span>())<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::stringstream str_stream;\t\t<span class=\"comment\">//创建对应的流字符串来对文件的缓存的内容读入读出，string是不可以进行流操作的\t\t</span></span><br><span class=\"line\">str_stream &lt;&lt; file.<span class=\"built_in\">rdbuf</span>();\t\t\t<span class=\"comment\">//让对应的流字符串对象读取文件所有内容（rdbuf，其实就是readbuffer，读取缓存）</span></span><br><span class=\"line\">file.<span class=\"built_in\">close</span>();\t\t\t\t\t\t<span class=\"comment\">//读取后文件关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">cJSON* json_root = <span class=\"built_in\">cJSON_Parse</span>(str_stream.<span class=\"built_in\">str</span>().<span class=\"built_in\">c_str</span>());\t<span class=\"comment\">//paese（解析），以cJSON去解析这些数据，参数是C语言风格的字符串。</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>以fstream对象打开文件</p>\n</li>\n<li><p>将file文件的内容写入stringstream对象</p>\n<blockquote>\n<p>file.rdbuf();返回的是与文件关联的缓冲对象filebuf*(指针).</p>\n<p>应该是stringstream有重载&lt;&lt;运算符(关于filebuf*),可以从filebuf关联的文件中读取所有内容进入stringstream对象</p>\n</blockquote>\n</li>\n<li><p>读取后关闭文件</p>\n</li>\n<li><p>将stringstream对象转换为string,再进一步转化为char* (c语言风格字符串),最后利用cJSON库将其转化为cJSON对象,之后就可以利用其指针json_root读取json文件格式了</p>\n</li>\n</ol>\n<p><strong>总结</strong>:在我看来,在文件的格式的转化中,stringstream就相当于在转换中建立了桥梁,fstream帮忙打开文件,stringstream负责读取流文件的内容,最后再根据stringstream对象转换为string进一步char*,供cjson读取,成功获取了我们需要的json格式的内容.</p>"},{"title":"C++类的继承","date":"2024-06-20T16:00:00.000Z","updated":"2024-06-20T16:00:00.000Z","_content":"\n# 类的继承\n\n> 在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。\n>\n> 那今天就好好看看关于继承方面要注意的语法点\n\n---\n\n<!-- More -->\n\n## 派生类的定义\n\n~~~CPP\nclass 派生类名：继承方式 基类名\n{\n    新增加的成员定义；\n}\n\nclass student: public people\n{\n    \n};\n~~~\n\n唯一要说明的其实就是**继承方式**\n\n- public\n\npublic（公有类）指的是对应的成员变量和函数可以被**外界**（全局函数，其他类的成员函数），**自己的成员函数**和**友元**直接调用\n\n最直观的就是被外界调用（前提是这些在类内是public）\n\n~~~CPP\nstudent 小明；\n    小明.height();\t//函数返回\n\t小明。height；\t\t//直接返回成员变量\n//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量\n~~~\n\n- private\n\nprivate（私有类）就是仅仅只限于类内的成员函数和友元进行访问\n\n- protected\n\nprotected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数\n\n但是基类的成员函数和成员变量的访问特性也会随着继承方式变化\n\n| 基于成员的访问特性 | public继承 | protected继承 | private继承 |\n| ------------------ | ---------- | ------------- | ----------- |\n| public             | public     | protected     | private     |\n| private            | 不可访问   | 不可访问      | 不可访问    |\n| protected          | protected  | protected     | private     |\n\n其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性\n\n**我们只需要关注继承过来的变量对于当前类的访问特性。**\n\n~~~CPP\nclass base\n{\nprivate:\n    int a;\npublic:\n    void deal();\n};\n\nclass base1:protected base\n{\n    //这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用\n    //public继承过来则是protected类，说明可以继续往下继承\n};\n\nclass base2:protected base1\n{\n    //这个也是完全能调用deal\n};\n~~~\n\n其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用\n\n---\n\n## 派生类对象的构造和析构\n\n> 好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。\n>\n> 因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要\n>\n> 但还是得了解不是吗？\n\n继承的构造和析构其实也很好理解\n\n\n\n对于子类的构造，优先级是这样的\n\n1. **基类的构造函数**\n2. **自己里面包含的其他类的构造函数**\n3. **然后是自己的构造函数**\n\n派生类的构造函数形式如下\n\n~~~CPP\nstudent(int a,int b):people(a)\n{\n    //在：后面给对应的基类传去对应的参数就行\n}\n~~~\n\n**注意：**派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决\n\n\n\n析构函数的顺序则是相反\n\n1. **先执行自己的析构函数**\n2. **再解决基类的析构函数**\n\n---\n\n## 重定义基类的函数\n\n当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖\n\n~~~CPP\nclass base\n{\npublic:\n    int deal(){}\n}\nclass base1:public base\n{\npublic:\n    int deal(){}\n}\n//此时调用base1.deal则是用派生类定义的deal\n\n//如果需要调用父类的那个函数\nclass base\n{\npublic:\n    int deal()\n    {\n        base:deal();\t\t\t\t\t//需要“基类名：函数名”来调用父类的重定义的函数\n    }\n}\n~~~\n\n---\n\n## 将派生类对象隐式转换为基类对象\n\n#### 1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）\n\n就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员\n\n~~~CPP\nbase=base1；\n~~~\n\n<img src=\"p1.png\" style=\"zoom:50%;\" />\n\n#### 2.基类指针指向派生类（很重要）\n\n> 在植物明星大乱斗中，我们都是通过基类指针指向派生的对象\n>\n> player指针指向豌豆和向日葵，scene指向不同的场景\n\n<img src=\"p2.png\" style=\"zoom:50%;\" />\n\n基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。\n\n因此指向派生类的基类指针出发，只能访问派生类中的基类成员。\n\n~~~CPP\nclass base\n{\npublic:\n    void deal()\n    {\n\t}\n};\nclass base1:public base\n{\n    void play();\n}\nbase* point=new base;\npoint->deal();\t\t//这是可以的\npoint->play();\t\t//这是不行的\n~~~\n\n**注意：**虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展\n\n> **但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？**\n>\n> Q&A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量\n\n\n\n#### 3.基类对象引用派生类的对象\n\n> 引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分\n\n~~~CPP\nbase &point=new base1;\n~~~\n\n\n\n<img src=\"p3.png\" style=\"zoom: 50%;\" />\n\n这样对基类引用的访问其实就是对派生类的基类的访问\n\n\n\n注意：\n\n- 派生类的指针不能指向基类\n- 派生类的指针也不能接受基类的指针\n\n~~~CPP\nbase1 d,*dp;\nbase *bp=dp;\t//基类指针指向派生类，正确的\ndp=bp;\t\t\t//但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的\n~~~\n\n如果强制要转,使用强制类型转换（明确不会犯错）\n\n~~~CPP\ndp=reinterpret_cast<Derived*> bp; \n~~~\n\n---\n\n## 最后附上一段植物明星大乱斗子弹类的继承（删了一些）\n\n**基类**\n\n~~~CPP\n#ifndef _BULLET_H_\n#define _BULLET_H_\n\n#include \"vector2.h\"\n#include \"player_id.h\"\n#include \"camera.h\"\n#include <graphics.h>\n\n#include <functional>\n\nextern bool is_debug;\n\nclass Bullet\n{\npublic:\n\tBullet() = default;\n\t~Bullet() = default;\n\tvoid set_callback(std::function<void()> callback)\t\t\t\t\n\t{\n\t\tthis->callback = callback;\n\t}\n\n\tvoid set_valid(bool flag)\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tvalid = flag;\n\t}\n\n\tbool get_valid()const\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\treturn valid;\n\t}\n\n\tbool check_can_remove()const\t\t\t\t\t\t\t\t\t\n\t{\n\t\treturn can_remove;\n\t}\n\n\tvirtual void on_collide()\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tif (callback)\n\t\t\tcallback();\n\t}\n\n\n\tvirtual bool check_collision(const Vector2& position, const Vector2& size)\t\n\t{\n\t\treturn this->position.x + this->size.x / 2 >= position.x\n\t\t\t&& this->position.x + this->size.x / 2 <= position.x + size.x\n\t\t\t&& this->position.y + this->size.y / 2 >= position.y\n\t\t\t&& this->position.y + this->size.y / 2 <= position.y + size.y;\n\t}\n\n\tvirtual void on_update(int delta){}\n\n\tvirtual void on_draw(const Camera& camera)const\n\t{\n\t\tif (is_debug)\n\t\t{\n\t\t\tsetfillcolor(RGB(255, 255, 255));\n\t\t\tsetlinecolor(RGB(255, 255, 255));\n\t\t\trectangle((int)position.x, (int)position.y, (int)position.x + size.x, (int)position.y + size.y);\n\n\t\t\tsolidcircle((int)(position.x + size.x / 2), (int)(position.y + size.y / 2), 5);\n\t\t\t\n\t\t}\n\t}\n\n\n\n\nprotected:\t\t\t\t\t\t\t\t//为了方便子类可以直接读取数据，所以选择protected\n\n\tVector2 size;\t\t\t\t\t\t//子弹尺寸\n\tVector2 position;\t\t\t\t\t//子弹位置\n\tVector2 velocity;\t\t\t\t\t//子弹速度\n\tint damage = 10;\t\t\t\t\t//子弹伤害\n\tbool valid = true;\t\t\t\t\t//子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画\n\tbool can_remove = false;\t\t\t//子弹是否可以被移除\n\tstd::function<void()> callback;\t\t//子弹碰撞回调函数，因为子弹可以积攒玩家的能量\n\tPlayerID target_id = PlayerID::P1;\t//子弹碰撞目标玩家ID，以免自己打自己\n\nprotected:\n\tbool check_if_exceeds_screen()\t\t\n\t{\n\t\treturn (position.x + size.x <= 0 || position.x >= getwidth()\n\t\t\t|| position.y + size.y <= 0 || position.y >= getheight());\n\t}\n\n};\n\n\n#endif // !_BULLET_H_\n~~~\n\n**派生类**\n\n~~~CPP\n#ifndef _PEA_BULLET_H_\n#define _PEA_BULLET_H_\n\n#include \"bullet.h\"\n#include \"animation.h\"\n\nextern IMAGE img_pea;\nextern Atlas atlas_pea_break;\n\nclass PeaBullet :public Bullet\n{\npublic:\n\tPeaBullet()\n\t{\n\t\tsize.x = 64;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tsize.y = 64;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tdamage = 10;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tanimation_break.set_atlas(&atlas_pea_break);\t\t\t\t\t\t\n\t\tanimation_break.set_interval(100);\n\t\tanimation_break.set_loop(false);\t\t\t\t\t\t\t\t\n\t\tanimation_break.set_callback([&]() {can_remove = true; });\t\t\t\n\t\t\n\t}\n\n\t~PeaBullet() = default;\n\n\tvoid on_collide()\n\t{\n\t\tBullet::on_collide();\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tswitch (rand() % 3)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t{\n\t\tcase 0:\n\t\t\tmciSendString(_T(\"play pea_break_1 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmciSendString(_T(\"play pea_break_2 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmciSendString(_T(\"play pea_break_3 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tvoid on_update(int delta)\n\t{\n\t\tposition += velocity * (float)delta;\t\t\t\t\t\t\t\t\n\t\tif (!valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tanimation_break.on_updata(delta);\n\n\t\tif (check_if_exceeds_screen())\t\t\t\t\t\t\t\t\t\t\n\t\t\tcan_remove = true;\n\t}\n\n\tvoid on_draw(const Camera& camera)const\n\t{\n\t\tif (valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tputimage_alpha(camera, (int)position.x, (int)position.y, &img_pea);\n\t\telse\n\t\t\tanimation_break.on_draw(camera, (int)position.x, (int)position.y);\n\n\n\t\tBullet::on_draw(camera);\n\t}\n\nprivate:\n\tAnimation animation_break;\t\t\t\t\t\t\n};\n\n\n#endif // !_PEA_BULLET_H_\n\n~~~\n\n","source":"_posts/yang/C++继承.md","raw":"---\ntitle: C++类的继承\ndate: 2024-06-21\nupdated: 2024-06-21\npermalink: articles/yang12342/继承/\ncategories: yang12342\ntags: [c++语法]\n---\n\n# 类的继承\n\n> 在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。\n>\n> 那今天就好好看看关于继承方面要注意的语法点\n\n---\n\n<!-- More -->\n\n## 派生类的定义\n\n~~~CPP\nclass 派生类名：继承方式 基类名\n{\n    新增加的成员定义；\n}\n\nclass student: public people\n{\n    \n};\n~~~\n\n唯一要说明的其实就是**继承方式**\n\n- public\n\npublic（公有类）指的是对应的成员变量和函数可以被**外界**（全局函数，其他类的成员函数），**自己的成员函数**和**友元**直接调用\n\n最直观的就是被外界调用（前提是这些在类内是public）\n\n~~~CPP\nstudent 小明；\n    小明.height();\t//函数返回\n\t小明。height；\t\t//直接返回成员变量\n//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量\n~~~\n\n- private\n\nprivate（私有类）就是仅仅只限于类内的成员函数和友元进行访问\n\n- protected\n\nprotected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数\n\n但是基类的成员函数和成员变量的访问特性也会随着继承方式变化\n\n| 基于成员的访问特性 | public继承 | protected继承 | private继承 |\n| ------------------ | ---------- | ------------- | ----------- |\n| public             | public     | protected     | private     |\n| private            | 不可访问   | 不可访问      | 不可访问    |\n| protected          | protected  | protected     | private     |\n\n其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性\n\n**我们只需要关注继承过来的变量对于当前类的访问特性。**\n\n~~~CPP\nclass base\n{\nprivate:\n    int a;\npublic:\n    void deal();\n};\n\nclass base1:protected base\n{\n    //这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用\n    //public继承过来则是protected类，说明可以继续往下继承\n};\n\nclass base2:protected base1\n{\n    //这个也是完全能调用deal\n};\n~~~\n\n其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用\n\n---\n\n## 派生类对象的构造和析构\n\n> 好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。\n>\n> 因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要\n>\n> 但还是得了解不是吗？\n\n继承的构造和析构其实也很好理解\n\n\n\n对于子类的构造，优先级是这样的\n\n1. **基类的构造函数**\n2. **自己里面包含的其他类的构造函数**\n3. **然后是自己的构造函数**\n\n派生类的构造函数形式如下\n\n~~~CPP\nstudent(int a,int b):people(a)\n{\n    //在：后面给对应的基类传去对应的参数就行\n}\n~~~\n\n**注意：**派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决\n\n\n\n析构函数的顺序则是相反\n\n1. **先执行自己的析构函数**\n2. **再解决基类的析构函数**\n\n---\n\n## 重定义基类的函数\n\n当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖\n\n~~~CPP\nclass base\n{\npublic:\n    int deal(){}\n}\nclass base1:public base\n{\npublic:\n    int deal(){}\n}\n//此时调用base1.deal则是用派生类定义的deal\n\n//如果需要调用父类的那个函数\nclass base\n{\npublic:\n    int deal()\n    {\n        base:deal();\t\t\t\t\t//需要“基类名：函数名”来调用父类的重定义的函数\n    }\n}\n~~~\n\n---\n\n## 将派生类对象隐式转换为基类对象\n\n#### 1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）\n\n就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员\n\n~~~CPP\nbase=base1；\n~~~\n\n<img src=\"p1.png\" style=\"zoom:50%;\" />\n\n#### 2.基类指针指向派生类（很重要）\n\n> 在植物明星大乱斗中，我们都是通过基类指针指向派生的对象\n>\n> player指针指向豌豆和向日葵，scene指向不同的场景\n\n<img src=\"p2.png\" style=\"zoom:50%;\" />\n\n基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。\n\n因此指向派生类的基类指针出发，只能访问派生类中的基类成员。\n\n~~~CPP\nclass base\n{\npublic:\n    void deal()\n    {\n\t}\n};\nclass base1:public base\n{\n    void play();\n}\nbase* point=new base;\npoint->deal();\t\t//这是可以的\npoint->play();\t\t//这是不行的\n~~~\n\n**注意：**虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展\n\n> **但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？**\n>\n> Q&A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量\n\n\n\n#### 3.基类对象引用派生类的对象\n\n> 引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分\n\n~~~CPP\nbase &point=new base1;\n~~~\n\n\n\n<img src=\"p3.png\" style=\"zoom: 50%;\" />\n\n这样对基类引用的访问其实就是对派生类的基类的访问\n\n\n\n注意：\n\n- 派生类的指针不能指向基类\n- 派生类的指针也不能接受基类的指针\n\n~~~CPP\nbase1 d,*dp;\nbase *bp=dp;\t//基类指针指向派生类，正确的\ndp=bp;\t\t\t//但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的\n~~~\n\n如果强制要转,使用强制类型转换（明确不会犯错）\n\n~~~CPP\ndp=reinterpret_cast<Derived*> bp; \n~~~\n\n---\n\n## 最后附上一段植物明星大乱斗子弹类的继承（删了一些）\n\n**基类**\n\n~~~CPP\n#ifndef _BULLET_H_\n#define _BULLET_H_\n\n#include \"vector2.h\"\n#include \"player_id.h\"\n#include \"camera.h\"\n#include <graphics.h>\n\n#include <functional>\n\nextern bool is_debug;\n\nclass Bullet\n{\npublic:\n\tBullet() = default;\n\t~Bullet() = default;\n\tvoid set_callback(std::function<void()> callback)\t\t\t\t\n\t{\n\t\tthis->callback = callback;\n\t}\n\n\tvoid set_valid(bool flag)\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tvalid = flag;\n\t}\n\n\tbool get_valid()const\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\treturn valid;\n\t}\n\n\tbool check_can_remove()const\t\t\t\t\t\t\t\t\t\n\t{\n\t\treturn can_remove;\n\t}\n\n\tvirtual void on_collide()\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tif (callback)\n\t\t\tcallback();\n\t}\n\n\n\tvirtual bool check_collision(const Vector2& position, const Vector2& size)\t\n\t{\n\t\treturn this->position.x + this->size.x / 2 >= position.x\n\t\t\t&& this->position.x + this->size.x / 2 <= position.x + size.x\n\t\t\t&& this->position.y + this->size.y / 2 >= position.y\n\t\t\t&& this->position.y + this->size.y / 2 <= position.y + size.y;\n\t}\n\n\tvirtual void on_update(int delta){}\n\n\tvirtual void on_draw(const Camera& camera)const\n\t{\n\t\tif (is_debug)\n\t\t{\n\t\t\tsetfillcolor(RGB(255, 255, 255));\n\t\t\tsetlinecolor(RGB(255, 255, 255));\n\t\t\trectangle((int)position.x, (int)position.y, (int)position.x + size.x, (int)position.y + size.y);\n\n\t\t\tsolidcircle((int)(position.x + size.x / 2), (int)(position.y + size.y / 2), 5);\n\t\t\t\n\t\t}\n\t}\n\n\n\n\nprotected:\t\t\t\t\t\t\t\t//为了方便子类可以直接读取数据，所以选择protected\n\n\tVector2 size;\t\t\t\t\t\t//子弹尺寸\n\tVector2 position;\t\t\t\t\t//子弹位置\n\tVector2 velocity;\t\t\t\t\t//子弹速度\n\tint damage = 10;\t\t\t\t\t//子弹伤害\n\tbool valid = true;\t\t\t\t\t//子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画\n\tbool can_remove = false;\t\t\t//子弹是否可以被移除\n\tstd::function<void()> callback;\t\t//子弹碰撞回调函数，因为子弹可以积攒玩家的能量\n\tPlayerID target_id = PlayerID::P1;\t//子弹碰撞目标玩家ID，以免自己打自己\n\nprotected:\n\tbool check_if_exceeds_screen()\t\t\n\t{\n\t\treturn (position.x + size.x <= 0 || position.x >= getwidth()\n\t\t\t|| position.y + size.y <= 0 || position.y >= getheight());\n\t}\n\n};\n\n\n#endif // !_BULLET_H_\n~~~\n\n**派生类**\n\n~~~CPP\n#ifndef _PEA_BULLET_H_\n#define _PEA_BULLET_H_\n\n#include \"bullet.h\"\n#include \"animation.h\"\n\nextern IMAGE img_pea;\nextern Atlas atlas_pea_break;\n\nclass PeaBullet :public Bullet\n{\npublic:\n\tPeaBullet()\n\t{\n\t\tsize.x = 64;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tsize.y = 64;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tdamage = 10;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tanimation_break.set_atlas(&atlas_pea_break);\t\t\t\t\t\t\n\t\tanimation_break.set_interval(100);\n\t\tanimation_break.set_loop(false);\t\t\t\t\t\t\t\t\n\t\tanimation_break.set_callback([&]() {can_remove = true; });\t\t\t\n\t\t\n\t}\n\n\t~PeaBullet() = default;\n\n\tvoid on_collide()\n\t{\n\t\tBullet::on_collide();\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tswitch (rand() % 3)\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t{\n\t\tcase 0:\n\t\t\tmciSendString(_T(\"play pea_break_1 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmciSendString(_T(\"play pea_break_2 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmciSendString(_T(\"play pea_break_3 from 0\"), NULL, 0, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tvoid on_update(int delta)\n\t{\n\t\tposition += velocity * (float)delta;\t\t\t\t\t\t\t\t\n\t\tif (!valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tanimation_break.on_updata(delta);\n\n\t\tif (check_if_exceeds_screen())\t\t\t\t\t\t\t\t\t\t\n\t\t\tcan_remove = true;\n\t}\n\n\tvoid on_draw(const Camera& camera)const\n\t{\n\t\tif (valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tputimage_alpha(camera, (int)position.x, (int)position.y, &img_pea);\n\t\telse\n\t\t\tanimation_break.on_draw(camera, (int)position.x, (int)position.y);\n\n\n\t\tBullet::on_draw(camera);\n\t}\n\nprivate:\n\tAnimation animation_break;\t\t\t\t\t\t\n};\n\n\n#endif // !_PEA_BULLET_H_\n\n~~~\n\n","slug":"yang/C++继承","published":1,"__permalink":"articles/yang12342/继承/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85l000tlcut8e2ygji7","content":"<h1 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h1><blockquote>\n<p>在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。</p>\n<p>那今天就好好看看关于继承方面要注意的语法点</p>\n</blockquote>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"派生类的定义\"><a href=\"#派生类的定义\" class=\"headerlink\" title=\"派生类的定义\"></a>派生类的定义</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> 派生类名：继承方式 基类名</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    新增加的成员定义；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">student</span>: <span class=\"keyword\">public</span> people</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>唯一要说明的其实就是<strong>继承方式</strong></p>\n<ul>\n<li>public</li>\n</ul>\n<p>public（公有类）指的是对应的成员变量和函数可以被<strong>外界</strong>（全局函数，其他类的成员函数），<strong>自己的成员函数</strong>和<strong>友元</strong>直接调用</p>\n<p>最直观的就是被外界调用（前提是这些在类内是public）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student 小明；</span><br><span class=\"line\">    小明.<span class=\"built_in\">height</span>();\t<span class=\"comment\">//函数返回</span></span><br><span class=\"line\">\t小明。height；\t\t<span class=\"comment\">//直接返回成员变量</span></span><br><span class=\"line\"><span class=\"comment\">//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>private</li>\n</ul>\n<p>private（私有类）就是仅仅只限于类内的成员函数和友元进行访问</p>\n<ul>\n<li>protected</li>\n</ul>\n<p>protected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数</p>\n<p>但是基类的成员函数和成员变量的访问特性也会随着继承方式变化</p>\n<table>\n<thead>\n<tr>\n<th>基于成员的访问特性</th>\n<th>public继承</th>\n<th>protected继承</th>\n<th>private继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>public</td>\n<td>protected</td>\n<td>private</td>\n</tr>\n<tr>\n<td>private</td>\n<td>不可访问</td>\n<td>不可访问</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>protected</td>\n<td>protected</td>\n<td>private</td>\n</tr>\n</tbody></table>\n<p>其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性</p>\n<p><strong>我们只需要关注继承过来的变量对于当前类的访问特性。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">protected</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用</span></span><br><span class=\"line\">    <span class=\"comment\">//public继承过来则是protected类，说明可以继续往下继承</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base2</span>:<span class=\"keyword\">protected</span> base1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个也是完全能调用deal</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用</p>\n<hr>\n<h2 id=\"派生类对象的构造和析构\"><a href=\"#派生类对象的构造和析构\" class=\"headerlink\" title=\"派生类对象的构造和析构\"></a>派生类对象的构造和析构</h2><blockquote>\n<p>好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。</p>\n<p>因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要</p>\n<p>但还是得了解不是吗？</p>\n</blockquote>\n<p>继承的构造和析构其实也很好理解</p>\n<p>对于子类的构造，优先级是这样的</p>\n<ol>\n<li><strong>基类的构造函数</strong></li>\n<li><strong>自己里面包含的其他类的构造函数</strong></li>\n<li><strong>然后是自己的构造函数</strong></li>\n</ol>\n<p>派生类的构造函数形式如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">student</span>(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b):<span class=\"built_in\">people</span>(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在：后面给对应的基类传去对应的参数就行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决</p>\n<p>析构函数的顺序则是相反</p>\n<ol>\n<li><strong>先执行自己的析构函数</strong></li>\n<li><strong>再解决基类的析构函数</strong></li>\n</ol>\n<hr>\n<h2 id=\"重定义基类的函数\"><a href=\"#重定义基类的函数\" class=\"headerlink\" title=\"重定义基类的函数\"></a>重定义基类的函数</h2><p>当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此时调用base1.deal则是用派生类定义的deal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果需要调用父类的那个函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        base:<span class=\"built_in\">deal</span>();\t\t\t\t\t<span class=\"comment\">//需要“基类名：函数名”来调用父类的重定义的函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"将派生类对象隐式转换为基类对象\"><a href=\"#将派生类对象隐式转换为基类对象\" class=\"headerlink\" title=\"将派生类对象隐式转换为基类对象\"></a>将派生类对象隐式转换为基类对象</h2><h4 id=\"1-将派生类对象赋予基类对象（默认的赋值，好像没啥用）\"><a href=\"#1-将派生类对象赋予基类对象（默认的赋值，好像没啥用）\" class=\"headerlink\" title=\"1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）\"></a>1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）</h4><p>就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base=base1；</span><br></pre></td></tr></table></figure>\n\n<img src=\"p1.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"2-基类指针指向派生类（很重要）\"><a href=\"#2-基类指针指向派生类（很重要）\" class=\"headerlink\" title=\"2.基类指针指向派生类（很重要）\"></a>2.基类指针指向派生类（很重要）</h4><blockquote>\n<p>在植物明星大乱斗中，我们都是通过基类指针指向派生的对象</p>\n<p>player指针指向豌豆和向日葵，scene指向不同的场景</p>\n</blockquote>\n<img src=\"p2.png\" style=\"zoom:50%;\" />\n\n<p>基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。</p>\n<p>因此指向派生类的基类指针出发，只能访问派生类中的基类成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">base* point=<span class=\"keyword\">new</span> base;</span><br><span class=\"line\">point-&gt;<span class=\"built_in\">deal</span>();\t\t<span class=\"comment\">//这是可以的</span></span><br><span class=\"line\">point-&gt;<span class=\"built_in\">play</span>();\t\t<span class=\"comment\">//这是不行的</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展</p>\n<blockquote>\n<p><strong>但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？</strong></p>\n<p>Q&amp;A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量</p>\n</blockquote>\n<h4 id=\"3-基类对象引用派生类的对象\"><a href=\"#3-基类对象引用派生类的对象\" class=\"headerlink\" title=\"3.基类对象引用派生类的对象\"></a>3.基类对象引用派生类的对象</h4><blockquote>\n<p>引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base &amp;point=<span class=\"keyword\">new</span> base1;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"p3.png\" style=\"zoom: 50%;\" />\n\n<p>这样对基类引用的访问其实就是对派生类的基类的访问</p>\n<p>注意：</p>\n<ul>\n<li>派生类的指针不能指向基类</li>\n<li>派生类的指针也不能接受基类的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base1 d,*dp;</span><br><span class=\"line\">base *bp=dp;\t<span class=\"comment\">//基类指针指向派生类，正确的</span></span><br><span class=\"line\">dp=bp;\t\t\t<span class=\"comment\">//但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的</span></span><br></pre></td></tr></table></figure>\n\n<p>如果强制要转,使用强制类型转换（明确不会犯错）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp=<span class=\"keyword\">reinterpret_cast</span>&lt;Derived*&gt; bp; </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"最后附上一段植物明星大乱斗子弹类的继承（删了一些）\"><a href=\"#最后附上一段植物明星大乱斗子弹类的继承（删了一些）\" class=\"headerlink\" title=\"最后附上一段植物明星大乱斗子弹类的继承（删了一些）\"></a>最后附上一段植物明星大乱斗子弹类的继承（删了一些）</h2><p><strong>基类</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _BULLET_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _BULLET_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;vector2.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player_id.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;camera.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">bool</span> is_debug;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bullet</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Bullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Bullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_valid</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tvalid = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">get_valid</span><span class=\"params\">()</span><span class=\"type\">const</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> valid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span><span class=\"type\">const</span>\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> can_remove;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_collide</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (callback)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(<span class=\"type\">const</span> Vector2&amp; position, <span class=\"type\">const</span> Vector2&amp; size)</span>\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &gt;= position.x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &lt;= position.x + size.x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &gt;= position.y</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &lt;= position.y + size.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_debug)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">setfillcolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">setlinecolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">rectangle</span>((<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y, (<span class=\"type\">int</span>)position.x + size.x, (<span class=\"type\">int</span>)position.y + size.y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">solidcircle</span>((<span class=\"type\">int</span>)(position.x + size.x / <span class=\"number\">2</span>), (<span class=\"type\">int</span>)(position.y + size.y / <span class=\"number\">2</span>), <span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:\t\t\t\t\t\t\t\t<span class=\"comment\">//为了方便子类可以直接读取数据，所以选择protected</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tVector2 size;\t\t\t\t\t\t<span class=\"comment\">//子弹尺寸</span></span><br><span class=\"line\">\tVector2 position;\t\t\t\t\t<span class=\"comment\">//子弹位置</span></span><br><span class=\"line\">\tVector2 velocity;\t\t\t\t\t<span class=\"comment\">//子弹速度</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> damage = <span class=\"number\">10</span>;\t\t\t\t\t<span class=\"comment\">//子弹伤害</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> valid = <span class=\"literal\">true</span>;\t\t\t\t\t<span class=\"comment\">//子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;\t\t\t<span class=\"comment\">//子弹是否可以被移除</span></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t<span class=\"comment\">//子弹碰撞回调函数，因为子弹可以积攒玩家的能量</span></span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;\t<span class=\"comment\">//子弹碰撞目标玩家ID，以免自己打自己</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span>\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (position.x + size.x &lt;= <span class=\"number\">0</span> || position.x &gt;= <span class=\"built_in\">getwidth</span>()</span><br><span class=\"line\">\t\t\t|| position.y + size.y &lt;= <span class=\"number\">0</span> || position.y &gt;= <span class=\"built_in\">getheight</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_BULLET_H_</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>派生类</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _PEA_BULLET_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PEA_BULLET_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bullet.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;animation.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> IMAGE img_pea;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> Atlas atlas_pea_break;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PeaBullet</span> :<span class=\"keyword\">public</span> Bullet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">PeaBullet</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">64</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tsize.y = <span class=\"number\">64</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdamage = <span class=\"number\">10</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_atlas</span>(&amp;atlas_pea_break);\t\t\t\t\t\t</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_interval</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_loop</span>(<span class=\"literal\">false</span>);\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_callback</span>([&amp;]() &#123;can_remove = <span class=\"literal\">true</span>; &#125;);\t\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">PeaBullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collide</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tBullet::<span class=\"built_in\">on_collide</span>();\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (<span class=\"built_in\">rand</span>() % <span class=\"number\">3</span>)\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_1 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_2 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_3 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition += velocity * (<span class=\"type\">float</span>)delta;\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\tanimation_break.<span class=\"built_in\">on_updata</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_if_exceeds_screen</span>())\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">putimage_alpha</span>(camera, (<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y, &amp;img_pea);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tanimation_break.<span class=\"built_in\">on_draw</span>(camera, (<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBullet::<span class=\"built_in\">on_draw</span>(camera);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tAnimation animation_break;\t\t\t\t\t\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_PEA_BULLET_H_</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h1><blockquote>\n<p>在游戏开发中，我们对于一些GameObject都会创建基类，然后通过继承创建出不同的游戏对象，这有利于我们更好的管理角色或者其他对象。在植物明星大乱斗中，我们不论是子弹，玩家，场景都是通过创建基类再进一步继承创建相应的对象。</p>\n<p>那今天就好好看看关于继承方面要注意的语法点</p>\n</blockquote>\n<hr>","more":"<h2 id=\"派生类的定义\"><a href=\"#派生类的定义\" class=\"headerlink\" title=\"派生类的定义\"></a>派生类的定义</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> 派生类名：继承方式 基类名</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    新增加的成员定义；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">student</span>: <span class=\"keyword\">public</span> people</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>唯一要说明的其实就是<strong>继承方式</strong></p>\n<ul>\n<li>public</li>\n</ul>\n<p>public（公有类）指的是对应的成员变量和函数可以被<strong>外界</strong>（全局函数，其他类的成员函数），<strong>自己的成员函数</strong>和<strong>友元</strong>直接调用</p>\n<p>最直观的就是被外界调用（前提是这些在类内是public）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student 小明；</span><br><span class=\"line\">    小明.<span class=\"built_in\">height</span>();\t<span class=\"comment\">//函数返回</span></span><br><span class=\"line\">\t小明。height；\t\t<span class=\"comment\">//直接返回成员变量</span></span><br><span class=\"line\"><span class=\"comment\">//类似这样我直接可以通过实例化的对象直接调用内部的public函数或者成员变量</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>private</li>\n</ul>\n<p>private（私有类）就是仅仅只限于类内的成员函数和友元进行访问</p>\n<ul>\n<li>protected</li>\n</ul>\n<p>protected是针对继承的一个方式，对与类来说，protected访问特性的成员变量和成员函数只限于被派生类的成员函数和友元函数</p>\n<p>但是基类的成员函数和成员变量的访问特性也会随着继承方式变化</p>\n<table>\n<thead>\n<tr>\n<th>基于成员的访问特性</th>\n<th>public继承</th>\n<th>protected继承</th>\n<th>private继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>public</td>\n<td>protected</td>\n<td>private</td>\n</tr>\n<tr>\n<td>private</td>\n<td>不可访问</td>\n<td>不可访问</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>protected</td>\n<td>protected</td>\n<td>private</td>\n</tr>\n</tbody></table>\n<p>其实成员的访问特性只针对当前的类自己，protected完全是针对继承子类一种访问特性</p>\n<p><strong>我们只需要关注继承过来的变量对于当前类的访问特性。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">protected</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这样继承，base的x对于base1就是不可访问（只限于base自己用），无法使用</span></span><br><span class=\"line\">    <span class=\"comment\">//public继承过来则是protected类，说明可以继续往下继承</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base2</span>:<span class=\"keyword\">protected</span> base1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个也是完全能调用deal</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实继承就是一个不断包含的过程，要区分的就是成员的访问特性对于当下的类是否可以使用</p>\n<hr>\n<h2 id=\"派生类对象的构造和析构\"><a href=\"#派生类对象的构造和析构\" class=\"headerlink\" title=\"派生类对象的构造和析构\"></a>派生类对象的构造和析构</h2><blockquote>\n<p>好像是在《游戏引擎架构》一书中，强调了其实对于类并不推荐使用构造函数和析构函数，而是推荐创建对应的函数去显示的调用。</p>\n<p>因为构造函数和析构函数很容易无法确定构造和析构的顺序，对于复杂引擎的正确顺序的子系统启动很重要</p>\n<p>但还是得了解不是吗？</p>\n</blockquote>\n<p>继承的构造和析构其实也很好理解</p>\n<p>对于子类的构造，优先级是这样的</p>\n<ol>\n<li><strong>基类的构造函数</strong></li>\n<li><strong>自己里面包含的其他类的构造函数</strong></li>\n<li><strong>然后是自己的构造函数</strong></li>\n</ol>\n<p>派生类的构造函数形式如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">student</span>(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b):<span class=\"built_in\">people</span>(a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在：后面给对应的基类传去对应的参数就行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>派生类的构造函数只需要关注自己的父类，如果自己父类也是继承的，对于student完全是不用考虑，在people的构造中会自己解决</p>\n<p>析构函数的顺序则是相反</p>\n<ol>\n<li><strong>先执行自己的析构函数</strong></li>\n<li><strong>再解决基类的析构函数</strong></li>\n</ol>\n<hr>\n<h2 id=\"重定义基类的函数\"><a href=\"#重定义基类的函数\" class=\"headerlink\" title=\"重定义基类的函数\"></a>重定义基类的函数</h2><p>当派生类和基类的成员函数定义原型完全相同时，此时子类会对父类的函数进行覆盖</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此时调用base1.deal则是用派生类定义的deal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果需要调用父类的那个函数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        base:<span class=\"built_in\">deal</span>();\t\t\t\t\t<span class=\"comment\">//需要“基类名：函数名”来调用父类的重定义的函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"将派生类对象隐式转换为基类对象\"><a href=\"#将派生类对象隐式转换为基类对象\" class=\"headerlink\" title=\"将派生类对象隐式转换为基类对象\"></a>将派生类对象隐式转换为基类对象</h2><h4 id=\"1-将派生类对象赋予基类对象（默认的赋值，好像没啥用）\"><a href=\"#1-将派生类对象赋予基类对象（默认的赋值，好像没啥用）\" class=\"headerlink\" title=\"1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）\"></a>1.将派生类对象赋予基类对象（默认的赋值，好像没啥用）</h4><p>就是当派生类赋值给基类，基类只会接受派生类中基类的数据成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base=base1；</span><br></pre></td></tr></table></figure>\n\n<img src=\"p1.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"2-基类指针指向派生类（很重要）\"><a href=\"#2-基类指针指向派生类（很重要）\" class=\"headerlink\" title=\"2.基类指针指向派生类（很重要）\"></a>2.基类指针指向派生类（很重要）</h4><blockquote>\n<p>在植物明星大乱斗中，我们都是通过基类指针指向派生的对象</p>\n<p>player指针指向豌豆和向日葵，scene指向不同的场景</p>\n</blockquote>\n<img src=\"p2.png\" style=\"zoom:50%;\" />\n\n<p>基类的指针可以指向派生类，但是只能解释基类的成员，不能解释派生类新增的成员。</p>\n<p>因此指向派生类的基类指针出发，只能访问派生类中的基类成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">base1</span>:<span class=\"keyword\">public</span> base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">base* point=<span class=\"keyword\">new</span> base;</span><br><span class=\"line\">point-&gt;<span class=\"built_in\">deal</span>();\t\t<span class=\"comment\">//这是可以的</span></span><br><span class=\"line\">point-&gt;<span class=\"built_in\">play</span>();\t\t<span class=\"comment\">//这是不行的</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>虽然不能指向派生类新增成员，但是如果是基于父类函数的重定义是完全可以的，这样就增加了灵活性。这样我们只需要在基类给好函数模板，再在子类上进行拓展</p>\n<blockquote>\n<p><strong>但是有一个问题，成员函数是这样，但是成员变量该怎么办，派生类对象肯定有自己特殊的成员变量？</strong></p>\n<p>Q&amp;A：我们基于父类指针生成派生类对象，派生类对象的所有定义的都会生成，只是无法用指针访问，我们完全是可以在模板基础上拓展到函数里面去调用派生类特殊的成员变量</p>\n</blockquote>\n<h4 id=\"3-基类对象引用派生类的对象\"><a href=\"#3-基类对象引用派生类的对象\" class=\"headerlink\" title=\"3.基类对象引用派生类的对象\"></a>3.基类对象引用派生类的对象</h4><blockquote>\n<p>引用事实上是一种隐式的指针。当用一个基类对象引用派生类对象时，相当于给基类部分取了一个名称，从这个基类对象看到的时派生类中的基类部分</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base &amp;point=<span class=\"keyword\">new</span> base1;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"p3.png\" style=\"zoom: 50%;\" />\n\n<p>这样对基类引用的访问其实就是对派生类的基类的访问</p>\n<p>注意：</p>\n<ul>\n<li>派生类的指针不能指向基类</li>\n<li>派生类的指针也不能接受基类的指针</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">base1 d,*dp;</span><br><span class=\"line\">base *bp=dp;\t<span class=\"comment\">//基类指针指向派生类，正确的</span></span><br><span class=\"line\">dp=bp;\t\t\t<span class=\"comment\">//但是即使基类指向派生类，也不能把基类指针的东西赋值给派生类指针，这是错误的</span></span><br></pre></td></tr></table></figure>\n\n<p>如果强制要转,使用强制类型转换（明确不会犯错）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp=<span class=\"keyword\">reinterpret_cast</span>&lt;Derived*&gt; bp; </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"最后附上一段植物明星大乱斗子弹类的继承（删了一些）\"><a href=\"#最后附上一段植物明星大乱斗子弹类的继承（删了一些）\" class=\"headerlink\" title=\"最后附上一段植物明星大乱斗子弹类的继承（删了一些）\"></a>最后附上一段植物明星大乱斗子弹类的继承（删了一些）</h2><p><strong>基类</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _BULLET_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _BULLET_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;vector2.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;player_id.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;camera.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;graphics.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">bool</span> is_debug;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bullet</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Bullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Bullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_valid</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tvalid = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">get_valid</span><span class=\"params\">()</span><span class=\"type\">const</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> valid;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_can_remove</span><span class=\"params\">()</span><span class=\"type\">const</span>\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> can_remove;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_collide</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (callback)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">check_collision</span><span class=\"params\">(<span class=\"type\">const</span> Vector2&amp; position, <span class=\"type\">const</span> Vector2&amp; size)</span>\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &gt;= position.x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.x + <span class=\"keyword\">this</span>-&gt;size.x / <span class=\"number\">2</span> &lt;= position.x + size.x</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &gt;= position.y</span><br><span class=\"line\">\t\t\t&amp;&amp; <span class=\"keyword\">this</span>-&gt;position.y + <span class=\"keyword\">this</span>-&gt;size.y / <span class=\"number\">2</span> &lt;= position.y + size.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_debug)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">setfillcolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">setlinecolor</span>(<span class=\"built_in\">RGB</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">rectangle</span>((<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y, (<span class=\"type\">int</span>)position.x + size.x, (<span class=\"type\">int</span>)position.y + size.y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">solidcircle</span>((<span class=\"type\">int</span>)(position.x + size.x / <span class=\"number\">2</span>), (<span class=\"type\">int</span>)(position.y + size.y / <span class=\"number\">2</span>), <span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:\t\t\t\t\t\t\t\t<span class=\"comment\">//为了方便子类可以直接读取数据，所以选择protected</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tVector2 size;\t\t\t\t\t\t<span class=\"comment\">//子弹尺寸</span></span><br><span class=\"line\">\tVector2 position;\t\t\t\t\t<span class=\"comment\">//子弹位置</span></span><br><span class=\"line\">\tVector2 velocity;\t\t\t\t\t<span class=\"comment\">//子弹速度</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> damage = <span class=\"number\">10</span>;\t\t\t\t\t<span class=\"comment\">//子弹伤害</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> valid = <span class=\"literal\">true</span>;\t\t\t\t\t<span class=\"comment\">//子弹是否有效，有效要进行碰撞检测，无效说明碰撞发生，子弹开始播放销毁动画</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> can_remove = <span class=\"literal\">false</span>;\t\t\t<span class=\"comment\">//子弹是否可以被移除</span></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t<span class=\"comment\">//子弹碰撞回调函数，因为子弹可以积攒玩家的能量</span></span><br><span class=\"line\">\tPlayerID target_id = PlayerID::P1;\t<span class=\"comment\">//子弹碰撞目标玩家ID，以免自己打自己</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_if_exceeds_screen</span><span class=\"params\">()</span>\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (position.x + size.x &lt;= <span class=\"number\">0</span> || position.x &gt;= <span class=\"built_in\">getwidth</span>()</span><br><span class=\"line\">\t\t\t|| position.y + size.y &lt;= <span class=\"number\">0</span> || position.y &gt;= <span class=\"built_in\">getheight</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_BULLET_H_</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>派生类</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _PEA_BULLET_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PEA_BULLET_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bullet.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;animation.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> IMAGE img_pea;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> Atlas atlas_pea_break;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PeaBullet</span> :<span class=\"keyword\">public</span> Bullet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">PeaBullet</span>()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsize.x = <span class=\"number\">64</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tsize.y = <span class=\"number\">64</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdamage = <span class=\"number\">10</span>;\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_atlas</span>(&amp;atlas_pea_break);\t\t\t\t\t\t</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_interval</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_loop</span>(<span class=\"literal\">false</span>);\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tanimation_break.<span class=\"built_in\">set_callback</span>([&amp;]() &#123;can_remove = <span class=\"literal\">true</span>; &#125;);\t\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">PeaBullet</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_collide</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tBullet::<span class=\"built_in\">on_collide</span>();\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (<span class=\"built_in\">rand</span>() % <span class=\"number\">3</span>)\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_1 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_2 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mciSendString</span>(_T(<span class=\"string\">&quot;play pea_break_3 from 0&quot;</span>), <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tposition += velocity * (<span class=\"type\">float</span>)delta;\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\tanimation_break.<span class=\"built_in\">on_updata</span>(delta);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">check_if_exceeds_screen</span>())\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\tcan_remove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_draw</span><span class=\"params\">(<span class=\"type\">const</span> Camera&amp; camera)</span><span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (valid)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">putimage_alpha</span>(camera, (<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y, &amp;img_pea);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tanimation_break.<span class=\"built_in\">on_draw</span>(camera, (<span class=\"type\">int</span>)position.x, (<span class=\"type\">int</span>)position.y);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBullet::<span class=\"built_in\">on_draw</span>(camera);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tAnimation animation_break;\t\t\t\t\t\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_PEA_BULLET_H_</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"map&&unordered_map","date":"2024-06-29T16:00:00.000Z","updated":"2024-06-29T16:00:00.000Z","_content":"\n## map&&unordered_map\n\n> 恰巧看到大V老师使用unordered_map来实现了资源池，那么便想在分析池的概念前，先弄清这个STL的提供的结构\n>\n> 将分析pair，map，unordered_map\n>\n> 我们将解决课程的以下疑问\n>\n> 1. map和unordered_map的一些使用方法和概念（主要是解释map）？\n> 2. 为什么大v老师的使用下标【】的方法就可以构建新的对象？\n> 3. 大v老师的键值使用了枚举，那么对于unordered_map键值类型限制和map的键值类型限制具体有哪些，枚举为什么可以作为其键值（最后的比较会解释）？\n\n<!-- More -->\n\n## pair和map\n\n## pair\n\n> pair是c++定义好的一个类模板的结构体，使用需要加上头文件<utility>\n\npair意如其名，就是一对，用于一对数据的集合，这个数据结构就十分有利于后面的键值和关键字值的集合，进一步实现各类查找表，map的基本单元就是pair构成的。\n\npair的部分源码\n\n~~~CPP\ntemplate <class T1, class T2>\nstruct pair\n{\n\ttypedef T1 first_type;\t\t\t//对第一个类型的别名\n\ttypedef T2 second_type;\t\t\t//对第二个类型的别名\n\t\n\tT1 first;\t\t\t\t\t\t//第一个数据成员\n\tT2 second;\t\t\t\t\t\t//第二个数据成员\n\tpair(): first(T1()), second(T2())\n\t{}\n\tpair(const T1& a, const T2& b): first(a), second(b)\n\t{}\n}\n~~~\n\n最常用的就是pair的俩个可访问的first和second\n\n**【声明方式】**\n\n~~~CPP\nstd::pair<第一种数据类型，第二种数据类型> 变量名;\n~~~\n\n**【简单的使用】**\n\n~~~CPP\n#include <iostream>\n#include <utility>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    pair<int, int> test;\n    stu.first = 1;\n    stu.second = 2;\n   cout << stu.first <<endl;\n   cout << stu.second<<endl;\n    return 0;\n}\n\n~~~\n\n#### **初始化**\n\n<img src=\"./8c4bc7708c19453186b2bb91df9ed7e9.png\" alt=\"在这里插入图片描述\" />\n\n1. 第一种就是默认构造函数，数字类型数据初始化为0，字符串初始化为空，\n\n   如果是类的话从上面提供的部分源码看，进一步调用类的构造函数\n\n~~~CPP\npair<int,int >test;\n~~~\n\n2. 第二种就是拷贝构造函数，必须是同类型的就是了\n\n~~~CPP\npair<int,int >test（pair_copy）;\npair<int,int >test=pair_copy;\t\t//这俩种形式调用的都是赋值构造函数，不是=的运算符重载\n~~~\n\n3. 第三种就是构造函数传入对应的俩个值了,就是构造函数重载\n\n~~~CPP\npair<int,int>test(1,1);\n~~~\n\n#### **还能比较大小**\n\n就是实现了运算符重载\n\n<img src=\"./45d8c982a7bc4392b7cdc220c3147b22.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<img src=\"./0902517424204b618b2d27075e4a3d37.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n先比first，first相等再比second（前提是对应的数据类型必须相同）\n\n字符串的比较大小的规则在string可以去了解，至于类可能就是取决于类的运算符重载了\n\n~~~CPP\npair_1>pair_2;\n~~~\n\n\n\n#### make_pair()\n\n<img src=\"./74bb10b1d0024d6aaee8e2036be019f1.png\" alt=\"在这里插入图片描述\" />\n\n这就是标准库的提供的一个函数，用于创建一个临时的pair\n\n功能：**`make_pair`函数接收两个参数，然后它会将这两个参数来创建`pair`对象**\n\n~~~CPP\nmap.insert(make_pair<int,int>tmp(1,2));//这样就可以在图直接插入一个临时创建的pair了\n~~~\n\n---\n\n## map\n\n> 首先在STL的容器类型上，map属于“关联式容器”\n>\n> **所谓关联式容器，就是每个元素都有一个键值（`key`）和一个实值（`value`）。当元素被插入到关联式容器中时，容器内部结构可能是红黑树，也可能是哈希表，然后按照其键值`key`大小，以某种特点规则将这个元素放在一个合适的位置**。\n>\n> 一般而言，**关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率**，也就没有一般序列式的容器的头尾元素\n\nmap就是以pair为基本单元，结构上采取红黑树形成的一个动态查找表。\n\n此时pair的俩个元素就有区别了pair<键值，实值>\n\n注意：map不允许重复的键值出现\n\n<img src=\"./4506b0d4a9fb4c68a4f21af2e8f4b7b3.png\" alt=\"在这里插入图片描述\" />\n\n#/## 插入\n\n> V老师的没有使用插入函数，而是使用索引去实现插入的功能，\n>\n> 虽然使用的是unordered_map（基于哈希表实现），但是和map大概原理也大差不差\n>\n> 后面也会分析如何实现【】访问操作\n\n**【函数原型】**\n\n<img src=\"./68bfe33fe1914bf5bfcc01ad7534cd5e.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./99abbcbff8fb414082511a66ece8f60a.png\" alt=\"在这里插入图片描述\" />\n\n从第一个插入函数参数我们可以直到调用map的insert参数是一个pair类型，其次注意其返回值是一个pair<迭代器，bool（是否插入成功）>\n\n所以要注意的就是参数和返回值。\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n    dic.insert(make_pair(1,1));\t\t\t\t//正常的插入操作\n    \n    //插入的返回值是一个pair，first是迭代器（指向插入的指针），second是bool显示是否插入成功\n\tcout << (dic.insert(make_pair(3, 3))).second;\t\t//调用返回的pair的second，显示为1，表示插入成功\n    cout << (dic.insert(make_pair(2, 2))).first->second;//使用first迭代器指向插入对象的second，显示为2\n    \n\treturn 0;\n}\n~~~\n\n常用的插入方式如下\n\n~~~CPP\n//方式1\npair<int,int>test=(1,1);\nmap.insert(test);\n//方式2\nmap.insert(make_pair(1,1));\n\n//根据插入函数2，起始发现可以使用迭代器插入，但是对于有序的map来说必然要涉及到重排什么的，我觉得我一般也用不上\niterator insert (const_iterator position, const value_type& val);\n//根据插入函数三，是c++11新提供的可以一次性插入多个值，我觉我也用不上，乐\nvoid insert (initializer_list<value_type> il);\n~~~\n\n### 迭代器\n\nmap支持迭代器，表明我们可以利用迭代器遍历甚至是for\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n\tdic.insert(make_pair(1, 1));\n\tdic.insert(make_pair(2, 1));\n\tdic.insert(make_pair(3, 1));\n\tdic.insert(make_pair(4, 1));\n\tdic.insert(make_pair(5, 1));\n\tmap<int, int>::iterator begin = dic.begin();\n\tmap<int,int>::iterator end=dic.end();\n\t//迭代器循环\n\twhile (begin != end)\n\t{\n\t\tcout << begin->first;\t\t//既可以用指针访问\n\t\tcout << (*begin).first;\t\t//也可以用*，再用.first访问\n\t\tbegin++;\n\t\t//显示了1122334455\n\t}\n\n\t//for循环的使用也是可以的，直接获取对方的引用\n\tfor (auto& pair : dic)\n\t{\n\t\tcout << pair.first;\n        //显示12345\n\t}\n\treturn 0;\n}\n~~~\n\n**那么现在就有一个问题：可以通过`map`的迭代器改变`map`的元素内容吗？**\n\n- **如果是想修改键值(`key`)是不行的**。还是和`set`一样的原因：`map`元素的键值关系到`map`元素的排列规则。任意改变`map`元素的`key`将会严重破坏`map`组织。\n- **但如果想要修改元素的实值(`value`)，那么是可以的**。因为`map`元素的实值`value`并不影响`map`的排列规则\n\n<img src=\"./95b245ce93fc49bb85c42e0fbd166697.png\" alt=\"在这里插入图片描述\" />\n\n这里显示键值是const，不可修改\n\n### operator【】\n\n对于上面的**实值**遍历我也可以这么写\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n\tdic.insert(make_pair(1, 1));\n\tdic.insert(make_pair(2, 1));\n\tdic.insert(make_pair(3, 1));\n\tdic.insert(make_pair(4, 1));\n\tdic.insert(make_pair(5, 1));\n\n\tcout << endl;\n\tfor (int i = 1; i < 6; i++)\n\t{\n\t\tcout << dic[i];\n\t}\n\t//显示了11111\n\n\treturn 0;\n}\n~~~\n\n不难看出对于map类函数，键值可以直接当做索引直接访问\n\n<img src=\"./202d8acdd52f4509b9dbab88998ab4ef.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./f3fc7b2dc87b4bc285059b5154d9292c.png\" alt=\"在这里插入图片描述\" />\n\nmapped_type就是对应的实值，key_type就是对应的键值\n\n【】的重载以键值为参数，返回对实值的引用\n\n\n\n**但是V老师明明是在创建新的对象，为什么可以直接赋值创建新对象呢呢**？\n\n<img src=\"./5e1c85cfceb84975951d63017b8bca37.png\" alt=\"在这里插入图片描述\" />\n\n上面的图像说明了原理，我们之前也分析了insert函数的返回值是$pair<iterator,bool>$\n\n先调用map当前的insert函数（this->insert()）\n\n如果有重复的键值就会插入失败，返回pair<对应位置的迭代器，false>,返回pair的first（要查找的pair）的second（实值）。\n\n如果没有重复的键值显然插入成功了，返回pair<新插入的点的迭代器，true>，返回pair的first（新创建的pair）的second。\n\n> 那么访问的也不过俩种情况\n>\n> 1. 键值`key`已经在树里，那么就返回树里面`key`所在结点的迭代器\n> 2. 键值`key`不在树里，那么就返回新插入`key`所在结点的迭代器（注意没有键值就新插入一个了）\n>\n> **注意观察函数的返回值是引用，表明我们可以修改对应的实值value。**\n\n\n\n从而大v老师的创建也就合理，因为对应的键值没有，所以在访问的时候已经创建了。\n\n虽然大v老师使用的是无序图(哈希表实现)的，但实现类似不妨碍我们去理解。\n\n（对于枚举作键值起始也很好理解，枚举ResID是一种类型，就像int，里面的实际的对象就是键值，就像1，2\n\n但是对于哈希表的键值，这里枚举能使用的原因也比较特殊）\n\n~~~CPP\ntexture_pool[ResID::Tex_Player] = IMG_LoadTexture(renderer, \"resources/player.png\");\ntexture_pool[ResID::Tex_Archer] = IMG_LoadTexture(renderer, \"resources/tower_archer.png\");\ntexture_pool[ResID::Tex_Axeman] = IMG_LoadTexture(renderer, \"resources/tower_axeman.png\");\n~~~\n\n---\n\n### 常见的其他map函数方法\n\n#### 取值\n\nMap中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。\n\n[]实现原理我们也解释了,不难理解为什么不会\n\n~~~CPP\nID_Name.at(2016)；\n~~~\n\n#### 容量查询\n\n~~~CPP\n// 查询map是否为空\nbool empty();\n\n// 查询map中键值对的数量\nsize_t size();\n\n// 查询map所能包含的最大键值对数量，和系统和应用库有关。\n// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了\nsize_t max_size();\n\n// 查询关键字为key的元素的个数，在map里结果非0即1\nsize_t count( const Key& key ) const; //\n~~~\n\n#### 删除\n\n~~~CPP\n// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type& key );\n\n// 清空map，清空后的size为0\nvoid clear();\n~~~\n\n#### 交换\n\n~~~CPP\n// 就是两个map的内容互换\nvoid swap( map& other );\n~~~\n\n#### 顺序比较\n\n~~~CPP\n// 比较两个关键字在map中位置的先后\nkey_compare key_comp() const;\n~~~\n\n#### 查找\n\n~~~CPP\n// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器\n// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator\niterator find (const key_type& k);\nconst_iterator find (const key_type& k) const;\n~~~\n\n---\n\n## unordered_map和map简单比较（使用方法类似，只说说不同）\n\n首先最大的区别就是底层的实现逻辑不同\n\n**map：**\n\n优点：\n\n1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作\n2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高\n\n缺点： \n\n1. 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间\n\n适用处：对于那些有顺序要求的问题，用map会更高效一些\n\n\n\n**unordered_map：**\n\n优点： \n\n1. 因为内部实现了哈希表，因此其查找速度非常的快\n\n缺点： \n\n1. 哈希表的建立比较耗费时间\n\n适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n---\n\n有一点我比较在意就是关于**键值的问题**\n\n对于红黑树的有序排序必然少不了比较，而哈希表的键值映射到索引的过程如何转换\n\n**对于map来说**\n\n对于提供键值的类型虽然没有限制，但是对于一些自定义的类，必须有比较运算符的重载（>,<,==,）\n\n不然无法在红黑树实现有序的排序，下面的方式就会报错\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct num\n{\n\tstring tmp;\n\tint a;\n\tint b;\n};\n\nint main()\n{\n\tmap<num,int> dic;\n\n\tnum tmp1;\n\ttmp1.tmp = \"lalla\";\ttmp1.a = 1;tmp1.b = 2;\n\tnum tmp2;\n\ttmp2.tmp = \"lalla\";tmp2.a = 1;tmp2.b = 2;\n    \n\tdic.insert(make_pair(tmp1, 2));\n\tdic.insert(make_pair(tmp2, 2));\n\t//会显示失败，因为没有定义重载运算符\n\treturn 0;\n}\n~~~\n\n**对于unordered_map来说**\n\n键值只能是int或者string类型，因为哈希表是一个映射的过程\n\n<img src=\"./image-20240630204341298.png\" alt=\"image-20240630204341298\" />\n\n所以显然类无法通过函数实现映射，只能使用其哈希内部定义的整型和字符串\n\n\n\n**对于大v老师的使用来说，恰巧枚举是可以视为整型数据的，所以可以作为unordered_map的键值，这一点也是十分巧妙。**\n","source":"_posts/yang/map&&unordered_map.md","raw":"---\ntitle: map&&unordered_map\ndate: 2024-06-30\nupdated: 2024-06-30\npermalink: articles/yang12342/map&&unordered_map的使用/\ncategories: yang12342\ntags: [STL,数据结构,塔防课程]\n---\n\n## map&&unordered_map\n\n> 恰巧看到大V老师使用unordered_map来实现了资源池，那么便想在分析池的概念前，先弄清这个STL的提供的结构\n>\n> 将分析pair，map，unordered_map\n>\n> 我们将解决课程的以下疑问\n>\n> 1. map和unordered_map的一些使用方法和概念（主要是解释map）？\n> 2. 为什么大v老师的使用下标【】的方法就可以构建新的对象？\n> 3. 大v老师的键值使用了枚举，那么对于unordered_map键值类型限制和map的键值类型限制具体有哪些，枚举为什么可以作为其键值（最后的比较会解释）？\n\n<!-- More -->\n\n## pair和map\n\n## pair\n\n> pair是c++定义好的一个类模板的结构体，使用需要加上头文件<utility>\n\npair意如其名，就是一对，用于一对数据的集合，这个数据结构就十分有利于后面的键值和关键字值的集合，进一步实现各类查找表，map的基本单元就是pair构成的。\n\npair的部分源码\n\n~~~CPP\ntemplate <class T1, class T2>\nstruct pair\n{\n\ttypedef T1 first_type;\t\t\t//对第一个类型的别名\n\ttypedef T2 second_type;\t\t\t//对第二个类型的别名\n\t\n\tT1 first;\t\t\t\t\t\t//第一个数据成员\n\tT2 second;\t\t\t\t\t\t//第二个数据成员\n\tpair(): first(T1()), second(T2())\n\t{}\n\tpair(const T1& a, const T2& b): first(a), second(b)\n\t{}\n}\n~~~\n\n最常用的就是pair的俩个可访问的first和second\n\n**【声明方式】**\n\n~~~CPP\nstd::pair<第一种数据类型，第二种数据类型> 变量名;\n~~~\n\n**【简单的使用】**\n\n~~~CPP\n#include <iostream>\n#include <utility>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    pair<int, int> test;\n    stu.first = 1;\n    stu.second = 2;\n   cout << stu.first <<endl;\n   cout << stu.second<<endl;\n    return 0;\n}\n\n~~~\n\n#### **初始化**\n\n<img src=\"./8c4bc7708c19453186b2bb91df9ed7e9.png\" alt=\"在这里插入图片描述\" />\n\n1. 第一种就是默认构造函数，数字类型数据初始化为0，字符串初始化为空，\n\n   如果是类的话从上面提供的部分源码看，进一步调用类的构造函数\n\n~~~CPP\npair<int,int >test;\n~~~\n\n2. 第二种就是拷贝构造函数，必须是同类型的就是了\n\n~~~CPP\npair<int,int >test（pair_copy）;\npair<int,int >test=pair_copy;\t\t//这俩种形式调用的都是赋值构造函数，不是=的运算符重载\n~~~\n\n3. 第三种就是构造函数传入对应的俩个值了,就是构造函数重载\n\n~~~CPP\npair<int,int>test(1,1);\n~~~\n\n#### **还能比较大小**\n\n就是实现了运算符重载\n\n<img src=\"./45d8c982a7bc4392b7cdc220c3147b22.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<img src=\"./0902517424204b618b2d27075e4a3d37.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n先比first，first相等再比second（前提是对应的数据类型必须相同）\n\n字符串的比较大小的规则在string可以去了解，至于类可能就是取决于类的运算符重载了\n\n~~~CPP\npair_1>pair_2;\n~~~\n\n\n\n#### make_pair()\n\n<img src=\"./74bb10b1d0024d6aaee8e2036be019f1.png\" alt=\"在这里插入图片描述\" />\n\n这就是标准库的提供的一个函数，用于创建一个临时的pair\n\n功能：**`make_pair`函数接收两个参数，然后它会将这两个参数来创建`pair`对象**\n\n~~~CPP\nmap.insert(make_pair<int,int>tmp(1,2));//这样就可以在图直接插入一个临时创建的pair了\n~~~\n\n---\n\n## map\n\n> 首先在STL的容器类型上，map属于“关联式容器”\n>\n> **所谓关联式容器，就是每个元素都有一个键值（`key`）和一个实值（`value`）。当元素被插入到关联式容器中时，容器内部结构可能是红黑树，也可能是哈希表，然后按照其键值`key`大小，以某种特点规则将这个元素放在一个合适的位置**。\n>\n> 一般而言，**关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率**，也就没有一般序列式的容器的头尾元素\n\nmap就是以pair为基本单元，结构上采取红黑树形成的一个动态查找表。\n\n此时pair的俩个元素就有区别了pair<键值，实值>\n\n注意：map不允许重复的键值出现\n\n<img src=\"./4506b0d4a9fb4c68a4f21af2e8f4b7b3.png\" alt=\"在这里插入图片描述\" />\n\n#/## 插入\n\n> V老师的没有使用插入函数，而是使用索引去实现插入的功能，\n>\n> 虽然使用的是unordered_map（基于哈希表实现），但是和map大概原理也大差不差\n>\n> 后面也会分析如何实现【】访问操作\n\n**【函数原型】**\n\n<img src=\"./68bfe33fe1914bf5bfcc01ad7534cd5e.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./99abbcbff8fb414082511a66ece8f60a.png\" alt=\"在这里插入图片描述\" />\n\n从第一个插入函数参数我们可以直到调用map的insert参数是一个pair类型，其次注意其返回值是一个pair<迭代器，bool（是否插入成功）>\n\n所以要注意的就是参数和返回值。\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n    dic.insert(make_pair(1,1));\t\t\t\t//正常的插入操作\n    \n    //插入的返回值是一个pair，first是迭代器（指向插入的指针），second是bool显示是否插入成功\n\tcout << (dic.insert(make_pair(3, 3))).second;\t\t//调用返回的pair的second，显示为1，表示插入成功\n    cout << (dic.insert(make_pair(2, 2))).first->second;//使用first迭代器指向插入对象的second，显示为2\n    \n\treturn 0;\n}\n~~~\n\n常用的插入方式如下\n\n~~~CPP\n//方式1\npair<int,int>test=(1,1);\nmap.insert(test);\n//方式2\nmap.insert(make_pair(1,1));\n\n//根据插入函数2，起始发现可以使用迭代器插入，但是对于有序的map来说必然要涉及到重排什么的，我觉得我一般也用不上\niterator insert (const_iterator position, const value_type& val);\n//根据插入函数三，是c++11新提供的可以一次性插入多个值，我觉我也用不上，乐\nvoid insert (initializer_list<value_type> il);\n~~~\n\n### 迭代器\n\nmap支持迭代器，表明我们可以利用迭代器遍历甚至是for\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n\tdic.insert(make_pair(1, 1));\n\tdic.insert(make_pair(2, 1));\n\tdic.insert(make_pair(3, 1));\n\tdic.insert(make_pair(4, 1));\n\tdic.insert(make_pair(5, 1));\n\tmap<int, int>::iterator begin = dic.begin();\n\tmap<int,int>::iterator end=dic.end();\n\t//迭代器循环\n\twhile (begin != end)\n\t{\n\t\tcout << begin->first;\t\t//既可以用指针访问\n\t\tcout << (*begin).first;\t\t//也可以用*，再用.first访问\n\t\tbegin++;\n\t\t//显示了1122334455\n\t}\n\n\t//for循环的使用也是可以的，直接获取对方的引用\n\tfor (auto& pair : dic)\n\t{\n\t\tcout << pair.first;\n        //显示12345\n\t}\n\treturn 0;\n}\n~~~\n\n**那么现在就有一个问题：可以通过`map`的迭代器改变`map`的元素内容吗？**\n\n- **如果是想修改键值(`key`)是不行的**。还是和`set`一样的原因：`map`元素的键值关系到`map`元素的排列规则。任意改变`map`元素的`key`将会严重破坏`map`组织。\n- **但如果想要修改元素的实值(`value`)，那么是可以的**。因为`map`元素的实值`value`并不影响`map`的排列规则\n\n<img src=\"./95b245ce93fc49bb85c42e0fbd166697.png\" alt=\"在这里插入图片描述\" />\n\n这里显示键值是const，不可修改\n\n### operator【】\n\n对于上面的**实值**遍历我也可以这么写\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n\tmap<int,int> dic;\n\tdic.insert(make_pair(1, 1));\n\tdic.insert(make_pair(2, 1));\n\tdic.insert(make_pair(3, 1));\n\tdic.insert(make_pair(4, 1));\n\tdic.insert(make_pair(5, 1));\n\n\tcout << endl;\n\tfor (int i = 1; i < 6; i++)\n\t{\n\t\tcout << dic[i];\n\t}\n\t//显示了11111\n\n\treturn 0;\n}\n~~~\n\n不难看出对于map类函数，键值可以直接当做索引直接访问\n\n<img src=\"./202d8acdd52f4509b9dbab88998ab4ef.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./f3fc7b2dc87b4bc285059b5154d9292c.png\" alt=\"在这里插入图片描述\" />\n\nmapped_type就是对应的实值，key_type就是对应的键值\n\n【】的重载以键值为参数，返回对实值的引用\n\n\n\n**但是V老师明明是在创建新的对象，为什么可以直接赋值创建新对象呢呢**？\n\n<img src=\"./5e1c85cfceb84975951d63017b8bca37.png\" alt=\"在这里插入图片描述\" />\n\n上面的图像说明了原理，我们之前也分析了insert函数的返回值是$pair<iterator,bool>$\n\n先调用map当前的insert函数（this->insert()）\n\n如果有重复的键值就会插入失败，返回pair<对应位置的迭代器，false>,返回pair的first（要查找的pair）的second（实值）。\n\n如果没有重复的键值显然插入成功了，返回pair<新插入的点的迭代器，true>，返回pair的first（新创建的pair）的second。\n\n> 那么访问的也不过俩种情况\n>\n> 1. 键值`key`已经在树里，那么就返回树里面`key`所在结点的迭代器\n> 2. 键值`key`不在树里，那么就返回新插入`key`所在结点的迭代器（注意没有键值就新插入一个了）\n>\n> **注意观察函数的返回值是引用，表明我们可以修改对应的实值value。**\n\n\n\n从而大v老师的创建也就合理，因为对应的键值没有，所以在访问的时候已经创建了。\n\n虽然大v老师使用的是无序图(哈希表实现)的，但实现类似不妨碍我们去理解。\n\n（对于枚举作键值起始也很好理解，枚举ResID是一种类型，就像int，里面的实际的对象就是键值，就像1，2\n\n但是对于哈希表的键值，这里枚举能使用的原因也比较特殊）\n\n~~~CPP\ntexture_pool[ResID::Tex_Player] = IMG_LoadTexture(renderer, \"resources/player.png\");\ntexture_pool[ResID::Tex_Archer] = IMG_LoadTexture(renderer, \"resources/tower_archer.png\");\ntexture_pool[ResID::Tex_Axeman] = IMG_LoadTexture(renderer, \"resources/tower_axeman.png\");\n~~~\n\n---\n\n### 常见的其他map函数方法\n\n#### 取值\n\nMap中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。\n\n[]实现原理我们也解释了,不难理解为什么不会\n\n~~~CPP\nID_Name.at(2016)；\n~~~\n\n#### 容量查询\n\n~~~CPP\n// 查询map是否为空\nbool empty();\n\n// 查询map中键值对的数量\nsize_t size();\n\n// 查询map所能包含的最大键值对数量，和系统和应用库有关。\n// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了\nsize_t max_size();\n\n// 查询关键字为key的元素的个数，在map里结果非0即1\nsize_t count( const Key& key ) const; //\n~~~\n\n#### 删除\n\n~~~CPP\n// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type& key );\n\n// 清空map，清空后的size为0\nvoid clear();\n~~~\n\n#### 交换\n\n~~~CPP\n// 就是两个map的内容互换\nvoid swap( map& other );\n~~~\n\n#### 顺序比较\n\n~~~CPP\n// 比较两个关键字在map中位置的先后\nkey_compare key_comp() const;\n~~~\n\n#### 查找\n\n~~~CPP\n// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器\n// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator\niterator find (const key_type& k);\nconst_iterator find (const key_type& k) const;\n~~~\n\n---\n\n## unordered_map和map简单比较（使用方法类似，只说说不同）\n\n首先最大的区别就是底层的实现逻辑不同\n\n**map：**\n\n优点：\n\n1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作\n2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高\n\n缺点： \n\n1. 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间\n\n适用处：对于那些有顺序要求的问题，用map会更高效一些\n\n\n\n**unordered_map：**\n\n优点： \n\n1. 因为内部实现了哈希表，因此其查找速度非常的快\n\n缺点： \n\n1. 哈希表的建立比较耗费时间\n\n适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n---\n\n有一点我比较在意就是关于**键值的问题**\n\n对于红黑树的有序排序必然少不了比较，而哈希表的键值映射到索引的过程如何转换\n\n**对于map来说**\n\n对于提供键值的类型虽然没有限制，但是对于一些自定义的类，必须有比较运算符的重载（>,<,==,）\n\n不然无法在红黑树实现有序的排序，下面的方式就会报错\n\n~~~CPP\n#include<iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct num\n{\n\tstring tmp;\n\tint a;\n\tint b;\n};\n\nint main()\n{\n\tmap<num,int> dic;\n\n\tnum tmp1;\n\ttmp1.tmp = \"lalla\";\ttmp1.a = 1;tmp1.b = 2;\n\tnum tmp2;\n\ttmp2.tmp = \"lalla\";tmp2.a = 1;tmp2.b = 2;\n    \n\tdic.insert(make_pair(tmp1, 2));\n\tdic.insert(make_pair(tmp2, 2));\n\t//会显示失败，因为没有定义重载运算符\n\treturn 0;\n}\n~~~\n\n**对于unordered_map来说**\n\n键值只能是int或者string类型，因为哈希表是一个映射的过程\n\n<img src=\"./image-20240630204341298.png\" alt=\"image-20240630204341298\" />\n\n所以显然类无法通过函数实现映射，只能使用其哈希内部定义的整型和字符串\n\n\n\n**对于大v老师的使用来说，恰巧枚举是可以视为整型数据的，所以可以作为unordered_map的键值，这一点也是十分巧妙。**\n","slug":"yang/map&&unordered_map","published":1,"__permalink":"articles/yang12342/map&&unordered_map的使用/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85m000wlcut1ncnd3ot","content":"<h2 id=\"map-unordered-map\"><a href=\"#map-unordered-map\" class=\"headerlink\" title=\"map&amp;&amp;unordered_map\"></a>map&amp;&amp;unordered_map</h2><blockquote>\n<p>恰巧看到大V老师使用unordered_map来实现了资源池，那么便想在分析池的概念前，先弄清这个STL的提供的结构</p>\n<p>将分析pair，map，unordered_map</p>\n<p>我们将解决课程的以下疑问</p>\n<ol>\n<li>map和unordered_map的一些使用方法和概念（主要是解释map）？</li>\n<li>为什么大v老师的使用下标【】的方法就可以构建新的对象？</li>\n<li>大v老师的键值使用了枚举，那么对于unordered_map键值类型限制和map的键值类型限制具体有哪些，枚举为什么可以作为其键值（最后的比较会解释）？</li>\n</ol>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"pair和map\"><a href=\"#pair和map\" class=\"headerlink\" title=\"pair和map\"></a>pair和map</h2><h2 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h2><blockquote>\n<p>pair是c++定义好的一个类模板的结构体，使用需要加上头文件<utility></p>\n</blockquote>\n<p>pair意如其名，就是一对，用于一对数据的集合，这个数据结构就十分有利于后面的键值和关键字值的集合，进一步实现各类查找表，map的基本单元就是pair构成的。</p>\n<p>pair的部分源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> T1 first_type;\t\t\t<span class=\"comment\">//对第一个类型的别名</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> T2 second_type;\t\t\t<span class=\"comment\">//对第二个类型的别名</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tT1 first;\t\t\t\t\t\t<span class=\"comment\">//第一个数据成员</span></span><br><span class=\"line\">\tT2 second;\t\t\t\t\t\t<span class=\"comment\">//第二个数据成员</span></span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>(): <span class=\"built_in\">first</span>(<span class=\"built_in\">T1</span>()), <span class=\"built_in\">second</span>(<span class=\"built_in\">T2</span>())</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>(<span class=\"type\">const</span> T1&amp; a, <span class=\"type\">const</span> T2&amp; b): <span class=\"built_in\">first</span>(a), <span class=\"built_in\">second</span>(b)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最常用的就是pair的俩个可访问的first和second</p>\n<p><strong>【声明方式】</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::pair&lt;第一种数据类型，第二种数据类型&gt; 变量名;</span><br></pre></td></tr></table></figure>\n\n<p><strong>【简单的使用】</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; test;</span><br><span class=\"line\">    stu.first = <span class=\"number\">1</span>;</span><br><span class=\"line\">    stu.second = <span class=\"number\">2</span>;</span><br><span class=\"line\">   cout &lt;&lt; stu.first &lt;&lt;endl;</span><br><span class=\"line\">   cout &lt;&lt; stu.second&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a><strong>初始化</strong></h4><img src=\"./8c4bc7708c19453186b2bb91df9ed7e9.png\" alt=\"在这里插入图片描述\" />\n\n<ol>\n<li><p>第一种就是默认构造函数，数字类型数据初始化为0，字符串初始化为空，</p>\n<p>如果是类的话从上面提供的部分源码看，进一步调用类的构造函数</p>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>第二种就是拷贝构造函数，必须是同类型的就是了</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test（pair_copy）;</span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test=pair_copy;\t\t<span class=\"comment\">//这俩种形式调用的都是赋值构造函数，不是=的运算符重载</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>第三种就是构造函数传入对应的俩个值了,就是构造函数重载</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"built_in\">test</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"还能比较大小\"><a href=\"#还能比较大小\" class=\"headerlink\" title=\"还能比较大小\"></a><strong>还能比较大小</strong></h4><p>就是实现了运算符重载</p>\n<img src=\"./45d8c982a7bc4392b7cdc220c3147b22.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<img src=\"./0902517424204b618b2d27075e4a3d37.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<p>先比first，first相等再比second（前提是对应的数据类型必须相同）</p>\n<p>字符串的比较大小的规则在string可以去了解，至于类可能就是取决于类的运算符重载了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_1&gt;pair_2;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"make-pair\"><a href=\"#make-pair\" class=\"headerlink\" title=\"make_pair()\"></a>make_pair()</h4><img src=\"./74bb10b1d0024d6aaee8e2036be019f1.png\" alt=\"在这里插入图片描述\" />\n\n<p>这就是标准库的提供的一个函数，用于创建一个临时的pair</p>\n<p>功能：**<code>make_pair</code>函数接收两个参数，然后它会将这两个参数来创建<code>pair</code>对象**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.<span class=\"built_in\">insert</span>(make_pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"built_in\">tmp</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>));<span class=\"comment\">//这样就可以在图直接插入一个临时创建的pair了</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><blockquote>\n<p>首先在STL的容器类型上，map属于“关联式容器”</p>\n<p><strong>所谓关联式容器，就是每个元素都有一个键值（<code>key</code>）和一个实值（<code>value</code>）。当元素被插入到关联式容器中时，容器内部结构可能是红黑树，也可能是哈希表，然后按照其键值<code>key</code>大小，以某种特点规则将这个元素放在一个合适的位置</strong>。</p>\n<p>一般而言，<strong>关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率</strong>，也就没有一般序列式的容器的头尾元素</p>\n</blockquote>\n<p>map就是以pair为基本单元，结构上采取红黑树形成的一个动态查找表。</p>\n<p>此时pair的俩个元素就有区别了pair&lt;键值，实值&gt;</p>\n<p>注意：map不允许重复的键值出现</p>\n<img src=\"./4506b0d4a9fb4c68a4f21af2e8f4b7b3.png\" alt=\"在这里插入图片描述\" />\n\n<p>#&#x2F;## 插入</p>\n<blockquote>\n<p>V老师的没有使用插入函数，而是使用索引去实现插入的功能，</p>\n<p>虽然使用的是unordered_map（基于哈希表实现），但是和map大概原理也大差不差</p>\n<p>后面也会分析如何实现【】访问操作</p>\n</blockquote>\n<p><strong>【函数原型】</strong></p>\n<img src=\"./68bfe33fe1914bf5bfcc01ad7534cd5e.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./99abbcbff8fb414082511a66ece8f60a.png\" alt=\"在这里插入图片描述\" />\n\n<p>从第一个插入函数参数我们可以直到调用map的insert参数是一个pair类型，其次注意其返回值是一个pair&lt;迭代器，bool（是否插入成功）&gt;</p>\n<p>所以要注意的就是参数和返回值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">    dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>));\t\t\t\t<span class=\"comment\">//正常的插入操作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//插入的返回值是一个pair，first是迭代器（指向插入的指针），second是bool显示是否插入成功</span></span><br><span class=\"line\">\tcout &lt;&lt; (dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>))).second;\t\t<span class=\"comment\">//调用返回的pair的second，显示为1，表示插入成功</span></span><br><span class=\"line\">    cout &lt;&lt; (dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>))).first-&gt;second;<span class=\"comment\">//使用first迭代器指向插入对象的second，显示为2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的插入方式如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;test=(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">map.<span class=\"built_in\">insert</span>(test);</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\">map.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据插入函数2，起始发现可以使用迭代器插入，但是对于有序的map来说必然要涉及到重排什么的，我觉得我一般也用不上</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span> <span class=\"params\">(const_iterator position, <span class=\"type\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//根据插入函数三，是c++11新提供的可以一次性插入多个值，我觉我也用不上，乐</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(initializer_list&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>map支持迭代器，表明我们可以利用迭代器遍历甚至是for</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">5</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;::iterator begin = dic.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;::iterator end=dic.<span class=\"built_in\">end</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//迭代器循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (begin != end)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; begin-&gt;first;\t\t<span class=\"comment\">//既可以用指针访问</span></span><br><span class=\"line\">\t\tcout &lt;&lt; (*begin).first;\t\t<span class=\"comment\">//也可以用*，再用.first访问</span></span><br><span class=\"line\">\t\tbegin++;</span><br><span class=\"line\">\t\t<span class=\"comment\">//显示了1122334455</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//for循环的使用也是可以的，直接获取对方的引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; pair : dic)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; pair.first;</span><br><span class=\"line\">        <span class=\"comment\">//显示12345</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>那么现在就有一个问题：可以通过<code>map</code>的迭代器改变<code>map</code>的元素内容吗？</strong></p>\n<ul>\n<li><strong>如果是想修改键值(<code>key</code>)是不行的</strong>。还是和<code>set</code>一样的原因：<code>map</code>元素的键值关系到<code>map</code>元素的排列规则。任意改变<code>map</code>元素的<code>key</code>将会严重破坏<code>map</code>组织。</li>\n<li><strong>但如果想要修改元素的实值(<code>value</code>)，那么是可以的</strong>。因为<code>map</code>元素的实值<code>value</code>并不影响<code>map</code>的排列规则</li>\n</ul>\n<img src=\"./95b245ce93fc49bb85c42e0fbd166697.png\" alt=\"在这里插入图片描述\" />\n\n<p>这里显示键值是const，不可修改</p>\n<h3 id=\"operator【】\"><a href=\"#operator【】\" class=\"headerlink\" title=\"operator【】\"></a>operator【】</h3><p>对于上面的<strong>实值</strong>遍历我也可以这么写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">5</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; dic[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//显示了11111</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难看出对于map类函数，键值可以直接当做索引直接访问</p>\n<img src=\"./202d8acdd52f4509b9dbab88998ab4ef.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./f3fc7b2dc87b4bc285059b5154d9292c.png\" alt=\"在这里插入图片描述\" />\n\n<p>mapped_type就是对应的实值，key_type就是对应的键值</p>\n<p>【】的重载以键值为参数，返回对实值的引用</p>\n<p><strong>但是V老师明明是在创建新的对象，为什么可以直接赋值创建新对象呢呢</strong>？</p>\n<img src=\"./5e1c85cfceb84975951d63017b8bca37.png\" alt=\"在这里插入图片描述\" />\n\n<p>上面的图像说明了原理，我们之前也分析了insert函数的返回值是$pair&lt;iterator,bool&gt;$</p>\n<p>先调用map当前的insert函数（this-&gt;insert()）</p>\n<p>如果有重复的键值就会插入失败，返回pair&lt;对应位置的迭代器，false&gt;,返回pair的first（要查找的pair）的second（实值）。</p>\n<p>如果没有重复的键值显然插入成功了，返回pair&lt;新插入的点的迭代器，true&gt;，返回pair的first（新创建的pair）的second。</p>\n<blockquote>\n<p>那么访问的也不过俩种情况</p>\n<ol>\n<li>键值<code>key</code>已经在树里，那么就返回树里面<code>key</code>所在结点的迭代器</li>\n<li>键值<code>key</code>不在树里，那么就返回新插入<code>key</code>所在结点的迭代器（注意没有键值就新插入一个了）</li>\n</ol>\n<p><strong>注意观察函数的返回值是引用，表明我们可以修改对应的实值value。</strong></p>\n</blockquote>\n<p>从而大v老师的创建也就合理，因为对应的键值没有，所以在访问的时候已经创建了。</p>\n<p>虽然大v老师使用的是无序图(哈希表实现)的，但实现类似不妨碍我们去理解。</p>\n<p>（对于枚举作键值起始也很好理解，枚举ResID是一种类型，就像int，里面的实际的对象就是键值，就像1，2</p>\n<p>但是对于哈希表的键值，这里枚举能使用的原因也比较特殊）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">texture_pool[ResID::Tex_Player] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/player.png&quot;</span>);</span><br><span class=\"line\">texture_pool[ResID::Tex_Archer] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/tower_archer.png&quot;</span>);</span><br><span class=\"line\">texture_pool[ResID::Tex_Axeman] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/tower_axeman.png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"常见的其他map函数方法\"><a href=\"#常见的其他map函数方法\" class=\"headerlink\" title=\"常见的其他map函数方法\"></a>常见的其他map函数方法</h3><h4 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h4><p>Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p>\n<p>[]实现原理我们也解释了,不难理解为什么不会</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ID_Name.<span class=\"built_in\">at</span>(<span class=\"number\">2016</span>)；</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"容量查询\"><a href=\"#容量查询\" class=\"headerlink\" title=\"容量查询\"></a>容量查询</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询map是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询map中键值对的数量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询map所能包含的最大键值对数量，和系统和应用库有关。</span></span><br><span class=\"line\"><span class=\"comment\">// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">max_size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">count</span><span class=\"params\">( <span class=\"type\">const</span> Key&amp; key )</span> <span class=\"type\">const</span></span>; <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">( iterator pos )</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 删除一定范围内的元素，并返回一个指向下一元素的迭代器</span></span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">( const_iterator first, const_iterator last )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">erase</span><span class=\"params\">( <span class=\"type\">const</span> key_type&amp; key )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空map，清空后的size为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换\"><a href=\"#交换\" class=\"headerlink\" title=\"交换\"></a>交换</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 就是两个map的内容互换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">( map&amp; other )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序比较\"><a href=\"#顺序比较\" class=\"headerlink\" title=\"顺序比较\"></a>顺序比较</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较两个关键字在map中位置的先后</span></span><br><span class=\"line\"><span class=\"function\">key_compare <span class=\"title\">key_comp</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器</span></span><br><span class=\"line\"><span class=\"comment\">// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">find</span> <span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k)</span></span>;</span><br><span class=\"line\"><span class=\"function\">const_iterator <span class=\"title\">find</span> <span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k)</span> <span class=\"type\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"unordered-map和map简单比较（使用方法类似，只说说不同）\"><a href=\"#unordered-map和map简单比较（使用方法类似，只说说不同）\" class=\"headerlink\" title=\"unordered_map和map简单比较（使用方法类似，只说说不同）\"></a>unordered_map和map简单比较（使用方法类似，只说说不同）</h2><p>首先最大的区别就是底层的实现逻辑不同</p>\n<p><strong>map：</strong></p>\n<p>优点：</p>\n<ol>\n<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>\n<li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>\n</ol>\n<p>缺点： </p>\n<ol>\n<li>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</li>\n</ol>\n<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>\n<p><strong>unordered_map：</strong></p>\n<p>优点： </p>\n<ol>\n<li>因为内部实现了哈希表，因此其查找速度非常的快</li>\n</ol>\n<p>缺点： </p>\n<ol>\n<li>哈希表的建立比较耗费时间</li>\n</ol>\n<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>\n<hr>\n<p>有一点我比较在意就是关于<strong>键值的问题</strong></p>\n<p>对于红黑树的有序排序必然少不了比较，而哈希表的键值映射到索引的过程如何转换</p>\n<p><strong>对于map来说</strong></p>\n<p>对于提供键值的类型虽然没有限制，但是对于一些自定义的类，必须有比较运算符的重载（&gt;,&lt;,&#x3D;&#x3D;,）</p>\n<p>不然无法在红黑树实现有序的排序，下面的方式就会报错</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">num</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring tmp;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;num,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnum tmp1;</span><br><span class=\"line\">\ttmp1.tmp = <span class=\"string\">&quot;lalla&quot;</span>;\ttmp1.a = <span class=\"number\">1</span>;tmp1.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\tnum tmp2;</span><br><span class=\"line\">\ttmp2.tmp = <span class=\"string\">&quot;lalla&quot;</span>;tmp2.a = <span class=\"number\">1</span>;tmp2.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(tmp1, <span class=\"number\">2</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(tmp2, <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//会显示失败，因为没有定义重载运算符</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于unordered_map来说</strong></p>\n<p>键值只能是int或者string类型，因为哈希表是一个映射的过程</p>\n<img src=\"./image-20240630204341298.png\" alt=\"image-20240630204341298\" />\n\n<p>所以显然类无法通过函数实现映射，只能使用其哈希内部定义的整型和字符串</p>\n<p><strong>对于大v老师的使用来说，恰巧枚举是可以视为整型数据的，所以可以作为unordered_map的键值，这一点也是十分巧妙。</strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"map-unordered-map\"><a href=\"#map-unordered-map\" class=\"headerlink\" title=\"map&amp;&amp;unordered_map\"></a>map&amp;&amp;unordered_map</h2><blockquote>\n<p>恰巧看到大V老师使用unordered_map来实现了资源池，那么便想在分析池的概念前，先弄清这个STL的提供的结构</p>\n<p>将分析pair，map，unordered_map</p>\n<p>我们将解决课程的以下疑问</p>\n<ol>\n<li>map和unordered_map的一些使用方法和概念（主要是解释map）？</li>\n<li>为什么大v老师的使用下标【】的方法就可以构建新的对象？</li>\n<li>大v老师的键值使用了枚举，那么对于unordered_map键值类型限制和map的键值类型限制具体有哪些，枚举为什么可以作为其键值（最后的比较会解释）？</li>\n</ol>\n</blockquote>","more":"<h2 id=\"pair和map\"><a href=\"#pair和map\" class=\"headerlink\" title=\"pair和map\"></a>pair和map</h2><h2 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h2><blockquote>\n<p>pair是c++定义好的一个类模板的结构体，使用需要加上头文件<utility></p>\n</blockquote>\n<p>pair意如其名，就是一对，用于一对数据的集合，这个数据结构就十分有利于后面的键值和关键字值的集合，进一步实现各类查找表，map的基本单元就是pair构成的。</p>\n<p>pair的部分源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> T1 first_type;\t\t\t<span class=\"comment\">//对第一个类型的别名</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> T2 second_type;\t\t\t<span class=\"comment\">//对第二个类型的别名</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tT1 first;\t\t\t\t\t\t<span class=\"comment\">//第一个数据成员</span></span><br><span class=\"line\">\tT2 second;\t\t\t\t\t\t<span class=\"comment\">//第二个数据成员</span></span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>(): <span class=\"built_in\">first</span>(<span class=\"built_in\">T1</span>()), <span class=\"built_in\">second</span>(<span class=\"built_in\">T2</span>())</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pair</span>(<span class=\"type\">const</span> T1&amp; a, <span class=\"type\">const</span> T2&amp; b): <span class=\"built_in\">first</span>(a), <span class=\"built_in\">second</span>(b)</span><br><span class=\"line\">\t&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最常用的就是pair的俩个可访问的first和second</p>\n<p><strong>【声明方式】</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::pair&lt;第一种数据类型，第二种数据类型&gt; 变量名;</span><br></pre></td></tr></table></figure>\n\n<p><strong>【简单的使用】</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; test;</span><br><span class=\"line\">    stu.first = <span class=\"number\">1</span>;</span><br><span class=\"line\">    stu.second = <span class=\"number\">2</span>;</span><br><span class=\"line\">   cout &lt;&lt; stu.first &lt;&lt;endl;</span><br><span class=\"line\">   cout &lt;&lt; stu.second&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a><strong>初始化</strong></h4><img src=\"./8c4bc7708c19453186b2bb91df9ed7e9.png\" alt=\"在这里插入图片描述\" />\n\n<ol>\n<li><p>第一种就是默认构造函数，数字类型数据初始化为0，字符串初始化为空，</p>\n<p>如果是类的话从上面提供的部分源码看，进一步调用类的构造函数</p>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>第二种就是拷贝构造函数，必须是同类型的就是了</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test（pair_copy）;</span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span> &gt;test=pair_copy;\t\t<span class=\"comment\">//这俩种形式调用的都是赋值构造函数，不是=的运算符重载</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>第三种就是构造函数传入对应的俩个值了,就是构造函数重载</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"built_in\">test</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"还能比较大小\"><a href=\"#还能比较大小\" class=\"headerlink\" title=\"还能比较大小\"></a><strong>还能比较大小</strong></h4><p>就是实现了运算符重载</p>\n<img src=\"./45d8c982a7bc4392b7cdc220c3147b22.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<img src=\"./0902517424204b618b2d27075e4a3d37.png\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\" />\n\n<p>先比first，first相等再比second（前提是对应的数据类型必须相同）</p>\n<p>字符串的比较大小的规则在string可以去了解，至于类可能就是取决于类的运算符重载了</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair_1&gt;pair_2;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"make-pair\"><a href=\"#make-pair\" class=\"headerlink\" title=\"make_pair()\"></a>make_pair()</h4><img src=\"./74bb10b1d0024d6aaee8e2036be019f1.png\" alt=\"在这里插入图片描述\" />\n\n<p>这就是标准库的提供的一个函数，用于创建一个临时的pair</p>\n<p>功能：**<code>make_pair</code>函数接收两个参数，然后它会将这两个参数来创建<code>pair</code>对象**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.<span class=\"built_in\">insert</span>(make_pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;<span class=\"built_in\">tmp</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>));<span class=\"comment\">//这样就可以在图直接插入一个临时创建的pair了</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><blockquote>\n<p>首先在STL的容器类型上，map属于“关联式容器”</p>\n<p><strong>所谓关联式容器，就是每个元素都有一个键值（<code>key</code>）和一个实值（<code>value</code>）。当元素被插入到关联式容器中时，容器内部结构可能是红黑树，也可能是哈希表，然后按照其键值<code>key</code>大小，以某种特点规则将这个元素放在一个合适的位置</strong>。</p>\n<p>一般而言，<strong>关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率</strong>，也就没有一般序列式的容器的头尾元素</p>\n</blockquote>\n<p>map就是以pair为基本单元，结构上采取红黑树形成的一个动态查找表。</p>\n<p>此时pair的俩个元素就有区别了pair&lt;键值，实值&gt;</p>\n<p>注意：map不允许重复的键值出现</p>\n<img src=\"./4506b0d4a9fb4c68a4f21af2e8f4b7b3.png\" alt=\"在这里插入图片描述\" />\n\n<p>#&#x2F;## 插入</p>\n<blockquote>\n<p>V老师的没有使用插入函数，而是使用索引去实现插入的功能，</p>\n<p>虽然使用的是unordered_map（基于哈希表实现），但是和map大概原理也大差不差</p>\n<p>后面也会分析如何实现【】访问操作</p>\n</blockquote>\n<p><strong>【函数原型】</strong></p>\n<img src=\"./68bfe33fe1914bf5bfcc01ad7534cd5e.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./99abbcbff8fb414082511a66ece8f60a.png\" alt=\"在这里插入图片描述\" />\n\n<p>从第一个插入函数参数我们可以直到调用map的insert参数是一个pair类型，其次注意其返回值是一个pair&lt;迭代器，bool（是否插入成功）&gt;</p>\n<p>所以要注意的就是参数和返回值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">    dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>));\t\t\t\t<span class=\"comment\">//正常的插入操作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//插入的返回值是一个pair，first是迭代器（指向插入的指针），second是bool显示是否插入成功</span></span><br><span class=\"line\">\tcout &lt;&lt; (dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>))).second;\t\t<span class=\"comment\">//调用返回的pair的second，显示为1，表示插入成功</span></span><br><span class=\"line\">    cout &lt;&lt; (dic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>))).first-&gt;second;<span class=\"comment\">//使用first迭代器指向插入对象的second，显示为2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的插入方式如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;test=(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">map.<span class=\"built_in\">insert</span>(test);</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\">map.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据插入函数2，起始发现可以使用迭代器插入，但是对于有序的map来说必然要涉及到重排什么的，我觉得我一般也用不上</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span> <span class=\"params\">(const_iterator position, <span class=\"type\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//根据插入函数三，是c++11新提供的可以一次性插入多个值，我觉我也用不上，乐</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(initializer_list&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>map支持迭代器，表明我们可以利用迭代器遍历甚至是for</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">5</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;::iterator begin = dic.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;::iterator end=dic.<span class=\"built_in\">end</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//迭代器循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (begin != end)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; begin-&gt;first;\t\t<span class=\"comment\">//既可以用指针访问</span></span><br><span class=\"line\">\t\tcout &lt;&lt; (*begin).first;\t\t<span class=\"comment\">//也可以用*，再用.first访问</span></span><br><span class=\"line\">\t\tbegin++;</span><br><span class=\"line\">\t\t<span class=\"comment\">//显示了1122334455</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//for循环的使用也是可以的，直接获取对方的引用</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; pair : dic)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; pair.first;</span><br><span class=\"line\">        <span class=\"comment\">//显示12345</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>那么现在就有一个问题：可以通过<code>map</code>的迭代器改变<code>map</code>的元素内容吗？</strong></p>\n<ul>\n<li><strong>如果是想修改键值(<code>key</code>)是不行的</strong>。还是和<code>set</code>一样的原因：<code>map</code>元素的键值关系到<code>map</code>元素的排列规则。任意改变<code>map</code>元素的<code>key</code>将会严重破坏<code>map</code>组织。</li>\n<li><strong>但如果想要修改元素的实值(<code>value</code>)，那么是可以的</strong>。因为<code>map</code>元素的实值<code>value</code>并不影响<code>map</code>的排列规则</li>\n</ul>\n<img src=\"./95b245ce93fc49bb85c42e0fbd166697.png\" alt=\"在这里插入图片描述\" />\n\n<p>这里显示键值是const，不可修改</p>\n<h3 id=\"operator【】\"><a href=\"#operator【】\" class=\"headerlink\" title=\"operator【】\"></a>operator【】</h3><p>对于上面的<strong>实值</strong>遍历我也可以这么写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">5</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; dic[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//显示了11111</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不难看出对于map类函数，键值可以直接当做索引直接访问</p>\n<img src=\"./202d8acdd52f4509b9dbab88998ab4ef.png\" alt=\"在这里插入图片描述\" />\n\n<img src=\"./f3fc7b2dc87b4bc285059b5154d9292c.png\" alt=\"在这里插入图片描述\" />\n\n<p>mapped_type就是对应的实值，key_type就是对应的键值</p>\n<p>【】的重载以键值为参数，返回对实值的引用</p>\n<p><strong>但是V老师明明是在创建新的对象，为什么可以直接赋值创建新对象呢呢</strong>？</p>\n<img src=\"./5e1c85cfceb84975951d63017b8bca37.png\" alt=\"在这里插入图片描述\" />\n\n<p>上面的图像说明了原理，我们之前也分析了insert函数的返回值是$pair&lt;iterator,bool&gt;$</p>\n<p>先调用map当前的insert函数（this-&gt;insert()）</p>\n<p>如果有重复的键值就会插入失败，返回pair&lt;对应位置的迭代器，false&gt;,返回pair的first（要查找的pair）的second（实值）。</p>\n<p>如果没有重复的键值显然插入成功了，返回pair&lt;新插入的点的迭代器，true&gt;，返回pair的first（新创建的pair）的second。</p>\n<blockquote>\n<p>那么访问的也不过俩种情况</p>\n<ol>\n<li>键值<code>key</code>已经在树里，那么就返回树里面<code>key</code>所在结点的迭代器</li>\n<li>键值<code>key</code>不在树里，那么就返回新插入<code>key</code>所在结点的迭代器（注意没有键值就新插入一个了）</li>\n</ol>\n<p><strong>注意观察函数的返回值是引用，表明我们可以修改对应的实值value。</strong></p>\n</blockquote>\n<p>从而大v老师的创建也就合理，因为对应的键值没有，所以在访问的时候已经创建了。</p>\n<p>虽然大v老师使用的是无序图(哈希表实现)的，但实现类似不妨碍我们去理解。</p>\n<p>（对于枚举作键值起始也很好理解，枚举ResID是一种类型，就像int，里面的实际的对象就是键值，就像1，2</p>\n<p>但是对于哈希表的键值，这里枚举能使用的原因也比较特殊）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">texture_pool[ResID::Tex_Player] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/player.png&quot;</span>);</span><br><span class=\"line\">texture_pool[ResID::Tex_Archer] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/tower_archer.png&quot;</span>);</span><br><span class=\"line\">texture_pool[ResID::Tex_Axeman] = <span class=\"built_in\">IMG_LoadTexture</span>(renderer, <span class=\"string\">&quot;resources/tower_axeman.png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"常见的其他map函数方法\"><a href=\"#常见的其他map函数方法\" class=\"headerlink\" title=\"常见的其他map函数方法\"></a>常见的其他map函数方法</h3><h4 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h4><p>Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p>\n<p>[]实现原理我们也解释了,不难理解为什么不会</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ID_Name.<span class=\"built_in\">at</span>(<span class=\"number\">2016</span>)；</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"容量查询\"><a href=\"#容量查询\" class=\"headerlink\" title=\"容量查询\"></a>容量查询</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询map是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询map中键值对的数量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询map所能包含的最大键值对数量，和系统和应用库有关。</span></span><br><span class=\"line\"><span class=\"comment\">// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">max_size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">count</span><span class=\"params\">( <span class=\"type\">const</span> Key&amp; key )</span> <span class=\"type\">const</span></span>; <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">( iterator pos )</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 删除一定范围内的元素，并返回一个指向下一元素的迭代器</span></span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">( const_iterator first, const_iterator last )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">erase</span><span class=\"params\">( <span class=\"type\">const</span> key_type&amp; key )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空map，清空后的size为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换\"><a href=\"#交换\" class=\"headerlink\" title=\"交换\"></a>交换</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 就是两个map的内容互换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">( map&amp; other )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"顺序比较\"><a href=\"#顺序比较\" class=\"headerlink\" title=\"顺序比较\"></a>顺序比较</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较两个关键字在map中位置的先后</span></span><br><span class=\"line\"><span class=\"function\">key_compare <span class=\"title\">key_comp</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器</span></span><br><span class=\"line\"><span class=\"comment\">// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">find</span> <span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k)</span></span>;</span><br><span class=\"line\"><span class=\"function\">const_iterator <span class=\"title\">find</span> <span class=\"params\">(<span class=\"type\">const</span> key_type&amp; k)</span> <span class=\"type\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"unordered-map和map简单比较（使用方法类似，只说说不同）\"><a href=\"#unordered-map和map简单比较（使用方法类似，只说说不同）\" class=\"headerlink\" title=\"unordered_map和map简单比较（使用方法类似，只说说不同）\"></a>unordered_map和map简单比较（使用方法类似，只说说不同）</h2><p>首先最大的区别就是底层的实现逻辑不同</p>\n<p><strong>map：</strong></p>\n<p>优点：</p>\n<ol>\n<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>\n<li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>\n</ol>\n<p>缺点： </p>\n<ol>\n<li>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</li>\n</ol>\n<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>\n<p><strong>unordered_map：</strong></p>\n<p>优点： </p>\n<ol>\n<li>因为内部实现了哈希表，因此其查找速度非常的快</li>\n</ol>\n<p>缺点： </p>\n<ol>\n<li>哈希表的建立比较耗费时间</li>\n</ol>\n<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>\n<hr>\n<p>有一点我比较在意就是关于<strong>键值的问题</strong></p>\n<p>对于红黑树的有序排序必然少不了比较，而哈希表的键值映射到索引的过程如何转换</p>\n<p><strong>对于map来说</strong></p>\n<p>对于提供键值的类型虽然没有限制，但是对于一些自定义的类，必须有比较运算符的重载（&gt;,&lt;,&#x3D;&#x3D;,）</p>\n<p>不然无法在红黑树实现有序的排序，下面的方式就会报错</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">num</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring tmp;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmap&lt;num,<span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnum tmp1;</span><br><span class=\"line\">\ttmp1.tmp = <span class=\"string\">&quot;lalla&quot;</span>;\ttmp1.a = <span class=\"number\">1</span>;tmp1.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\tnum tmp2;</span><br><span class=\"line\">\ttmp2.tmp = <span class=\"string\">&quot;lalla&quot;</span>;tmp2.a = <span class=\"number\">1</span>;tmp2.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(tmp1, <span class=\"number\">2</span>));</span><br><span class=\"line\">\tdic.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(tmp2, <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//会显示失败，因为没有定义重载运算符</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于unordered_map来说</strong></p>\n<p>键值只能是int或者string类型，因为哈希表是一个映射的过程</p>\n<img src=\"./image-20240630204341298.png\" alt=\"image-20240630204341298\" />\n\n<p>所以显然类无法通过函数实现映射，只能使用其哈希内部定义的整型和字符串</p>\n<p><strong>对于大v老师的使用来说，恰巧枚举是可以视为整型数据的，所以可以作为unordered_map的键值，这一点也是十分巧妙。</strong></p>"},{"date":"2024-06-13T16:00:00.000Z","updated":"2024-06-13T16:00:00.000Z","permlink":"articles/yang12342/计时器/","_content":"\n## 计时器\n\n[TOC]\n\n> 游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。\n>\n> 计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。\n\n我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现\n\n<!-- More -->\n\n~~~CPP\n#ifndef _TIMER_H_\n#define _TIMER_H_\n#include <functional>\n\n\nclass Timer\n{\npublic:\n\tTimer() = default;\n\t~Timer() = default;\n\n\tvoid restart()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpass_time = 0;\n\t\tshotted = false;\n\t}\n\n\tvoid set_wait_time(int val)\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\twait_time = val;\n\t}\n\n\tvoid set_one_shot(bool flag)\t\t\t\t\t\t\t\t\t\n\t{\n\t\tone_shot = flag;\n\t}\n\n\tvoid set_callback(std::function<void()> callback)\t\t\t\t\n\t{\n\t\tthis->callback = callback;\n\t}\n\n\tvoid pause()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = false;\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n\n\tvoid on_update(int delta)\n\t{\n\t\tif (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\treturn;\n\t\tpass_time += delta;\n\t\tif (pass_time >= wait_time)\t\t\t\t\t\t\t\t\t\n\t\t{\n\t\t\tif ((!one_shot || (one_shot && !shotted)) && callback)\t\n\t\t\t\tcallback();\n\t\t\tshotted = true;\n\t\t\tpass_time = pass_time-wait_time;\n\t\t}\n\t}\n\nprivate:\n\tint pass_time = 0;\t\t\t\t\t\t\t\t\n\tint wait_time = 0;\t\t\t\t\t\t\t\n\tbool paused = false;\t\t\t\t\t\t\t\n\tbool shotted = false;\t\t\t\t\t\t\n\tbool one_shot = false;\t\t\t\t\t\t\t\n\tstd::function<void()> callback;\t\t\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n#endif // !_TIMER_H_\n\n\n~~~\n\n我们先从函数设置上分析功能\n\n- 重置计时器（restart）\n- 是否选择重复触发（set_one_shot）\n- 设置重复触发的间隔时间（set_wait_time）\n- 回调函数的设置(set_callback)\n- 计时器暂停(pause)\n- 计时器继续(resume)\n- 计时器数据更新(on_update)\n\n从以上我们就简单看出了计时器的基本功能\n\n1. 状态的转换（单触发还是多次触发）\n2. 计时的暂停和继续\n3. 每次累计时间到达后执行的回调函数\n\n>回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作\n>\n>类似lambda函数，后面分析函数会具体说明\n\n---\n\n### 函数实现的简单分析\n\n#### 成员变量\n\n~~~CPP\nprivate:\n\tint pass_time = 0;\t\t\t\t\t\t\t\t//单次累计时间\n\tint wait_time = 0;\t\t\t\t\t\t\t\t//间隔时间\n\tbool paused = false;\t\t\t\t\t\t\t//计时器是否暂停\n\tbool shotted = false;\t\t\t\t\t\t\t//是否触发的状态量\n\tbool one_shot = false;\t\t\t\t\t\t\t//是否单次触发，false为循环触发\n\tstd::function<void()> callback;\t\t\t\t\t//回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后还会用到LAMBDA函数，来作为实参传输\n~~~\n\n\n\n#### restart（）\n\n~~~CPP\nvoid restart()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpass_time = 0;\t\t\t\t\t\t\t\t\t\t//累计时间清零\n\t\tshotted = false;\t\t\t\t\t\t\t\t\t//触发状态量回归未触发状态\n\t}\n~~~\n\n每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据\n\n\n\n#### set_on_shot()\n\n~~~CPP\nvoid set_one_shot(bool flag)\t\t\t\t\t\t\t\t\t//是否单次触发\n\t{\n\t\tone_shot = flag;\t\t\t\t\t\t\t\t\t\t//false为循环触发\n\t}\n~~~\n\n有的游戏应用场景下只需要计时器触发一次\n\n例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次）\n\n\n\n#### set_wait_time（）\n\n~~~CPP\nvoid set_wait_time(int val)\t\t\t\t\t\t\t\t\t\t//设置触发的时间间隔\n\t{\n\t\twait_time = val;\n\t}\n~~~\n\n循环计时需要设置间隔时间\n\n例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔\n\n\n\n#### set_callback()\n\n~~~CPP\nvoid set_callback(std::function<void()> callback)\t\t//这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 \n\t{\n\t\tthis->callback = callback;\n\t}\n~~~\n\n传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针）\n\n例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex=false;的逻辑\n\n后面分析游戏实例会讲解\n\n\n\n#### pause()&&resume()\n\n~~~CPP\n\tvoid pause()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = false;\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n~~~\n\n计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值\n\n\n\n#### on_update()\n\n~~~CPP\nvoid on_update(int delta)\n\t{\n\t\tif (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t//先检查计时器是否处于暂停状态\n\t\t\treturn;\t\t\t\t\t\t\t\n\t\tpass_time += delta;\t\t\t\t\t\t\t\t\t\t\t//若不暂停，则计时\n\t\tif (pass_time >= wait_time)\t\t\t\t\t\t\t\t\t//如果到达了触发间隔且未暂停\n\t\t{\n\t\t\tif ((!one_shot || (one_shot && !shotted)) && callback)\t\n//前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数\n\t\t\t\tcallback();\n\t\t\tshotted = true;\n\t\t\tpass_time = pass_time-wait_time;\n\t\t}\n\t}\n~~~\n\n计时器数据更新的关键就是\n\n**何时触发和什么条件触发回调函数**\n\n（由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键）\n\n~~~CPP\nif ((!one_shot || (one_shot && !shotted)) && callback)\t\n    callback();\n~~~\n\n首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0）\n\n其次就是**循环触发**（那就不考虑shotted状态了，时间到了就触发）和**单次触发且还处于未触发状态**（shotted为false）\n\n不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数\n\n---\n\n### 关于回调函数和函数指针，lambda函数的分析\n\n#### 函数指针\n\n>指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针\n\n定义格式：**返回类型  （\\*指针变量）(形式参数表)**\n\n~~~CPP\nint (*point)();\t\t\t\t\t\t\t\t\t\t\t//指向一个参数，返回值为int的函数\nint (*point)(int);\t\t\t\t\t\t\t\t\t\t//指向一个有int参数，返回值为int的函数\n~~~\n\n**注意：**声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高\n\n指针的赋值可以是：**指针变量名=函数名**\n\n~~~CPP\npoint=f1；\n~~~\n\n\n\n函数指针主要有俩个用途：**作为函数的参数（就是作为形参），和实现菜单**\n\n- 作为函数的参数\n\n~~~CPP\ntemplate<class T>\nvoid sort(T a[],int size,bool(*f)(T,T))\n{\n    //冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较\n    bool is_bigger=f(a,b)；\n}\n~~~\n\n为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入\n\n- 菜单的实现（其实是函数指针数组的使用）\n\n~~~CPP\nint main()\n{\n    //假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数\n    void (*menu[6])()={NULL,add,erase,modify,printSalary,printReport};\n    int n;\n    cin>>n;\n    menu[n];\n}\n~~~\n\n就是理解函数指针也是有数组的，让函数的接口变得更见简答易用\n\n\n\n#### lambda函数\n\n>看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量\n\n表达形式：**[捕获列表] （形式参数表）->返回类型{函数体}**\n\n~~~CPP\n[](int x,int y)->int{return x+y};\n~~~\n\n有俩个形参，返回类型为int\n\n**注意**：当返回类型很明确时，lambda函数可以不用尾置指定返回类型\n\n例如：\n\n~~~CPP\n[](int x,int y){return x+y};\n~~~\n\n返回类型很明确不需要尾置，这也是正确的，也是比较常用的\n\n\n\n> 与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称**捕获**\n\n常见的捕获有一下几种形式\n\n- \\[x]:以值捕获的方式捕获变量x\n- \\[=]:以值捕获的方式捕获所有变量\n- \\[&x]：以引用捕获的方式捕获变量x\n- \\[&]:以引用捕获的方式捕获所有变量\n\n> **回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。**\n>\n> 如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。\n>\n> **当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。**\n\n这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面\n\n~~~CPP\nint main()\n{\n    int x=15;\n    auto f=[&x](int y)->int {return (++x)+y;};\n    x=20;\n    f(5);\n    cout<<x;\n}\n~~~\n\n【&x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到\n\n\n\n#### 回调函数\n\n> 在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。\n>\n> 使用functional库的回调函数，可以实现以下功能：\n>\n> 1. 将函数作为参数传递给其他函数，以便在需要的时候调用。\n> 2. 在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。\n> 3. 在函数式编程中，可以使用回调函数来实现高阶函数的操作。\n\n定义：**std::function<返回类型（参数类型列表）> 回调函数名**\n\n~~~CPP\nstd::function<void(int)> callback\n~~~\n\n表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装）\n\n**注意：**function也是定义在标准函数库里的，所以要声明域名std\n\n\n\n基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器\n\n---\n\n### 关于植物明星大乱斗中的计时器逻辑分析\n\n大体本游戏使用了一下的计时器\n\n~~~CPP\nTimer timer_invulnerable;\t\t\t\t\t\t//无敌状态定时器\nTimer timer_invulnerable_blink;\t\t\t\t\t//无敌状态闪烁定时器，用于不同序列帧的切换功能\n\nTimer timer_attack_cd;\t\t\t\t\t\t\t//普通攻击冷却定时器\n\nTimer timer_run_effect_generation;\t\t\t\t//跑动粒子特效发射定时器\nTimer timer_die_effect_generation;\t\t\t\t//死亡特效例子发射器\n\nTimer timer_cursor_visibility;\t\t\t\t\t//玩家光标指示器可见性定时器\n~~~\n\n- 无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态\n- 闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、\n- 普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成\n- 跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片）\n- 死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成\n- 玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示\n\n\n\n例子：\n\n#### 无敌状态定时器\n\n~~~CPP\n\tTimer timer_invulnerable;\t\t\t\t\t\t//无敌状态定时器\n\n\tPlayer() \n\t{\n\t\t//无敌状态定时器的初始化设置\n\t\ttimer_invulnerable.set_wait_time(750);\t\t//触发事件间隔750毫秒，0.75秒\n\t\ttimer_invulnerable.set_one_shot(true);\t\t//单次触发\n\t\ttimer_invulnerable.set_callback([&]()\t\t//设置回调函数\n\t\t\t{\n\t\t\t\tis_invulnerable = false;\n\t\t\t});\n\t}\n\n  \tvoid on_update()\n    {\n        .....\n       timer_invulnerable.on_update(delta);//更新\n        \n        move_and_collide();\t\t\t\t\t//检测触发函数\n    }\n\t\n\tvoid make_invulnerable()\n\t{\t\n\t\tis_invulnerable = true;\t\t\t\t//受击状态量改为true\n\t\ttimer_invulnerable.restart();\t\t//计时器重置，shotted改为false，事件到达后is_vulnerable改回false\n\t}\n\n\n\n~~~\n\n简单分析一下这里的回调函数\n\n\\[&\\](){is_invulnerable=false;}\n\n以引用捕获的方式获取类的局部变量，没有形参，函数主体\n\n<img src=\"image-20240614140821676.png\" style=\"zoom:50%;\" />大体流程就是这样子的\n\n\n\n\n\n**总结：** 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。\n\n<span style=\"color:blue\">相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解</span>\n\n<div style=\"text-align:center\">\n    >>> <a herf=\"https://space.bilibili.com/25864506?spm_id_from=333.337.search-card.all.click\">植物明星大乱斗教程（voidMatrix）</a><<<\n</div>\n","source":"_posts/yang/计时器的分析.md","raw":"---\ndate: 2024-06-14\nupdated: 2024-06-14\npermlink: articles/yang12342/计时器/\ncategories: yang12342\ntags: [植物明星大乱斗]\n---\n\n## 计时器\n\n[TOC]\n\n> 游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。\n>\n> 计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。\n\n我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现\n\n<!-- More -->\n\n~~~CPP\n#ifndef _TIMER_H_\n#define _TIMER_H_\n#include <functional>\n\n\nclass Timer\n{\npublic:\n\tTimer() = default;\n\t~Timer() = default;\n\n\tvoid restart()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpass_time = 0;\n\t\tshotted = false;\n\t}\n\n\tvoid set_wait_time(int val)\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\twait_time = val;\n\t}\n\n\tvoid set_one_shot(bool flag)\t\t\t\t\t\t\t\t\t\n\t{\n\t\tone_shot = flag;\n\t}\n\n\tvoid set_callback(std::function<void()> callback)\t\t\t\t\n\t{\n\t\tthis->callback = callback;\n\t}\n\n\tvoid pause()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = false;\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n\n\tvoid on_update(int delta)\n\t{\n\t\tif (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\treturn;\n\t\tpass_time += delta;\n\t\tif (pass_time >= wait_time)\t\t\t\t\t\t\t\t\t\n\t\t{\n\t\t\tif ((!one_shot || (one_shot && !shotted)) && callback)\t\n\t\t\t\tcallback();\n\t\t\tshotted = true;\n\t\t\tpass_time = pass_time-wait_time;\n\t\t}\n\t}\n\nprivate:\n\tint pass_time = 0;\t\t\t\t\t\t\t\t\n\tint wait_time = 0;\t\t\t\t\t\t\t\n\tbool paused = false;\t\t\t\t\t\t\t\n\tbool shotted = false;\t\t\t\t\t\t\n\tbool one_shot = false;\t\t\t\t\t\t\t\n\tstd::function<void()> callback;\t\t\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n#endif // !_TIMER_H_\n\n\n~~~\n\n我们先从函数设置上分析功能\n\n- 重置计时器（restart）\n- 是否选择重复触发（set_one_shot）\n- 设置重复触发的间隔时间（set_wait_time）\n- 回调函数的设置(set_callback)\n- 计时器暂停(pause)\n- 计时器继续(resume)\n- 计时器数据更新(on_update)\n\n从以上我们就简单看出了计时器的基本功能\n\n1. 状态的转换（单触发还是多次触发）\n2. 计时的暂停和继续\n3. 每次累计时间到达后执行的回调函数\n\n>回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作\n>\n>类似lambda函数，后面分析函数会具体说明\n\n---\n\n### 函数实现的简单分析\n\n#### 成员变量\n\n~~~CPP\nprivate:\n\tint pass_time = 0;\t\t\t\t\t\t\t\t//单次累计时间\n\tint wait_time = 0;\t\t\t\t\t\t\t\t//间隔时间\n\tbool paused = false;\t\t\t\t\t\t\t//计时器是否暂停\n\tbool shotted = false;\t\t\t\t\t\t\t//是否触发的状态量\n\tbool one_shot = false;\t\t\t\t\t\t\t//是否单次触发，false为循环触发\n\tstd::function<void()> callback;\t\t\t\t\t//回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后还会用到LAMBDA函数，来作为实参传输\n~~~\n\n\n\n#### restart（）\n\n~~~CPP\nvoid restart()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpass_time = 0;\t\t\t\t\t\t\t\t\t\t//累计时间清零\n\t\tshotted = false;\t\t\t\t\t\t\t\t\t//触发状态量回归未触发状态\n\t}\n~~~\n\n每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据\n\n\n\n#### set_on_shot()\n\n~~~CPP\nvoid set_one_shot(bool flag)\t\t\t\t\t\t\t\t\t//是否单次触发\n\t{\n\t\tone_shot = flag;\t\t\t\t\t\t\t\t\t\t//false为循环触发\n\t}\n~~~\n\n有的游戏应用场景下只需要计时器触发一次\n\n例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次）\n\n\n\n#### set_wait_time（）\n\n~~~CPP\nvoid set_wait_time(int val)\t\t\t\t\t\t\t\t\t\t//设置触发的时间间隔\n\t{\n\t\twait_time = val;\n\t}\n~~~\n\n循环计时需要设置间隔时间\n\n例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔\n\n\n\n#### set_callback()\n\n~~~CPP\nvoid set_callback(std::function<void()> callback)\t\t//这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 \n\t{\n\t\tthis->callback = callback;\n\t}\n~~~\n\n传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针）\n\n例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex=false;的逻辑\n\n后面分析游戏实例会讲解\n\n\n\n#### pause()&&resume()\n\n~~~CPP\n\tvoid pause()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = true;\n\t}\n\n\tvoid resume()\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t{\n\t\tpaused = false;\t\t\t\t\t\t\t\t\t\t\t\t\n\t}\n~~~\n\n计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值\n\n\n\n#### on_update()\n\n~~~CPP\nvoid on_update(int delta)\n\t{\n\t\tif (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t//先检查计时器是否处于暂停状态\n\t\t\treturn;\t\t\t\t\t\t\t\n\t\tpass_time += delta;\t\t\t\t\t\t\t\t\t\t\t//若不暂停，则计时\n\t\tif (pass_time >= wait_time)\t\t\t\t\t\t\t\t\t//如果到达了触发间隔且未暂停\n\t\t{\n\t\t\tif ((!one_shot || (one_shot && !shotted)) && callback)\t\n//前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数\n\t\t\t\tcallback();\n\t\t\tshotted = true;\n\t\t\tpass_time = pass_time-wait_time;\n\t\t}\n\t}\n~~~\n\n计时器数据更新的关键就是\n\n**何时触发和什么条件触发回调函数**\n\n（由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键）\n\n~~~CPP\nif ((!one_shot || (one_shot && !shotted)) && callback)\t\n    callback();\n~~~\n\n首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0）\n\n其次就是**循环触发**（那就不考虑shotted状态了，时间到了就触发）和**单次触发且还处于未触发状态**（shotted为false）\n\n不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数\n\n---\n\n### 关于回调函数和函数指针，lambda函数的分析\n\n#### 函数指针\n\n>指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针\n\n定义格式：**返回类型  （\\*指针变量）(形式参数表)**\n\n~~~CPP\nint (*point)();\t\t\t\t\t\t\t\t\t\t\t//指向一个参数，返回值为int的函数\nint (*point)(int);\t\t\t\t\t\t\t\t\t\t//指向一个有int参数，返回值为int的函数\n~~~\n\n**注意：**声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高\n\n指针的赋值可以是：**指针变量名=函数名**\n\n~~~CPP\npoint=f1；\n~~~\n\n\n\n函数指针主要有俩个用途：**作为函数的参数（就是作为形参），和实现菜单**\n\n- 作为函数的参数\n\n~~~CPP\ntemplate<class T>\nvoid sort(T a[],int size,bool(*f)(T,T))\n{\n    //冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较\n    bool is_bigger=f(a,b)；\n}\n~~~\n\n为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入\n\n- 菜单的实现（其实是函数指针数组的使用）\n\n~~~CPP\nint main()\n{\n    //假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数\n    void (*menu[6])()={NULL,add,erase,modify,printSalary,printReport};\n    int n;\n    cin>>n;\n    menu[n];\n}\n~~~\n\n就是理解函数指针也是有数组的，让函数的接口变得更见简答易用\n\n\n\n#### lambda函数\n\n>看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量\n\n表达形式：**[捕获列表] （形式参数表）->返回类型{函数体}**\n\n~~~CPP\n[](int x,int y)->int{return x+y};\n~~~\n\n有俩个形参，返回类型为int\n\n**注意**：当返回类型很明确时，lambda函数可以不用尾置指定返回类型\n\n例如：\n\n~~~CPP\n[](int x,int y){return x+y};\n~~~\n\n返回类型很明确不需要尾置，这也是正确的，也是比较常用的\n\n\n\n> 与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称**捕获**\n\n常见的捕获有一下几种形式\n\n- \\[x]:以值捕获的方式捕获变量x\n- \\[=]:以值捕获的方式捕获所有变量\n- \\[&x]：以引用捕获的方式捕获变量x\n- \\[&]:以引用捕获的方式捕获所有变量\n\n> **回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。**\n>\n> 如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。\n>\n> **当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。**\n\n这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面\n\n~~~CPP\nint main()\n{\n    int x=15;\n    auto f=[&x](int y)->int {return (++x)+y;};\n    x=20;\n    f(5);\n    cout<<x;\n}\n~~~\n\n【&x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到\n\n\n\n#### 回调函数\n\n> 在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。\n>\n> 使用functional库的回调函数，可以实现以下功能：\n>\n> 1. 将函数作为参数传递给其他函数，以便在需要的时候调用。\n> 2. 在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。\n> 3. 在函数式编程中，可以使用回调函数来实现高阶函数的操作。\n\n定义：**std::function<返回类型（参数类型列表）> 回调函数名**\n\n~~~CPP\nstd::function<void(int)> callback\n~~~\n\n表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装）\n\n**注意：**function也是定义在标准函数库里的，所以要声明域名std\n\n\n\n基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器\n\n---\n\n### 关于植物明星大乱斗中的计时器逻辑分析\n\n大体本游戏使用了一下的计时器\n\n~~~CPP\nTimer timer_invulnerable;\t\t\t\t\t\t//无敌状态定时器\nTimer timer_invulnerable_blink;\t\t\t\t\t//无敌状态闪烁定时器，用于不同序列帧的切换功能\n\nTimer timer_attack_cd;\t\t\t\t\t\t\t//普通攻击冷却定时器\n\nTimer timer_run_effect_generation;\t\t\t\t//跑动粒子特效发射定时器\nTimer timer_die_effect_generation;\t\t\t\t//死亡特效例子发射器\n\nTimer timer_cursor_visibility;\t\t\t\t\t//玩家光标指示器可见性定时器\n~~~\n\n- 无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态\n- 闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、\n- 普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成\n- 跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片）\n- 死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成\n- 玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示\n\n\n\n例子：\n\n#### 无敌状态定时器\n\n~~~CPP\n\tTimer timer_invulnerable;\t\t\t\t\t\t//无敌状态定时器\n\n\tPlayer() \n\t{\n\t\t//无敌状态定时器的初始化设置\n\t\ttimer_invulnerable.set_wait_time(750);\t\t//触发事件间隔750毫秒，0.75秒\n\t\ttimer_invulnerable.set_one_shot(true);\t\t//单次触发\n\t\ttimer_invulnerable.set_callback([&]()\t\t//设置回调函数\n\t\t\t{\n\t\t\t\tis_invulnerable = false;\n\t\t\t});\n\t}\n\n  \tvoid on_update()\n    {\n        .....\n       timer_invulnerable.on_update(delta);//更新\n        \n        move_and_collide();\t\t\t\t\t//检测触发函数\n    }\n\t\n\tvoid make_invulnerable()\n\t{\t\n\t\tis_invulnerable = true;\t\t\t\t//受击状态量改为true\n\t\ttimer_invulnerable.restart();\t\t//计时器重置，shotted改为false，事件到达后is_vulnerable改回false\n\t}\n\n\n\n~~~\n\n简单分析一下这里的回调函数\n\n\\[&\\](){is_invulnerable=false;}\n\n以引用捕获的方式获取类的局部变量，没有形参，函数主体\n\n<img src=\"image-20240614140821676.png\" style=\"zoom:50%;\" />大体流程就是这样子的\n\n\n\n\n\n**总结：** 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。\n\n<span style=\"color:blue\">相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解</span>\n\n<div style=\"text-align:center\">\n    >>> <a herf=\"https://space.bilibili.com/25864506?spm_id_from=333.337.search-card.all.click\">植物明星大乱斗教程（voidMatrix）</a><<<\n</div>\n","slug":"yang/计时器的分析","published":1,"title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r85p0012lcut8mjb94fx","content":"<h2 id=\"计时器\"><a href=\"#计时器\" class=\"headerlink\" title=\"计时器\"></a>计时器</h2><p>[TOC]</p>\n<blockquote>\n<p>游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。</p>\n<p>计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。</p>\n</blockquote>\n<p>我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _TIMER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _TIMER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Timer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">int</span> val)</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tpass_time += delta;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tpass_time = pass_time-wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> pass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> wait_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t\t\t\t</span><br><span class=\"line\">&#125;;\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_TIMER_H_</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们先从函数设置上分析功能</p>\n<ul>\n<li>重置计时器（restart）</li>\n<li>是否选择重复触发（set_one_shot）</li>\n<li>设置重复触发的间隔时间（set_wait_time）</li>\n<li>回调函数的设置(set_callback)</li>\n<li>计时器暂停(pause)</li>\n<li>计时器继续(resume)</li>\n<li>计时器数据更新(on_update)</li>\n</ul>\n<p>从以上我们就简单看出了计时器的基本功能</p>\n<ol>\n<li>状态的转换（单触发还是多次触发）</li>\n<li>计时的暂停和继续</li>\n<li>每次累计时间到达后执行的回调函数</li>\n</ol>\n<blockquote>\n<p>回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作</p>\n<p>类似lambda函数，后面分析函数会具体说明</p>\n</blockquote>\n<hr>\n<h3 id=\"函数实现的简单分析\"><a href=\"#函数实现的简单分析\" class=\"headerlink\" title=\"函数实现的简单分析\"></a>函数实现的简单分析</h3><h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> pass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//单次累计时间</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> wait_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//间隔时间</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//计时器是否暂停</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//是否触发的状态量</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//是否单次触发，false为循环触发</span></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t\t\t\t<span class=\"comment\">//回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后还会用到LAMBDA函数，来作为实参传输</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"restart（）\"><a href=\"#restart（）\" class=\"headerlink\" title=\"restart（）\"></a>restart（）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//累计时间清零</span></span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">//触发状态量回归未触发状态</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据</p>\n<h4 id=\"set-on-shot\"><a href=\"#set-on-shot\" class=\"headerlink\" title=\"set_on_shot()\"></a>set_on_shot()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t<span class=\"comment\">//是否单次触发</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//false为循环触发</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有的游戏应用场景下只需要计时器触发一次</p>\n<p>例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次）</p>\n<h4 id=\"set-wait-time（）\"><a href=\"#set-wait-time（）\" class=\"headerlink\" title=\"set_wait_time（）\"></a>set_wait_time（）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">int</span> val)</span>\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//设置触发的时间间隔</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>循环计时需要设置间隔时间</p>\n<p>例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔</p>\n<h4 id=\"set-callback\"><a href=\"#set-callback\" class=\"headerlink\" title=\"set_callback()\"></a>set_callback()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t<span class=\"comment\">//这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 </span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针）</p>\n<p>例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex&#x3D;false;的逻辑</p>\n<p>后面分析游戏实例会讲解</p>\n<h4 id=\"pause-resume\"><a href=\"#pause-resume\" class=\"headerlink\" title=\"pause()&amp;&amp;resume()\"></a>pause()&amp;&amp;resume()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tpaused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值</p>\n<h4 id=\"on-update\"><a href=\"#on-update\" class=\"headerlink\" title=\"on_update()\"></a>on_update()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//先检查计时器是否处于暂停状态</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tpass_time += delta;\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//若不暂停，则计时</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果到达了触发间隔且未暂停</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\"><span class=\"comment\">//前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tpass_time = pass_time-wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计时器数据更新的关键就是</p>\n<p><strong>何时触发和什么条件触发回调函数</strong></p>\n<p>（由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\">    <span class=\"built_in\">callback</span>();</span><br></pre></td></tr></table></figure>\n\n<p>首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0）</p>\n<p>其次就是<strong>循环触发</strong>（那就不考虑shotted状态了，时间到了就触发）和<strong>单次触发且还处于未触发状态</strong>（shotted为false）</p>\n<p>不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数</p>\n<hr>\n<h3 id=\"关于回调函数和函数指针，lambda函数的分析\"><a href=\"#关于回调函数和函数指针，lambda函数的分析\" class=\"headerlink\" title=\"关于回调函数和函数指针，lambda函数的分析\"></a>关于回调函数和函数指针，lambda函数的分析</h3><h4 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h4><blockquote>\n<p>指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针</p>\n</blockquote>\n<p>定义格式：<strong>返回类型  （*指针变量）(形式参数表)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*point)();\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指向一个参数，返回值为int的函数</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> (*point)(<span class=\"type\">int</span>);\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指向一个有int参数，返回值为int的函数</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高</p>\n<p>指针的赋值可以是：<strong>指针变量名&#x3D;函数名</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">point=f1；</span><br></pre></td></tr></table></figure>\n\n\n\n<p>函数指针主要有俩个用途：<strong>作为函数的参数（就是作为形参），和实现菜单</strong></p>\n<ul>\n<li>作为函数的参数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T a[],<span class=\"type\">int</span> size,<span class=\"type\">bool</span>(*f)(T,T))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> is_bigger=<span class=\"built_in\">f</span>(a,b)；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入</p>\n<ul>\n<li>菜单的实现（其实是函数指针数组的使用）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数</span></span><br><span class=\"line\">    <span class=\"built_in\">void</span> (*menu[<span class=\"number\">6</span>])()=&#123;<span class=\"literal\">NULL</span>,add,erase,modify,printSalary,printReport&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    menu[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是理解函数指针也是有数组的，让函数的接口变得更见简答易用</p>\n<h4 id=\"lambda函数\"><a href=\"#lambda函数\" class=\"headerlink\" title=\"lambda函数\"></a>lambda函数</h4><blockquote>\n<p>看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量</p>\n</blockquote>\n<p>表达形式：**[捕获列表] （形式参数表）-&gt;返回类型{函数体}**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)-&gt;<span class=\"type\">int</span>&#123;<span class=\"keyword\">return</span> x+y&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>有俩个形参，返回类型为int</p>\n<p><strong>注意</strong>：当返回类型很明确时，lambda函数可以不用尾置指定返回类型</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)&#123;<span class=\"keyword\">return</span> x+y&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>返回类型很明确不需要尾置，这也是正确的，也是比较常用的</p>\n<blockquote>\n<p>与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称<strong>捕获</strong></p>\n</blockquote>\n<p>常见的捕获有一下几种形式</p>\n<ul>\n<li>[x]:以值捕获的方式捕获变量x</li>\n<li>[&#x3D;]:以值捕获的方式捕获所有变量</li>\n<li>[&amp;x]：以引用捕获的方式捕获变量x</li>\n<li>[&amp;]:以引用捕获的方式捕获所有变量</li>\n</ul>\n<blockquote>\n<p><strong>回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。</strong></p>\n<p>如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。</p>\n<p><strong>当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。</strong></p>\n</blockquote>\n<p>这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x=<span class=\"number\">15</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f=[&amp;x](<span class=\"type\">int</span> y)-&gt;<span class=\"type\">int</span> &#123;<span class=\"built_in\">return</span> (++x)+y;&#125;;</span><br><span class=\"line\">    x=<span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">f</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>【&amp;x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><blockquote>\n<p>在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。</p>\n<p>使用functional库的回调函数，可以实现以下功能：</p>\n<ol>\n<li>将函数作为参数传递给其他函数，以便在需要的时候调用。</li>\n<li>在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。</li>\n<li>在函数式编程中，可以使用回调函数来实现高阶函数的操作。</li>\n</ol>\n</blockquote>\n<p>定义：<strong>std::function&lt;返回类型（参数类型列表）&gt; 回调函数名</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">int</span>)&gt; callback</span><br></pre></td></tr></table></figure>\n\n<p>表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装）</p>\n<p><strong>注意：</strong>function也是定义在标准函数库里的，所以要声明域名std</p>\n<p>基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器</p>\n<hr>\n<h3 id=\"关于植物明星大乱斗中的计时器逻辑分析\"><a href=\"#关于植物明星大乱斗中的计时器逻辑分析\" class=\"headerlink\" title=\"关于植物明星大乱斗中的计时器逻辑分析\"></a>关于植物明星大乱斗中的计时器逻辑分析</h3><p>大体本游戏使用了一下的计时器</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timer timer_invulnerable;\t\t\t\t\t\t<span class=\"comment\">//无敌状态定时器</span></span><br><span class=\"line\">Timer timer_invulnerable_blink;\t\t\t\t\t<span class=\"comment\">//无敌状态闪烁定时器，用于不同序列帧的切换功能</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_attack_cd;\t\t\t\t\t\t\t<span class=\"comment\">//普通攻击冷却定时器</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_run_effect_generation;\t\t\t\t<span class=\"comment\">//跑动粒子特效发射定时器</span></span><br><span class=\"line\">Timer timer_die_effect_generation;\t\t\t\t<span class=\"comment\">//死亡特效例子发射器</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_cursor_visibility;\t\t\t\t\t<span class=\"comment\">//玩家光标指示器可见性定时器</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态</li>\n<li>闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、</li>\n<li>普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成</li>\n<li>跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片）</li>\n<li>死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成</li>\n<li>玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示</li>\n</ul>\n<p>例子：</p>\n<h4 id=\"无敌状态定时器\"><a href=\"#无敌状态定时器\" class=\"headerlink\" title=\"无敌状态定时器\"></a>无敌状态定时器</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timer timer_invulnerable;\t\t\t\t\t\t<span class=\"comment\">//无敌状态定时器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Player</span>() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//无敌状态定时器的初始化设置</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">750</span>);\t\t<span class=\"comment\">//触发事件间隔750毫秒，0.75秒</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);\t\t<span class=\"comment\">//单次触发</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_callback</span>([&amp;]()\t\t<span class=\"comment\">//设置回调函数</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tis_invulnerable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       .....</span><br><span class=\"line\">      timer_invulnerable.<span class=\"built_in\">on_update</span>(delta);<span class=\"comment\">//更新</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"built_in\">move_and_collide</span>();\t\t\t\t\t<span class=\"comment\">//检测触发函数</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">make_invulnerable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t</span><br><span class=\"line\">\tis_invulnerable = <span class=\"literal\">true</span>;\t\t\t\t<span class=\"comment\">//受击状态量改为true</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">restart</span>();\t\t<span class=\"comment\">//计时器重置，shotted改为false，事件到达后is_vulnerable改回false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>简单分析一下这里的回调函数</p>\n<p>[&amp;](){is_invulnerable&#x3D;false;}</p>\n<p>以引用捕获的方式获取类的局部变量，没有形参，函数主体</p>\n<p><img src=\"image-20240614140821676.png\" style=\"zoom:50%;\" />大体流程就是这样子的</p>\n<p><strong>总结：</strong> 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。</p>\n<p><span style=\"color:blue\">相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解</span></p>\n<div style=\"text-align:center\">\n    >>> <a herf=\"https://space.bilibili.com/25864506?spm_id_from=333.337.search-card.all.click\">植物明星大乱斗教程（voidMatrix）</a><<<\n</div>\n","site":{"data":{}},"excerpt":"<h2 id=\"计时器\"><a href=\"#计时器\" class=\"headerlink\" title=\"计时器\"></a>计时器</h2><p>[TOC]</p>\n<blockquote>\n<p>游戏设计中的计时器类通常用于控制、管理和记录游戏中时间相关的功能。计时器类的作用是在游戏中跟踪时间的流逝、延迟执行特定事件、限制某些活动的时间长度等。</p>\n<p>计时器类的功能包括启动计时器、停止计时器、重置计时器、设置计时器的时间间隔、执行回调函数等。</p>\n</blockquote>\n<p>我们先通过植物明星大乱斗的计时器实现代码来分析，然后从实例中讲解每一步的实现</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _TIMER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _TIMER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Timer</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Timer</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">int</span> val)</span>\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpaused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\tpass_time += delta;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tpass_time = pass_time-wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> pass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> wait_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t</span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t\t\t\t</span><br><span class=\"line\">&#125;;\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_TIMER_H_</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们先从函数设置上分析功能</p>\n<ul>\n<li>重置计时器（restart）</li>\n<li>是否选择重复触发（set_one_shot）</li>\n<li>设置重复触发的间隔时间（set_wait_time）</li>\n<li>回调函数的设置(set_callback)</li>\n<li>计时器暂停(pause)</li>\n<li>计时器继续(resume)</li>\n<li>计时器数据更新(on_update)</li>\n</ul>\n<p>从以上我们就简单看出了计时器的基本功能</p>\n<ol>\n<li>状态的转换（单触发还是多次触发）</li>\n<li>计时的暂停和继续</li>\n<li>每次累计时间到达后执行的回调函数</li>\n</ol>\n<blockquote>\n<p>回调函数是一种类似函数指针的使用，因为不同计时器计时周期到达的目的不同，我们会选择让对象传入想要执行的操作</p>\n<p>类似lambda函数，后面分析函数会具体说明</p>\n</blockquote>\n<hr>\n<h3 id=\"函数实现的简单分析\"><a href=\"#函数实现的简单分析\" class=\"headerlink\" title=\"函数实现的简单分析\"></a>函数实现的简单分析</h3><h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> pass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//单次累计时间</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> wait_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//间隔时间</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> paused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//计时器是否暂停</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> shotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//是否触发的状态量</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> one_shot = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t<span class=\"comment\">//是否单次触发，false为循环触发</span></span><br><span class=\"line\">\tstd::function&lt;<span class=\"type\">void</span>()&gt; callback;\t\t\t\t\t<span class=\"comment\">//回调函数，这里相当于我们常用的函数指针，大体方式模板一样，之后还\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后还会用到LAMBDA函数，来作为实参传输</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"restart（）\"><a href=\"#restart（）\" class=\"headerlink\" title=\"restart（）\"></a>restart（）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">restart</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tpass_time = <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//累计时间清零</span></span><br><span class=\"line\">\t\tshotted = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t<span class=\"comment\">//触发状态量回归未触发状态</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次重新启用的时候都需要restart一下，尤其是暂停使用了，后面重新启用的时候记得restart一下，清除上一次的遗留的pass_time和shotted数据</p>\n<h4 id=\"set-on-shot\"><a href=\"#set-on-shot\" class=\"headerlink\" title=\"set_on_shot()\"></a>set_on_shot()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_one_shot</span><span class=\"params\">(<span class=\"type\">bool</span> flag)</span>\t\t\t\t\t\t\t\t\t<span class=\"comment\">//是否单次触发</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\tone_shot = flag;\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//false为循环触发</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有的游戏应用场景下只需要计时器触发一次</p>\n<p>例如：我释放了大招需要，规定动画在计时器的限制下播放2秒，到达时间后结束大招动画（这样的计时行为只需要这样一次）</p>\n<h4 id=\"set-wait-time（）\"><a href=\"#set-wait-time（）\" class=\"headerlink\" title=\"set_wait_time（）\"></a>set_wait_time（）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_wait_time</span><span class=\"params\">(<span class=\"type\">int</span> val)</span>\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//设置触发的时间间隔</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\twait_time = val;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>循环计时需要设置间隔时间</p>\n<p>例如：豌豆子弹的发射，需要在一定冷却时间后才能发射下一颗子弹，这个是不断循环的过程，子弹的冷却时间就是循环的时间间隔</p>\n<h4 id=\"set-callback\"><a href=\"#set-callback\" class=\"headerlink\" title=\"set_callback()\"></a>set_callback()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_callback</span><span class=\"params\">(std::function&lt;<span class=\"type\">void</span>()&gt; callback)</span>\t\t<span class=\"comment\">//这里就相当于将你传参的lambda函数的实现方法给到这个函数指针 </span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;callback = callback;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入特定对象需要的触发逻辑，选择了functional库中的回调函数（实际上就是函数指针）</p>\n<p>例如：我累计时间到了，要触发，例如我要大招结束，我要结束大招进行的状态量，就可以传入is_attacking_ex&#x3D;false;的逻辑</p>\n<p>后面分析游戏实例会讲解</p>\n<h4 id=\"pause-resume\"><a href=\"#pause-resume\" class=\"headerlink\" title=\"pause()&amp;&amp;resume()\"></a>pause()&amp;&amp;resume()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tpaused = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resume</span><span class=\"params\">()</span>\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tpaused = <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计时器的暂停和进行，修改（决定是否更新数据的状态变量）paused的值</p>\n<h4 id=\"on-update\"><a href=\"#on-update\" class=\"headerlink\" title=\"on_update()\"></a>on_update()</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">(<span class=\"type\">int</span> delta)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (paused)\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//先检查计时器是否处于暂停状态</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tpass_time += delta;\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//若不暂停，则计时</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pass_time &gt;= wait_time)\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果到达了触发间隔且未暂停</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\"><span class=\"comment\">//前面是检查计时器是否能被触发，俩种情况，如果计时器不是单次触发，或者时单次触发且没有触发过，后面则是检查callback是否传入了函数</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">callback</span>();</span><br><span class=\"line\">\t\t\tshotted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tpass_time = pass_time-wait_time;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>计时器数据更新的关键就是</p>\n<p><strong>何时触发和什么条件触发回调函数</strong></p>\n<p>（由于不论是单次触发还是多次触发，我们对不会显示调用暂停，而是放在那里一直计时，所以条件设置很关键）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((!one_shot || (one_shot &amp;&amp; !shotted)) &amp;&amp; callback)\t</span><br><span class=\"line\">    <span class=\"built_in\">callback</span>();</span><br></pre></td></tr></table></figure>\n\n<p>首先callback（函数指针必须赋予了函数，不然空指针为nullptr，默认为0）</p>\n<p>其次就是<strong>循环触发</strong>（那就不考虑shotted状态了，时间到了就触发）和<strong>单次触发且还处于未触发状态</strong>（shotted为false）</p>\n<p>不难看出shotted针对单循环设置的，就是为了防止计时器一直更新单次触发计时器而不断调用回调函数</p>\n<hr>\n<h3 id=\"关于回调函数和函数指针，lambda函数的分析\"><a href=\"#关于回调函数和函数指针，lambda函数的分析\" class=\"headerlink\" title=\"关于回调函数和函数指针，lambda函数的分析\"></a>关于回调函数和函数指针，lambda函数的分析</h3><h4 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h4><blockquote>\n<p>指针保存函数的入口地址，这样就嫩用指针调用函数的地址，这样的指针被称为函数指针</p>\n</blockquote>\n<p>定义格式：<strong>返回类型  （*指针变量）(形式参数表)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*point)();\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指向一个参数，返回值为int的函数</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> (*point)(<span class=\"type\">int</span>);\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指向一个有int参数，返回值为int的函数</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>声明函数指针的时候一定要带上括号，不然会认为时返回指针的函数，从而使用括号（）比*运算逻辑高</p>\n<p>指针的赋值可以是：<strong>指针变量名&#x3D;函数名</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">point=f1；</span><br></pre></td></tr></table></figure>\n\n\n\n<p>函数指针主要有俩个用途：<strong>作为函数的参数（就是作为形参），和实现菜单</strong></p>\n<ul>\n<li>作为函数的参数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T a[],<span class=\"type\">int</span> size,<span class=\"type\">bool</span>(*f)(T,T))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//冒泡排序，针对不同数据类型传入不同的比较函数，利用函数指针f比较</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> is_bigger=<span class=\"built_in\">f</span>(a,b)；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了实现泛型的模板，适应所有数据类型，从而将比较函数让使用者自己传入</p>\n<ul>\n<li>菜单的实现（其实是函数指针数组的使用）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//假设有六个函数名，放入函数指针数组，这样就可以通过索引调用函数</span></span><br><span class=\"line\">    <span class=\"built_in\">void</span> (*menu[<span class=\"number\">6</span>])()=&#123;<span class=\"literal\">NULL</span>,add,erase,modify,printSalary,printReport&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    menu[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是理解函数指针也是有数组的，让函数的接口变得更见简答易用</p>\n<h4 id=\"lambda函数\"><a href=\"#lambda函数\" class=\"headerlink\" title=\"lambda函数\"></a>lambda函数</h4><blockquote>\n<p>看作是一个未命名的内联函数，与普通函数不同的是，lambda函数可以定义在函数内部，必须用尾置返回可以访问所在函数的局部变量</p>\n</blockquote>\n<p>表达形式：**[捕获列表] （形式参数表）-&gt;返回类型{函数体}**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)-&gt;<span class=\"type\">int</span>&#123;<span class=\"keyword\">return</span> x+y&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>有俩个形参，返回类型为int</p>\n<p><strong>注意</strong>：当返回类型很明确时，lambda函数可以不用尾置指定返回类型</p>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)&#123;<span class=\"keyword\">return</span> x+y&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>返回类型很明确不需要尾置，这也是正确的，也是比较常用的</p>\n<blockquote>\n<p>与普通函数不同，lambda表达式允许访问所在函数中的其他变量，这一过程称<strong>捕获</strong></p>\n</blockquote>\n<p>常见的捕获有一下几种形式</p>\n<ul>\n<li>[x]:以值捕获的方式捕获变量x</li>\n<li>[&#x3D;]:以值捕获的方式捕获所有变量</li>\n<li>[&amp;x]：以引用捕获的方式捕获变量x</li>\n<li>[&amp;]:以引用捕获的方式捕获所有变量</li>\n</ul>\n<blockquote>\n<p><strong>回调函数的引用捕获的范围取决于函数定义的位置和调用的方式。</strong></p>\n<p>如果回调函数是在全局作用域或模块作用域中定义的，那么它可以捕获全局作用域或模块作用域中的所有变量。</p>\n<p><strong>当一个函数在另一个函数内部定义时，引用捕获的范围是包含该函数定义的函数的作用域。这意味着在调用函数时，其内部定义的回调函数可以访问外部函数的局部变量。</strong></p>\n</blockquote>\n<p>这个意味着类里面的函数使用这个lambda，完全可以访问类的数据成员，因为函数嵌套在类里面</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x=<span class=\"number\">15</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f=[&amp;x](<span class=\"type\">int</span> y)-&gt;<span class=\"type\">int</span> &#123;<span class=\"built_in\">return</span> (++x)+y;&#125;;</span><br><span class=\"line\">    x=<span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"built_in\">f</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>【&amp;x】表示引用捕获当前main函数（最靠近的函数）的x变量，调用函数f，就会导致main函数的x发生数值变化，因为时引用，后面案例也会介绍到</p>\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><blockquote>\n<p>在functional库中，回调函数是一个常用的概念，它允许我们传递一个函数作为参数，并在需要的时候调用这个函数。</p>\n<p>使用functional库的回调函数，可以实现以下功能：</p>\n<ol>\n<li>将函数作为参数传递给其他函数，以便在需要的时候调用。</li>\n<li>在事件驱动的程序中，可以使用回调函数来处理异步操作的结果。</li>\n<li>在函数式编程中，可以使用回调函数来实现高阶函数的操作。</li>\n</ol>\n</blockquote>\n<p>定义：<strong>std::function&lt;返回类型（参数类型列表）&gt; 回调函数名</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::function&lt;<span class=\"type\">void</span>(<span class=\"type\">int</span>)&gt; callback</span><br></pre></td></tr></table></figure>\n\n<p>表示接受一个无返回值，形参为一个整型的函数（实际上就是对函数指针的封装）</p>\n<p><strong>注意：</strong>function也是定义在标准函数库里的，所以要声明域名std</p>\n<p>基于这种灵活的功能我们选择将其封装在计时器实现面向不同对象的触发逻辑，从而实现真正解耦的计时器</p>\n<hr>\n<h3 id=\"关于植物明星大乱斗中的计时器逻辑分析\"><a href=\"#关于植物明星大乱斗中的计时器逻辑分析\" class=\"headerlink\" title=\"关于植物明星大乱斗中的计时器逻辑分析\"></a>关于植物明星大乱斗中的计时器逻辑分析</h3><p>大体本游戏使用了一下的计时器</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timer timer_invulnerable;\t\t\t\t\t\t<span class=\"comment\">//无敌状态定时器</span></span><br><span class=\"line\">Timer timer_invulnerable_blink;\t\t\t\t\t<span class=\"comment\">//无敌状态闪烁定时器，用于不同序列帧的切换功能</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_attack_cd;\t\t\t\t\t\t\t<span class=\"comment\">//普通攻击冷却定时器</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_run_effect_generation;\t\t\t\t<span class=\"comment\">//跑动粒子特效发射定时器</span></span><br><span class=\"line\">Timer timer_die_effect_generation;\t\t\t\t<span class=\"comment\">//死亡特效例子发射器</span></span><br><span class=\"line\"></span><br><span class=\"line\">Timer timer_cursor_visibility;\t\t\t\t\t<span class=\"comment\">//玩家光标指示器可见性定时器</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>无敌状态定时器：受击后开始计时，单次触发，无敌时间到后结束无敌状态</li>\n<li>闪烁定时器：受击时且有剩余血量触发，重复触发，每次到达时间，不断切换闪白动画和原动画的、</li>\n<li>普通攻击冷却定时器：每次发射子弹计时，单次触发，每次时间到后，使子弹可再次生成</li>\n<li>跑动粒子发射定时器：跑动过程中触发，重复触发，每次到达时间后，使粒子生成（本游戏的粒子其实是图片）</li>\n<li>死亡特效粒子发生定时器：进入死亡状态时，重复触发，每次到达时间后，使粒子生成</li>\n<li>玩家光标指示器定时器：开局显示玩家位置，单次触发，到达时间后使光标不再显示</li>\n</ul>\n<p>例子：</p>\n<h4 id=\"无敌状态定时器\"><a href=\"#无敌状态定时器\" class=\"headerlink\" title=\"无敌状态定时器\"></a>无敌状态定时器</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timer timer_invulnerable;\t\t\t\t\t\t<span class=\"comment\">//无敌状态定时器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Player</span>() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//无敌状态定时器的初始化设置</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_wait_time</span>(<span class=\"number\">750</span>);\t\t<span class=\"comment\">//触发事件间隔750毫秒，0.75秒</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_one_shot</span>(<span class=\"literal\">true</span>);\t\t<span class=\"comment\">//单次触发</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">set_callback</span>([&amp;]()\t\t<span class=\"comment\">//设置回调函数</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tis_invulnerable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">on_update</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       .....</span><br><span class=\"line\">      timer_invulnerable.<span class=\"built_in\">on_update</span>(delta);<span class=\"comment\">//更新</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"built_in\">move_and_collide</span>();\t\t\t\t\t<span class=\"comment\">//检测触发函数</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">make_invulnerable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t</span><br><span class=\"line\">\tis_invulnerable = <span class=\"literal\">true</span>;\t\t\t\t<span class=\"comment\">//受击状态量改为true</span></span><br><span class=\"line\">\ttimer_invulnerable.<span class=\"built_in\">restart</span>();\t\t<span class=\"comment\">//计时器重置，shotted改为false，事件到达后is_vulnerable改回false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>简单分析一下这里的回调函数</p>\n<p>[&amp;](){is_invulnerable&#x3D;false;}</p>\n<p>以引用捕获的方式获取类的局部变量，没有形参，函数主体</p>\n<p><img src=\"image-20240614140821676.png\" style=\"zoom:50%;\" />大体流程就是这样子的</p>\n<p><strong>总结：</strong> 其实计时器就是相当于一个整体的组件，定时管理着一些东西。主体就是计时器的初始化，计时器的更新，计时器的重置，计时器的触发几个方面。</p>\n<p><span style=\"color:blue\">相信你如果看过植物明星大乱斗的教程，再加上这里的梳理你一定能够对计时器有更深的理解</span></p>\n<div style=\"text-align:center\">\n    >>> <a herf=\"https://space.bilibili.com/25864506?spm_id_from=333.337.search-card.all.click\">植物明星大乱斗教程（voidMatrix）</a><<<\n</div>"},{"title":"算法数据结构和效率","date":"2024-06-20T16:00:00.000Z","updated":"2024-06-20T16:00:00.000Z","_content":"\n有关算法效率分析的笔记，包括Big-Oh表示法、Master定理和部分算法与数据结构的算法分析。\n<div style=\"text-align:center\">\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/cover.png\" alt=\"封面\" width=\"300\">\n</div>\n\n<!-- More -->\n\n---\n\n# 介绍\n\n原博客：[点击跳转](https://www.zexnocs.top/post/%E7%AC%94%E8%AE%B0%2F%E7%AC%94%E8%AE%B0-ADE-%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%88%E7%8E%87)\n\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n\n本笔记主要分为下面五个部分：\n- 一. 算法效率的评估\n- 二. Big-Oh表示法和其家族\n- 三. Master定理\n- 四. 数据结构\n- 五. 算法\n\n\n# 一. 算法效率的评估\n\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 **程序的运行时间** 来评估测量算法效率。\n\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 ~~(关于SPFA，它死了)~~ 。\n\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n---\n\n## 方法一：Experiment 实验统计\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png\" alt=\"实验统计样例\" width=\"300\">\n\n> 实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。\n\n具体步骤如下:\n- 写一个程序实施该算法\n- 使用不同的输入大小和输入信息运行程序\n- 记录实际运行时间\n- 绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注**最差的情况**，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n\n### 缺点 & 局限性\n- 必须用程序实现该算法，可能会很耗时。\n- 需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n- 效率的评估受到硬件/软件/语言环境的影响。\n\n---\n\n## 方法二：Theory 理论分析\n\n> 理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n\n跟实验统计一样，我通常指关注**最差的情况**。\n\n### 特点\n- 具有一定的抽象性。\n- 能够独立于硬件/软件/语言环境来评估算法的效率。\n- 能够考虑所有可能的输入。\n\n### 缺点 & 局限性\n- 实施过程可能会比较困难，需要一定的知识基础。\n- 在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n### 评估标准\n在实验统计中，我们往往使用 **程序的运行时间** 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：**原始运算数量**。\n\n#### 原始运算的定义\n\n> 原始运算(primitive operations)是算法执行的基本运算。\n\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将**汇编代码**、**算数运算**视作一个原始运算。\n\n注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：\n\n|描述|伪代码样例|\n|----|---------|\n|变量赋值|`a ← 0`|\n|数组索引|`a[10]`|\n|变量比较|`a == 10`|\n|算数运算|`a + 1`|\n|函数调用|`function()`|\n|函数返回|`return 0`|\n\n**注意：**\n- 在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n- 数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n- 函数调用属于原始运算是因为它需要在内存中进行索引。\n- 在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n|描述|分析|操作数|伪代码样例|\n|----|----|-----|---------|\n|for循环，循环次数为$n$|要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)|$1+n+2n = 3n+1$|`for i ← 1 to n do`|\n|for循环，循环次数为$(n-1)$|要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)|$1+2(n-1)+2(n-1) = 4n-3$|`for i ← 1 to (n-1) do`|\n|while循环，循环次数为$n$|每次循环只需要判断即可|$n$|`while i > n`|\n|while循环，循环次数为$(n-1)$|每次循环都需要进行判断和减法|$2(n-1)$|`while i > (n-1)`|\n|if then判断，then内部原始运算数为$k$|一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)|$1 + k$|`if ... then ...`|\n\n:::details 一个计算原始运算数的例子: arrayMax(A, n)\n\n一个返回数组最大值arrayMax(A, n)的伪代码：\n```\nAlgorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。\n  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值\n  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)\n    if A[i] > currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)\n      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)\n  return currentMax         # 原始运算为1，函数返回\n```\n\n综上所述，这个算法的原始运算总数为 $2 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 4$\n\n:::\n\n原始运算的个数并不是固定的，例如在计算操作 $c \\leftarrow A[i]$ 中，你也可以认为是$4$个原始运算：\n- 获取$A$数组的指针储存在寄存器中。\n- 获取$i$储存在寄存器中。\n- 计算$A + i$作为$A[i]$的指针储存在寄存器中。\n- 复制变量$c$的数值写在$A + i$指针的内存中。\n\n当然在这个笔记中，你也可以认为只有$2$个原始运算：\n- 根据$i$索引获取$A[i]$数组位置 (数组索引)。\n- 将变量$c$的数值赋值给$A[i]$ (变量赋值)。\n\n但是无论是$4$还是$2$，这个操作永远不可能会是$2n$，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。\n\n> 原始运算的个数只与算法的效率有关，与正确性无关。\n\n#### 使用原始运算估算运行时间\n\n增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。\n\n> 对于算法来说，假设它的最差情况的运行时间为$T(n)$，那么$T(n)$的增长率是该算法的固有属性，是不受硬件/软件环境影响的。\n\n我们可以使用原始运算来估算运行时间，假设：\n- 原始运算的个数为$P(n)$。\n- 最快的原始运算所需要的时间为$a$，是一个常数。\n- 最慢的原始运算所需要的时间为$b$，是一个常数。\n\n可以得出：$$aP(n) \\leq T(n) \\leq bP(n)$$\n\n由于a和b都是常数，那么我们认为\\[T(n)\\]和\\[P(n)\\]具有相同的增长率。很明显$T(n)$和$P(n)$的导数肯定是不同的，因此增长率并不等同于导数。\n\n但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。\n\n\n\n# 二. Big-Oh表示法和其家族\n## 基本知识\n我们需要一种函数分类(Classification of Functions)来通过**缩放**的行为将函数分组在一起，同一组的函数具有这样的相似性：\n- 删除不必要的细节。\n- 相对快速、简单。\n- 处理运行时可能会发生的“奇怪的”函数(例如分段函数)。\n- 在数学上拥有明确的定义。\n\n其中一种最佳的方法是使用[Big-Oh表示法和其家族(Big-Oh notation and family)](https://en.wikipedia.org/wiki/Big_O_notation)：\n- $O$: Big-Oh\n- $\\Omega$: Big-Omega\n- $\\Theta$: Big-Theta\n- $o$: little-oh\n- $\\omega$: little-omega\n\n本笔记只集中于前四个的定义和Big-Oh的相关理论。\n\n---\n\n## Big-Oh：O(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ O(g(n))$ ，当且仅当\n$$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| \\leq c \\ g(n)$$\n\n**注意:**\n- 量词顺序是 $\\exists \\ \\exists \\ \\forall$\n- $c$ 和 $n_0$必须是常数，不能随着$n$变化。不然这是没有意义的。\n- 注意符号$>,\\geq,\\leq$的区分。相比之下是比较严格的(例如，$n_0$ 不能等于 $0$, $n$ 可以等于 $n_0$)。\n\n此外，Big-Oh可以会被定义为：\n$$\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} < \\infty $$\n\n> Big-Oh只规定了$f(n)$的**增长率的上限**(upper bound on the growth rate of the function)。\n\n### 特点\n- Big-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于**函数**。也就是说它并不是对算法进行分类，而是对**函数**进行分类。\n- 一般$f(n)$表示运行时间，$n$表示输入的个数，所以Big-Oh中描述的函数一般为 $f: \\mathbb{N^+} \\to \\mathbb{R^+}$，$g(n)$也类似。\n- Big-Oh只规定了$f(n)$的**增长率的上限**，也就是说，当$n$足够大时，$f(n)$的增长速率不大于$g(n)$。\n- Big-Oh中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) = 1$可以是$O(1)$，但也可以是$O(n)$。因此$g(n)$的增长率越小越能反应出$f(x)$的增长率。\n\n### 性质\n\nBig-Oh作为一个二元关系(binary relation)，拥有以下性质：\n- Big-Oh具有自反性(Reflexive, e.g. $x R x$)，即 $f(n)$ 是 $O(f(n))$。\n- Big-Oh不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)，例如 $f(n) = 1$ 是 $O(n)$，但是 $f(n) = n$ 不是 $O(1)$。\n- Big-Oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。即如果 $\\forall n \\geq n_1, f(n) \\leq c_1g(n)$，且$\\forall n \\geq n_2, g(n) \\leq c_2h(n)$，那么总有 $\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3=\\max(n_1,n_2)$。\n\n综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是$\\subset, \\in, \\leq$,而不是$=$，因此有一种表示方法是将Big-Oh视作集合，使用$n \\in O(n)$。此时也有会 $O(lower\\ order) \\subset O(heigher\\ order)$。\n\n*此外，也有一种说法是使用$f(n) = O(n)$，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。*\n\n### 推论 & 方法\n\n- 推论1：存在三个函数$f(n)$, $g(n)$, $p(n)$和正数$k, b\\in \\mathbb{N^+}$，如果$f(n)$是$O(g(n))$，且$f(n)=k\\ p(n) + b$，那么有$p(n)$是$O(g(n))$。\n\n:::details 证明推论1\n\n假设有$c_0 > 0, n_0 > 0$，对于$n_1 \\geq n_0$，有：\n\n$f(n_1) \\leq c_0 \\ g(n_1)$，那么有：\n\n$k\\ p(n_1) + b \\leq c_0 \\ g(n_1)$，整理得：\n\n$p(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}$\n\n当n足够大时候，假设此时$n_1 \\geq n_2$，有 $cg(n_1) \\geq 2b$\n\n从而有 $p(n_1) \\leq \\frac{c_0}{2k}g(n_1)$\n\n设 $c_1=\\frac{c}{2k}>0$，我们得到：\n\n$p(n_1) \\leq c_1\\ g(n_1)$，即\n\n存在 $c_1$，$n_2$使得 $\\forall n > n_2, p(n) \\leq c_1\\ g(n)$\n\n因此$p(n)$是$O(g(n))$。\n\n:::\n\n- 推论2 （乘法）：如果$f_1(n)$ 是 $O(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$。\n\n:::details 证明推论2\n\n$∵ f_1(n)$ 是 $O(g_1(n))$\n\n$∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1$\n\n$∵ f_2(n)$ 是 $O(g_2(n))$\n\n$∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2$\n\n$∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0$\n\n那么有 $n_0 = \\max(n_1, n_2)$\n$f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0$\n\n因此$f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$\n\n:::\n\n- 推论3 （加法）：如果 $f(n) = 1 + h(n)$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(1)$。\n\n:::details 证明推论3\n\n$∵$ 当$n \\to \\infty$ 时 $h(n) \\to 0$\n$∴$ $\\exists n_0 > 0,\\ \\forall n \\geq n_0, h(n) \\leq 1$\n$∴$ $\\exists n_0 > 0,\\ \\forall n \\geq n_0, f(n) \\leq 2$\n$∴$ $f(n)$ 是 $O(1)$ 取 $c = 2, n_0 = n_1$ 且 $h(n_1) <= 1$\n\n:::\n\n一些常用的 $h(n)$:\n- $n^2/2^n$\n- $n^{2000}/2^{\\frac{n}{100}}$\n- $(log(n))^{100} / n^{0.1}$\n\n综合推论2和3，可知如果 $f(n) = g(n)(1 + h(n))$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(g(n))$。\n\n因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：\n- 删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。\n- 删除常数(constant)项系数 (根据推论1,总能找到 $k$ 使得系数变成 $1$)。\n\n### 例子\n\n:::details 证明arrayMax(A, n)是 $O(n)$ 的例子 (定义)\n\n由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 $f(n) = 8n - 4$\n\n设$g(n) = n$，因此需要求证 $\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)$，整理可得：\n\n$$\n\\begin{cases}\nn \\leq \\frac{4}{c - 8} & c > 8 \\\\\nn \\geq \\frac{4}{c - 8} & c < 8 \\\\\n-4 \\leq 0 & c = 8\n\\end{cases}\n$$\n\n由于我们规定是 $\\forall n \\geq n_0$，因此我们只能取 $n \\geq 8$。\n\n当我们取 $n = 8$时，很明显任意$n_0 > 0$都可以证明成立。此时我们可以取 $n_0 = 1$。\n\n当我们取 $n > 8$时，很明显任意$n_0 > \\frac{4}{c - 8}$都可以证明成立。此时我们可以取 $n_0 = \\frac{4}{c - 8}$。\n\n实际上，上述情况只需要求出一组$(c,n_0)$即可，因此我们可以直接取$c = 8, n_0 = 1$。不过这里给出了一种选取$(c,n_0)$的具体方法。\n\n因此arrayMax(A, n)的时间复杂度是 $O(n)$。\n\n:::\n\n:::details 对于分段函数Big-Oh的证明 (定义)\n\n如何计算下面函数的Big-Oh:\n$$\nf(n) = \n\\begin{cases}\nn & \\text{if } n \\text{ is even} \\\\\n1 & \\text{if } n \\text{ is odd}\n\\end{cases}\n$$\n\n因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即$f(n) = n$，此时当$c = 1, n_0 = 1$可以证明出$f(n)$是$O(n)$，而无法证明出$f(n)$是$O(1)$。\n\n:::\n\n:::details 求 $f_(n) = n^2 + n$ 的Big-Oh (定理2, 3)\n\n$f(n) = n^2 + n = n^2(1 + \\frac{1}{n})$\n\n因为自反性，$n^2$ 是 $O(n^2)$。\n\n因为当$n \\to \\infty$ 时 $\\frac{1}{n} \\to 0$，根据推理3可知 $1 + \\frac{1}{n}$ 是 $O(1)$。\n\n因此根据推理2，$f(n)$ 是 $O(n^2 * 1) = O(n^2)$\n\n:::\n\n:::details 求 $f_(n) = 5n^4 + 3n^3$ 的Big-Oh (删除规则)\n\n- 删除低阶$3^n$，因此$f(n)$ 是 $O(5n^4)$\n- 删除常数$5$，因此$f(n)$ 是 $O(n^4)$\n\n:::\n\n### Big-Oh公约\n遵循这个公约可以更好地去分析算法以及给出最大的信息。\n\n- 使用最小且正确的增长率函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(n^2)$，尽管后者也是正确的。\n- 使用最简的函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(2n)$。\n\n### 其他\n对于 $n^{O(1)}$来说，相当于是 $\\{ n^f(n)\\ |\\ f(n) \\text{ is } O(1)\\}$。\n也就是说 $\\{n^1, n^2, n^3, ...\\} \\subset n^{O(1)}$，$\\{n^\\frac{1}{2}, n^\\frac{1}{3}, n^\\frac{1}{4}... \\} \\subset n^{O(1)}$\n\n> $n^{O(1)}$ is any function that is no worse than (Big-Oh of) some power law.\n$n^{O(1)}$表示任何不超过指数级的函数。\n\n---\n\n## Big-Omega：Ω(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Omega (g(n))$ ，当且仅当\n$$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : f(n) \\geq c \\ g(n)$$\n\n注意：\n- 量词顺序是 $\\exists \\ \\exists \\ \\forall$。\n- 与Big-Oh不同，最后的符号是 $\\geq$ 而不是 $\\leq$。\n\n此外，Big-Omega可以会被定义为：\n$$\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} > 0 $$\n\n### 特点\n- Big-Omega规定了$f(n)$的**增长率的下限**，也就是说，当$n$足够大时，$f(n)$的增长速率不小于$g(n)$。\n- Big-Omega中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) = n^3 - n$ 可以是 $\\Omega(n^3)$，但也可以是 $\\Omega(n^2)$。因此$g(n)$的增长率越大越能说明$f(n)$的增长率。\n- 一般可以用来描述算法的最佳情况。\n\n### 性质\n类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：\n- Big-Omega具有自反性(Reflexive, e.g. $x R x$)。\n- Big-Omega不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)。\n- Big-Omega具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nBig-Omega更像是 $\\geq$。\n\n### 推论 & 方法\n- 推论1：$f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))$\n- 推论2 （乘法）：如果$f_1(n)$ 是 $\\Omega(g_1(n))$, $f_2(n)$ 是 $\\Omega(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $\\Omega(g_1(n)g_2(n))$。\n\n删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是**删除低阶函数**而不是删除高阶函数。\n\n例如 $f(n) = n^3 - n$中，应该删除的是$n$。找到$n^3$后我们就可以找比$n^3$阶级低的函数来代替。\n\n---\n\n## Big-Theta：θ(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Theta (g(n))$ ，当且仅当\n> $$\\exists c' > 0, \\exists c''>0, \\exists n_0 > 0, \\forall n \\geq n_0 : c'\\ g(n) \\leq f(n) \\leq c'' \\ g(n)$$\n\n此外，Big-Theta可以被定义为：\n> $$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))$$\n> $$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))$$\n\n### 性质\nBig-Theta作为一个二元关系拥有下面的性质：\n- Big-Theta具有自反性(Reflexive, e.g. $x R x$)。\n- Big-Theta**具有**对称性(Symmetric, e.g. $x R y \\iff y R x$)：如果 $f(n)$ 是 $\\Theta(g(n))$，那么 $g(n)$ 是 $\\Theta(f(n))$。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。\n- Big-Theta具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nBig-Theta更像是 $\\approx$。\n\n---\n\n## little-oh：o(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ o(g(n))$ ，当且仅当\n$$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| < c \\ g(n)$$\n\n**注意:**\n- 量词顺序是 $\\forall \\ \\exists \\ \\forall$。\n- 因为是对于全部的 $c$ 存在 $n_0$，因此 $n_0$ 的数值可以依赖于 $c$。\n- 与Big-Oh不同，最后的符号是 $<$ 而不是 $\\leq$。\n\nlittle-oh也可以被定义为：\n$$\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n### 性质\nlittle-oh作为一个二元关系(binary relation)，拥有以下性质：\n- little-oh**不具有**自反性(Reflexive, e.g. $x R x$)。即$f(n) = n$ 不是 $o(n)$。\n- little-oh**不具有**对称性(Symmetric, e.g. $x R y \\iff y R x$)。\n- little-oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nlittle-oh 更像是严格的 $<$。\n\n### 特点\n- 与Big-Oh类似，little-Oh定义是函数的**严格无法到达的上限**。\n- little-oh的意思是，当$n$足够大时，$f(n)$的增长速率小于$g(n)$。\n- little-oh中 $g(n)$ 阶级越小，越能说明 $f(n)$ 的增长率。\n\n### 推论 & 方法\n- 推论1：如果$f(n)$ 是 $o(g(n))$，那么 $f(n)$ 一定是 $O(g(n))$\n正如 $<\\ \\to\\ \\leq$ 一样，很明显 $O(g(n)) \\subset o(g(n))$。\n- 推论2 （乘法1）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $o(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。\n- 推论3 （乘法2）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。\n\n与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。\n\n### 例子\n\n:::details 证明 $f(n) = n ^ 2 + n$ 是 $o(n^3)$\n\n要证明$f(n) = n ^ 2 + n$ 是 $O(n^3)$，则需要证明 $\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : f(n) < c \\ g(n)$。\n\n代入和整理可得 $\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : cn^2-n-1 > 0$。\n\n由公式可得，若 $cn^2-n-1 = 0$，且$n_r > 0$，可解得 $n_r = \\frac{1 + \\sqrt{4c + 1}}{2c} > 0$。\n\n且当 $n > n_r$ 时，$cn^2 - n - 1 > 0$ 恒成立，那么可以取 $n_0 = n_r + 1 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$，使得 $\\forall n \\geq n_0 : f(n) < c \\ g(n)$ 恒成立。\n\n因此，$f(n) = n ^ 2 + n$ 是 $O(n^3)$，此时对于所有的 $c$ 取 $n_0 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$。\n\n:::\n\n### 关于Big-Oh和little-oh的定义上的思考：\n\n如果将Big-Oh的定义改为：$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| < c \\ g(n)$，称为 $O_<$，而原定义称为 $O_{\\leq}$，\n那么实际上，对于 $g(n) > 0$， $f(n)$ 是 $O_<(g(n)) \\iff f(n)$ 是 $O_{\\leq}(g(n))$。\n唯一的区别是对于 $f(n) = 0, g(n) = 0$ 来说 $0$ 是 $O_{\\leq}(0)$ 而不是 $O_<(0)$。\n而我们想要定义Big-Oh的渐进符号为 $\\leq$，就得要求 $0$ 是 $O(0)$，因此使用 $\\leq$ 而不是 $<$。\n\n同理，对于little-oh如果定义改为：$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)|  \\leq c \\ g(n)$，称为 $o_{\\leq}$，而原定义称为 $o_{<}$。\n此时 $o_{<}$ 与 $o_{\\leq}$ 定义的唯一区别也是当 $f(n) = 0, g(n) = 0$ 的时候，此时 $0$ 是 $o_{\\leq}(0)$ 而不是 $o_{<}(0)$。\n而我们想要定义little-oh的渐进符号是 $<$，就得要求 $0$ 不是 $o(0)$，那么使用的是 $<$ 而不是 $\\leq$。\n\n实际上，对于Big-Oh和little-oh最主要的区别是 $\\exists c$ 和 $\\forall c$。\n\n---\n\n## 常用表示表\n\n根据阶级(order)从小到大排名。\n\n|表示|中文名|英文名|数量级|\n|----|-----|------|-----|\n|$O(n^c), c < 0$ $or$ $O(\\frac{k}{n})$|负数幂级|negative power|$\\infty$,不存在|\n|$O(1)$|常数级|constant|$\\infty$|\n|$O(\\log{\\log{n}})$|双对数级|double logarithmic|$2^{2^{10^6}}$|\n|$O(\\log{n})$|对数级|logarithmic|$10^{301030}$|\n|$O((\\log{n})^c), c > 1$|多重对数级|polylogarithmic|$2^{10^{\\frac{6}{c}}}$|\n|$O(n^c), 0 < c < 1$ $or$ $O(\\sqrt[c]{n})$|分数幂级|fractional power|$10^{6c}$|\n|$O(n)$|线性级|linear|$10^6$|\n|$O(n\\log{n}) = O(\\log{n!})$|对数线性/拟线性级|loglinear, n-log-n|$10^5$|\n|$O(n^2)$|二次级|quadratic|$10^3$|\n|$O(n^c), c > 1$|多项式/代数级|polynomial, algebraic|$\\sqrt[c]{10^6}$|\n|$O(c^n)$|指数级|exponential|$6\\log_{c}{10}$|\n|$O(n!)$|阶乘级|factorial|$9$|\n\n---\n\n## Big-Oh家族使用样例\n- 用于表示一个范围：算法 X 最坏的情况时间复杂度是 $o(n^4)$ 和 $\\Omega(n^3)$，但是实际表现并不确定。\n- 用于确定一个增长率：算法 X 最佳的情况时间复杂度是 $\\Theta(n^2)$。\n- 用来表示一个平均值：算法 X 平均情况时间复杂度是 $O(n^3)$。\n\n---\n## 使用Big-Oh家族分析算法效率注意点\nBig-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 $n$ **足够大**时渐进的范围,也可以说是 $n$ 的增长率。 \n\n但是在 $n$ **比较小**时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的**实际工作**时的效率。\n\n例如：\n- $10000n$ 是 $O(n)$，同时 $2^n$ 是 $O(2^n)$，当时当 $n$ 比较小时，例如 $n = 6$ 时，前者需要进行的计算数是 $60000$，而后者是 $64$，此时前者的效率是不如后者的。\n- $O(1.02^n)$ 尽管是指数级(exponential)，但是它的效率并不逊色。\n\n但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 $n$ 比小的时候程序所消耗的时间往往是会忽略不计的。\n\n---\n\n## 总结\n- Big-Oh家族定义及其渐进表示法总结\n\n|表示法|名字|描述|渐进符号|形式定义|\n|-----|----|----|-------|-------|\n|$o(g(n))$|little-Oh|函数渐进地由$g$支配|$<$|$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : \\| f(n) \\| < c \\ g(n)$|\n|$O(g(n))$|Big-Oh|函数以$g$为渐进边界|$\\leq$|$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : \\|f(n)\\| \\leq c\\ g(n)$|\n|$\\Theta(g(n))$|Big-Theta|函数由$g$为渐进边界和下边界|$\\approx$|$\\exists c'>0,\\exists c''>0, \\exists n_0 > 0, \\forall n \\geq n_0 : c'g(n) \\leq f(n) \\leq c''g(n)$|\n|$\\Omega(g(n))$|Big-Omega|函数由$g$为渐进下边界|$\\geq$|$\\exists c>0,\\exists n_0>0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)$|\n|$\\omega(g(n))$|little-omega|函数渐进支配$g$|$>$|$\\exists c>0,\\forall n_0 > 0, \\exists n \\geq n_0 : f(n) > c\\ g(n)$|\n\n- 如何求解一个算法的时间复杂度Big-Oh：\n  - 建立算法函数的伪代码。\n  - 求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。\n  - 根据该函数求出Big-Oh表示。\n\n---\n\n# 三. Master定理\n## 分而治之(Divide and Conquer)\n分而治之是一个设计算法的思想，它通常能够高速地处理问题。\n\n分而治之的组成成分如下：\n  - 分解 (Divide)：将输入分为两个或多个不相交的输入子集。\n  - 递归 (Recur)：使用递归解决这些子集的子问题。\n  - 组合 (Conquer)：将所有子集的解组合起来形成输入的解。\n\n---\n\n## 递归关系 Recurrence Relation\n定义：\n> A recurrence relation is a recursively-defined function.\n[递归关系(Recurrence Relation)](https://en.wikipedia.org/wiki/Recurrence_relation)是使用递归定义的函数。\n\n假设一个程序的运行时间是 $T(n)$，那么递归关系会在一系列小于n的值中来表达 $T(n)$。\n\n:::details 例子：归并排序(merge-sort)的递归关系及其时间复杂度的证明\n\n关于归并排序的具体算法请看下面 **五. 算法** 中 **归并排序**。\n\n假设归并排序的运行时间为 $T(n)$，那么\n\n$$\n\\begin{aligned}\nT(n) & = 2\\ T(\\frac{n}{2}) + b + an \\\\T(1) & = 1\n\\end{aligned}\n$$\n\n- $2\\ T(\\frac{n}{2})$ 表示数组分成了两个子数组，每个子数组的大小为 $\\frac{n}{2}$。\n- $b$ 是分裂的花费。\n- $an$ 是 `merge` 的花费。\n\n因此我们经过带入可以得到：\n- $T(2) = 2\\ T(1) + b + 2a = 2 + b + 2a$\n- $T(4) = 2\\ T(4) + b + 4a = 2 (2 + b + 2a) + b + 4a = 4 + 3b + 8a$\n- $T(8) = 2\\ T(4) + b + 8a = 2 (4 + 3b + 8a) + b + 8a = 8 + 7b + 24a$\n\n由此我们猜测 $T(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$\n我们可以使用数学归纳法(induction)来验证：\n\nClaim: $T(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$.\nBase case: $k = 0$，$T(1) = 1 + 0 * b + 0 * 1 * a = 1$ is meet the claim.\nStep case: Assume that the claim is true at k, and we need to prove that $T(k + 1)$ is true.\n$$\n\\begin{aligned} \nT(2^{k+1}) & = 2\\ T(2^k) + b + 2^{k+1}a \\\\\n & = 2 (2^k + (2^k - 1)b + k\\ 2^ka) + b + 2^{k + 1}a \\\\\n & = 2^{k+1} + (2^{k+1} - 2)b + b + k\\ 2^{k+1}a + 2^{k + 1}a \\\\\n & = 2^{k+1} + (2^{k+1} - 1)b + (k + 1)\\ 2^{k+1}a\n\\end{aligned} $$\n$Q.E.D.$\n\n我们假设 $T'(n) = n + (n - 1)b + an\\log(n), \\text{for } n = 2^k, k\\in \\mathbb{N}$。\n我们可以证明出 $T(n)$ 是 $\\Theta(T'(n))$。\n因此，$T(n)$ 是 $\\Theta(n\\log n)$。\n\n:::\n\n---\n\n## Master定理 (Master Theorem)\n\n考虑存在下面的递归关系：\n$$\n\\begin{aligned}\nT(n) & = a\\ T(\\frac{n}{b}) + f(n) \\\\\nT(1) & = 1\n\\end{aligned}\n$$\n这是一个由分而治之设计的算法：分解成 $a$ 个子集，每个子集的大小是 $\\frac{n}{b}$，此外每个递归/循环有一些额外的操作 $f(n)$。\n\n[Master定理(Master Theorem)](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))是一个根据 $a, b$ 的数值以及对 $f(n)$ 进行放缩来快速求出$T(n)$的Big-Oh家族的方法。\n\n下面就对 $f(n), a, b$ 不同情况进行讨论。\n\n*注意，本笔记中不形式证明Master定理，具体可以自行查阅。*\n\n### > $f(n) = 0$ 时\n此时 $T(n) = aT(\\frac{n}{b})$，我们可以使用数学归纳法证明出 $T(b^k) = a^k$。\n\n我们令$n = b^k$，根据数学公式我们可以推导出 $a^k = (b^k)^{\\log_ba}$，因此我们可以得到\n$$T(n) = n^{\\log_ba}$$\n\n因此我们可以知道 $T(n)$ 是 $\\Theta(n^{\\log_ba})$。\n\n### > $f(n) \\neq 0$ 时\n此时可以分为三种情况：\n\n|$f(n)$ 的形式|$c$ 与 $\\log_ba$ 的关系|$T(n)$的Big-Theta|描述|\n|-------------|----------------------|-----------------|----|\n|$f(n)$ 是 $O(n^c)$|$c < \\log_ba$|$\\Theta(n^{\\log_ba})$|$f(n)$ 的 增长率非常小，此时忽略 $f(n)$|\n|$f(n)$ 是 $\\Theta(n^c(\\log n)^k), k \\geq 0$|$c = \\log_ba$|$\\Theta(n^c(\\log n)^{k+1})$|$f(n)$ 的 增长率适中，此时混合使用$a, b, f(n)$|\n|$f(n)$ 是 $\\Omega(n^c)$, 并满足正则条件|$c > log_ba$|$\\Theta(f(n))$|$f(n)$ 的 增长率非常大，此时只考虑 $f(n)$|\n\n情况三中需要满足正则条件(Regularity Condition)：\n$$\\exists k < 1 : a f(\\frac{n}{b}) \\leq k f(n)$$\n\n*该条件保证了这个条件确保 $f(n)$ 不会增长过快导致 $T(n)$ 完全被非递归部分主导。*\n\n注意$f(n)$ 的形式以及$c$ 与 $\\log_ba$ 的关系。\n\n- 情况一中可知，$f(n)$的渐进上边界都不如 $n^{\\log_ba}$，那么$f(n)$ 的增长率是可以被忽略的。\n- 情况二中可知，$f(n)$的增长率是与 $n^{\\log_ba}$ 持平的，因此应该要混合使用$a, b, f(n)$。\n- 情况三中可知，$f(n)$的渐进下边界都超过了 $n^{\\log_ba}$，因此只考虑 $f(n)$。\n\n---\n\n# 四. 数据结构\n## 一些定义\n- 遍历(Traversals)：指访问(visit)一个数据结构的所有元素。\n  - 每一个元素只访问一次。\n  - 访问的顺序是系统的、有序的、有意义的。\n\n- 抽象数据类型(Abstract Data Types, ADTs)：是数据结构的抽象。\n  - 组成成分：\n    - 储存的数据类型。\n    - 对数据的操作。\n    - 与操作相关的错误条件。\n  - 一般ADT的相关操作会使用Big-Oh来限制效率。\n\n- 具体数据类型(Concrete Data Types, CDTs)：是数据结构的实际。\n  - ADT的实现是通过选择不同的CDT。\n  - CDT是数据隐藏的和封装的（面向对象）。\n  - CDT的选择影响运行时间和空间使用。\n\n- 面向对象编程(Object-oriented)的原因：\n  - 区分规范(specification) 和 实施细节(implementation details)\n  - 使用相同的ADT来探索不同的CDTs。\n  - 无需更改ADT的代码来快速更改和提升CDTs。\n\n---\n\n## 单向链表(Singly Linked List) (CDT)\n### 介绍\n> A singly linked list is a concrete data structure consisting of a sequence of nodes. Each node stores an element and a pointer/reference to the next node.\n\n### 成员\n- `Node` 节点\n  - `Element` 元素\n  - `next` 指向下一个节点的指针\n- `head : Node*` 头节点指针\n- `tail : Node*` 尾节点指针 (可选)\n\n### 功能性函数\n插入类函数：\n- `void insertHead(Object)`：插入头结点\n  - 时间复杂度：$O(1)$\n- `void insertTail(Object)`：插入尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n\n删除类函数：\n- `void removeHead()`：删除头节点\n  - 时间复杂度：$O(1)$\n- `void removeTail(Object)`：删除尾节点\n  - 无论有没有记录尾节点，时间复杂度：$O(n)$\n    - 因为要让尾节点的前一个节点的`next`指针指向`NULL`\n\n交换类函数：\n- `void swapElement(Node, Node)`：交换元素而不交换节点的位置\n  - 时间复杂度 $O(1)$\n- `void swapNode(Node, Node)`：交换节点的位置（不常用）\n  - 时间复杂度 $O(n)$\n    - 因为要找到这两个`Node`的上一个`Node`来修改`next`。\n\n---\n\n## 双向链表(Doubly Linked List) (CDT)\n### 介绍\n> A doubly linked list provides a natural extension of a singly linked list.Each node stores an element and a pointer/reference to the next node and a pointer/reference to the previous node.\n\n### 成员\n- `Node` 节点\n  - `element` 元素\n  - `next` 指向下一个节点的指针\n  - `pre` 指向上一个节点的指针\n- `head : Node* | Node` 头节点指针/节点\n- `tail : Node* | Node` 尾节点指针/节点\n\n### 功能性函数\n插入类函数：\n- `void insertHead(Object)`：插入头结点\n  - 时间复杂度：$O(1)$\n- `void insertTail(Object)`：插入尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n- `void insertAfter(Node, Object)`：插入到`Node`节点后面\n  - 时间复杂度：$O(1)$\n\n删除类函数：\n- `void removeHead()`：删除头节点\n  - 时间复杂度：$O(1)$\n- `void removeTail(Object)`：删除尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n\n交换类函数：\n- `void swapElement(Node, Node)`：交换元素而不交换节点的位置（不常用）\n  - 时间复杂度 $O(1)$\n- `void swapNode(Node, Node)`：交换节点的位置（建议）\n  - 时间复杂度 $O(1)$\n\n### 补充\n- 有两种双向链表设计方式\n  - 让`head`和`tail`指向实实在在的节点。如果链表为空，则`head = NULL, tail = NULL`。\n  - 分配`head`和`tail`为新的节点，节点的元素为空。如果链表为空，则`head.next == tail`。\n\n### 数据结构的思考\n相比于数组 `Array`，链表数据结构具有较快的插入和删除能力。但是，链表具有较差的查询能力，其查询能力的时间复杂度是 $O(n)$。\n\n一般具有较快的插入、删除和查询能力的数据结构都比较复杂，例如：\n- 跳表 (Skip List)：其三个操作的时间复杂度都是 $O(\\log n)$。\n- 平衡树(Balanced Trees)：其三个操作的时间复杂度都是 $O(\\log n)$。\n  - 红黑树(Red-Black Tree)\n  - AVL树(AVL Tree)\n- 哈希表(Hash Table)：其三个操作的平均时间复杂度都是 $O(1)$，最差情况下时间复杂度是 $O(n)$。\n\n---\n\n## 向量(Vector) (ADT)\n### 介绍\n向量(Vector)是一种抽象数据类型(ADT)。向量的主要目的是创建一个比数组(Array)更泛用的模型。\n\n其主要的特性是：\n- 一个元素在向量中的索引(index)被认为是前面元素的个数(number of elements prceding it)。\n  - 为了不完全依赖于数组，因此我们不使用“索引(index)”概念，而使用“前面元素的个数”概念。\n  - 例如对于一个向量 $A$ 来说，$A[2]$ 表示有 $2$ 个元素在它的前面，分别是 $A[0], A[1]$。\n  - 这个概念也可以被称为**排名(rank)**。\n- 与数组固定大小不同，向量一个自动调节大小的数据结构。\n\n### 向量ADT主要操作(operator)/方法\n- `Object elemAtRank(int r)`：返回 `rank` 为 `r` 的元素。\n- `Object replaceAtRank(int r, Object o)`：替换掉 `rank` 为 `r` 的元素为 `o`，并返回原来的元素。\n- `void insertAtRank(int r, Object o)`：在 `rank` 为 `r` 的位置插入新的元素 `o`。\n- `Object removeAtRank(int r)`：删除 `rank` 为 `r` 位置的元素。\n- `int size()`：返回向量大小。\n- `boolean isEmpty()`：返回向量是否为空。\n\n### 使用向量作为栈(Stack)\n栈(Stack)是一个先入后出(first in last out, FILO)的数据结构，其操作主要是：\n- `Object top()`：返回栈顶。\n  - 相当于 `elemAtRank(size())`。\n- `void push(Object o)`：在最后的元素(栈顶)后面添加一个新的元素。\n  - 相当于 `insertAtRank(size(), Object o)`。\n- `void pop()`：删除最后的元素(栈顶)。\n  - 相当于 `removeAtRank(size())`。\n\n### 基于数组的向量(Array-based Vector) (CDT)\n是使用一个大小为`N`的数组`V`作为向量的CDT，并使用整型变量`n`记录向量的大小。\n\n#### >操作/方法时间复杂度分析\n- `elemAtRank(r)`：可以直接返回`V[r]`，因此其时间复杂度是 $O(1)$。\n- `replaceAtRank(r, o)`：时间复杂度是 $O(1)$。\n- `insertAtRank(r, o)`：需要对原来的元素进行右平移，在最坏的情况下(即 $r = 0$ )时间复杂度是 $O(n)$。\n- `removeAtRank(r, o)`：需要对原来的元素进行左平移，在最坏的情况下(即 $r = 0$ )时间复杂度是 $O(n)$。\n- `size()`：直接返回变量 `n`，因此时间复杂度是 $O(1)$。\n- `isEmpty()`：直接返回 `n == 0`，因此时间复杂度是 $O(1)$。\n- `push(o)`：不需要进行平移。\n  - 如果**不需要扩大数组**时间复杂度是 $O(1)$。\n  - **扩大数组**需要平摊时间(amortized time)获取时间复杂度。具体可以看下面扩大数组中不同策略。\n- `pop()`：不需要进行平移，因此时间复杂度是 $O(1)$。\n\n平摊时间(amortized time)是从**一组**操作中每个操作平摊下来的时间。与平均时间(average time)不同，后者主要是针对**一次**操作的平均时间。\n\n#### >扩大数组(Resize Array)\n在`insertAtRank(r, o)` 和 `push(o)` 操作中，如果数组已经满了，那么需要替换数组为更大的数组。\n\n替换数组需要复制原来的数据到新的数据中。假设当前数组的大小为 $c$，每次替换所使用的时间为 $s_2$，那么这个过程需要的时间$T(c) = s_2c$，即这个过程的时间复杂度是 $O(c)$。\n\n扩大数组的方法一共有两种：\n- 增量策略(incremental strategy)：使用固定的常数 `c` 来进行扩大数组。\n  - 假设执行`push`的次数为 $n$，那么替换数组的次数一共为 $k = floor(n / c)$ 次。\n  - 假设$T(n)$是执行`push` $n$ 次所需要的运行时间，$s_1$是一次`push`所需要的时间，$s_2$是一次替换数组所需要的时间。\n    - $s_1$ 和 $s_2$ 都是常数。\n    - $T(n) = s_1n + s_2(c + 2c + ... + kc) = s_1n + s_2c\\frac{k(k+1)}{2}$，因此 $T(n)$ 是 $O(n^2)$。\n  - 平摊下来每次 `push` 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(n)$。这个是要比一般 `push` 操作所需要的时间复杂度 $O(1)$ 是要差的。\n\n- 双倍策略(doubling strategy)：双倍数组的大小。\n  - 假设执行`push`的次数为 $n$，那么替换数组的次数一共为 $k = floor(\\log n)$ 次。\n  - 假设$T(n)$是执行`push` $n$ 次所需要的运行时间，$s_1$是一次`push`所需要的时间，$s_2$是一次替换数组所需要的时间。\n    - $s_1$ 和 $s_2$ 都是常数。\n    - $T(n) = s_1n + s_2(1 + 2 + 4 + ... + 2^{k - 1}) = (s_1 + s_2)n - s_2$，因此 $T(n)$ 是 $O(n)$。\n  - 平摊下来每次 `push` 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(1)$。\n\n---\n\n## 树(Tree) (ADT)\n### 介绍\n树是一种抽象数据结构(ADT)。\n\n> In computer science, a tree is an abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.\n\n### 成员\n- `Node` 节点\n  - `element`  元素\n  - `parent` 父节点\n  - `children[]` 子节点\n- `root : Node*` 根节点：不具有父节点的节点。\n- `internal : Node` 内节点：具有至少一个子节点的节点。\n- `leaf / external : Node` 叶节点/外节点：不具有子节点的节点。\n- `ancestors : Node → Node[]` 祖先节点：(递归定义) 一个节点其父节点和其父节点的祖先节点的数组/集合。\n- `descendant : Node → Node[]` 祖孙节点：(递归定义) 一个节点其所有子节点和所有子节点的祖孙节点的数组/集合。\n- `depth : Node → Int` 节点的深度：该节点的祖先节点的个数(不包括自己)。\n  - 根节点的深度为0，根节点的子节点深度为1，以此类推。\n- `height : Tree → Int` 树的高度：最大的叶节点深度。或者说从根节点到叶节点最长的路径(不包括根节点)。\n  - 只有根节点的树的深度为0。\n\n### 树ADT主要操作/方法：\n#### > 基础方法 (Generic)：\n- `int size()`：返回树的大小。\n- `bool isEmpty()`：返回树是否为空。\n- `Iterator iterator()`：返回树的遍历所有元素的迭代器。\n- `Iterator positions()`：返回树的以一定顺序遍历位置的迭代器。\n#### > 接入方法 (Accessor)：\n- `Node root()`：返回树的根节点。\n- `Node parent(Node)`：返回节点的父节点。\n- `Iterator children(Node)`：返回节点的子节点迭代器。\n#### > 查询方法 (Query)：\n- `bool isInternal(Node)`：是否是内部节点。\n- `bool isExternal(Node)`：是否是叶节点。\n- `bool isRoot(Node)`：是否是根节点。\n\n### 树的遍历 (Traversals)\n#### > 前序遍历 Preorder Traversal \n先遍历父节点，再从左到右遍历其子节点。\n\n```\nAlgorithm preOrder(v)\n  visit(v)\n  for each child w of v\n    preorder(w)\n```\n\n#### > 后序遍历 Postorder Traversal\n先遍历子节点，再遍历父节点\n\n```\nAlgorithm postOrde(v)\n  for each child w of v\n    postOrder(w)\n  visit(v)\n```\n\n---\n\n## 二叉树(Binary Tree) (ADT)\n### 定义\n二叉树是一种抽象数据结构(ADT)。\n\n- 一般定义：\n>  a tree whose each internal node has at most two children, and the children of a node are an ordered pair, though one might be “missing”.\n\n- 递归定义：\n> A tree consisting of a single node, or a tree whose root has an  ordered pair of “children”, each  of which is missing (a null) or is  the root of a binary tree\n\n- 特点：\n  - 每个节点最多有两个子节点\n  - 节点之间是有序的，即左子节点和右子节点，尽管有一个是空节点。\n\n### 性质\n#### > 合适/完满二叉树 (proper/full binary tree)\n> A binary tree is said to be “proper” (a.k.a. “full”) if every internal node has exactly 2 children.\n如果二叉树的所有内部节点都具有两个子节点，那么称这个二叉树是合适/完满二叉树。\n\n#### > 完美二叉树 (perfect binary tree)\n> A binary tree is perfect if it is proper and all leaves are at the same depth.\n如果一个满二叉树中所有的子节点都在同一个深度，那么称这个二叉树是完美二叉树。\n\n- 在深度 $d$ 拥有的节点的个数为 $2^d$\n- 在深度 $d$ 及其以下的深度总结点个数为 $2^{(d+1)}-1$\n- 高度为 $h$ 的树总节点为 $n$，那么有 $h = \\log_{2}(n+1) - 1$，$n = 2^{(h + 1)} - 1$\n\n#### > 完全二叉树 (complete binary tree)\n> 除了叶节点所处的深度以外，其他深度是一个完美二叉树，并且叶节点是靠右排序的二叉树是完全二叉树。\n\n### 二叉树的遍历 (Traversals)\n除了树通用的前序遍历和后序遍历以外，还有一个中序遍历(Inorder Traversal)：\n\n先遍历左子节点，再遍历该节点，最后遍历子节点。\n\n```\nAlgorithm inOrder(v)\n  if hasLeft(v)\n    inOrder(v.left)\n  visit(v)\n  if hasRight(v)\n    inOrder(v.right)\n```\n\n### 二叉树的效率分析\n- 求树的高度：如果树的大小为 $n$，那么：\n  - 对于完美二叉树来说，时间复杂度是 $\\Theta(\\log(n))$。\n  - 对于非完美二叉树来说，考虑到一条链，时间复杂度是 $\\Omega(\\log(n))$ 和 $O(n)$。\n\n### 基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)\n它也可以被称为 **树形数组(tree-as-array)**。它是一种使用数组作为CDT实现二叉树ADT的方式。\n\n一般使用 `int rank(Node)` 来表示节点的数组索引。注意，它返回的是**整型**。\n- `rank(root) = 1`：根节点的索引是 $1$。\n- `rank(parent(node)) = rank(node) >> 1`：每个节点的父节点是该节点的索引除以 $2$。\n- `rank(left_child(node)) = rank(node) << 1`：每个节点的左节点是该节点的索引乘以 $2$。\n- `rank(right_child(node)) = rank(node) << 1 + 1`：每个节点的右节点是该节点的索引乘以 $2$ 加 $1$。\n\n树形数组的优点：\n- 能够节省空间。因为不用储存相关的指针，而是使用计算代替。\n- 储存能够更紧凑，具有更好的内存局部性\"better memory locality\"。\n- 很好地解决缓存和内存层次结构的问题——当访问数组元素时，其他条目可以被拉入缓存，因此访问速度更快。\n\n---\n\n## 优先队列(Priority Queue) (ADT)\n### 介绍\n优先队列是一个抽象数据结构(ADT)。优先队列是储存一组具有 `(key, value)` 的数据结构，并能够有效地返回和操作其中具有最小/最大 `key` 的元素。\n\n一般我们默认优先队列是**最小优先队列(Min-Priority Queue)**，也就是返回/操作拥有最小`key`的元素。\n\n### 优先队列ADT主要操作/方法：\n- `void insert(k, v)`：插入一组`(k, v)`的元素。\n- `Element removeMin()`：删除并返回具有最小`key`的元素。\n- `Element min()`：返回具有最小`key`的元素。\n- `int size()`：返回元素个数。\n- `bool isEmpty()`：优先队列返回是否为空。\n\n### 基于二叉堆(Binary Heap)的优先队列 (CDT)\n本笔记中默认的二叉堆是 **小根堆**。\n\n>  A binary heap is a complete binary tree storing key-value pairs at its nodes.\n二叉堆是将 `(key, value)` 对储存在节点的完全二叉树。\n\n*除了二叉堆以外，还有二项式堆(Binomial Heap)和斐波那契堆(Fibonacci Heap)。*\n\n二叉堆具有以下的性质：\n- Heap-Order：对于每一个除了根以外的节点，都有 `key(v) >= key(parent(v))`。\n  - 即子节点的值不会比父节点更小。\n  - 那么堆顶，即二叉堆的根节点是所有节点中的最小值。\n- Complete Binary Tree：是一个二叉树。因此如果一共有 $n$ 个节点，则树的高度为 $h = \\log n$。\n\n#### 堆的插入(insert)\n步骤如下：\n1. 根据完全二叉树性质寻找插入点 $Z$ 作为叶节点。\n2. 储存 $key$ 值给点 $Z$。\n3. 恢复堆序属性(`unheap`操作)：将插入点 $Z$ 从下到上进行 **冒泡**，如果父节点的 `key` 值比 $Z$ 大，那么就交换两个节点的位置或元素，直到父节点的 `key` 值比 $Z$ 小或者已经到达根节点。\n\n关于 $1$，如果使用结构体模拟树的结构，那么时间复杂度可能会达到 $O(n)$。但是如果使用数组作为CDT模拟二叉树(具体可看上方二叉树中基于数组的二叉树，树形数组)，那么只需要在数组的末尾插入新的节点即可，此时的时间复杂度是 $O(1)$。\n关于 $3$，因为二叉树的高度是 $h = \\log n$，因此 `upheap` 操作的时间复杂度是 $O(\\log n)$。\n\n#### 堆的删除(remove / pop)\n堆的删除指的是删除堆顶。步骤如下：\n1. 使用最后一个节点 $w$ 代替根节点。\n2. 删除 $w$ 原节点。\n3. 恢复堆属性(`Downheap`操作)：选择两个子节点中**最小**的子节点，如果该子节点的`key`值比 $w$ 节点的小，那么就交换两个节点的位置或元素，直到所有子节点的 `key` 值比 $w$ 大或者已经达到叶节点。\n\n---\n\n## 映射(Maps) (ADT)\n### 介绍\n> A map models a collection of `(key, value)` entries that is searchable by the `key`.\n\n性质：\n- 具有搜索、插入、删除元素的功能。\n- 具有相同 `key` 值的元素是不被允许的。\n\n### 映射ADT主要操作/方法：\n- `Value get(Key k)`：如果存在`key`相应的元素，则通过 `key` 获取相应的 `value`，否则返回 `NULL`。\n- `Value put(Key k, Value v)`：插入 `(key, value)` 对。如果已经存在 `key` 在映射里则返回 `NULL`，否则返回 `value`值。\n- `Value remove(Key k)`：如果存在`key`相应的元素，则通过 `key` 来删除并返回该元素的 `value`，否则返回 `NULL`。\n- `int size()`：返回元素个数。\n- `bool isEmpty()`：返回是否为空。\n- `Iterator keys()`：返回 `key` 的迭代器。\n- `Iterator values()`：返回 `value` 的迭代器。\n- `Iteraotr entries()`：返回 `(key, value)` 的迭代器。\n\n### 基于简单链表的MAP (CDT)\n- `get(k)`：遍历链表来寻找 `key`。时间复杂度是 $O(n)$。\n- `put(k, v)`：遍历链表来寻找是否有重复的 `key`，如果没有则插入到链表中。时间复杂度是 $O(n)$。\n- `remove(k, v)`：遍历链表来寻找 `key`。时间复杂度是 $O(n)$。\n\n因为链表的特性（具有较差的访问能力），因此无论是排序的链表还是未排序的链表（链表无法使用二分查找法），时间复杂度操作都是 $O(n)$。\n\n### 基于哈希表的MAP (CDT)\n基本思想：将每个 `key` 转化成 `index` 放入一个较大的数组 `Array` 中。\n\n哈希表的特性：\n- 哈希值 (hash value)：由哈希函数得到的值被称为哈希值。\n- 哈希码 $h_1$ (hash code)：是一个键值转一个整型的函数，即`keys → integers`。一些可能的方法：\n  - 将 `key` 的内存地址作为哈希码。\n  - 将 `key` 的 `bit` 值转化成整型作为哈希码。一般用于内存不大于整型的数据类型，例如`byte, short, int, float`。\n  - 将 `key` 的 `bit` 值划分成相同长度的部分，对这些部分求和(忽略溢出)。适用于内存大于整型的数据类型，例如 `double, long`。\n  - 多项式累积方法。\n- 压缩函数 $h_2$ (Compression function)：是一个将整型压缩到一定范围的函数，即`integers → [0, N-1]`。一些可能的方法：\n  - 除法(Division)：$h_2(x) = x \\mod N$。\n    - $N$ 通常是一个素数。\n  - 乘加除法(Multiply, Add and Divide (MAD))：$h_2(x) = (ax + b) \\mod N$。\n    - $a, b$ 是非负整数。\n    - $a \\mod N \\neq 0$，否则无论 $x$ 为多少总会映射到 $b$。\n- 哈希函数 $h$ (hash function)：是一个将对象(Object)映射到一个固定的范围 $[0, N-1]$ 整型的函数。\n  - 此时有 $h(x) = h_2(h_1(x))$。\n  - 哈希函数的主要目的是使用明显**随机**的方式来将 `keys` **分散**。\n  - 分散的目的是为了减少冲突(Collision)。\n  - 随机的目的是为了减少模式(Pattern)，从而减少冲突。\n- 冲突 (Collision)：当不同的元素获取到相同的索引时，会发生冲突。一些可能的解决方法：\n  - 分离链(Separate Chaining)：让相同 `index` 的元素以链表的形式连接起来。\n  - 二叉搜索树(Binary Search Tree)。\n  - 开放地址(Open addressing)：让冲突的新元素放入到下一个可用的数组中。一些可能的方法：\n    - 线性探索(Linear probing)：使用一个常数 $c$ 来进行冲突元素的新元素寻址，即$h(k) + c$。\n      - 一般使用循环数组作为哈希表。\n      - 可能会导致未来新元素使用更长的时间来寻址。\n      - 如果数组满了可能会导致死循环，因此要规定最多循环次数。\n      - 如果中间有冲突的数组被删除，可能会导致后面冲突的数组查询失败。\n        - 一个删除的解决方案是不断检测右边是否具有相同的哈希值，如果相同则将该数值重新插入。\n        - Lazy deletion延迟删除：将被删除的数值标记为“删除”，只当用到它的时候再进行修复。当被查询到“删除”标记的点时直接跳过而不是停止。\n    - 双哈希(Double Hashing)：使用一个额外的哈希函数 $d(k)$ 来辅助寻找新元素。\n      - 新的哈希值为 $(h(k) + j\\ d(k))\\mod N, j\\in[0, N-1]$，选择第一个空元素作为哈希值。一些可能的 $h(k)$：\n        - $d(k) = q - (k \\mod q)$，其中 $q < N$ 且 $q$ 是素数。\n      - 对于线性探索来说，$d(k) = 1$。\n      - $N$ 必须是素数，以探索所有的可能数组包。\n\n那么使用哈希表来实现`Map`主要的思路是：\n- 寻找哈希函数：将 $(k,v)$ 储存在 $i = h(k)$ 索引的数组中。\n- 处理冲突。\n\n#### 基于分离链(Separate Chaining)处理冲突的方法\n因为分离链定义让相同 `index` 的元素以链表的形式连接起来，其中链表中每个节点还有一个单独的 `key` 值用于寻找具体的元素。\n\n那么链表的每个节点应该具有以下的操作，假设有 $m$ 个冲突的元素：\n- `Element get(k)`：获取`key = k`的元素。其时间复杂度是 $O(m)$。\n- `Element put(k, v)`：放入`(k, v)`对的元素，需要检测是否有相同 `key` 的元素，如果有则返回`null`。因此时间复杂度是 $O(m)$。\n- `Element remove(k)`：删除`key = k`的元素。其时间复杂度是 $O(m)$。\n\n那么使用基于分离链哈希表的`map`具体实现方式如下：\n- `get(k)`：`return A[h(k)].get(k)`。\n- `put(k, v)`：`return A[h(k)].put(k)`。注意要让 `size++`。\n- `remove(k)`: `return A[h(k)].remove(k)`。注意要让 `size--`。\n\n对于每个操作，最佳访问时间是 $O(1)$，最差访问时间依然是 $O(n)$，即全部都有冲突。但是平均下来，其时间复杂度应该是 $O(n / N)$，其中 $N$ 是哈希表数组的容量。\n\n#### 哈希函数的性能分析\n在最坏的情况下，搜索、插入和删除的时间复杂度都是 $O(n)$。\n\n一般用负载因子(load factor) $\\alpha = n / N$ 来表示哈希表的性能。\n\n哈希表各个操作的期望值基本上都是 $O(1)$。具体证明可自行查阅。\n\n---\n## 二叉搜索树(Binary Search Tree) (ADT)\n> A binary search tree is a binary tree storing `(key,value)` entries at its internal nodes and satisfying the following “search tree” property.\n二叉搜索树是一个储存`(key,value)`值到节点的二叉树，并满足下面的性质：\n\n性质：\n- 对于任意一个内部节点 $v$，拥有左子节点 $u$ 和 右子节点 $w$，满足 `key(u) <= key(v) <= key(w)`。\n- 对于任意一个节点 $v$，其左边子辈的值都比 $v$ 小，右边子辈的值都比 $v$ 大。\n- 换句话说，二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据`key`升序的。\n\n### 二叉搜索树ADT主要操作/方法\n- `Node search(Key k)`：返回`key = k`的节点，如果没有则返回`null`。\n  - 实现：比较当前节点储存的`key` 与 `k` 相比较，如果等于则返回。如果`k`大则查找右节点，如果`k`小则查找左节点。如果不存在节点，则返回`null`。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n  - 如果是平衡二叉树，则时间复杂度是 $O(\\log n)$。\n- `void insert(Key k, Value v)`：插入 `(k, v)` 对。\n  - 实现：使用二分法找到要插入的位置，将其插入进去。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n- `Node remove(Key k)`：删除 `key = k` 的节点。\n  - 实现：使用二分查找找到要删除的节点删除，分为下面四个情况：\n    - 没有找到该节点，此时返回 `null`。\n    - 该节点是叶节点，此时删除该节点。\n    - 节点具有一个子节点，将该子节点替换到原来的位置。\n    - 节点具有两个子节点，此时根据树的中序遍历找到当前`key`的下一个`key`节点 $w$ ($w$ 称为该节点的中序后继)，并使用这个节点 $w$ 替代该节点，再尝试删除 $w$，直到不符合被删除的节点具有两个子节点为止。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n\n### 平衡二叉树(Balanced Trees)\n平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。\n平衡二叉树的高度 $h = \\log n$。\n\n一般使用旋转(notation)的方法来让二叉搜索树逐步变成平衡二叉树。\n\n#### 一次旋转 (Single Rotation)\n一次旋转适合三个高度节点之间呈类似于 `\\` 和 `/` 的直线形。也就是中间高度的节点是中间值的情况。\n\n过程如下：\n- 选择一个节点 $P$。\n- 选择该节点的一个子节点 $C$。\n- 交换两个节点：\n  - 选择 $C$ 中相反方向的子节点 $V$：如果 $C$ 是 $P$ 的左节点，那么就选择 $C$ 的右节点。否则选择左节点。\n  - 处理 $P$ 的父节点：\n    - 将 $P$ 的父节点相应方向的子节点修改为 $C$。\n    - 将 $C$ 的父节点修改为 $P$ 的父节点。\n    - 如果 $P$ 为根节点，那么修改根节点为 $C$。\n  - 处理 $C$ 的子节点 $V$：\n    - 将 $V$ 的父节点修改为 $P$。\n    - 将 $P$ 原来方向上的子节点 $C$ 的位置修改为 $V$。\n  - 处理 $C$ 和 $P$：\n    - 将 $C$ 原来 $V$ 位置的子节点修改为 $P$。\n    - 将 $P$ 的父节点修改为 $C$。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png\" alt=\"平衡二叉树旋转\" width=\"650\">\n\n整个过程时间复杂度是 $O(1)$。\n\n#### 二次旋转 (Double Rotation)\n\n诸如下图中的类似 `>`和`<` 形，是无法使用一次旋转的，如果只旋转`a` 和 `c` 将无法改变高度。\n\n此时需要先将`>`或`<`形旋转成`/`或`\\`形，再进行一次旋转。整个过程被称为二次旋转，如下图。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png\" alt=\"平衡二叉树二次旋转\" width=\"650\">\n\n具体的其他二叉树方法将（例如AVL树、红黑树）不在本笔记中展示。可能会未来在其他笔记中展示。\n\n#### \n\n---\n\n# 五. 算法\n\n算法的设计思路通常有这么几种：\n- 暴力搜索(Brute Force)：生成所有潜在解决方案并测试哪些是实际解决方案。时间复杂通常非常高，是属于多项式级其以上的时间复杂度。\n- 分而治之(Divide and Conquer)：递归地将问题分解成更小的部分并逐步解决它们，然后将它们重新组合在一起。是一种比较高效的设计思路。\n- 启发式(Heuristics)：是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n- 动态规划(DP)：DP是一种适用于最优解满足“分解性质”情况的通用方法。\n\n---\n\n## 排序算法(Sorting algorithms)\n排序算法的性质：\n- 排序稳定性(Stability)：如果两个元素键值相等，排序算法会保留这两个元素的相对位置。\n- 排序自适应性(Adaptive)：如果数组已经接近已排序，那么算法的效率会提高。\n- 排序接入模式(Access Patterns)\n  - Sequential Access：数据的读取和写入是按照其在存储器中存放的顺序进行的。\n  - Random Access：数据储存中能够在常数时间 $O(1)$ 内直接访问任意位置的数据。\n- 是否需要额外空间。\n\n如果没有特殊说明，以下算法都默认**从小到大排序/升序**、使用 **数组(array)** 作为数据结构。\n\n### 基于比较的排序算法的一些思考\n如果一个排序算法仅包含关于成对比较元素的信息，那么就称这个排序是**基于比较**的(comparison-based)。\n\n并不是所有的排序算法都是基于比较的，例如桶排序(bucket sort)是使用实际的值来进行排序的，其时间复杂度是$O(n)$，但是其实现依赖于其值的范围。是一种使用空间换取时间的方法。\n\n对于 $n$ 个数的数组来说，它一共拥有 $n!$ 种排序方法。我们使用基于比较的算法来对数组进行排序是通过两两比较来减半它排序方法的可能性。也就是说，基于比较的排序算法本质其实是逐步将 $n!$ 减半成 $1$。\n\n这意味着我们需要去做 $\\log_2(n!)$ 次比较。实际上 $O(\\log(n!)) = O(n \\log n)$。也就是说基于比较的算法不能比 $O(n \\log n)$ 更优。\n\n---\n\n### 1. 冒泡排序(Bubble sort)\n#### 基本思想\n让大的元素逐渐往后移动。\n- 外部循环(Outer loop)：扫描整个数组。\n- 内部循环(Inner loop)：对于数组每个元素与右边邻域对比，如果右边邻域更小则立即交换。\n\n#### 算法思考\n因为算法中最大元素像水泡一样逐渐向上冒，因此被称为冒泡排序。\n\n#### 复杂性分析\n考虑到最差的情况，也就是每次循环都会进行交换。外部循环次数为$(n - 1)$，假设当前外部循环$index = i$，那么内部循环次数为 $(n - i - 1)$，因此总循环次数为 $\\frac{n(n - 1)}{2}$。\n\n假设比较和交换原始操作数为 $t$ 为常数，循环以外的原始操作数为 $k$ 为常数，那么总原始操作数为 $\\frac{n(n - 1)}{2} + t(n - 1) + k$。\n\n根据删除规则，我们可以知道它的时间复杂度是 $O(n^2)$。\n\n此外，也可以使用递归关系来证明冒泡排序的时间复杂度：\n\n:::details 使用递归关系证明冒泡排序的时间复杂度\n\n首先冒泡排序并不是天然递归的，而是一个双重循环。\n\n但是我们能使用递归思想来将冒泡排序改成递归：如果要将长度为 $n$ 的数组进行排序，首先将这个数组中的最大数值通过冒泡操作交换到当前数组最右边的位置并固定，随后再将剩下 $n - 1$ 的数组进行排序(递归)。\n\n这样就写出其运行时间的递推公式：\n$$\n\\begin{aligned} \nT(n) & = dn + T(n - 1) \\\\\nT(1) & = 1\n\\end{aligned}\n$$\n- $dn$ 表示通过冒泡操作交换所需要的时间。\n- $T(n - 1)$ 表示剩余数组排序所需要的时间。\n\n我们可以根据等差数列求出 $T(n)$ 的通项公式为：\n$$T(n) = 1 + (\\frac{n(n+1)}{2} - 1) d$$\n\n那么很明显 $T(n)$ 是 $\\Theta(n^2)$。\n\n:::\n\n#### 算法的性质。\n- 如果相同的元素不进行交换，那么该算法 **具有** 稳定性。\n- 可以通过添加变量来让算法 **具有** 自适应性（内部循环没有进行任何交换）。\n- 不需要额外的空间。\n- 可适用于单向链表的`swapElement(Node, Node)`，时间复杂度不变。\n\n---\n\n### 2. 选择排序(Selection sort)\n#### 基本思想\n保持数组后面的元素不变作为**已排序**的元素，前面的元素作为**未排序**的元素，选择**未排序**的元素组中最大的元素插入到**已排序**元素组的头部。\n- 外部循环：扫描整个数组。\n- 内部循环：扫描整个**未排序部分**的数组。并不会让最大的元素立即交换，而是记录住最大元素的位置。等内部循环扫描完，将被记录的元素：\n  - 插入到**已排序部分**的数组的最左边。或者：\n  - 与**未排序部分**的数组最右边的元素交换并将其加入到**已排序部分**数组。\n\n#### 算法思考\n与冒泡排序不同，冒泡排序是比较当前元素和其邻域，而该排序是比较当前元素和被记录的元素。\n为什么要延迟交换而不是立即交换：\n- 如果交换操作可能会比较昂贵，并不像数组一样是$O(1)$，那么就需要尽可能减少交换次数。\n- 如果数组非常大，那么需要尽可能地减少交换次数来提高效率。\n\n#### 复杂度分析\n相比于冒泡排序，它们具有相同数量的迭代和比较，仅仅是有更少数量的交换。\n\n因此它的时间复杂度也是$O(n^2)$。\n\n#### 算法的性质。\n- 该算法 **不具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 不需要额外的空间。\n- 可适用于单向链表的`swapElement(Node, Node)`，时间复杂度不变。\n\n---\n\n### 3. 插入排序(Insertion sort)\n保持数组前面元素的排序不变作为**已经排序**的元素，后面的元素作为**未排序**的元素。选择当前**未排序**元素不断交换左边比该元素大的元素，并将其加入到**已经排序**的元素。\n- 外部循环：扫描整个数组。\n- 内部循环：获取并记录当前**未排序**元素的最左边元素，从右到左扫描**已经排序**的元素，如果被扫描的元素比记录的元素大，那么就交换，直到被扫描的元素比记录的元素小。\n\n#### 复杂度分析\n- 在最坏的情况下，它的外部原始操作数是 $O(n)$，内部原始操作数是 $O(n)$，因此它的总时间复杂度是$O(n * n) = O(n^2)$。\n- 在最佳的情况下，它内部循环操作数是 $O(1)$，那么它的总时间复杂程度是 $O(n * 1) = O(n)$。\n\n#### 算法的性质\n- 如果相同的元素不进行交换，那么该算法 **具有** 稳定性。\n- 该算法 **具有** 自适应性。\n- 不需要额外的空间。\n- 不适用于单向链表。适用于双向链表。\n\n--- \n\n### 4. 归并排序(Merge sort)\n归并排序是一个基于分而治之(divide-and-conquer)的算法，它是先划分再排序。\n- 分解 (Divide)：将待排序的数组 $S$ 分解为两个部分 $S_1$, $S_2$。\n  - 分解直到只剩下单个元素或者空元素为止。因为单个元素的数组一定是已经排序好的数组。\n  - 分解只是简单的数学运算，因此时间复杂度是 $O(1)$。\n- 递归 (Recur)：递归地将 $S_1$ 和 $S_2$ 进行排序(带入到分而治之中)。\n  - 递归分解，回归组合。\n  - 递归全部子集的时间复杂度是 $O(\\log(n))$。\n- 组合 (Conquer)：将已排序的 $S_1$ 和 $S_2$ 合并(merge)。\n  - merge是基于两个已经排序好的数组进行的：依次判断两个数组当前第一个数(最小的数)，选择最小的一个放入到新的数组后面，直到有一个数组为空后，将另一个数组剩余的元素依次放入到新的数组后面。\n  - 假设放入的操作时间复杂度是$O(1)$，那么合并的时间复杂度是 $O(n)$。\n\n归并排序递归调用的过程是一个二叉树结构。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png\" alt=\"归并排序\" width=\"450\">\n\n#### 复杂度分析\n综上所述，归并排序的时间复杂度是 $O(n\\log{n})$。\n此外可以使用递归关系来证明归并排序的时间复杂度，详细请见 **三.Master定理** 中 **递归关系** 中的样例。\n归并排序需要用到额外的空间，因此其空间复杂度是 $O(n)$。\n*也可以使得空间复杂度是 $O(1)$，但是过于混乱一般不作考虑。*\n\n#### 算法的性质\n- 在归并遇见相等数据时，如果优先选择左边数组那么该算法 **具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 该算法 **需要** 额外的空间。\n- 该算法对数据的访问是顺序的(sequential)，因此在硬盘中具有较好的排序效率。\n- 因为依赖于快速对中间的数据进行访问，因此不太适合使用链表。\n\n---\n### 5. 快速排序(Quick Sort)\n快排是一个基于分而治之的算法，它是先排序后划分。\n- 分解 (Divide)：称之为`partition`操作。选择一个元素 $x$ 称之为枢(pivot)，并将数组 $S$ 分为：\n  - $L$：元素小于 $x$ 的。\n  - $GE$ 元素大于等于 $x$ 的。\n  - `pivot`经常是使用随机选择。\n  - 假设 交换 或者 删除再插入 的时间复杂度是$O(1)$，那么分解的时间复杂度是 $O(n)$。\n- 递归 (Recur)：对 $L$ 和 $GE$ 使用进行递归排序，带入到分而治之中。\n  - 最差的情况下，选择的枢总是最小/最大值，那么此时递归所有的子集时间复杂度是 $O(n)$。\n  - 最佳的情况下，选择的枢总是中间值，那么此时递归所有的子集时间复杂度是 $O(\\log n)$。\n- 组合 (Conquer)：将 $L$ 和 $GE$ 左右连接起来。\n  - 组合只是简单的连接，时间复杂度是 $O(1)$。\n\n快速排序递归调用的过程是一个二叉树结构。\n\n#### 快速算法的分解(Divide)实现形式\n该操作称为`partition`操作。\n- 使用额外的空间进行分解，具体思想如下：\n  1. 创建两个数组，分别表示 $L$ 和 $GE$。\n  2. 选择一个枢(pivot)。\n  3. 从左到右遍历数组，将小于枢的数加入到 $L$，将大于等于枢的数加入到 $GE$。\n\n- 使用双指针的方法进行分解，这个方法是就地(in-place)，步骤如下：\n  1. 选择一个枢(pivot)。\n  2. 定义两个指针 $j$ 和 $k$，分别初始化指向数组的开头和结尾。\n  3. 使用 $j$ 向右扫描，直到找到第一个 $\\geq$ 枢的元素 或者 $j == k$ 停止。\n  4. 使用 $k$ 向左扫描，直到找到第一个 $<$ 枢的元素 或者 $j == k$ 停止。\n  5. 交换 $j, k$ 的元素。\n  6. 如果 $j < k$，则返回 $3$。\n  7. 此时 $j == k$，并且此时 $j, k$ 的位置元素等于枢，也是 $GE$ 位置的左边界线。\n\n#### 算法的思考\n如果选择枢的方式是固定而不是随机的(例如总是选择第一个值作为枢)，并且出现了 $L$ 子集是空的情况(此时选择的枢是最小值)，那么此时会导致算法出现死循环。因为每次对 $GE$ 子集进行排序时，总是会选择最左边的值(也是最小值)作为枢，从而导致 $L$ 子集是空的情况。\n> 快速排序要避免固定选择枢和出现一方子集是空集的情况，否则可能会导致死循环。\n- 解决方法1：使用随机的方式选择枢。\n- 解决方法2：将排序分为三个部分，分别是 $L$, $\\{pivot\\}$, $E+G$。\n- 解决方法3：三点取值，选择最左边的数、中间的数和最右边的数中的中位数作为枢。\n\n#### 复杂度分析\n- 最差的情况下，快速排序的时间复杂度是 $O(n^2)$。\n- 最佳的情况下，快速排序的时间复杂度是 $O(n\\log{n})$。\n- 平均情况下，在一半的时间中快速排序选择的枢是中间值，那么时间复杂度是 $O(n\\log{n})$。\n  - 也可以认为平均情况下，选择的枢值总是让两个子集分解成 $\\frac{1}{3}$ 和 $\\frac{2}{3}$ 两个区域，也就是说递归二叉树的高度是 $\\frac{3}{2}\\log n$。\n  - *具体证明可以自行查看[维基百科](https://en.wikipedia.org/wiki/Quicksort)*。\n\n快速排序不需要用到额外的空间，因此其空间复杂度是 $O(1)$。\n\n#### 算法的性质\n- 快速排序 **不具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 该算法 **不需要** 额外的空间，是就地(in-place)的算法。\n- 该算法对数据的访问是随机的(randomized)。\n- 因为是使用 交换 或者 删除再插入 操作进行，因此可以使用双向链表。\n\n---\n\n## 启发式算法(Heuristics)\n启发式算法是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n通常有两种：\n1. 程序中的决策可以给出准确/最佳的答案，但通常是为了加快程序运行速度。\n    - 例如，A*搜索算法中使用可接受的启发式方法(Admissible heuristic)、在快速排序算法中使用随机选择的方式选择枢(pivot)。\n2. 程序中的决策可能不会给出最佳答案，但旨在给出以其他方式无法获得的良好答案。\n    - 一般用于解决一些`NP-hard`问题，例如 TSP问题、图染色问题等。\n    - 例如 遗传算法、模拟退火。\n    - 具体可以参考[AIM-优化算法](/post/笔记%2F笔记-AIM-优化算法)笔记。\n\n### 贪心算法(Greedy)\n贪心算法是一种常见的启发式算法。贪心算法是做出短期内看起来最好的决定，而不考虑未来的策略。\n\n一些贪心算法可以得到最优解，例如最小生成树(Minimal Spanning Tree, MST)中Prim算法。\n\n大部分贪心算法无法给出最优解，但是可以给出接近最优的解。\n\n#### 最小生成树问题(Minimal Spanning Tre, MST)\n问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。\n问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。\n\n##### Prim算法\n思路：\n1. 选择任意顶点 $M$。\n2. 选择对外可以连接到的所有的点中最小的那个边，并将边加入到 `MST`中，将点加入到内部的点中。\n3. 是否全部连接，如果没有则返回 $2$。通过已连接的边个数判断，即 边的个数 $e = n - 1$。\n\n算法实现：\n- $1.$ 初始化数组 `value[n] = inf`，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数`m = 0`。\n- $2.$ 随机选择一个点 $M$。\n- $3.$ 使`value[M] = 0`，并根据 $M$ 连接的所有边 $(M, V)$ 更新 `edge` 数组。即 \n```\nvalue[M] = 0              # 因为已经被连接，所以更新为0\nforall e in edge(M)\n  v = e.v                 # 获取边连接的另一个点\n  if(e.value < value[v])  # 根据边权值更新对外连接点的大小\n    value[v] = e.value \n```\n- $4.$ 找到 `value[v] != 0` 中最小的点 $V$，使 `value[V] = 0`，`m++`。\n- $5.$ 跟 $3$ 一样根据 $V$ 连接的所有边 $(V, U)$ 更新 `edge` 数组。\n- $6.$ 判断是否所有的点已经连通，即 `(m - 1) == n`，如果没有则返回 $4$。\n\n---\n\n## 动态规划(Dynamic Programming, DP)\n> DP is a general method that can be suitable when the optimal solutions satisfy a “decomposition property”.\nDP 是一种适用于最优解满足“分解性质”情况的通用方法。\n\nDP的步骤通常如下：\n1. 将最优解分解为子解相当于将问题分解为子问题，并且子解对于子问题是最优的。\n2. 因此，最优解可以通过更小的子问题的最优解来构建。\n\n*与分治法不同的是，DP中的子问题可以重叠，即不同的路径可能会遇见相同的子问题。*\n\n因此DP的思想通常是，对于某一个解 $S_n$，如果我想要得到这个解，我该直到哪些解才能得出这个解，并依次获取和尝试合并这些可能解的组合。又或者说，我现在已知某一个解，我是否可以让这个解和其他输入/解组合获取一个新的解。其中这个“得到”和“获取”的过程是一个状态转移的过程，这个过程是一个状态转移方程/贝尔曼方程(Bellman Equation)。\n- 例如，假设有这样一个问题：给出一个整型集合 $S$，和一个目标值 $K$，我是否可以找出一个 $S_{sub}$ 的子集，其元素的和等于 $K$。\n  - 假设我们输入 $S[i], 0 \\leq i \\leq (n-1)$ 是集合第 $i$ 个元素。\n  - 我们使用 $dp[i][m] = true, 0 \\leq m \\leq K$ 来表示使用前 $i$ 个元素组成的子集中 $S_{sub}$ 元素和可以等于 $m$。\n  - 如果我们知道 $dp[i - 1][m] = true$，那么可以根据它和当前元素 $S[i]$ 得出 $dp[i][m + S[i]] = true$。\n  - 如何知道$dp[i - 1][m] = true$? 只需要对 $m$ 进行遍历 $(0 \\leq m \\leq K-S[i])$ 依次检查是否为`true`即可。\n  - 由此我们就可以得到状态转移方程：$dp[i][m] = dp[i][m]\\ \\text{ | } \\ dp[i - 1][m - S[i]]$。\n  - 时间复杂度是 $O(kn)$。\n  - 此外我们可以使用滚动数组将其变成一维dp，此时对容量 $m$ 的遍历是倒着的（如果正着就会导致元素 $i$ 被重复计算，此时属于完全背包问题）。\n\n*与暴力搜索，暴力搜索是将所有可能的答案依次列出来并测试，答案之间可能没有太大的关系。而动态规划是根据状态转移来尝试获取哪些解。*\n\n---\n\n## 最短路算法(Shortest Path)\n最短路算法分为单源最短路和多源最短路。\n解决单源最短路的一种方法是 `Dijkstra` 算法，其时间复杂度是 $O(n\\log n + m)$。如果将其应用在多源最短路的话，那么其时间复杂度是 $O(n(n\\log n + m))$。\n\n此外，有一个特定的算法用来解决多源最短路，就是`Floyd-Warshall (FW)`算法，该算法的时间复杂度是 $O(n^3)$。\n\n### Floyd-Warshall (FW)\nFW算法是一个动态规划的算法，通过逐步加入点来构造子答案从而获取整体最优解的方法。\n适用于负数边、有向边的情况。\n\n- 定义：\n  - 定义 $d(i,j,k)$：表示点在 $i,j$ 之间使用 $\\{1,...,k\\}$ 作为允许使用的潜在中间点的最短路。\n    - 例如 $d(2,5,3)$：在仅使用 $\\{1,2,3\\}$ 其中的点作为中间点（这些点可以使用也可以不使用，但不能使用其他的点）时点 $2$ 到点 $5$ 的最短路。\n\n  - 定义 $w(i, j)$：表示两个点之间的距离。\n    - 如果不连通则等于 $\\infty$，即 `w(i, j) = inf`。\n    - 自边等于 $0$，即 `w(i, i) = 0`。\n\n- 初始化：对于所有的两个点之间：$d(i, j, 0) = w(i, j)$。\n\n- 状态转移方程：考虑当 `k = k + 1`时，即对于每两对点之间在前 `k` 个点已经加入好，那么有：\n$$d(i, j, k+1) = \\min (d(i, j, k), d(i, k+1, k) + d(k+1, j, k))$$\n\n---\n\n# Reference\n1. \"Big O Notation.\" Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Big_O_notation. Accessed 19 May 2024.\n2. \"Recurrence Relation.\" Wikipedia, The Free Encyclopedia, 8 April 2024, en.wikipedia.org/wiki/Recurrence_relation. Accessed 20 May 2024.\n3. \"Master Theorem (Analysis of Algorithms).\" Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms). Accessed 22 May 2024.\n4. \"Quicksort.\" Wikipedia, The Free Encyclopedia, 12 May 2024, en.wikipedia.org/wiki/Quicksort. Accessed 21 May 2024.","source":"_posts/zExNocs/笔记-ADE-算法数据结构和效率.md","raw":"---\ntitle: 算法数据结构和效率\ndate: 2024-06-21\nupdated: 2024-06-21\npermalink: articles/zExNocs/笔记-ADE-算法数据结构和效率/\ncategories: zExNocs\ntags:\n  - 算法\n  - 数据结构\n  - Big-Oh\n---\n\n有关算法效率分析的笔记，包括Big-Oh表示法、Master定理和部分算法与数据结构的算法分析。\n<div style=\"text-align:center\">\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/cover.png\" alt=\"封面\" width=\"300\">\n</div>\n\n<!-- More -->\n\n---\n\n# 介绍\n\n原博客：[点击跳转](https://www.zexnocs.top/post/%E7%AC%94%E8%AE%B0%2F%E7%AC%94%E8%AE%B0-ADE-%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%88%E7%8E%87)\n\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n\n本笔记主要分为下面五个部分：\n- 一. 算法效率的评估\n- 二. Big-Oh表示法和其家族\n- 三. Master定理\n- 四. 数据结构\n- 五. 算法\n\n\n# 一. 算法效率的评估\n\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 **程序的运行时间** 来评估测量算法效率。\n\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 ~~(关于SPFA，它死了)~~ 。\n\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n---\n\n## 方法一：Experiment 实验统计\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png\" alt=\"实验统计样例\" width=\"300\">\n\n> 实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。\n\n具体步骤如下:\n- 写一个程序实施该算法\n- 使用不同的输入大小和输入信息运行程序\n- 记录实际运行时间\n- 绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注**最差的情况**，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n\n### 缺点 & 局限性\n- 必须用程序实现该算法，可能会很耗时。\n- 需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n- 效率的评估受到硬件/软件/语言环境的影响。\n\n---\n\n## 方法二：Theory 理论分析\n\n> 理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n\n跟实验统计一样，我通常指关注**最差的情况**。\n\n### 特点\n- 具有一定的抽象性。\n- 能够独立于硬件/软件/语言环境来评估算法的效率。\n- 能够考虑所有可能的输入。\n\n### 缺点 & 局限性\n- 实施过程可能会比较困难，需要一定的知识基础。\n- 在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n### 评估标准\n在实验统计中，我们往往使用 **程序的运行时间** 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：**原始运算数量**。\n\n#### 原始运算的定义\n\n> 原始运算(primitive operations)是算法执行的基本运算。\n\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将**汇编代码**、**算数运算**视作一个原始运算。\n\n注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：\n\n|描述|伪代码样例|\n|----|---------|\n|变量赋值|`a ← 0`|\n|数组索引|`a[10]`|\n|变量比较|`a == 10`|\n|算数运算|`a + 1`|\n|函数调用|`function()`|\n|函数返回|`return 0`|\n\n**注意：**\n- 在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n- 数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n- 函数调用属于原始运算是因为它需要在内存中进行索引。\n- 在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n|描述|分析|操作数|伪代码样例|\n|----|----|-----|---------|\n|for循环，循环次数为$n$|要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)|$1+n+2n = 3n+1$|`for i ← 1 to n do`|\n|for循环，循环次数为$(n-1)$|要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)|$1+2(n-1)+2(n-1) = 4n-3$|`for i ← 1 to (n-1) do`|\n|while循环，循环次数为$n$|每次循环只需要判断即可|$n$|`while i > n`|\n|while循环，循环次数为$(n-1)$|每次循环都需要进行判断和减法|$2(n-1)$|`while i > (n-1)`|\n|if then判断，then内部原始运算数为$k$|一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)|$1 + k$|`if ... then ...`|\n\n:::details 一个计算原始运算数的例子: arrayMax(A, n)\n\n一个返回数组最大值arrayMax(A, n)的伪代码：\n```\nAlgorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。\n  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值\n  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)\n    if A[i] > currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)\n      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)\n  return currentMax         # 原始运算为1，函数返回\n```\n\n综上所述，这个算法的原始运算总数为 $2 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 4$\n\n:::\n\n原始运算的个数并不是固定的，例如在计算操作 $c \\leftarrow A[i]$ 中，你也可以认为是$4$个原始运算：\n- 获取$A$数组的指针储存在寄存器中。\n- 获取$i$储存在寄存器中。\n- 计算$A + i$作为$A[i]$的指针储存在寄存器中。\n- 复制变量$c$的数值写在$A + i$指针的内存中。\n\n当然在这个笔记中，你也可以认为只有$2$个原始运算：\n- 根据$i$索引获取$A[i]$数组位置 (数组索引)。\n- 将变量$c$的数值赋值给$A[i]$ (变量赋值)。\n\n但是无论是$4$还是$2$，这个操作永远不可能会是$2n$，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。\n\n> 原始运算的个数只与算法的效率有关，与正确性无关。\n\n#### 使用原始运算估算运行时间\n\n增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。\n\n> 对于算法来说，假设它的最差情况的运行时间为$T(n)$，那么$T(n)$的增长率是该算法的固有属性，是不受硬件/软件环境影响的。\n\n我们可以使用原始运算来估算运行时间，假设：\n- 原始运算的个数为$P(n)$。\n- 最快的原始运算所需要的时间为$a$，是一个常数。\n- 最慢的原始运算所需要的时间为$b$，是一个常数。\n\n可以得出：$$aP(n) \\leq T(n) \\leq bP(n)$$\n\n由于a和b都是常数，那么我们认为\\[T(n)\\]和\\[P(n)\\]具有相同的增长率。很明显$T(n)$和$P(n)$的导数肯定是不同的，因此增长率并不等同于导数。\n\n但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。\n\n\n\n# 二. Big-Oh表示法和其家族\n## 基本知识\n我们需要一种函数分类(Classification of Functions)来通过**缩放**的行为将函数分组在一起，同一组的函数具有这样的相似性：\n- 删除不必要的细节。\n- 相对快速、简单。\n- 处理运行时可能会发生的“奇怪的”函数(例如分段函数)。\n- 在数学上拥有明确的定义。\n\n其中一种最佳的方法是使用[Big-Oh表示法和其家族(Big-Oh notation and family)](https://en.wikipedia.org/wiki/Big_O_notation)：\n- $O$: Big-Oh\n- $\\Omega$: Big-Omega\n- $\\Theta$: Big-Theta\n- $o$: little-oh\n- $\\omega$: little-omega\n\n本笔记只集中于前四个的定义和Big-Oh的相关理论。\n\n---\n\n## Big-Oh：O(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ O(g(n))$ ，当且仅当\n$$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| \\leq c \\ g(n)$$\n\n**注意:**\n- 量词顺序是 $\\exists \\ \\exists \\ \\forall$\n- $c$ 和 $n_0$必须是常数，不能随着$n$变化。不然这是没有意义的。\n- 注意符号$>,\\geq,\\leq$的区分。相比之下是比较严格的(例如，$n_0$ 不能等于 $0$, $n$ 可以等于 $n_0$)。\n\n此外，Big-Oh可以会被定义为：\n$$\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} < \\infty $$\n\n> Big-Oh只规定了$f(n)$的**增长率的上限**(upper bound on the growth rate of the function)。\n\n### 特点\n- Big-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于**函数**。也就是说它并不是对算法进行分类，而是对**函数**进行分类。\n- 一般$f(n)$表示运行时间，$n$表示输入的个数，所以Big-Oh中描述的函数一般为 $f: \\mathbb{N^+} \\to \\mathbb{R^+}$，$g(n)$也类似。\n- Big-Oh只规定了$f(n)$的**增长率的上限**，也就是说，当$n$足够大时，$f(n)$的增长速率不大于$g(n)$。\n- Big-Oh中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) = 1$可以是$O(1)$，但也可以是$O(n)$。因此$g(n)$的增长率越小越能反应出$f(x)$的增长率。\n\n### 性质\n\nBig-Oh作为一个二元关系(binary relation)，拥有以下性质：\n- Big-Oh具有自反性(Reflexive, e.g. $x R x$)，即 $f(n)$ 是 $O(f(n))$。\n- Big-Oh不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)，例如 $f(n) = 1$ 是 $O(n)$，但是 $f(n) = n$ 不是 $O(1)$。\n- Big-Oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。即如果 $\\forall n \\geq n_1, f(n) \\leq c_1g(n)$，且$\\forall n \\geq n_2, g(n) \\leq c_2h(n)$，那么总有 $\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3=\\max(n_1,n_2)$。\n\n综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是$\\subset, \\in, \\leq$,而不是$=$，因此有一种表示方法是将Big-Oh视作集合，使用$n \\in O(n)$。此时也有会 $O(lower\\ order) \\subset O(heigher\\ order)$。\n\n*此外，也有一种说法是使用$f(n) = O(n)$，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。*\n\n### 推论 & 方法\n\n- 推论1：存在三个函数$f(n)$, $g(n)$, $p(n)$和正数$k, b\\in \\mathbb{N^+}$，如果$f(n)$是$O(g(n))$，且$f(n)=k\\ p(n) + b$，那么有$p(n)$是$O(g(n))$。\n\n:::details 证明推论1\n\n假设有$c_0 > 0, n_0 > 0$，对于$n_1 \\geq n_0$，有：\n\n$f(n_1) \\leq c_0 \\ g(n_1)$，那么有：\n\n$k\\ p(n_1) + b \\leq c_0 \\ g(n_1)$，整理得：\n\n$p(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}$\n\n当n足够大时候，假设此时$n_1 \\geq n_2$，有 $cg(n_1) \\geq 2b$\n\n从而有 $p(n_1) \\leq \\frac{c_0}{2k}g(n_1)$\n\n设 $c_1=\\frac{c}{2k}>0$，我们得到：\n\n$p(n_1) \\leq c_1\\ g(n_1)$，即\n\n存在 $c_1$，$n_2$使得 $\\forall n > n_2, p(n) \\leq c_1\\ g(n)$\n\n因此$p(n)$是$O(g(n))$。\n\n:::\n\n- 推论2 （乘法）：如果$f_1(n)$ 是 $O(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$。\n\n:::details 证明推论2\n\n$∵ f_1(n)$ 是 $O(g_1(n))$\n\n$∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1$\n\n$∵ f_2(n)$ 是 $O(g_2(n))$\n\n$∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2$\n\n$∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0$\n\n那么有 $n_0 = \\max(n_1, n_2)$\n$f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0$\n\n因此$f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$\n\n:::\n\n- 推论3 （加法）：如果 $f(n) = 1 + h(n)$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(1)$。\n\n:::details 证明推论3\n\n$∵$ 当$n \\to \\infty$ 时 $h(n) \\to 0$\n$∴$ $\\exists n_0 > 0,\\ \\forall n \\geq n_0, h(n) \\leq 1$\n$∴$ $\\exists n_0 > 0,\\ \\forall n \\geq n_0, f(n) \\leq 2$\n$∴$ $f(n)$ 是 $O(1)$ 取 $c = 2, n_0 = n_1$ 且 $h(n_1) <= 1$\n\n:::\n\n一些常用的 $h(n)$:\n- $n^2/2^n$\n- $n^{2000}/2^{\\frac{n}{100}}$\n- $(log(n))^{100} / n^{0.1}$\n\n综合推论2和3，可知如果 $f(n) = g(n)(1 + h(n))$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(g(n))$。\n\n因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：\n- 删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。\n- 删除常数(constant)项系数 (根据推论1,总能找到 $k$ 使得系数变成 $1$)。\n\n### 例子\n\n:::details 证明arrayMax(A, n)是 $O(n)$ 的例子 (定义)\n\n由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 $f(n) = 8n - 4$\n\n设$g(n) = n$，因此需要求证 $\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)$，整理可得：\n\n$$\n\\begin{cases}\nn \\leq \\frac{4}{c - 8} & c > 8 \\\\\nn \\geq \\frac{4}{c - 8} & c < 8 \\\\\n-4 \\leq 0 & c = 8\n\\end{cases}\n$$\n\n由于我们规定是 $\\forall n \\geq n_0$，因此我们只能取 $n \\geq 8$。\n\n当我们取 $n = 8$时，很明显任意$n_0 > 0$都可以证明成立。此时我们可以取 $n_0 = 1$。\n\n当我们取 $n > 8$时，很明显任意$n_0 > \\frac{4}{c - 8}$都可以证明成立。此时我们可以取 $n_0 = \\frac{4}{c - 8}$。\n\n实际上，上述情况只需要求出一组$(c,n_0)$即可，因此我们可以直接取$c = 8, n_0 = 1$。不过这里给出了一种选取$(c,n_0)$的具体方法。\n\n因此arrayMax(A, n)的时间复杂度是 $O(n)$。\n\n:::\n\n:::details 对于分段函数Big-Oh的证明 (定义)\n\n如何计算下面函数的Big-Oh:\n$$\nf(n) = \n\\begin{cases}\nn & \\text{if } n \\text{ is even} \\\\\n1 & \\text{if } n \\text{ is odd}\n\\end{cases}\n$$\n\n因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即$f(n) = n$，此时当$c = 1, n_0 = 1$可以证明出$f(n)$是$O(n)$，而无法证明出$f(n)$是$O(1)$。\n\n:::\n\n:::details 求 $f_(n) = n^2 + n$ 的Big-Oh (定理2, 3)\n\n$f(n) = n^2 + n = n^2(1 + \\frac{1}{n})$\n\n因为自反性，$n^2$ 是 $O(n^2)$。\n\n因为当$n \\to \\infty$ 时 $\\frac{1}{n} \\to 0$，根据推理3可知 $1 + \\frac{1}{n}$ 是 $O(1)$。\n\n因此根据推理2，$f(n)$ 是 $O(n^2 * 1) = O(n^2)$\n\n:::\n\n:::details 求 $f_(n) = 5n^4 + 3n^3$ 的Big-Oh (删除规则)\n\n- 删除低阶$3^n$，因此$f(n)$ 是 $O(5n^4)$\n- 删除常数$5$，因此$f(n)$ 是 $O(n^4)$\n\n:::\n\n### Big-Oh公约\n遵循这个公约可以更好地去分析算法以及给出最大的信息。\n\n- 使用最小且正确的增长率函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(n^2)$，尽管后者也是正确的。\n- 使用最简的函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(2n)$。\n\n### 其他\n对于 $n^{O(1)}$来说，相当于是 $\\{ n^f(n)\\ |\\ f(n) \\text{ is } O(1)\\}$。\n也就是说 $\\{n^1, n^2, n^3, ...\\} \\subset n^{O(1)}$，$\\{n^\\frac{1}{2}, n^\\frac{1}{3}, n^\\frac{1}{4}... \\} \\subset n^{O(1)}$\n\n> $n^{O(1)}$ is any function that is no worse than (Big-Oh of) some power law.\n$n^{O(1)}$表示任何不超过指数级的函数。\n\n---\n\n## Big-Omega：Ω(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Omega (g(n))$ ，当且仅当\n$$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : f(n) \\geq c \\ g(n)$$\n\n注意：\n- 量词顺序是 $\\exists \\ \\exists \\ \\forall$。\n- 与Big-Oh不同，最后的符号是 $\\geq$ 而不是 $\\leq$。\n\n此外，Big-Omega可以会被定义为：\n$$\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} > 0 $$\n\n### 特点\n- Big-Omega规定了$f(n)$的**增长率的下限**，也就是说，当$n$足够大时，$f(n)$的增长速率不小于$g(n)$。\n- Big-Omega中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) = n^3 - n$ 可以是 $\\Omega(n^3)$，但也可以是 $\\Omega(n^2)$。因此$g(n)$的增长率越大越能说明$f(n)$的增长率。\n- 一般可以用来描述算法的最佳情况。\n\n### 性质\n类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：\n- Big-Omega具有自反性(Reflexive, e.g. $x R x$)。\n- Big-Omega不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)。\n- Big-Omega具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nBig-Omega更像是 $\\geq$。\n\n### 推论 & 方法\n- 推论1：$f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))$\n- 推论2 （乘法）：如果$f_1(n)$ 是 $\\Omega(g_1(n))$, $f_2(n)$ 是 $\\Omega(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $\\Omega(g_1(n)g_2(n))$。\n\n删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是**删除低阶函数**而不是删除高阶函数。\n\n例如 $f(n) = n^3 - n$中，应该删除的是$n$。找到$n^3$后我们就可以找比$n^3$阶级低的函数来代替。\n\n---\n\n## Big-Theta：θ(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Theta (g(n))$ ，当且仅当\n> $$\\exists c' > 0, \\exists c''>0, \\exists n_0 > 0, \\forall n \\geq n_0 : c'\\ g(n) \\leq f(n) \\leq c'' \\ g(n)$$\n\n此外，Big-Theta可以被定义为：\n> $$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))$$\n> $$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))$$\n\n### 性质\nBig-Theta作为一个二元关系拥有下面的性质：\n- Big-Theta具有自反性(Reflexive, e.g. $x R x$)。\n- Big-Theta**具有**对称性(Symmetric, e.g. $x R y \\iff y R x$)：如果 $f(n)$ 是 $\\Theta(g(n))$，那么 $g(n)$ 是 $\\Theta(f(n))$。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。\n- Big-Theta具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nBig-Theta更像是 $\\approx$。\n\n---\n\n## little-oh：o(n)\n### 定义\n假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ o(g(n))$ ，当且仅当\n$$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| < c \\ g(n)$$\n\n**注意:**\n- 量词顺序是 $\\forall \\ \\exists \\ \\forall$。\n- 因为是对于全部的 $c$ 存在 $n_0$，因此 $n_0$ 的数值可以依赖于 $c$。\n- 与Big-Oh不同，最后的符号是 $<$ 而不是 $\\leq$。\n\nlittle-oh也可以被定义为：\n$$\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n### 性质\nlittle-oh作为一个二元关系(binary relation)，拥有以下性质：\n- little-oh**不具有**自反性(Reflexive, e.g. $x R x$)。即$f(n) = n$ 不是 $o(n)$。\n- little-oh**不具有**对称性(Symmetric, e.g. $x R y \\iff y R x$)。\n- little-oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。\n\nlittle-oh 更像是严格的 $<$。\n\n### 特点\n- 与Big-Oh类似，little-Oh定义是函数的**严格无法到达的上限**。\n- little-oh的意思是，当$n$足够大时，$f(n)$的增长速率小于$g(n)$。\n- little-oh中 $g(n)$ 阶级越小，越能说明 $f(n)$ 的增长率。\n\n### 推论 & 方法\n- 推论1：如果$f(n)$ 是 $o(g(n))$，那么 $f(n)$ 一定是 $O(g(n))$\n正如 $<\\ \\to\\ \\leq$ 一样，很明显 $O(g(n)) \\subset o(g(n))$。\n- 推论2 （乘法1）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $o(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。\n- 推论3 （乘法2）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。\n\n与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。\n\n### 例子\n\n:::details 证明 $f(n) = n ^ 2 + n$ 是 $o(n^3)$\n\n要证明$f(n) = n ^ 2 + n$ 是 $O(n^3)$，则需要证明 $\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : f(n) < c \\ g(n)$。\n\n代入和整理可得 $\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : cn^2-n-1 > 0$。\n\n由公式可得，若 $cn^2-n-1 = 0$，且$n_r > 0$，可解得 $n_r = \\frac{1 + \\sqrt{4c + 1}}{2c} > 0$。\n\n且当 $n > n_r$ 时，$cn^2 - n - 1 > 0$ 恒成立，那么可以取 $n_0 = n_r + 1 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$，使得 $\\forall n \\geq n_0 : f(n) < c \\ g(n)$ 恒成立。\n\n因此，$f(n) = n ^ 2 + n$ 是 $O(n^3)$，此时对于所有的 $c$ 取 $n_0 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$。\n\n:::\n\n### 关于Big-Oh和little-oh的定义上的思考：\n\n如果将Big-Oh的定义改为：$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)| < c \\ g(n)$，称为 $O_<$，而原定义称为 $O_{\\leq}$，\n那么实际上，对于 $g(n) > 0$， $f(n)$ 是 $O_<(g(n)) \\iff f(n)$ 是 $O_{\\leq}(g(n))$。\n唯一的区别是对于 $f(n) = 0, g(n) = 0$ 来说 $0$ 是 $O_{\\leq}(0)$ 而不是 $O_<(0)$。\n而我们想要定义Big-Oh的渐进符号为 $\\leq$，就得要求 $0$ 是 $O(0)$，因此使用 $\\leq$ 而不是 $<$。\n\n同理，对于little-oh如果定义改为：$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : |f(n)|  \\leq c \\ g(n)$，称为 $o_{\\leq}$，而原定义称为 $o_{<}$。\n此时 $o_{<}$ 与 $o_{\\leq}$ 定义的唯一区别也是当 $f(n) = 0, g(n) = 0$ 的时候，此时 $0$ 是 $o_{\\leq}(0)$ 而不是 $o_{<}(0)$。\n而我们想要定义little-oh的渐进符号是 $<$，就得要求 $0$ 不是 $o(0)$，那么使用的是 $<$ 而不是 $\\leq$。\n\n实际上，对于Big-Oh和little-oh最主要的区别是 $\\exists c$ 和 $\\forall c$。\n\n---\n\n## 常用表示表\n\n根据阶级(order)从小到大排名。\n\n|表示|中文名|英文名|数量级|\n|----|-----|------|-----|\n|$O(n^c), c < 0$ $or$ $O(\\frac{k}{n})$|负数幂级|negative power|$\\infty$,不存在|\n|$O(1)$|常数级|constant|$\\infty$|\n|$O(\\log{\\log{n}})$|双对数级|double logarithmic|$2^{2^{10^6}}$|\n|$O(\\log{n})$|对数级|logarithmic|$10^{301030}$|\n|$O((\\log{n})^c), c > 1$|多重对数级|polylogarithmic|$2^{10^{\\frac{6}{c}}}$|\n|$O(n^c), 0 < c < 1$ $or$ $O(\\sqrt[c]{n})$|分数幂级|fractional power|$10^{6c}$|\n|$O(n)$|线性级|linear|$10^6$|\n|$O(n\\log{n}) = O(\\log{n!})$|对数线性/拟线性级|loglinear, n-log-n|$10^5$|\n|$O(n^2)$|二次级|quadratic|$10^3$|\n|$O(n^c), c > 1$|多项式/代数级|polynomial, algebraic|$\\sqrt[c]{10^6}$|\n|$O(c^n)$|指数级|exponential|$6\\log_{c}{10}$|\n|$O(n!)$|阶乘级|factorial|$9$|\n\n---\n\n## Big-Oh家族使用样例\n- 用于表示一个范围：算法 X 最坏的情况时间复杂度是 $o(n^4)$ 和 $\\Omega(n^3)$，但是实际表现并不确定。\n- 用于确定一个增长率：算法 X 最佳的情况时间复杂度是 $\\Theta(n^2)$。\n- 用来表示一个平均值：算法 X 平均情况时间复杂度是 $O(n^3)$。\n\n---\n## 使用Big-Oh家族分析算法效率注意点\nBig-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 $n$ **足够大**时渐进的范围,也可以说是 $n$ 的增长率。 \n\n但是在 $n$ **比较小**时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的**实际工作**时的效率。\n\n例如：\n- $10000n$ 是 $O(n)$，同时 $2^n$ 是 $O(2^n)$，当时当 $n$ 比较小时，例如 $n = 6$ 时，前者需要进行的计算数是 $60000$，而后者是 $64$，此时前者的效率是不如后者的。\n- $O(1.02^n)$ 尽管是指数级(exponential)，但是它的效率并不逊色。\n\n但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 $n$ 比小的时候程序所消耗的时间往往是会忽略不计的。\n\n---\n\n## 总结\n- Big-Oh家族定义及其渐进表示法总结\n\n|表示法|名字|描述|渐进符号|形式定义|\n|-----|----|----|-------|-------|\n|$o(g(n))$|little-Oh|函数渐进地由$g$支配|$<$|$\\forall c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : \\| f(n) \\| < c \\ g(n)$|\n|$O(g(n))$|Big-Oh|函数以$g$为渐进边界|$\\leq$|$\\exists c > 0, \\exists n_0 > 0, \\forall n \\geq n_0 : \\|f(n)\\| \\leq c\\ g(n)$|\n|$\\Theta(g(n))$|Big-Theta|函数由$g$为渐进边界和下边界|$\\approx$|$\\exists c'>0,\\exists c''>0, \\exists n_0 > 0, \\forall n \\geq n_0 : c'g(n) \\leq f(n) \\leq c''g(n)$|\n|$\\Omega(g(n))$|Big-Omega|函数由$g$为渐进下边界|$\\geq$|$\\exists c>0,\\exists n_0>0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)$|\n|$\\omega(g(n))$|little-omega|函数渐进支配$g$|$>$|$\\exists c>0,\\forall n_0 > 0, \\exists n \\geq n_0 : f(n) > c\\ g(n)$|\n\n- 如何求解一个算法的时间复杂度Big-Oh：\n  - 建立算法函数的伪代码。\n  - 求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。\n  - 根据该函数求出Big-Oh表示。\n\n---\n\n# 三. Master定理\n## 分而治之(Divide and Conquer)\n分而治之是一个设计算法的思想，它通常能够高速地处理问题。\n\n分而治之的组成成分如下：\n  - 分解 (Divide)：将输入分为两个或多个不相交的输入子集。\n  - 递归 (Recur)：使用递归解决这些子集的子问题。\n  - 组合 (Conquer)：将所有子集的解组合起来形成输入的解。\n\n---\n\n## 递归关系 Recurrence Relation\n定义：\n> A recurrence relation is a recursively-defined function.\n[递归关系(Recurrence Relation)](https://en.wikipedia.org/wiki/Recurrence_relation)是使用递归定义的函数。\n\n假设一个程序的运行时间是 $T(n)$，那么递归关系会在一系列小于n的值中来表达 $T(n)$。\n\n:::details 例子：归并排序(merge-sort)的递归关系及其时间复杂度的证明\n\n关于归并排序的具体算法请看下面 **五. 算法** 中 **归并排序**。\n\n假设归并排序的运行时间为 $T(n)$，那么\n\n$$\n\\begin{aligned}\nT(n) & = 2\\ T(\\frac{n}{2}) + b + an \\\\T(1) & = 1\n\\end{aligned}\n$$\n\n- $2\\ T(\\frac{n}{2})$ 表示数组分成了两个子数组，每个子数组的大小为 $\\frac{n}{2}$。\n- $b$ 是分裂的花费。\n- $an$ 是 `merge` 的花费。\n\n因此我们经过带入可以得到：\n- $T(2) = 2\\ T(1) + b + 2a = 2 + b + 2a$\n- $T(4) = 2\\ T(4) + b + 4a = 2 (2 + b + 2a) + b + 4a = 4 + 3b + 8a$\n- $T(8) = 2\\ T(4) + b + 8a = 2 (4 + 3b + 8a) + b + 8a = 8 + 7b + 24a$\n\n由此我们猜测 $T(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$\n我们可以使用数学归纳法(induction)来验证：\n\nClaim: $T(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$.\nBase case: $k = 0$，$T(1) = 1 + 0 * b + 0 * 1 * a = 1$ is meet the claim.\nStep case: Assume that the claim is true at k, and we need to prove that $T(k + 1)$ is true.\n$$\n\\begin{aligned} \nT(2^{k+1}) & = 2\\ T(2^k) + b + 2^{k+1}a \\\\\n & = 2 (2^k + (2^k - 1)b + k\\ 2^ka) + b + 2^{k + 1}a \\\\\n & = 2^{k+1} + (2^{k+1} - 2)b + b + k\\ 2^{k+1}a + 2^{k + 1}a \\\\\n & = 2^{k+1} + (2^{k+1} - 1)b + (k + 1)\\ 2^{k+1}a\n\\end{aligned} $$\n$Q.E.D.$\n\n我们假设 $T'(n) = n + (n - 1)b + an\\log(n), \\text{for } n = 2^k, k\\in \\mathbb{N}$。\n我们可以证明出 $T(n)$ 是 $\\Theta(T'(n))$。\n因此，$T(n)$ 是 $\\Theta(n\\log n)$。\n\n:::\n\n---\n\n## Master定理 (Master Theorem)\n\n考虑存在下面的递归关系：\n$$\n\\begin{aligned}\nT(n) & = a\\ T(\\frac{n}{b}) + f(n) \\\\\nT(1) & = 1\n\\end{aligned}\n$$\n这是一个由分而治之设计的算法：分解成 $a$ 个子集，每个子集的大小是 $\\frac{n}{b}$，此外每个递归/循环有一些额外的操作 $f(n)$。\n\n[Master定理(Master Theorem)](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))是一个根据 $a, b$ 的数值以及对 $f(n)$ 进行放缩来快速求出$T(n)$的Big-Oh家族的方法。\n\n下面就对 $f(n), a, b$ 不同情况进行讨论。\n\n*注意，本笔记中不形式证明Master定理，具体可以自行查阅。*\n\n### > $f(n) = 0$ 时\n此时 $T(n) = aT(\\frac{n}{b})$，我们可以使用数学归纳法证明出 $T(b^k) = a^k$。\n\n我们令$n = b^k$，根据数学公式我们可以推导出 $a^k = (b^k)^{\\log_ba}$，因此我们可以得到\n$$T(n) = n^{\\log_ba}$$\n\n因此我们可以知道 $T(n)$ 是 $\\Theta(n^{\\log_ba})$。\n\n### > $f(n) \\neq 0$ 时\n此时可以分为三种情况：\n\n|$f(n)$ 的形式|$c$ 与 $\\log_ba$ 的关系|$T(n)$的Big-Theta|描述|\n|-------------|----------------------|-----------------|----|\n|$f(n)$ 是 $O(n^c)$|$c < \\log_ba$|$\\Theta(n^{\\log_ba})$|$f(n)$ 的 增长率非常小，此时忽略 $f(n)$|\n|$f(n)$ 是 $\\Theta(n^c(\\log n)^k), k \\geq 0$|$c = \\log_ba$|$\\Theta(n^c(\\log n)^{k+1})$|$f(n)$ 的 增长率适中，此时混合使用$a, b, f(n)$|\n|$f(n)$ 是 $\\Omega(n^c)$, 并满足正则条件|$c > log_ba$|$\\Theta(f(n))$|$f(n)$ 的 增长率非常大，此时只考虑 $f(n)$|\n\n情况三中需要满足正则条件(Regularity Condition)：\n$$\\exists k < 1 : a f(\\frac{n}{b}) \\leq k f(n)$$\n\n*该条件保证了这个条件确保 $f(n)$ 不会增长过快导致 $T(n)$ 完全被非递归部分主导。*\n\n注意$f(n)$ 的形式以及$c$ 与 $\\log_ba$ 的关系。\n\n- 情况一中可知，$f(n)$的渐进上边界都不如 $n^{\\log_ba}$，那么$f(n)$ 的增长率是可以被忽略的。\n- 情况二中可知，$f(n)$的增长率是与 $n^{\\log_ba}$ 持平的，因此应该要混合使用$a, b, f(n)$。\n- 情况三中可知，$f(n)$的渐进下边界都超过了 $n^{\\log_ba}$，因此只考虑 $f(n)$。\n\n---\n\n# 四. 数据结构\n## 一些定义\n- 遍历(Traversals)：指访问(visit)一个数据结构的所有元素。\n  - 每一个元素只访问一次。\n  - 访问的顺序是系统的、有序的、有意义的。\n\n- 抽象数据类型(Abstract Data Types, ADTs)：是数据结构的抽象。\n  - 组成成分：\n    - 储存的数据类型。\n    - 对数据的操作。\n    - 与操作相关的错误条件。\n  - 一般ADT的相关操作会使用Big-Oh来限制效率。\n\n- 具体数据类型(Concrete Data Types, CDTs)：是数据结构的实际。\n  - ADT的实现是通过选择不同的CDT。\n  - CDT是数据隐藏的和封装的（面向对象）。\n  - CDT的选择影响运行时间和空间使用。\n\n- 面向对象编程(Object-oriented)的原因：\n  - 区分规范(specification) 和 实施细节(implementation details)\n  - 使用相同的ADT来探索不同的CDTs。\n  - 无需更改ADT的代码来快速更改和提升CDTs。\n\n---\n\n## 单向链表(Singly Linked List) (CDT)\n### 介绍\n> A singly linked list is a concrete data structure consisting of a sequence of nodes. Each node stores an element and a pointer/reference to the next node.\n\n### 成员\n- `Node` 节点\n  - `Element` 元素\n  - `next` 指向下一个节点的指针\n- `head : Node*` 头节点指针\n- `tail : Node*` 尾节点指针 (可选)\n\n### 功能性函数\n插入类函数：\n- `void insertHead(Object)`：插入头结点\n  - 时间复杂度：$O(1)$\n- `void insertTail(Object)`：插入尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n\n删除类函数：\n- `void removeHead()`：删除头节点\n  - 时间复杂度：$O(1)$\n- `void removeTail(Object)`：删除尾节点\n  - 无论有没有记录尾节点，时间复杂度：$O(n)$\n    - 因为要让尾节点的前一个节点的`next`指针指向`NULL`\n\n交换类函数：\n- `void swapElement(Node, Node)`：交换元素而不交换节点的位置\n  - 时间复杂度 $O(1)$\n- `void swapNode(Node, Node)`：交换节点的位置（不常用）\n  - 时间复杂度 $O(n)$\n    - 因为要找到这两个`Node`的上一个`Node`来修改`next`。\n\n---\n\n## 双向链表(Doubly Linked List) (CDT)\n### 介绍\n> A doubly linked list provides a natural extension of a singly linked list.Each node stores an element and a pointer/reference to the next node and a pointer/reference to the previous node.\n\n### 成员\n- `Node` 节点\n  - `element` 元素\n  - `next` 指向下一个节点的指针\n  - `pre` 指向上一个节点的指针\n- `head : Node* | Node` 头节点指针/节点\n- `tail : Node* | Node` 尾节点指针/节点\n\n### 功能性函数\n插入类函数：\n- `void insertHead(Object)`：插入头结点\n  - 时间复杂度：$O(1)$\n- `void insertTail(Object)`：插入尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n- `void insertAfter(Node, Object)`：插入到`Node`节点后面\n  - 时间复杂度：$O(1)$\n\n删除类函数：\n- `void removeHead()`：删除头节点\n  - 时间复杂度：$O(1)$\n- `void removeTail(Object)`：删除尾节点\n  - 如果有记录尾节点，时间复杂度： $O(1)$\n  - 如果没有记录尾节点，时间复杂度： $O(n)$\n\n交换类函数：\n- `void swapElement(Node, Node)`：交换元素而不交换节点的位置（不常用）\n  - 时间复杂度 $O(1)$\n- `void swapNode(Node, Node)`：交换节点的位置（建议）\n  - 时间复杂度 $O(1)$\n\n### 补充\n- 有两种双向链表设计方式\n  - 让`head`和`tail`指向实实在在的节点。如果链表为空，则`head = NULL, tail = NULL`。\n  - 分配`head`和`tail`为新的节点，节点的元素为空。如果链表为空，则`head.next == tail`。\n\n### 数据结构的思考\n相比于数组 `Array`，链表数据结构具有较快的插入和删除能力。但是，链表具有较差的查询能力，其查询能力的时间复杂度是 $O(n)$。\n\n一般具有较快的插入、删除和查询能力的数据结构都比较复杂，例如：\n- 跳表 (Skip List)：其三个操作的时间复杂度都是 $O(\\log n)$。\n- 平衡树(Balanced Trees)：其三个操作的时间复杂度都是 $O(\\log n)$。\n  - 红黑树(Red-Black Tree)\n  - AVL树(AVL Tree)\n- 哈希表(Hash Table)：其三个操作的平均时间复杂度都是 $O(1)$，最差情况下时间复杂度是 $O(n)$。\n\n---\n\n## 向量(Vector) (ADT)\n### 介绍\n向量(Vector)是一种抽象数据类型(ADT)。向量的主要目的是创建一个比数组(Array)更泛用的模型。\n\n其主要的特性是：\n- 一个元素在向量中的索引(index)被认为是前面元素的个数(number of elements prceding it)。\n  - 为了不完全依赖于数组，因此我们不使用“索引(index)”概念，而使用“前面元素的个数”概念。\n  - 例如对于一个向量 $A$ 来说，$A[2]$ 表示有 $2$ 个元素在它的前面，分别是 $A[0], A[1]$。\n  - 这个概念也可以被称为**排名(rank)**。\n- 与数组固定大小不同，向量一个自动调节大小的数据结构。\n\n### 向量ADT主要操作(operator)/方法\n- `Object elemAtRank(int r)`：返回 `rank` 为 `r` 的元素。\n- `Object replaceAtRank(int r, Object o)`：替换掉 `rank` 为 `r` 的元素为 `o`，并返回原来的元素。\n- `void insertAtRank(int r, Object o)`：在 `rank` 为 `r` 的位置插入新的元素 `o`。\n- `Object removeAtRank(int r)`：删除 `rank` 为 `r` 位置的元素。\n- `int size()`：返回向量大小。\n- `boolean isEmpty()`：返回向量是否为空。\n\n### 使用向量作为栈(Stack)\n栈(Stack)是一个先入后出(first in last out, FILO)的数据结构，其操作主要是：\n- `Object top()`：返回栈顶。\n  - 相当于 `elemAtRank(size())`。\n- `void push(Object o)`：在最后的元素(栈顶)后面添加一个新的元素。\n  - 相当于 `insertAtRank(size(), Object o)`。\n- `void pop()`：删除最后的元素(栈顶)。\n  - 相当于 `removeAtRank(size())`。\n\n### 基于数组的向量(Array-based Vector) (CDT)\n是使用一个大小为`N`的数组`V`作为向量的CDT，并使用整型变量`n`记录向量的大小。\n\n#### >操作/方法时间复杂度分析\n- `elemAtRank(r)`：可以直接返回`V[r]`，因此其时间复杂度是 $O(1)$。\n- `replaceAtRank(r, o)`：时间复杂度是 $O(1)$。\n- `insertAtRank(r, o)`：需要对原来的元素进行右平移，在最坏的情况下(即 $r = 0$ )时间复杂度是 $O(n)$。\n- `removeAtRank(r, o)`：需要对原来的元素进行左平移，在最坏的情况下(即 $r = 0$ )时间复杂度是 $O(n)$。\n- `size()`：直接返回变量 `n`，因此时间复杂度是 $O(1)$。\n- `isEmpty()`：直接返回 `n == 0`，因此时间复杂度是 $O(1)$。\n- `push(o)`：不需要进行平移。\n  - 如果**不需要扩大数组**时间复杂度是 $O(1)$。\n  - **扩大数组**需要平摊时间(amortized time)获取时间复杂度。具体可以看下面扩大数组中不同策略。\n- `pop()`：不需要进行平移，因此时间复杂度是 $O(1)$。\n\n平摊时间(amortized time)是从**一组**操作中每个操作平摊下来的时间。与平均时间(average time)不同，后者主要是针对**一次**操作的平均时间。\n\n#### >扩大数组(Resize Array)\n在`insertAtRank(r, o)` 和 `push(o)` 操作中，如果数组已经满了，那么需要替换数组为更大的数组。\n\n替换数组需要复制原来的数据到新的数据中。假设当前数组的大小为 $c$，每次替换所使用的时间为 $s_2$，那么这个过程需要的时间$T(c) = s_2c$，即这个过程的时间复杂度是 $O(c)$。\n\n扩大数组的方法一共有两种：\n- 增量策略(incremental strategy)：使用固定的常数 `c` 来进行扩大数组。\n  - 假设执行`push`的次数为 $n$，那么替换数组的次数一共为 $k = floor(n / c)$ 次。\n  - 假设$T(n)$是执行`push` $n$ 次所需要的运行时间，$s_1$是一次`push`所需要的时间，$s_2$是一次替换数组所需要的时间。\n    - $s_1$ 和 $s_2$ 都是常数。\n    - $T(n) = s_1n + s_2(c + 2c + ... + kc) = s_1n + s_2c\\frac{k(k+1)}{2}$，因此 $T(n)$ 是 $O(n^2)$。\n  - 平摊下来每次 `push` 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(n)$。这个是要比一般 `push` 操作所需要的时间复杂度 $O(1)$ 是要差的。\n\n- 双倍策略(doubling strategy)：双倍数组的大小。\n  - 假设执行`push`的次数为 $n$，那么替换数组的次数一共为 $k = floor(\\log n)$ 次。\n  - 假设$T(n)$是执行`push` $n$ 次所需要的运行时间，$s_1$是一次`push`所需要的时间，$s_2$是一次替换数组所需要的时间。\n    - $s_1$ 和 $s_2$ 都是常数。\n    - $T(n) = s_1n + s_2(1 + 2 + 4 + ... + 2^{k - 1}) = (s_1 + s_2)n - s_2$，因此 $T(n)$ 是 $O(n)$。\n  - 平摊下来每次 `push` 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(1)$。\n\n---\n\n## 树(Tree) (ADT)\n### 介绍\n树是一种抽象数据结构(ADT)。\n\n> In computer science, a tree is an abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.\n\n### 成员\n- `Node` 节点\n  - `element`  元素\n  - `parent` 父节点\n  - `children[]` 子节点\n- `root : Node*` 根节点：不具有父节点的节点。\n- `internal : Node` 内节点：具有至少一个子节点的节点。\n- `leaf / external : Node` 叶节点/外节点：不具有子节点的节点。\n- `ancestors : Node → Node[]` 祖先节点：(递归定义) 一个节点其父节点和其父节点的祖先节点的数组/集合。\n- `descendant : Node → Node[]` 祖孙节点：(递归定义) 一个节点其所有子节点和所有子节点的祖孙节点的数组/集合。\n- `depth : Node → Int` 节点的深度：该节点的祖先节点的个数(不包括自己)。\n  - 根节点的深度为0，根节点的子节点深度为1，以此类推。\n- `height : Tree → Int` 树的高度：最大的叶节点深度。或者说从根节点到叶节点最长的路径(不包括根节点)。\n  - 只有根节点的树的深度为0。\n\n### 树ADT主要操作/方法：\n#### > 基础方法 (Generic)：\n- `int size()`：返回树的大小。\n- `bool isEmpty()`：返回树是否为空。\n- `Iterator iterator()`：返回树的遍历所有元素的迭代器。\n- `Iterator positions()`：返回树的以一定顺序遍历位置的迭代器。\n#### > 接入方法 (Accessor)：\n- `Node root()`：返回树的根节点。\n- `Node parent(Node)`：返回节点的父节点。\n- `Iterator children(Node)`：返回节点的子节点迭代器。\n#### > 查询方法 (Query)：\n- `bool isInternal(Node)`：是否是内部节点。\n- `bool isExternal(Node)`：是否是叶节点。\n- `bool isRoot(Node)`：是否是根节点。\n\n### 树的遍历 (Traversals)\n#### > 前序遍历 Preorder Traversal \n先遍历父节点，再从左到右遍历其子节点。\n\n```\nAlgorithm preOrder(v)\n  visit(v)\n  for each child w of v\n    preorder(w)\n```\n\n#### > 后序遍历 Postorder Traversal\n先遍历子节点，再遍历父节点\n\n```\nAlgorithm postOrde(v)\n  for each child w of v\n    postOrder(w)\n  visit(v)\n```\n\n---\n\n## 二叉树(Binary Tree) (ADT)\n### 定义\n二叉树是一种抽象数据结构(ADT)。\n\n- 一般定义：\n>  a tree whose each internal node has at most two children, and the children of a node are an ordered pair, though one might be “missing”.\n\n- 递归定义：\n> A tree consisting of a single node, or a tree whose root has an  ordered pair of “children”, each  of which is missing (a null) or is  the root of a binary tree\n\n- 特点：\n  - 每个节点最多有两个子节点\n  - 节点之间是有序的，即左子节点和右子节点，尽管有一个是空节点。\n\n### 性质\n#### > 合适/完满二叉树 (proper/full binary tree)\n> A binary tree is said to be “proper” (a.k.a. “full”) if every internal node has exactly 2 children.\n如果二叉树的所有内部节点都具有两个子节点，那么称这个二叉树是合适/完满二叉树。\n\n#### > 完美二叉树 (perfect binary tree)\n> A binary tree is perfect if it is proper and all leaves are at the same depth.\n如果一个满二叉树中所有的子节点都在同一个深度，那么称这个二叉树是完美二叉树。\n\n- 在深度 $d$ 拥有的节点的个数为 $2^d$\n- 在深度 $d$ 及其以下的深度总结点个数为 $2^{(d+1)}-1$\n- 高度为 $h$ 的树总节点为 $n$，那么有 $h = \\log_{2}(n+1) - 1$，$n = 2^{(h + 1)} - 1$\n\n#### > 完全二叉树 (complete binary tree)\n> 除了叶节点所处的深度以外，其他深度是一个完美二叉树，并且叶节点是靠右排序的二叉树是完全二叉树。\n\n### 二叉树的遍历 (Traversals)\n除了树通用的前序遍历和后序遍历以外，还有一个中序遍历(Inorder Traversal)：\n\n先遍历左子节点，再遍历该节点，最后遍历子节点。\n\n```\nAlgorithm inOrder(v)\n  if hasLeft(v)\n    inOrder(v.left)\n  visit(v)\n  if hasRight(v)\n    inOrder(v.right)\n```\n\n### 二叉树的效率分析\n- 求树的高度：如果树的大小为 $n$，那么：\n  - 对于完美二叉树来说，时间复杂度是 $\\Theta(\\log(n))$。\n  - 对于非完美二叉树来说，考虑到一条链，时间复杂度是 $\\Omega(\\log(n))$ 和 $O(n)$。\n\n### 基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)\n它也可以被称为 **树形数组(tree-as-array)**。它是一种使用数组作为CDT实现二叉树ADT的方式。\n\n一般使用 `int rank(Node)` 来表示节点的数组索引。注意，它返回的是**整型**。\n- `rank(root) = 1`：根节点的索引是 $1$。\n- `rank(parent(node)) = rank(node) >> 1`：每个节点的父节点是该节点的索引除以 $2$。\n- `rank(left_child(node)) = rank(node) << 1`：每个节点的左节点是该节点的索引乘以 $2$。\n- `rank(right_child(node)) = rank(node) << 1 + 1`：每个节点的右节点是该节点的索引乘以 $2$ 加 $1$。\n\n树形数组的优点：\n- 能够节省空间。因为不用储存相关的指针，而是使用计算代替。\n- 储存能够更紧凑，具有更好的内存局部性\"better memory locality\"。\n- 很好地解决缓存和内存层次结构的问题——当访问数组元素时，其他条目可以被拉入缓存，因此访问速度更快。\n\n---\n\n## 优先队列(Priority Queue) (ADT)\n### 介绍\n优先队列是一个抽象数据结构(ADT)。优先队列是储存一组具有 `(key, value)` 的数据结构，并能够有效地返回和操作其中具有最小/最大 `key` 的元素。\n\n一般我们默认优先队列是**最小优先队列(Min-Priority Queue)**，也就是返回/操作拥有最小`key`的元素。\n\n### 优先队列ADT主要操作/方法：\n- `void insert(k, v)`：插入一组`(k, v)`的元素。\n- `Element removeMin()`：删除并返回具有最小`key`的元素。\n- `Element min()`：返回具有最小`key`的元素。\n- `int size()`：返回元素个数。\n- `bool isEmpty()`：优先队列返回是否为空。\n\n### 基于二叉堆(Binary Heap)的优先队列 (CDT)\n本笔记中默认的二叉堆是 **小根堆**。\n\n>  A binary heap is a complete binary tree storing key-value pairs at its nodes.\n二叉堆是将 `(key, value)` 对储存在节点的完全二叉树。\n\n*除了二叉堆以外，还有二项式堆(Binomial Heap)和斐波那契堆(Fibonacci Heap)。*\n\n二叉堆具有以下的性质：\n- Heap-Order：对于每一个除了根以外的节点，都有 `key(v) >= key(parent(v))`。\n  - 即子节点的值不会比父节点更小。\n  - 那么堆顶，即二叉堆的根节点是所有节点中的最小值。\n- Complete Binary Tree：是一个二叉树。因此如果一共有 $n$ 个节点，则树的高度为 $h = \\log n$。\n\n#### 堆的插入(insert)\n步骤如下：\n1. 根据完全二叉树性质寻找插入点 $Z$ 作为叶节点。\n2. 储存 $key$ 值给点 $Z$。\n3. 恢复堆序属性(`unheap`操作)：将插入点 $Z$ 从下到上进行 **冒泡**，如果父节点的 `key` 值比 $Z$ 大，那么就交换两个节点的位置或元素，直到父节点的 `key` 值比 $Z$ 小或者已经到达根节点。\n\n关于 $1$，如果使用结构体模拟树的结构，那么时间复杂度可能会达到 $O(n)$。但是如果使用数组作为CDT模拟二叉树(具体可看上方二叉树中基于数组的二叉树，树形数组)，那么只需要在数组的末尾插入新的节点即可，此时的时间复杂度是 $O(1)$。\n关于 $3$，因为二叉树的高度是 $h = \\log n$，因此 `upheap` 操作的时间复杂度是 $O(\\log n)$。\n\n#### 堆的删除(remove / pop)\n堆的删除指的是删除堆顶。步骤如下：\n1. 使用最后一个节点 $w$ 代替根节点。\n2. 删除 $w$ 原节点。\n3. 恢复堆属性(`Downheap`操作)：选择两个子节点中**最小**的子节点，如果该子节点的`key`值比 $w$ 节点的小，那么就交换两个节点的位置或元素，直到所有子节点的 `key` 值比 $w$ 大或者已经达到叶节点。\n\n---\n\n## 映射(Maps) (ADT)\n### 介绍\n> A map models a collection of `(key, value)` entries that is searchable by the `key`.\n\n性质：\n- 具有搜索、插入、删除元素的功能。\n- 具有相同 `key` 值的元素是不被允许的。\n\n### 映射ADT主要操作/方法：\n- `Value get(Key k)`：如果存在`key`相应的元素，则通过 `key` 获取相应的 `value`，否则返回 `NULL`。\n- `Value put(Key k, Value v)`：插入 `(key, value)` 对。如果已经存在 `key` 在映射里则返回 `NULL`，否则返回 `value`值。\n- `Value remove(Key k)`：如果存在`key`相应的元素，则通过 `key` 来删除并返回该元素的 `value`，否则返回 `NULL`。\n- `int size()`：返回元素个数。\n- `bool isEmpty()`：返回是否为空。\n- `Iterator keys()`：返回 `key` 的迭代器。\n- `Iterator values()`：返回 `value` 的迭代器。\n- `Iteraotr entries()`：返回 `(key, value)` 的迭代器。\n\n### 基于简单链表的MAP (CDT)\n- `get(k)`：遍历链表来寻找 `key`。时间复杂度是 $O(n)$。\n- `put(k, v)`：遍历链表来寻找是否有重复的 `key`，如果没有则插入到链表中。时间复杂度是 $O(n)$。\n- `remove(k, v)`：遍历链表来寻找 `key`。时间复杂度是 $O(n)$。\n\n因为链表的特性（具有较差的访问能力），因此无论是排序的链表还是未排序的链表（链表无法使用二分查找法），时间复杂度操作都是 $O(n)$。\n\n### 基于哈希表的MAP (CDT)\n基本思想：将每个 `key` 转化成 `index` 放入一个较大的数组 `Array` 中。\n\n哈希表的特性：\n- 哈希值 (hash value)：由哈希函数得到的值被称为哈希值。\n- 哈希码 $h_1$ (hash code)：是一个键值转一个整型的函数，即`keys → integers`。一些可能的方法：\n  - 将 `key` 的内存地址作为哈希码。\n  - 将 `key` 的 `bit` 值转化成整型作为哈希码。一般用于内存不大于整型的数据类型，例如`byte, short, int, float`。\n  - 将 `key` 的 `bit` 值划分成相同长度的部分，对这些部分求和(忽略溢出)。适用于内存大于整型的数据类型，例如 `double, long`。\n  - 多项式累积方法。\n- 压缩函数 $h_2$ (Compression function)：是一个将整型压缩到一定范围的函数，即`integers → [0, N-1]`。一些可能的方法：\n  - 除法(Division)：$h_2(x) = x \\mod N$。\n    - $N$ 通常是一个素数。\n  - 乘加除法(Multiply, Add and Divide (MAD))：$h_2(x) = (ax + b) \\mod N$。\n    - $a, b$ 是非负整数。\n    - $a \\mod N \\neq 0$，否则无论 $x$ 为多少总会映射到 $b$。\n- 哈希函数 $h$ (hash function)：是一个将对象(Object)映射到一个固定的范围 $[0, N-1]$ 整型的函数。\n  - 此时有 $h(x) = h_2(h_1(x))$。\n  - 哈希函数的主要目的是使用明显**随机**的方式来将 `keys` **分散**。\n  - 分散的目的是为了减少冲突(Collision)。\n  - 随机的目的是为了减少模式(Pattern)，从而减少冲突。\n- 冲突 (Collision)：当不同的元素获取到相同的索引时，会发生冲突。一些可能的解决方法：\n  - 分离链(Separate Chaining)：让相同 `index` 的元素以链表的形式连接起来。\n  - 二叉搜索树(Binary Search Tree)。\n  - 开放地址(Open addressing)：让冲突的新元素放入到下一个可用的数组中。一些可能的方法：\n    - 线性探索(Linear probing)：使用一个常数 $c$ 来进行冲突元素的新元素寻址，即$h(k) + c$。\n      - 一般使用循环数组作为哈希表。\n      - 可能会导致未来新元素使用更长的时间来寻址。\n      - 如果数组满了可能会导致死循环，因此要规定最多循环次数。\n      - 如果中间有冲突的数组被删除，可能会导致后面冲突的数组查询失败。\n        - 一个删除的解决方案是不断检测右边是否具有相同的哈希值，如果相同则将该数值重新插入。\n        - Lazy deletion延迟删除：将被删除的数值标记为“删除”，只当用到它的时候再进行修复。当被查询到“删除”标记的点时直接跳过而不是停止。\n    - 双哈希(Double Hashing)：使用一个额外的哈希函数 $d(k)$ 来辅助寻找新元素。\n      - 新的哈希值为 $(h(k) + j\\ d(k))\\mod N, j\\in[0, N-1]$，选择第一个空元素作为哈希值。一些可能的 $h(k)$：\n        - $d(k) = q - (k \\mod q)$，其中 $q < N$ 且 $q$ 是素数。\n      - 对于线性探索来说，$d(k) = 1$。\n      - $N$ 必须是素数，以探索所有的可能数组包。\n\n那么使用哈希表来实现`Map`主要的思路是：\n- 寻找哈希函数：将 $(k,v)$ 储存在 $i = h(k)$ 索引的数组中。\n- 处理冲突。\n\n#### 基于分离链(Separate Chaining)处理冲突的方法\n因为分离链定义让相同 `index` 的元素以链表的形式连接起来，其中链表中每个节点还有一个单独的 `key` 值用于寻找具体的元素。\n\n那么链表的每个节点应该具有以下的操作，假设有 $m$ 个冲突的元素：\n- `Element get(k)`：获取`key = k`的元素。其时间复杂度是 $O(m)$。\n- `Element put(k, v)`：放入`(k, v)`对的元素，需要检测是否有相同 `key` 的元素，如果有则返回`null`。因此时间复杂度是 $O(m)$。\n- `Element remove(k)`：删除`key = k`的元素。其时间复杂度是 $O(m)$。\n\n那么使用基于分离链哈希表的`map`具体实现方式如下：\n- `get(k)`：`return A[h(k)].get(k)`。\n- `put(k, v)`：`return A[h(k)].put(k)`。注意要让 `size++`。\n- `remove(k)`: `return A[h(k)].remove(k)`。注意要让 `size--`。\n\n对于每个操作，最佳访问时间是 $O(1)$，最差访问时间依然是 $O(n)$，即全部都有冲突。但是平均下来，其时间复杂度应该是 $O(n / N)$，其中 $N$ 是哈希表数组的容量。\n\n#### 哈希函数的性能分析\n在最坏的情况下，搜索、插入和删除的时间复杂度都是 $O(n)$。\n\n一般用负载因子(load factor) $\\alpha = n / N$ 来表示哈希表的性能。\n\n哈希表各个操作的期望值基本上都是 $O(1)$。具体证明可自行查阅。\n\n---\n## 二叉搜索树(Binary Search Tree) (ADT)\n> A binary search tree is a binary tree storing `(key,value)` entries at its internal nodes and satisfying the following “search tree” property.\n二叉搜索树是一个储存`(key,value)`值到节点的二叉树，并满足下面的性质：\n\n性质：\n- 对于任意一个内部节点 $v$，拥有左子节点 $u$ 和 右子节点 $w$，满足 `key(u) <= key(v) <= key(w)`。\n- 对于任意一个节点 $v$，其左边子辈的值都比 $v$ 小，右边子辈的值都比 $v$ 大。\n- 换句话说，二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据`key`升序的。\n\n### 二叉搜索树ADT主要操作/方法\n- `Node search(Key k)`：返回`key = k`的节点，如果没有则返回`null`。\n  - 实现：比较当前节点储存的`key` 与 `k` 相比较，如果等于则返回。如果`k`大则查找右节点，如果`k`小则查找左节点。如果不存在节点，则返回`null`。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n  - 如果是平衡二叉树，则时间复杂度是 $O(\\log n)$。\n- `void insert(Key k, Value v)`：插入 `(k, v)` 对。\n  - 实现：使用二分法找到要插入的位置，将其插入进去。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n- `Node remove(Key k)`：删除 `key = k` 的节点。\n  - 实现：使用二分查找找到要删除的节点删除，分为下面四个情况：\n    - 没有找到该节点，此时返回 `null`。\n    - 该节点是叶节点，此时删除该节点。\n    - 节点具有一个子节点，将该子节点替换到原来的位置。\n    - 节点具有两个子节点，此时根据树的中序遍历找到当前`key`的下一个`key`节点 $w$ ($w$ 称为该节点的中序后继)，并使用这个节点 $w$ 替代该节点，再尝试删除 $w$，直到不符合被删除的节点具有两个子节点为止。\n  - 时间复杂度是 $O(h)$，其中 $h$ 是树的高度。\n\n### 平衡二叉树(Balanced Trees)\n平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。\n平衡二叉树的高度 $h = \\log n$。\n\n一般使用旋转(notation)的方法来让二叉搜索树逐步变成平衡二叉树。\n\n#### 一次旋转 (Single Rotation)\n一次旋转适合三个高度节点之间呈类似于 `\\` 和 `/` 的直线形。也就是中间高度的节点是中间值的情况。\n\n过程如下：\n- 选择一个节点 $P$。\n- 选择该节点的一个子节点 $C$。\n- 交换两个节点：\n  - 选择 $C$ 中相反方向的子节点 $V$：如果 $C$ 是 $P$ 的左节点，那么就选择 $C$ 的右节点。否则选择左节点。\n  - 处理 $P$ 的父节点：\n    - 将 $P$ 的父节点相应方向的子节点修改为 $C$。\n    - 将 $C$ 的父节点修改为 $P$ 的父节点。\n    - 如果 $P$ 为根节点，那么修改根节点为 $C$。\n  - 处理 $C$ 的子节点 $V$：\n    - 将 $V$ 的父节点修改为 $P$。\n    - 将 $P$ 原来方向上的子节点 $C$ 的位置修改为 $V$。\n  - 处理 $C$ 和 $P$：\n    - 将 $C$ 原来 $V$ 位置的子节点修改为 $P$。\n    - 将 $P$ 的父节点修改为 $C$。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png\" alt=\"平衡二叉树旋转\" width=\"650\">\n\n整个过程时间复杂度是 $O(1)$。\n\n#### 二次旋转 (Double Rotation)\n\n诸如下图中的类似 `>`和`<` 形，是无法使用一次旋转的，如果只旋转`a` 和 `c` 将无法改变高度。\n\n此时需要先将`>`或`<`形旋转成`/`或`\\`形，再进行一次旋转。整个过程被称为二次旋转，如下图。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png\" alt=\"平衡二叉树二次旋转\" width=\"650\">\n\n具体的其他二叉树方法将（例如AVL树、红黑树）不在本笔记中展示。可能会未来在其他笔记中展示。\n\n#### \n\n---\n\n# 五. 算法\n\n算法的设计思路通常有这么几种：\n- 暴力搜索(Brute Force)：生成所有潜在解决方案并测试哪些是实际解决方案。时间复杂通常非常高，是属于多项式级其以上的时间复杂度。\n- 分而治之(Divide and Conquer)：递归地将问题分解成更小的部分并逐步解决它们，然后将它们重新组合在一起。是一种比较高效的设计思路。\n- 启发式(Heuristics)：是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n- 动态规划(DP)：DP是一种适用于最优解满足“分解性质”情况的通用方法。\n\n---\n\n## 排序算法(Sorting algorithms)\n排序算法的性质：\n- 排序稳定性(Stability)：如果两个元素键值相等，排序算法会保留这两个元素的相对位置。\n- 排序自适应性(Adaptive)：如果数组已经接近已排序，那么算法的效率会提高。\n- 排序接入模式(Access Patterns)\n  - Sequential Access：数据的读取和写入是按照其在存储器中存放的顺序进行的。\n  - Random Access：数据储存中能够在常数时间 $O(1)$ 内直接访问任意位置的数据。\n- 是否需要额外空间。\n\n如果没有特殊说明，以下算法都默认**从小到大排序/升序**、使用 **数组(array)** 作为数据结构。\n\n### 基于比较的排序算法的一些思考\n如果一个排序算法仅包含关于成对比较元素的信息，那么就称这个排序是**基于比较**的(comparison-based)。\n\n并不是所有的排序算法都是基于比较的，例如桶排序(bucket sort)是使用实际的值来进行排序的，其时间复杂度是$O(n)$，但是其实现依赖于其值的范围。是一种使用空间换取时间的方法。\n\n对于 $n$ 个数的数组来说，它一共拥有 $n!$ 种排序方法。我们使用基于比较的算法来对数组进行排序是通过两两比较来减半它排序方法的可能性。也就是说，基于比较的排序算法本质其实是逐步将 $n!$ 减半成 $1$。\n\n这意味着我们需要去做 $\\log_2(n!)$ 次比较。实际上 $O(\\log(n!)) = O(n \\log n)$。也就是说基于比较的算法不能比 $O(n \\log n)$ 更优。\n\n---\n\n### 1. 冒泡排序(Bubble sort)\n#### 基本思想\n让大的元素逐渐往后移动。\n- 外部循环(Outer loop)：扫描整个数组。\n- 内部循环(Inner loop)：对于数组每个元素与右边邻域对比，如果右边邻域更小则立即交换。\n\n#### 算法思考\n因为算法中最大元素像水泡一样逐渐向上冒，因此被称为冒泡排序。\n\n#### 复杂性分析\n考虑到最差的情况，也就是每次循环都会进行交换。外部循环次数为$(n - 1)$，假设当前外部循环$index = i$，那么内部循环次数为 $(n - i - 1)$，因此总循环次数为 $\\frac{n(n - 1)}{2}$。\n\n假设比较和交换原始操作数为 $t$ 为常数，循环以外的原始操作数为 $k$ 为常数，那么总原始操作数为 $\\frac{n(n - 1)}{2} + t(n - 1) + k$。\n\n根据删除规则，我们可以知道它的时间复杂度是 $O(n^2)$。\n\n此外，也可以使用递归关系来证明冒泡排序的时间复杂度：\n\n:::details 使用递归关系证明冒泡排序的时间复杂度\n\n首先冒泡排序并不是天然递归的，而是一个双重循环。\n\n但是我们能使用递归思想来将冒泡排序改成递归：如果要将长度为 $n$ 的数组进行排序，首先将这个数组中的最大数值通过冒泡操作交换到当前数组最右边的位置并固定，随后再将剩下 $n - 1$ 的数组进行排序(递归)。\n\n这样就写出其运行时间的递推公式：\n$$\n\\begin{aligned} \nT(n) & = dn + T(n - 1) \\\\\nT(1) & = 1\n\\end{aligned}\n$$\n- $dn$ 表示通过冒泡操作交换所需要的时间。\n- $T(n - 1)$ 表示剩余数组排序所需要的时间。\n\n我们可以根据等差数列求出 $T(n)$ 的通项公式为：\n$$T(n) = 1 + (\\frac{n(n+1)}{2} - 1) d$$\n\n那么很明显 $T(n)$ 是 $\\Theta(n^2)$。\n\n:::\n\n#### 算法的性质。\n- 如果相同的元素不进行交换，那么该算法 **具有** 稳定性。\n- 可以通过添加变量来让算法 **具有** 自适应性（内部循环没有进行任何交换）。\n- 不需要额外的空间。\n- 可适用于单向链表的`swapElement(Node, Node)`，时间复杂度不变。\n\n---\n\n### 2. 选择排序(Selection sort)\n#### 基本思想\n保持数组后面的元素不变作为**已排序**的元素，前面的元素作为**未排序**的元素，选择**未排序**的元素组中最大的元素插入到**已排序**元素组的头部。\n- 外部循环：扫描整个数组。\n- 内部循环：扫描整个**未排序部分**的数组。并不会让最大的元素立即交换，而是记录住最大元素的位置。等内部循环扫描完，将被记录的元素：\n  - 插入到**已排序部分**的数组的最左边。或者：\n  - 与**未排序部分**的数组最右边的元素交换并将其加入到**已排序部分**数组。\n\n#### 算法思考\n与冒泡排序不同，冒泡排序是比较当前元素和其邻域，而该排序是比较当前元素和被记录的元素。\n为什么要延迟交换而不是立即交换：\n- 如果交换操作可能会比较昂贵，并不像数组一样是$O(1)$，那么就需要尽可能减少交换次数。\n- 如果数组非常大，那么需要尽可能地减少交换次数来提高效率。\n\n#### 复杂度分析\n相比于冒泡排序，它们具有相同数量的迭代和比较，仅仅是有更少数量的交换。\n\n因此它的时间复杂度也是$O(n^2)$。\n\n#### 算法的性质。\n- 该算法 **不具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 不需要额外的空间。\n- 可适用于单向链表的`swapElement(Node, Node)`，时间复杂度不变。\n\n---\n\n### 3. 插入排序(Insertion sort)\n保持数组前面元素的排序不变作为**已经排序**的元素，后面的元素作为**未排序**的元素。选择当前**未排序**元素不断交换左边比该元素大的元素，并将其加入到**已经排序**的元素。\n- 外部循环：扫描整个数组。\n- 内部循环：获取并记录当前**未排序**元素的最左边元素，从右到左扫描**已经排序**的元素，如果被扫描的元素比记录的元素大，那么就交换，直到被扫描的元素比记录的元素小。\n\n#### 复杂度分析\n- 在最坏的情况下，它的外部原始操作数是 $O(n)$，内部原始操作数是 $O(n)$，因此它的总时间复杂度是$O(n * n) = O(n^2)$。\n- 在最佳的情况下，它内部循环操作数是 $O(1)$，那么它的总时间复杂程度是 $O(n * 1) = O(n)$。\n\n#### 算法的性质\n- 如果相同的元素不进行交换，那么该算法 **具有** 稳定性。\n- 该算法 **具有** 自适应性。\n- 不需要额外的空间。\n- 不适用于单向链表。适用于双向链表。\n\n--- \n\n### 4. 归并排序(Merge sort)\n归并排序是一个基于分而治之(divide-and-conquer)的算法，它是先划分再排序。\n- 分解 (Divide)：将待排序的数组 $S$ 分解为两个部分 $S_1$, $S_2$。\n  - 分解直到只剩下单个元素或者空元素为止。因为单个元素的数组一定是已经排序好的数组。\n  - 分解只是简单的数学运算，因此时间复杂度是 $O(1)$。\n- 递归 (Recur)：递归地将 $S_1$ 和 $S_2$ 进行排序(带入到分而治之中)。\n  - 递归分解，回归组合。\n  - 递归全部子集的时间复杂度是 $O(\\log(n))$。\n- 组合 (Conquer)：将已排序的 $S_1$ 和 $S_2$ 合并(merge)。\n  - merge是基于两个已经排序好的数组进行的：依次判断两个数组当前第一个数(最小的数)，选择最小的一个放入到新的数组后面，直到有一个数组为空后，将另一个数组剩余的元素依次放入到新的数组后面。\n  - 假设放入的操作时间复杂度是$O(1)$，那么合并的时间复杂度是 $O(n)$。\n\n归并排序递归调用的过程是一个二叉树结构。\n\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png\" alt=\"归并排序\" width=\"450\">\n\n#### 复杂度分析\n综上所述，归并排序的时间复杂度是 $O(n\\log{n})$。\n此外可以使用递归关系来证明归并排序的时间复杂度，详细请见 **三.Master定理** 中 **递归关系** 中的样例。\n归并排序需要用到额外的空间，因此其空间复杂度是 $O(n)$。\n*也可以使得空间复杂度是 $O(1)$，但是过于混乱一般不作考虑。*\n\n#### 算法的性质\n- 在归并遇见相等数据时，如果优先选择左边数组那么该算法 **具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 该算法 **需要** 额外的空间。\n- 该算法对数据的访问是顺序的(sequential)，因此在硬盘中具有较好的排序效率。\n- 因为依赖于快速对中间的数据进行访问，因此不太适合使用链表。\n\n---\n### 5. 快速排序(Quick Sort)\n快排是一个基于分而治之的算法，它是先排序后划分。\n- 分解 (Divide)：称之为`partition`操作。选择一个元素 $x$ 称之为枢(pivot)，并将数组 $S$ 分为：\n  - $L$：元素小于 $x$ 的。\n  - $GE$ 元素大于等于 $x$ 的。\n  - `pivot`经常是使用随机选择。\n  - 假设 交换 或者 删除再插入 的时间复杂度是$O(1)$，那么分解的时间复杂度是 $O(n)$。\n- 递归 (Recur)：对 $L$ 和 $GE$ 使用进行递归排序，带入到分而治之中。\n  - 最差的情况下，选择的枢总是最小/最大值，那么此时递归所有的子集时间复杂度是 $O(n)$。\n  - 最佳的情况下，选择的枢总是中间值，那么此时递归所有的子集时间复杂度是 $O(\\log n)$。\n- 组合 (Conquer)：将 $L$ 和 $GE$ 左右连接起来。\n  - 组合只是简单的连接，时间复杂度是 $O(1)$。\n\n快速排序递归调用的过程是一个二叉树结构。\n\n#### 快速算法的分解(Divide)实现形式\n该操作称为`partition`操作。\n- 使用额外的空间进行分解，具体思想如下：\n  1. 创建两个数组，分别表示 $L$ 和 $GE$。\n  2. 选择一个枢(pivot)。\n  3. 从左到右遍历数组，将小于枢的数加入到 $L$，将大于等于枢的数加入到 $GE$。\n\n- 使用双指针的方法进行分解，这个方法是就地(in-place)，步骤如下：\n  1. 选择一个枢(pivot)。\n  2. 定义两个指针 $j$ 和 $k$，分别初始化指向数组的开头和结尾。\n  3. 使用 $j$ 向右扫描，直到找到第一个 $\\geq$ 枢的元素 或者 $j == k$ 停止。\n  4. 使用 $k$ 向左扫描，直到找到第一个 $<$ 枢的元素 或者 $j == k$ 停止。\n  5. 交换 $j, k$ 的元素。\n  6. 如果 $j < k$，则返回 $3$。\n  7. 此时 $j == k$，并且此时 $j, k$ 的位置元素等于枢，也是 $GE$ 位置的左边界线。\n\n#### 算法的思考\n如果选择枢的方式是固定而不是随机的(例如总是选择第一个值作为枢)，并且出现了 $L$ 子集是空的情况(此时选择的枢是最小值)，那么此时会导致算法出现死循环。因为每次对 $GE$ 子集进行排序时，总是会选择最左边的值(也是最小值)作为枢，从而导致 $L$ 子集是空的情况。\n> 快速排序要避免固定选择枢和出现一方子集是空集的情况，否则可能会导致死循环。\n- 解决方法1：使用随机的方式选择枢。\n- 解决方法2：将排序分为三个部分，分别是 $L$, $\\{pivot\\}$, $E+G$。\n- 解决方法3：三点取值，选择最左边的数、中间的数和最右边的数中的中位数作为枢。\n\n#### 复杂度分析\n- 最差的情况下，快速排序的时间复杂度是 $O(n^2)$。\n- 最佳的情况下，快速排序的时间复杂度是 $O(n\\log{n})$。\n- 平均情况下，在一半的时间中快速排序选择的枢是中间值，那么时间复杂度是 $O(n\\log{n})$。\n  - 也可以认为平均情况下，选择的枢值总是让两个子集分解成 $\\frac{1}{3}$ 和 $\\frac{2}{3}$ 两个区域，也就是说递归二叉树的高度是 $\\frac{3}{2}\\log n$。\n  - *具体证明可以自行查看[维基百科](https://en.wikipedia.org/wiki/Quicksort)*。\n\n快速排序不需要用到额外的空间，因此其空间复杂度是 $O(1)$。\n\n#### 算法的性质\n- 快速排序 **不具有** 稳定性。\n- 该算法 **不具有** 自适应性。\n- 该算法 **不需要** 额外的空间，是就地(in-place)的算法。\n- 该算法对数据的访问是随机的(randomized)。\n- 因为是使用 交换 或者 删除再插入 操作进行，因此可以使用双向链表。\n\n---\n\n## 启发式算法(Heuristics)\n启发式算法是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n通常有两种：\n1. 程序中的决策可以给出准确/最佳的答案，但通常是为了加快程序运行速度。\n    - 例如，A*搜索算法中使用可接受的启发式方法(Admissible heuristic)、在快速排序算法中使用随机选择的方式选择枢(pivot)。\n2. 程序中的决策可能不会给出最佳答案，但旨在给出以其他方式无法获得的良好答案。\n    - 一般用于解决一些`NP-hard`问题，例如 TSP问题、图染色问题等。\n    - 例如 遗传算法、模拟退火。\n    - 具体可以参考[AIM-优化算法](/post/笔记%2F笔记-AIM-优化算法)笔记。\n\n### 贪心算法(Greedy)\n贪心算法是一种常见的启发式算法。贪心算法是做出短期内看起来最好的决定，而不考虑未来的策略。\n\n一些贪心算法可以得到最优解，例如最小生成树(Minimal Spanning Tree, MST)中Prim算法。\n\n大部分贪心算法无法给出最优解，但是可以给出接近最优的解。\n\n#### 最小生成树问题(Minimal Spanning Tre, MST)\n问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。\n问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。\n\n##### Prim算法\n思路：\n1. 选择任意顶点 $M$。\n2. 选择对外可以连接到的所有的点中最小的那个边，并将边加入到 `MST`中，将点加入到内部的点中。\n3. 是否全部连接，如果没有则返回 $2$。通过已连接的边个数判断，即 边的个数 $e = n - 1$。\n\n算法实现：\n- $1.$ 初始化数组 `value[n] = inf`，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数`m = 0`。\n- $2.$ 随机选择一个点 $M$。\n- $3.$ 使`value[M] = 0`，并根据 $M$ 连接的所有边 $(M, V)$ 更新 `edge` 数组。即 \n```\nvalue[M] = 0              # 因为已经被连接，所以更新为0\nforall e in edge(M)\n  v = e.v                 # 获取边连接的另一个点\n  if(e.value < value[v])  # 根据边权值更新对外连接点的大小\n    value[v] = e.value \n```\n- $4.$ 找到 `value[v] != 0` 中最小的点 $V$，使 `value[V] = 0`，`m++`。\n- $5.$ 跟 $3$ 一样根据 $V$ 连接的所有边 $(V, U)$ 更新 `edge` 数组。\n- $6.$ 判断是否所有的点已经连通，即 `(m - 1) == n`，如果没有则返回 $4$。\n\n---\n\n## 动态规划(Dynamic Programming, DP)\n> DP is a general method that can be suitable when the optimal solutions satisfy a “decomposition property”.\nDP 是一种适用于最优解满足“分解性质”情况的通用方法。\n\nDP的步骤通常如下：\n1. 将最优解分解为子解相当于将问题分解为子问题，并且子解对于子问题是最优的。\n2. 因此，最优解可以通过更小的子问题的最优解来构建。\n\n*与分治法不同的是，DP中的子问题可以重叠，即不同的路径可能会遇见相同的子问题。*\n\n因此DP的思想通常是，对于某一个解 $S_n$，如果我想要得到这个解，我该直到哪些解才能得出这个解，并依次获取和尝试合并这些可能解的组合。又或者说，我现在已知某一个解，我是否可以让这个解和其他输入/解组合获取一个新的解。其中这个“得到”和“获取”的过程是一个状态转移的过程，这个过程是一个状态转移方程/贝尔曼方程(Bellman Equation)。\n- 例如，假设有这样一个问题：给出一个整型集合 $S$，和一个目标值 $K$，我是否可以找出一个 $S_{sub}$ 的子集，其元素的和等于 $K$。\n  - 假设我们输入 $S[i], 0 \\leq i \\leq (n-1)$ 是集合第 $i$ 个元素。\n  - 我们使用 $dp[i][m] = true, 0 \\leq m \\leq K$ 来表示使用前 $i$ 个元素组成的子集中 $S_{sub}$ 元素和可以等于 $m$。\n  - 如果我们知道 $dp[i - 1][m] = true$，那么可以根据它和当前元素 $S[i]$ 得出 $dp[i][m + S[i]] = true$。\n  - 如何知道$dp[i - 1][m] = true$? 只需要对 $m$ 进行遍历 $(0 \\leq m \\leq K-S[i])$ 依次检查是否为`true`即可。\n  - 由此我们就可以得到状态转移方程：$dp[i][m] = dp[i][m]\\ \\text{ | } \\ dp[i - 1][m - S[i]]$。\n  - 时间复杂度是 $O(kn)$。\n  - 此外我们可以使用滚动数组将其变成一维dp，此时对容量 $m$ 的遍历是倒着的（如果正着就会导致元素 $i$ 被重复计算，此时属于完全背包问题）。\n\n*与暴力搜索，暴力搜索是将所有可能的答案依次列出来并测试，答案之间可能没有太大的关系。而动态规划是根据状态转移来尝试获取哪些解。*\n\n---\n\n## 最短路算法(Shortest Path)\n最短路算法分为单源最短路和多源最短路。\n解决单源最短路的一种方法是 `Dijkstra` 算法，其时间复杂度是 $O(n\\log n + m)$。如果将其应用在多源最短路的话，那么其时间复杂度是 $O(n(n\\log n + m))$。\n\n此外，有一个特定的算法用来解决多源最短路，就是`Floyd-Warshall (FW)`算法，该算法的时间复杂度是 $O(n^3)$。\n\n### Floyd-Warshall (FW)\nFW算法是一个动态规划的算法，通过逐步加入点来构造子答案从而获取整体最优解的方法。\n适用于负数边、有向边的情况。\n\n- 定义：\n  - 定义 $d(i,j,k)$：表示点在 $i,j$ 之间使用 $\\{1,...,k\\}$ 作为允许使用的潜在中间点的最短路。\n    - 例如 $d(2,5,3)$：在仅使用 $\\{1,2,3\\}$ 其中的点作为中间点（这些点可以使用也可以不使用，但不能使用其他的点）时点 $2$ 到点 $5$ 的最短路。\n\n  - 定义 $w(i, j)$：表示两个点之间的距离。\n    - 如果不连通则等于 $\\infty$，即 `w(i, j) = inf`。\n    - 自边等于 $0$，即 `w(i, i) = 0`。\n\n- 初始化：对于所有的两个点之间：$d(i, j, 0) = w(i, j)$。\n\n- 状态转移方程：考虑当 `k = k + 1`时，即对于每两对点之间在前 `k` 个点已经加入好，那么有：\n$$d(i, j, k+1) = \\min (d(i, j, k), d(i, k+1, k) + d(k+1, j, k))$$\n\n---\n\n# Reference\n1. \"Big O Notation.\" Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Big_O_notation. Accessed 19 May 2024.\n2. \"Recurrence Relation.\" Wikipedia, The Free Encyclopedia, 8 April 2024, en.wikipedia.org/wiki/Recurrence_relation. Accessed 20 May 2024.\n3. \"Master Theorem (Analysis of Algorithms).\" Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms). Accessed 22 May 2024.\n4. \"Quicksort.\" Wikipedia, The Free Encyclopedia, 12 May 2024, en.wikipedia.org/wiki/Quicksort. Accessed 21 May 2024.","slug":"zExNocs/笔记-ADE-算法数据结构和效率","published":1,"__permalink":"articles/zExNocs/笔记-ADE-算法数据结构和效率/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2e5r86h0022lcut6k8tgd9k","content":"<p>有关算法效率分析的笔记，包括Big-Oh表示法、Master定理和部分算法与数据结构的算法分析。</p>\n<div style=\"text-align:center\">\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/cover.png\" alt=\"封面\" width=\"300\">\n</div>\n\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>原博客：<a href=\"https://www.zexnocs.top/post/%E7%AC%94%E8%AE%B0%2F%E7%AC%94%E8%AE%B0-ADE-%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%88%E7%8E%87\">点击跳转</a></p>\n<p>本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。</p>\n<p>本笔记主要分为下面五个部分：</p>\n<ul>\n<li>一. 算法效率的评估</li>\n<li>二. Big-Oh表示法和其家族</li>\n<li>三. Master定理</li>\n<li>四. 数据结构</li>\n<li>五. 算法</li>\n</ul>\n<h1 id=\"一-算法效率的评估\"><a href=\"#一-算法效率的评估\" class=\"headerlink\" title=\"一. 算法效率的评估\"></a>一. 算法效率的评估</h1><p>如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 <strong>程序的运行时间</strong> 来评估测量算法效率。</p>\n<p>在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 <del>(关于SPFA，它死了)</del> 。</p>\n<p>由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。</p>\n<hr>\n<h2 id=\"方法一：Experiment-实验统计\"><a href=\"#方法一：Experiment-实验统计\" class=\"headerlink\" title=\"方法一：Experiment 实验统计\"></a>方法一：Experiment 实验统计</h2><img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png\" alt=\"实验统计样例\" width=\"300\">\n\n<blockquote>\n<p>实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。</p>\n</blockquote>\n<p>具体步骤如下:</p>\n<ul>\n<li>写一个程序实施该算法</li>\n<li>使用不同的输入大小和输入信息运行程序</li>\n<li>记录实际运行时间</li>\n<li>绘制并使用统计学分析（如回归分析）</li>\n</ul>\n<p>在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注<strong>最差的情况</strong>，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。</p>\n<h3 id=\"缺点-局限性\"><a href=\"#缺点-局限性\" class=\"headerlink\" title=\"缺点 &amp; 局限性\"></a>缺点 &amp; 局限性</h3><ul>\n<li>必须用程序实现该算法，可能会很耗时。</li>\n<li>需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。</li>\n<li>效率的评估受到硬件&#x2F;软件&#x2F;语言环境的影响。</li>\n</ul>\n<hr>\n<h2 id=\"方法二：Theory-理论分析\"><a href=\"#方法二：Theory-理论分析\" class=\"headerlink\" title=\"方法二：Theory 理论分析\"></a>方法二：Theory 理论分析</h2><blockquote>\n<p>理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。</p>\n</blockquote>\n<p>跟实验统计一样，我通常指关注<strong>最差的情况</strong>。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>具有一定的抽象性。</li>\n<li>能够独立于硬件&#x2F;软件&#x2F;语言环境来评估算法的效率。</li>\n<li>能够考虑所有可能的输入。</li>\n</ul>\n<h3 id=\"缺点-局限性-1\"><a href=\"#缺点-局限性-1\" class=\"headerlink\" title=\"缺点 &amp; 局限性\"></a>缺点 &amp; 局限性</h3><ul>\n<li>实施过程可能会比较困难，需要一定的知识基础。</li>\n<li>在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。</li>\n</ul>\n<h3 id=\"评估标准\"><a href=\"#评估标准\" class=\"headerlink\" title=\"评估标准\"></a>评估标准</h3><p>在实验统计中，我们往往使用 <strong>程序的运行时间</strong> 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：<strong>原始运算数量</strong>。</p>\n<h4 id=\"原始运算的定义\"><a href=\"#原始运算的定义\" class=\"headerlink\" title=\"原始运算的定义\"></a>原始运算的定义</h4><blockquote>\n<p>原始运算(primitive operations)是算法执行的基本运算。</p>\n</blockquote>\n<p>在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将<strong>汇编代码</strong>、<strong>算数运算</strong>视作一个原始运算。</p>\n<p>注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：</p>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>伪代码样例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>变量赋值</td>\n<td><code>a ← 0</code></td>\n</tr>\n<tr>\n<td>数组索引</td>\n<td><code>a[10]</code></td>\n</tr>\n<tr>\n<td>变量比较</td>\n<td><code>a == 10</code></td>\n</tr>\n<tr>\n<td>算数运算</td>\n<td><code>a + 1</code></td>\n</tr>\n<tr>\n<td>函数调用</td>\n<td><code>function()</code></td>\n</tr>\n<tr>\n<td>函数返回</td>\n<td><code>return 0</code></td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。</li>\n<li>数组索引需要用到袁术运算是因为它需要在内存中进行索引。</li>\n<li>函数调用属于原始运算是因为它需要在内存中进行索引。</li>\n<li>在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。</li>\n</ul>\n<p>对于其他的运算，都可以拆分为这些原始运算：</p>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>分析</th>\n<th>操作数</th>\n<th>伪代码样例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>for循环，循环次数为$n$</td>\n<td>要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)</td>\n<td>$1+n+2n &#x3D; 3n+1$</td>\n<td><code>for i ← 1 to n do</code></td>\n</tr>\n<tr>\n<td>for循环，循环次数为$(n-1)$</td>\n<td>要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)</td>\n<td>$1+2(n-1)+2(n-1) &#x3D; 4n-3$</td>\n<td><code>for i ← 1 to (n-1) do</code></td>\n</tr>\n<tr>\n<td>while循环，循环次数为$n$</td>\n<td>每次循环只需要判断即可</td>\n<td>$n$</td>\n<td><code>while i &gt; n</code></td>\n</tr>\n<tr>\n<td>while循环，循环次数为$(n-1)$</td>\n<td>每次循环都需要进行判断和减法</td>\n<td>$2(n-1)$</td>\n<td><code>while i &gt; (n-1)</code></td>\n</tr>\n<tr>\n<td>if then判断，then内部原始运算数为$k$</td>\n<td>一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)</td>\n<td>$1 + k$</td>\n<td><code>if ... then ...</code></td>\n</tr>\n</tbody></table>\n<p>:::details 一个计算原始运算数的例子: arrayMax(A, n)</p>\n<p>一个返回数组最大值arrayMax(A, n)的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。</span><br><span class=\"line\">  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值</span><br><span class=\"line\">  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)</span><br><span class=\"line\">    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)</span><br><span class=\"line\">      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)</span><br><span class=\"line\">  return currentMax         # 原始运算为1，函数返回</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，这个算法的原始运算总数为 $2 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 &#x3D; 8n - 4$</p>\n<p>:::</p>\n<p>原始运算的个数并不是固定的，例如在计算操作 $c \\leftarrow A[i]$ 中，你也可以认为是$4$个原始运算：</p>\n<ul>\n<li>获取$A$数组的指针储存在寄存器中。</li>\n<li>获取$i$储存在寄存器中。</li>\n<li>计算$A + i$作为$A[i]$的指针储存在寄存器中。</li>\n<li>复制变量$c$的数值写在$A + i$指针的内存中。</li>\n</ul>\n<p>当然在这个笔记中，你也可以认为只有$2$个原始运算：</p>\n<ul>\n<li>根据$i$索引获取$A[i]$数组位置 (数组索引)。</li>\n<li>将变量$c$的数值赋值给$A[i]$ (变量赋值)。</li>\n</ul>\n<p>但是无论是$4$还是$2$，这个操作永远不可能会是$2n$，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。</p>\n<blockquote>\n<p>原始运算的个数只与算法的效率有关，与正确性无关。</p>\n</blockquote>\n<h4 id=\"使用原始运算估算运行时间\"><a href=\"#使用原始运算估算运行时间\" class=\"headerlink\" title=\"使用原始运算估算运行时间\"></a>使用原始运算估算运行时间</h4><p>增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。</p>\n<blockquote>\n<p>对于算法来说，假设它的最差情况的运行时间为$T(n)$，那么$T(n)$的增长率是该算法的固有属性，是不受硬件&#x2F;软件环境影响的。</p>\n</blockquote>\n<p>我们可以使用原始运算来估算运行时间，假设：</p>\n<ul>\n<li>原始运算的个数为$P(n)$。</li>\n<li>最快的原始运算所需要的时间为$a$，是一个常数。</li>\n<li>最慢的原始运算所需要的时间为$b$，是一个常数。</li>\n</ul>\n<p>可以得出：$$aP(n) \\leq T(n) \\leq bP(n)$$</p>\n<p>由于a和b都是常数，那么我们认为[T(n)]和[P(n)]具有相同的增长率。很明显$T(n)$和$P(n)$的导数肯定是不同的，因此增长率并不等同于导数。</p>\n<p>但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。</p>\n<h1 id=\"二-Big-Oh表示法和其家族\"><a href=\"#二-Big-Oh表示法和其家族\" class=\"headerlink\" title=\"二. Big-Oh表示法和其家族\"></a>二. Big-Oh表示法和其家族</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>我们需要一种函数分类(Classification of Functions)来通过<strong>缩放</strong>的行为将函数分组在一起，同一组的函数具有这样的相似性：</p>\n<ul>\n<li>删除不必要的细节。</li>\n<li>相对快速、简单。</li>\n<li>处理运行时可能会发生的“奇怪的”函数(例如分段函数)。</li>\n<li>在数学上拥有明确的定义。</li>\n</ul>\n<p>其中一种最佳的方法是使用<a href=\"https://en.wikipedia.org/wiki/Big_O_notation\">Big-Oh表示法和其家族(Big-Oh notation and family)</a>：</p>\n<ul>\n<li>$O$: Big-Oh</li>\n<li>$\\Omega$: Big-Omega</li>\n<li>$\\Theta$: Big-Theta</li>\n<li>$o$: little-oh</li>\n<li>$\\omega$: little-omega</li>\n</ul>\n<p>本笔记只集中于前四个的定义和Big-Oh的相关理论。</p>\n<hr>\n<h2 id=\"Big-Oh：O-n\"><a href=\"#Big-Oh：O-n\" class=\"headerlink\" title=\"Big-Oh：O(n)\"></a>Big-Oh：O(n)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ O(g(n))$ ，当且仅当<br>$$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c \\ g(n)$$</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>量词顺序是 $\\exists \\ \\exists \\ \\forall$</li>\n<li>$c$ 和 $n_0$必须是常数，不能随着$n$变化。不然这是没有意义的。</li>\n<li>注意符号$&gt;,\\geq,\\leq$的区分。相比之下是比较严格的(例如，$n_0$ 不能等于 $0$, $n$ 可以等于 $n_0$)。</li>\n</ul>\n<p>此外，Big-Oh可以会被定义为：<br>$$\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty $$</p>\n<blockquote>\n<p>Big-Oh只规定了$f(n)$的<strong>增长率的上限</strong>(upper bound on the growth rate of the function)。</p>\n</blockquote>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>Big-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于<strong>函数</strong>。也就是说它并不是对算法进行分类，而是对<strong>函数</strong>进行分类。</li>\n<li>一般$f(n)$表示运行时间，$n$表示输入的个数，所以Big-Oh中描述的函数一般为 $f: \\mathbb{N^+} \\to \\mathbb{R^+}$，$g(n)$也类似。</li>\n<li>Big-Oh只规定了$f(n)$的<strong>增长率的上限</strong>，也就是说，当$n$足够大时，$f(n)$的增长速率不大于$g(n)$。</li>\n<li>Big-Oh中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) &#x3D; 1$可以是$O(1)$，但也可以是$O(n)$。因此$g(n)$的增长率越小越能反应出$f(x)$的增长率。</li>\n</ul>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>Big-Oh作为一个二元关系(binary relation)，拥有以下性质：</p>\n<ul>\n<li>Big-Oh具有自反性(Reflexive, e.g. $x R x$)，即 $f(n)$ 是 $O(f(n))$。</li>\n<li>Big-Oh不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)，例如 $f(n) &#x3D; 1$ 是 $O(n)$，但是 $f(n) &#x3D; n$ 不是 $O(1)$。</li>\n<li>Big-Oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。即如果 $\\forall n \\geq n_1, f(n) \\leq c_1g(n)$，且$\\forall n \\geq n_2, g(n) \\leq c_2h(n)$，那么总有 $\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3&#x3D;\\max(n_1,n_2)$。</li>\n</ul>\n<p>综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是$\\subset, \\in, \\leq$,而不是$&#x3D;$，因此有一种表示方法是将Big-Oh视作集合，使用$n \\in O(n)$。此时也有会 $O(lower\\ order) \\subset O(heigher\\ order)$。</p>\n<p><em>此外，也有一种说法是使用$f(n) &#x3D; O(n)$，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。</em></p>\n<h3 id=\"推论-方法\"><a href=\"#推论-方法\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：存在三个函数$f(n)$, $g(n)$, $p(n)$和正数$k, b\\in \\mathbb{N^+}$，如果$f(n)$是$O(g(n))$，且$f(n)&#x3D;k\\ p(n) + b$，那么有$p(n)$是$O(g(n))$。</li>\n</ul>\n<p>:::details 证明推论1</p>\n<p>假设有$c_0 &gt; 0, n_0 &gt; 0$，对于$n_1 \\geq n_0$，有：</p>\n<p>$f(n_1) \\leq c_0 \\ g(n_1)$，那么有：</p>\n<p>$k\\ p(n_1) + b \\leq c_0 \\ g(n_1)$，整理得：</p>\n<p>$p(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}$</p>\n<p>当n足够大时候，假设此时$n_1 \\geq n_2$，有 $cg(n_1) \\geq 2b$</p>\n<p>从而有 $p(n_1) \\leq \\frac{c_0}{2k}g(n_1)$</p>\n<p>设 $c_1&#x3D;\\frac{c}{2k}&gt;0$，我们得到：</p>\n<p>$p(n_1) \\leq c_1\\ g(n_1)$，即</p>\n<p>存在 $c_1$，$n_2$使得 $\\forall n &gt; n_2, p(n) \\leq c_1\\ g(n)$</p>\n<p>因此$p(n)$是$O(g(n))$。</p>\n<p>:::</p>\n<ul>\n<li>推论2 （乘法）：如果$f_1(n)$ 是 $O(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$。</li>\n</ul>\n<p>:::details 证明推论2</p>\n<p>$∵ f_1(n)$ 是 $O(g_1(n))$</p>\n<p>$∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1$</p>\n<p>$∵ f_2(n)$ 是 $O(g_2(n))$</p>\n<p>$∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2$</p>\n<p>$∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0$</p>\n<p>那么有 $n_0 &#x3D; \\max(n_1, n_2)$<br>$f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0$</p>\n<p>因此$f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$</p>\n<p>:::</p>\n<ul>\n<li>推论3 （加法）：如果 $f(n) &#x3D; 1 + h(n)$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(1)$。</li>\n</ul>\n<p>:::details 证明推论3</p>\n<p>$∵$ 当$n \\to \\infty$ 时 $h(n) \\to 0$<br>$∴$ $\\exists n_0 &gt; 0,\\ \\forall n \\geq n_0, h(n) \\leq 1$<br>$∴$ $\\exists n_0 &gt; 0,\\ \\forall n \\geq n_0, f(n) \\leq 2$<br>$∴$ $f(n)$ 是 $O(1)$ 取 $c &#x3D; 2, n_0 &#x3D; n_1$ 且 $h(n_1) &lt;&#x3D; 1$</p>\n<p>:::</p>\n<p>一些常用的 $h(n)$:</p>\n<ul>\n<li>$n^2&#x2F;2^n$</li>\n<li>$n^{2000}&#x2F;2^{\\frac{n}{100}}$</li>\n<li>$(log(n))^{100} &#x2F; n^{0.1}$</li>\n</ul>\n<p>综合推论2和3，可知如果 $f(n) &#x3D; g(n)(1 + h(n))$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(g(n))$。</p>\n<p>因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：</p>\n<ul>\n<li>删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。</li>\n<li>删除常数(constant)项系数 (根据推论1,总能找到 $k$ 使得系数变成 $1$)。</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>:::details 证明arrayMax(A, n)是 $O(n)$ 的例子 (定义)</p>\n<p>由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 $f(n) &#x3D; 8n - 4$</p>\n<p>设$g(n) &#x3D; n$，因此需要求证 $\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)$，整理可得：</p>\n<p>$$<br>\\begin{cases}<br>n \\leq \\frac{4}{c - 8} &amp; c &gt; 8 \\<br>n \\geq \\frac{4}{c - 8} &amp; c &lt; 8 \\<br>-4 \\leq 0 &amp; c &#x3D; 8<br>\\end{cases}<br>$$</p>\n<p>由于我们规定是 $\\forall n \\geq n_0$，因此我们只能取 $n \\geq 8$。</p>\n<p>当我们取 $n &#x3D; 8$时，很明显任意$n_0 &gt; 0$都可以证明成立。此时我们可以取 $n_0 &#x3D; 1$。</p>\n<p>当我们取 $n &gt; 8$时，很明显任意$n_0 &gt; \\frac{4}{c - 8}$都可以证明成立。此时我们可以取 $n_0 &#x3D; \\frac{4}{c - 8}$。</p>\n<p>实际上，上述情况只需要求出一组$(c,n_0)$即可，因此我们可以直接取$c &#x3D; 8, n_0 &#x3D; 1$。不过这里给出了一种选取$(c,n_0)$的具体方法。</p>\n<p>因此arrayMax(A, n)的时间复杂度是 $O(n)$。</p>\n<p>:::</p>\n<p>:::details 对于分段函数Big-Oh的证明 (定义)</p>\n<p>如何计算下面函数的Big-Oh:<br>$$<br>f(n) &#x3D;<br>\\begin{cases}<br>n &amp; \\text{if } n \\text{ is even} \\<br>1 &amp; \\text{if } n \\text{ is odd}<br>\\end{cases}<br>$$</p>\n<p>因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即$f(n) &#x3D; n$，此时当$c &#x3D; 1, n_0 &#x3D; 1$可以证明出$f(n)$是$O(n)$，而无法证明出$f(n)$是$O(1)$。</p>\n<p>:::</p>\n<p>:::details 求 $f_(n) &#x3D; n^2 + n$ 的Big-Oh (定理2, 3)</p>\n<p>$f(n) &#x3D; n^2 + n &#x3D; n^2(1 + \\frac{1}{n})$</p>\n<p>因为自反性，$n^2$ 是 $O(n^2)$。</p>\n<p>因为当$n \\to \\infty$ 时 $\\frac{1}{n} \\to 0$，根据推理3可知 $1 + \\frac{1}{n}$ 是 $O(1)$。</p>\n<p>因此根据推理2，$f(n)$ 是 $O(n^2 * 1) &#x3D; O(n^2)$</p>\n<p>:::</p>\n<p>:::details 求 $f_(n) &#x3D; 5n^4 + 3n^3$ 的Big-Oh (删除规则)</p>\n<ul>\n<li>删除低阶$3^n$，因此$f(n)$ 是 $O(5n^4)$</li>\n<li>删除常数$5$，因此$f(n)$ 是 $O(n^4)$</li>\n</ul>\n<p>:::</p>\n<h3 id=\"Big-Oh公约\"><a href=\"#Big-Oh公约\" class=\"headerlink\" title=\"Big-Oh公约\"></a>Big-Oh公约</h3><p>遵循这个公约可以更好地去分析算法以及给出最大的信息。</p>\n<ul>\n<li>使用最小且正确的增长率函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(n^2)$，尽管后者也是正确的。</li>\n<li>使用最简的函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(2n)$。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>对于 $n^{O(1)}$来说，相当于是 ${ n^f(n)\\ |\\ f(n) \\text{ is } O(1)}$。<br>也就是说 ${n^1, n^2, n^3, …} \\subset n^{O(1)}$，${n^\\frac{1}{2}, n^\\frac{1}{3}, n^\\frac{1}{4}… } \\subset n^{O(1)}$</p>\n<blockquote>\n<p>$n^{O(1)}$ is any function that is no worse than (Big-Oh of) some power law.<br>$n^{O(1)}$表示任何不超过指数级的函数。</p>\n</blockquote>\n<hr>\n<h2 id=\"Big-Omega：Ω-n\"><a href=\"#Big-Omega：Ω-n\" class=\"headerlink\" title=\"Big-Omega：Ω(n)\"></a>Big-Omega：Ω(n)</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Omega (g(n))$ ，当且仅当<br>$$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : f(n) \\geq c \\ g(n)$$</p>\n<p>注意：</p>\n<ul>\n<li>量词顺序是 $\\exists \\ \\exists \\ \\forall$。</li>\n<li>与Big-Oh不同，最后的符号是 $\\geq$ 而不是 $\\leq$。</li>\n</ul>\n<p>此外，Big-Omega可以会被定义为：<br>$$\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} &gt; 0 $$</p>\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>Big-Omega规定了$f(n)$的<strong>增长率的下限</strong>，也就是说，当$n$足够大时，$f(n)$的增长速率不小于$g(n)$。</li>\n<li>Big-Omega中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) &#x3D; n^3 - n$ 可以是 $\\Omega(n^3)$，但也可以是 $\\Omega(n^2)$。因此$g(n)$的增长率越大越能说明$f(n)$的增长率。</li>\n<li>一般可以用来描述算法的最佳情况。</li>\n</ul>\n<h3 id=\"性质-1\"><a href=\"#性质-1\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：</p>\n<ul>\n<li>Big-Omega具有自反性(Reflexive, e.g. $x R x$)。</li>\n<li>Big-Omega不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)。</li>\n<li>Big-Omega具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>Big-Omega更像是 $\\geq$。</p>\n<h3 id=\"推论-方法-1\"><a href=\"#推论-方法-1\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：$f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))$</li>\n<li>推论2 （乘法）：如果$f_1(n)$ 是 $\\Omega(g_1(n))$, $f_2(n)$ 是 $\\Omega(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $\\Omega(g_1(n)g_2(n))$。</li>\n</ul>\n<p>删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是<strong>删除低阶函数</strong>而不是删除高阶函数。</p>\n<p>例如 $f(n) &#x3D; n^3 - n$中，应该删除的是$n$。找到$n^3$后我们就可以找比$n^3$阶级低的函数来代替。</p>\n<hr>\n<h2 id=\"Big-Theta：θ-n\"><a href=\"#Big-Theta：θ-n\" class=\"headerlink\" title=\"Big-Theta：θ(n)\"></a>Big-Theta：θ(n)</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Theta (g(n))$ ，当且仅当</p>\n<blockquote>\n<p>$$\\exists c’ &gt; 0, \\exists c’’&gt;0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : c’\\ g(n) \\leq f(n) \\leq c’’ \\ g(n)$$</p>\n</blockquote>\n<p>此外，Big-Theta可以被定义为：</p>\n<blockquote>\n<p>$$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))$$<br>$$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))$$</p>\n</blockquote>\n<h3 id=\"性质-2\"><a href=\"#性质-2\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>Big-Theta作为一个二元关系拥有下面的性质：</p>\n<ul>\n<li>Big-Theta具有自反性(Reflexive, e.g. $x R x$)。</li>\n<li>Big-Theta<strong>具有</strong>对称性(Symmetric, e.g. $x R y \\iff y R x$)：如果 $f(n)$ 是 $\\Theta(g(n))$，那么 $g(n)$ 是 $\\Theta(f(n))$。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。</li>\n<li>Big-Theta具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>Big-Theta更像是 $\\approx$。</p>\n<hr>\n<h2 id=\"little-oh：o-n\"><a href=\"#little-oh：o-n\" class=\"headerlink\" title=\"little-oh：o(n)\"></a>little-oh：o(n)</h2><h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ o(g(n))$ ，当且仅当<br>$$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| &lt; c \\ g(n)$$</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>量词顺序是 $\\forall \\ \\exists \\ \\forall$。</li>\n<li>因为是对于全部的 $c$ 存在 $n_0$，因此 $n_0$ 的数值可以依赖于 $c$。</li>\n<li>与Big-Oh不同，最后的符号是 $&lt;$ 而不是 $\\leq$。</li>\n</ul>\n<p>little-oh也可以被定义为：<br>$$\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} &#x3D; 0$$</p>\n<h3 id=\"性质-3\"><a href=\"#性质-3\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>little-oh作为一个二元关系(binary relation)，拥有以下性质：</p>\n<ul>\n<li>little-oh<strong>不具有</strong>自反性(Reflexive, e.g. $x R x$)。即$f(n) &#x3D; n$ 不是 $o(n)$。</li>\n<li>little-oh<strong>不具有</strong>对称性(Symmetric, e.g. $x R y \\iff y R x$)。</li>\n<li>little-oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>little-oh 更像是严格的 $&lt;$。</p>\n<h3 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与Big-Oh类似，little-Oh定义是函数的<strong>严格无法到达的上限</strong>。</li>\n<li>little-oh的意思是，当$n$足够大时，$f(n)$的增长速率小于$g(n)$。</li>\n<li>little-oh中 $g(n)$ 阶级越小，越能说明 $f(n)$ 的增长率。</li>\n</ul>\n<h3 id=\"推论-方法-2\"><a href=\"#推论-方法-2\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：如果$f(n)$ 是 $o(g(n))$，那么 $f(n)$ 一定是 $O(g(n))$<br>正如 $&lt;\\ \\to\\ \\leq$ 一样，很明显 $O(g(n)) \\subset o(g(n))$。</li>\n<li>推论2 （乘法1）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $o(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。</li>\n<li>推论3 （乘法2）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。</li>\n</ul>\n<p>与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。</p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>:::details 证明 $f(n) &#x3D; n ^ 2 + n$ 是 $o(n^3)$</p>\n<p>要证明$f(n) &#x3D; n ^ 2 + n$ 是 $O(n^3)$，则需要证明 $\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : f(n) &lt; c \\ g(n)$。</p>\n<p>代入和整理可得 $\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : cn^2-n-1 &gt; 0$。</p>\n<p>由公式可得，若 $cn^2-n-1 &#x3D; 0$，且$n_r &gt; 0$，可解得 $n_r &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} &gt; 0$。</p>\n<p>且当 $n &gt; n_r$ 时，$cn^2 - n - 1 &gt; 0$ 恒成立，那么可以取 $n_0 &#x3D; n_r + 1 &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$，使得 $\\forall n \\geq n_0 : f(n) &lt; c \\ g(n)$ 恒成立。</p>\n<p>因此，$f(n) &#x3D; n ^ 2 + n$ 是 $O(n^3)$，此时对于所有的 $c$ 取 $n_0 &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$。</p>\n<p>:::</p>\n<h3 id=\"关于Big-Oh和little-oh的定义上的思考：\"><a href=\"#关于Big-Oh和little-oh的定义上的思考：\" class=\"headerlink\" title=\"关于Big-Oh和little-oh的定义上的思考：\"></a>关于Big-Oh和little-oh的定义上的思考：</h3><p>如果将Big-Oh的定义改为：$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| &lt; c \\ g(n)$，称为 $O_&lt;$，而原定义称为 $O_{\\leq}$，<br>那么实际上，对于 $g(n) &gt; 0$， $f(n)$ 是 $O_&lt;(g(n)) \\iff f(n)$ 是 $O_{\\leq}(g(n))$。<br>唯一的区别是对于 $f(n) &#x3D; 0, g(n) &#x3D; 0$ 来说 $0$ 是 $O_{\\leq}(0)$ 而不是 $O_&lt;(0)$。<br>而我们想要定义Big-Oh的渐进符号为 $\\leq$，就得要求 $0$ 是 $O(0)$，因此使用 $\\leq$ 而不是 $&lt;$。</p>\n<p>同理，对于little-oh如果定义改为：$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)|  \\leq c \\ g(n)$，称为 $o_{\\leq}$，而原定义称为 $o_{&lt;}$。<br>此时 $o_{&lt;}$ 与 $o_{\\leq}$ 定义的唯一区别也是当 $f(n) &#x3D; 0, g(n) &#x3D; 0$ 的时候，此时 $0$ 是 $o_{\\leq}(0)$ 而不是 $o_{&lt;}(0)$。<br>而我们想要定义little-oh的渐进符号是 $&lt;$，就得要求 $0$ 不是 $o(0)$，那么使用的是 $&lt;$ 而不是 $\\leq$。</p>\n<p>实际上，对于Big-Oh和little-oh最主要的区别是 $\\exists c$ 和 $\\forall c$。</p>\n<hr>\n<h2 id=\"常用表示表\"><a href=\"#常用表示表\" class=\"headerlink\" title=\"常用表示表\"></a>常用表示表</h2><p>根据阶级(order)从小到大排名。</p>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th>中文名</th>\n<th>英文名</th>\n<th>数量级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$O(n^c), c &lt; 0$ $or$ $O(\\frac{k}{n})$</td>\n<td>负数幂级</td>\n<td>negative power</td>\n<td>$\\infty$,不存在</td>\n</tr>\n<tr>\n<td>$O(1)$</td>\n<td>常数级</td>\n<td>constant</td>\n<td>$\\infty$</td>\n</tr>\n<tr>\n<td>$O(\\log{\\log{n}})$</td>\n<td>双对数级</td>\n<td>double logarithmic</td>\n<td>$2^{2^{10^6}}$</td>\n</tr>\n<tr>\n<td>$O(\\log{n})$</td>\n<td>对数级</td>\n<td>logarithmic</td>\n<td>$10^{301030}$</td>\n</tr>\n<tr>\n<td>$O((\\log{n})^c), c &gt; 1$</td>\n<td>多重对数级</td>\n<td>polylogarithmic</td>\n<td>$2^{10^{\\frac{6}{c}}}$</td>\n</tr>\n<tr>\n<td>$O(n^c), 0 &lt; c &lt; 1$ $or$ $O(\\sqrt[c]{n})$</td>\n<td>分数幂级</td>\n<td>fractional power</td>\n<td>$10^{6c}$</td>\n</tr>\n<tr>\n<td>$O(n)$</td>\n<td>线性级</td>\n<td>linear</td>\n<td>$10^6$</td>\n</tr>\n<tr>\n<td>$O(n\\log{n}) &#x3D; O(\\log{n!})$</td>\n<td>对数线性&#x2F;拟线性级</td>\n<td>loglinear, n-log-n</td>\n<td>$10^5$</td>\n</tr>\n<tr>\n<td>$O(n^2)$</td>\n<td>二次级</td>\n<td>quadratic</td>\n<td>$10^3$</td>\n</tr>\n<tr>\n<td>$O(n^c), c &gt; 1$</td>\n<td>多项式&#x2F;代数级</td>\n<td>polynomial, algebraic</td>\n<td>$\\sqrt[c]{10^6}$</td>\n</tr>\n<tr>\n<td>$O(c^n)$</td>\n<td>指数级</td>\n<td>exponential</td>\n<td>$6\\log_{c}{10}$</td>\n</tr>\n<tr>\n<td>$O(n!)$</td>\n<td>阶乘级</td>\n<td>factorial</td>\n<td>$9$</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"Big-Oh家族使用样例\"><a href=\"#Big-Oh家族使用样例\" class=\"headerlink\" title=\"Big-Oh家族使用样例\"></a>Big-Oh家族使用样例</h2><ul>\n<li>用于表示一个范围：算法 X 最坏的情况时间复杂度是 $o(n^4)$ 和 $\\Omega(n^3)$，但是实际表现并不确定。</li>\n<li>用于确定一个增长率：算法 X 最佳的情况时间复杂度是 $\\Theta(n^2)$。</li>\n<li>用来表示一个平均值：算法 X 平均情况时间复杂度是 $O(n^3)$。</li>\n</ul>\n<hr>\n<h2 id=\"使用Big-Oh家族分析算法效率注意点\"><a href=\"#使用Big-Oh家族分析算法效率注意点\" class=\"headerlink\" title=\"使用Big-Oh家族分析算法效率注意点\"></a>使用Big-Oh家族分析算法效率注意点</h2><p>Big-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 $n$ <strong>足够大</strong>时渐进的范围,也可以说是 $n$ 的增长率。 </p>\n<p>但是在 $n$ <strong>比较小</strong>时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的<strong>实际工作</strong>时的效率。</p>\n<p>例如：</p>\n<ul>\n<li>$10000n$ 是 $O(n)$，同时 $2^n$ 是 $O(2^n)$，当时当 $n$ 比较小时，例如 $n &#x3D; 6$ 时，前者需要进行的计算数是 $60000$，而后者是 $64$，此时前者的效率是不如后者的。</li>\n<li>$O(1.02^n)$ 尽管是指数级(exponential)，但是它的效率并不逊色。</li>\n</ul>\n<p>但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 $n$ 比小的时候程序所消耗的时间往往是会忽略不计的。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Big-Oh家族定义及其渐进表示法总结</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>表示法</th>\n<th>名字</th>\n<th>描述</th>\n<th>渐进符号</th>\n<th>形式定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$o(g(n))$</td>\n<td>little-Oh</td>\n<td>函数渐进地由$g$支配</td>\n<td>$&lt;$</td>\n<td>$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : | f(n) | &lt; c \\ g(n)$</td>\n</tr>\n<tr>\n<td>$O(g(n))$</td>\n<td>Big-Oh</td>\n<td>函数以$g$为渐进边界</td>\n<td>$\\leq$</td>\n<td>$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c\\ g(n)$</td>\n</tr>\n<tr>\n<td>$\\Theta(g(n))$</td>\n<td>Big-Theta</td>\n<td>函数由$g$为渐进边界和下边界</td>\n<td>$\\approx$</td>\n<td>$\\exists c’&gt;0,\\exists c’’&gt;0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : c’g(n) \\leq f(n) \\leq c’’g(n)$</td>\n</tr>\n<tr>\n<td>$\\Omega(g(n))$</td>\n<td>Big-Omega</td>\n<td>函数由$g$为渐进下边界</td>\n<td>$\\geq$</td>\n<td>$\\exists c&gt;0,\\exists n_0&gt;0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)$</td>\n</tr>\n<tr>\n<td>$\\omega(g(n))$</td>\n<td>little-omega</td>\n<td>函数渐进支配$g$</td>\n<td>$&gt;$</td>\n<td>$\\exists c&gt;0,\\forall n_0 &gt; 0, \\exists n \\geq n_0 : f(n) &gt; c\\ g(n)$</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如何求解一个算法的时间复杂度Big-Oh：<ul>\n<li>建立算法函数的伪代码。</li>\n<li>求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。</li>\n<li>根据该函数求出Big-Oh表示。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"三-Master定理\"><a href=\"#三-Master定理\" class=\"headerlink\" title=\"三. Master定理\"></a>三. Master定理</h1><h2 id=\"分而治之-Divide-and-Conquer\"><a href=\"#分而治之-Divide-and-Conquer\" class=\"headerlink\" title=\"分而治之(Divide and Conquer)\"></a>分而治之(Divide and Conquer)</h2><p>分而治之是一个设计算法的思想，它通常能够高速地处理问题。</p>\n<p>分而治之的组成成分如下：</p>\n<ul>\n<li>分解 (Divide)：将输入分为两个或多个不相交的输入子集。</li>\n<li>递归 (Recur)：使用递归解决这些子集的子问题。</li>\n<li>组合 (Conquer)：将所有子集的解组合起来形成输入的解。</li>\n</ul>\n<hr>\n<h2 id=\"递归关系-Recurrence-Relation\"><a href=\"#递归关系-Recurrence-Relation\" class=\"headerlink\" title=\"递归关系 Recurrence Relation\"></a>递归关系 Recurrence Relation</h2><p>定义：</p>\n<blockquote>\n<p>A recurrence relation is a recursively-defined function.<br><a href=\"https://en.wikipedia.org/wiki/Recurrence_relation\">递归关系(Recurrence Relation)</a>是使用递归定义的函数。</p>\n</blockquote>\n<p>假设一个程序的运行时间是 $T(n)$，那么递归关系会在一系列小于n的值中来表达 $T(n)$。</p>\n<p>:::details 例子：归并排序(merge-sort)的递归关系及其时间复杂度的证明</p>\n<p>关于归并排序的具体算法请看下面 <strong>五. 算法</strong> 中 <strong>归并排序</strong>。</p>\n<p>假设归并排序的运行时间为 $T(n)$，那么</p>\n<p>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; 2\\ T(\\frac{n}{2}) + b + an \\T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$</p>\n<ul>\n<li>$2\\ T(\\frac{n}{2})$ 表示数组分成了两个子数组，每个子数组的大小为 $\\frac{n}{2}$。</li>\n<li>$b$ 是分裂的花费。</li>\n<li>$an$ 是 <code>merge</code> 的花费。</li>\n</ul>\n<p>因此我们经过带入可以得到：</p>\n<ul>\n<li>$T(2) &#x3D; 2\\ T(1) + b + 2a &#x3D; 2 + b + 2a$</li>\n<li>$T(4) &#x3D; 2\\ T(4) + b + 4a &#x3D; 2 (2 + b + 2a) + b + 4a &#x3D; 4 + 3b + 8a$</li>\n<li>$T(8) &#x3D; 2\\ T(4) + b + 8a &#x3D; 2 (4 + 3b + 8a) + b + 8a &#x3D; 8 + 7b + 24a$</li>\n</ul>\n<p>由此我们猜测 $T(2^k) &#x3D; 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$<br>我们可以使用数学归纳法(induction)来验证：</p>\n<p>Claim: $T(2^k) &#x3D; 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$.<br>Base case: $k &#x3D; 0$，$T(1) &#x3D; 1 + 0 * b + 0 * 1 * a &#x3D; 1$ is meet the claim.<br>Step case: Assume that the claim is true at k, and we need to prove that $T(k + 1)$ is true.<br>$$<br>\\begin{aligned}<br>T(2^{k+1}) &amp; &#x3D; 2\\ T(2^k) + b + 2^{k+1}a \\<br> &amp; &#x3D; 2 (2^k + (2^k - 1)b + k\\ 2^ka) + b + 2^{k + 1}a \\<br> &amp; &#x3D; 2^{k+1} + (2^{k+1} - 2)b + b + k\\ 2^{k+1}a + 2^{k + 1}a \\<br> &amp; &#x3D; 2^{k+1} + (2^{k+1} - 1)b + (k + 1)\\ 2^{k+1}a<br>\\end{aligned} $$<br>$Q.E.D.$</p>\n<p>我们假设 $T’(n) &#x3D; n + (n - 1)b + an\\log(n), \\text{for } n &#x3D; 2^k, k\\in \\mathbb{N}$。<br>我们可以证明出 $T(n)$ 是 $\\Theta(T’(n))$。<br>因此，$T(n)$ 是 $\\Theta(n\\log n)$。</p>\n<p>:::</p>\n<hr>\n<h2 id=\"Master定理-Master-Theorem\"><a href=\"#Master定理-Master-Theorem\" class=\"headerlink\" title=\"Master定理 (Master Theorem)\"></a>Master定理 (Master Theorem)</h2><p>考虑存在下面的递归关系：<br>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; a\\ T(\\frac{n}{b}) + f(n) \\<br>T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$<br>这是一个由分而治之设计的算法：分解成 $a$ 个子集，每个子集的大小是 $\\frac{n}{b}$，此外每个递归&#x2F;循环有一些额外的操作 $f(n)$。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">Master定理(Master Theorem)</a>是一个根据 $a, b$ 的数值以及对 $f(n)$ 进行放缩来快速求出$T(n)$的Big-Oh家族的方法。</p>\n<p>下面就对 $f(n), a, b$ 不同情况进行讨论。</p>\n<p><em>注意，本笔记中不形式证明Master定理，具体可以自行查阅。</em></p>\n<h3 id=\"f-n-0-时\"><a href=\"#f-n-0-时\" class=\"headerlink\" title=\"&gt; $f(n) &#x3D; 0$ 时\"></a>&gt; $f(n) &#x3D; 0$ 时</h3><p>此时 $T(n) &#x3D; aT(\\frac{n}{b})$，我们可以使用数学归纳法证明出 $T(b^k) &#x3D; a^k$。</p>\n<p>我们令$n &#x3D; b^k$，根据数学公式我们可以推导出 $a^k &#x3D; (b^k)^{\\log_ba}$，因此我们可以得到<br>$$T(n) &#x3D; n^{\\log_ba}$$</p>\n<p>因此我们可以知道 $T(n)$ 是 $\\Theta(n^{\\log_ba})$。</p>\n<h3 id=\"f-n-neq-0-时\"><a href=\"#f-n-neq-0-时\" class=\"headerlink\" title=\"&gt; $f(n) \\neq 0$ 时\"></a>&gt; $f(n) \\neq 0$ 时</h3><p>此时可以分为三种情况：</p>\n<table>\n<thead>\n<tr>\n<th>$f(n)$ 的形式</th>\n<th>$c$ 与 $\\log_ba$ 的关系</th>\n<th>$T(n)$的Big-Theta</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$f(n)$ 是 $O(n^c)$</td>\n<td>$c &lt; \\log_ba$</td>\n<td>$\\Theta(n^{\\log_ba})$</td>\n<td>$f(n)$ 的 增长率非常小，此时忽略 $f(n)$</td>\n</tr>\n<tr>\n<td>$f(n)$ 是 $\\Theta(n^c(\\log n)^k), k \\geq 0$</td>\n<td>$c &#x3D; \\log_ba$</td>\n<td>$\\Theta(n^c(\\log n)^{k+1})$</td>\n<td>$f(n)$ 的 增长率适中，此时混合使用$a, b, f(n)$</td>\n</tr>\n<tr>\n<td>$f(n)$ 是 $\\Omega(n^c)$, 并满足正则条件</td>\n<td>$c &gt; log_ba$</td>\n<td>$\\Theta(f(n))$</td>\n<td>$f(n)$ 的 增长率非常大，此时只考虑 $f(n)$</td>\n</tr>\n</tbody></table>\n<p>情况三中需要满足正则条件(Regularity Condition)：<br>$$\\exists k &lt; 1 : a f(\\frac{n}{b}) \\leq k f(n)$$</p>\n<p><em>该条件保证了这个条件确保 $f(n)$ 不会增长过快导致 $T(n)$ 完全被非递归部分主导。</em></p>\n<p>注意$f(n)$ 的形式以及$c$ 与 $\\log_ba$ 的关系。</p>\n<ul>\n<li>情况一中可知，$f(n)$的渐进上边界都不如 $n^{\\log_ba}$，那么$f(n)$ 的增长率是可以被忽略的。</li>\n<li>情况二中可知，$f(n)$的增长率是与 $n^{\\log_ba}$ 持平的，因此应该要混合使用$a, b, f(n)$。</li>\n<li>情况三中可知，$f(n)$的渐进下边界都超过了 $n^{\\log_ba}$，因此只考虑 $f(n)$。</li>\n</ul>\n<hr>\n<h1 id=\"四-数据结构\"><a href=\"#四-数据结构\" class=\"headerlink\" title=\"四. 数据结构\"></a>四. 数据结构</h1><h2 id=\"一些定义\"><a href=\"#一些定义\" class=\"headerlink\" title=\"一些定义\"></a>一些定义</h2><ul>\n<li><p>遍历(Traversals)：指访问(visit)一个数据结构的所有元素。</p>\n<ul>\n<li>每一个元素只访问一次。</li>\n<li>访问的顺序是系统的、有序的、有意义的。</li>\n</ul>\n</li>\n<li><p>抽象数据类型(Abstract Data Types, ADTs)：是数据结构的抽象。</p>\n<ul>\n<li>组成成分：<ul>\n<li>储存的数据类型。</li>\n<li>对数据的操作。</li>\n<li>与操作相关的错误条件。</li>\n</ul>\n</li>\n<li>一般ADT的相关操作会使用Big-Oh来限制效率。</li>\n</ul>\n</li>\n<li><p>具体数据类型(Concrete Data Types, CDTs)：是数据结构的实际。</p>\n<ul>\n<li>ADT的实现是通过选择不同的CDT。</li>\n<li>CDT是数据隐藏的和封装的（面向对象）。</li>\n<li>CDT的选择影响运行时间和空间使用。</li>\n</ul>\n</li>\n<li><p>面向对象编程(Object-oriented)的原因：</p>\n<ul>\n<li>区分规范(specification) 和 实施细节(implementation details)</li>\n<li>使用相同的ADT来探索不同的CDTs。</li>\n<li>无需更改ADT的代码来快速更改和提升CDTs。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"单向链表-Singly-Linked-List-CDT\"><a href=\"#单向链表-Singly-Linked-List-CDT\" class=\"headerlink\" title=\"单向链表(Singly Linked List) (CDT)\"></a>单向链表(Singly Linked List) (CDT)</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A singly linked list is a concrete data structure consisting of a sequence of nodes. Each node stores an element and a pointer&#x2F;reference to the next node.</p>\n</blockquote>\n<h3 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>Element</code> 元素</li>\n<li><code>next</code> 指向下一个节点的指针</li>\n</ul>\n</li>\n<li><code>head : Node*</code> 头节点指针</li>\n<li><code>tail : Node*</code> 尾节点指针 (可选)</li>\n</ul>\n<h3 id=\"功能性函数\"><a href=\"#功能性函数\" class=\"headerlink\" title=\"功能性函数\"></a>功能性函数</h3><p>插入类函数：</p>\n<ul>\n<li><code>void insertHead(Object)</code>：插入头结点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void insertTail(Object)</code>：插入尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n</ul>\n<p>删除类函数：</p>\n<ul>\n<li><code>void removeHead()</code>：删除头节点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void removeTail(Object)</code>：删除尾节点<ul>\n<li>无论有没有记录尾节点，时间复杂度：$O(n)$<ul>\n<li>因为要让尾节点的前一个节点的<code>next</code>指针指向<code>NULL</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>交换类函数：</p>\n<ul>\n<li><code>void swapElement(Node, Node)</code>：交换元素而不交换节点的位置<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n<li><code>void swapNode(Node, Node)</code>：交换节点的位置（不常用）<ul>\n<li>时间复杂度 $O(n)$<ul>\n<li>因为要找到这两个<code>Node</code>的上一个<code>Node</code>来修改<code>next</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"双向链表-Doubly-Linked-List-CDT\"><a href=\"#双向链表-Doubly-Linked-List-CDT\" class=\"headerlink\" title=\"双向链表(Doubly Linked List) (CDT)\"></a>双向链表(Doubly Linked List) (CDT)</h2><h3 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A doubly linked list provides a natural extension of a singly linked list.Each node stores an element and a pointer&#x2F;reference to the next node and a pointer&#x2F;reference to the previous node.</p>\n</blockquote>\n<h3 id=\"成员-1\"><a href=\"#成员-1\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>element</code> 元素</li>\n<li><code>next</code> 指向下一个节点的指针</li>\n<li><code>pre</code> 指向上一个节点的指针</li>\n</ul>\n</li>\n<li><code>head : Node* | Node</code> 头节点指针&#x2F;节点</li>\n<li><code>tail : Node* | Node</code> 尾节点指针&#x2F;节点</li>\n</ul>\n<h3 id=\"功能性函数-1\"><a href=\"#功能性函数-1\" class=\"headerlink\" title=\"功能性函数\"></a>功能性函数</h3><p>插入类函数：</p>\n<ul>\n<li><code>void insertHead(Object)</code>：插入头结点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void insertTail(Object)</code>：插入尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n<li><code>void insertAfter(Node, Object)</code>：插入到<code>Node</code>节点后面<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n</ul>\n<p>删除类函数：</p>\n<ul>\n<li><code>void removeHead()</code>：删除头节点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void removeTail(Object)</code>：删除尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n</ul>\n<p>交换类函数：</p>\n<ul>\n<li><code>void swapElement(Node, Node)</code>：交换元素而不交换节点的位置（不常用）<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n<li><code>void swapNode(Node, Node)</code>：交换节点的位置（建议）<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li>有两种双向链表设计方式<ul>\n<li>让<code>head</code>和<code>tail</code>指向实实在在的节点。如果链表为空，则<code>head = NULL, tail = NULL</code>。</li>\n<li>分配<code>head</code>和<code>tail</code>为新的节点，节点的元素为空。如果链表为空，则<code>head.next == tail</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据结构的思考\"><a href=\"#数据结构的思考\" class=\"headerlink\" title=\"数据结构的思考\"></a>数据结构的思考</h3><p>相比于数组 <code>Array</code>，链表数据结构具有较快的插入和删除能力。但是，链表具有较差的查询能力，其查询能力的时间复杂度是 $O(n)$。</p>\n<p>一般具有较快的插入、删除和查询能力的数据结构都比较复杂，例如：</p>\n<ul>\n<li>跳表 (Skip List)：其三个操作的时间复杂度都是 $O(\\log n)$。</li>\n<li>平衡树(Balanced Trees)：其三个操作的时间复杂度都是 $O(\\log n)$。<ul>\n<li>红黑树(Red-Black Tree)</li>\n<li>AVL树(AVL Tree)</li>\n</ul>\n</li>\n<li>哈希表(Hash Table)：其三个操作的平均时间复杂度都是 $O(1)$，最差情况下时间复杂度是 $O(n)$。</li>\n</ul>\n<hr>\n<h2 id=\"向量-Vector-ADT\"><a href=\"#向量-Vector-ADT\" class=\"headerlink\" title=\"向量(Vector) (ADT)\"></a>向量(Vector) (ADT)</h2><h3 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>向量(Vector)是一种抽象数据类型(ADT)。向量的主要目的是创建一个比数组(Array)更泛用的模型。</p>\n<p>其主要的特性是：</p>\n<ul>\n<li>一个元素在向量中的索引(index)被认为是前面元素的个数(number of elements prceding it)。<ul>\n<li>为了不完全依赖于数组，因此我们不使用“索引(index)”概念，而使用“前面元素的个数”概念。</li>\n<li>例如对于一个向量 $A$ 来说，$A[2]$ 表示有 $2$ 个元素在它的前面，分别是 $A[0], A[1]$。</li>\n<li>这个概念也可以被称为**排名(rank)**。</li>\n</ul>\n</li>\n<li>与数组固定大小不同，向量一个自动调节大小的数据结构。</li>\n</ul>\n<h3 id=\"向量ADT主要操作-operator-方法\"><a href=\"#向量ADT主要操作-operator-方法\" class=\"headerlink\" title=\"向量ADT主要操作(operator)&#x2F;方法\"></a>向量ADT主要操作(operator)&#x2F;方法</h3><ul>\n<li><code>Object elemAtRank(int r)</code>：返回 <code>rank</code> 为 <code>r</code> 的元素。</li>\n<li><code>Object replaceAtRank(int r, Object o)</code>：替换掉 <code>rank</code> 为 <code>r</code> 的元素为 <code>o</code>，并返回原来的元素。</li>\n<li><code>void insertAtRank(int r, Object o)</code>：在 <code>rank</code> 为 <code>r</code> 的位置插入新的元素 <code>o</code>。</li>\n<li><code>Object removeAtRank(int r)</code>：删除 <code>rank</code> 为 <code>r</code> 位置的元素。</li>\n<li><code>int size()</code>：返回向量大小。</li>\n<li><code>boolean isEmpty()</code>：返回向量是否为空。</li>\n</ul>\n<h3 id=\"使用向量作为栈-Stack\"><a href=\"#使用向量作为栈-Stack\" class=\"headerlink\" title=\"使用向量作为栈(Stack)\"></a>使用向量作为栈(Stack)</h3><p>栈(Stack)是一个先入后出(first in last out, FILO)的数据结构，其操作主要是：</p>\n<ul>\n<li><code>Object top()</code>：返回栈顶。<ul>\n<li>相当于 <code>elemAtRank(size())</code>。</li>\n</ul>\n</li>\n<li><code>void push(Object o)</code>：在最后的元素(栈顶)后面添加一个新的元素。<ul>\n<li>相当于 <code>insertAtRank(size(), Object o)</code>。</li>\n</ul>\n</li>\n<li><code>void pop()</code>：删除最后的元素(栈顶)。<ul>\n<li>相当于 <code>removeAtRank(size())</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于数组的向量-Array-based-Vector-CDT\"><a href=\"#基于数组的向量-Array-based-Vector-CDT\" class=\"headerlink\" title=\"基于数组的向量(Array-based Vector) (CDT)\"></a>基于数组的向量(Array-based Vector) (CDT)</h3><p>是使用一个大小为<code>N</code>的数组<code>V</code>作为向量的CDT，并使用整型变量<code>n</code>记录向量的大小。</p>\n<h4 id=\"操作-方法时间复杂度分析\"><a href=\"#操作-方法时间复杂度分析\" class=\"headerlink\" title=\"&gt;操作&#x2F;方法时间复杂度分析\"></a>&gt;操作&#x2F;方法时间复杂度分析</h4><ul>\n<li><code>elemAtRank(r)</code>：可以直接返回<code>V[r]</code>，因此其时间复杂度是 $O(1)$。</li>\n<li><code>replaceAtRank(r, o)</code>：时间复杂度是 $O(1)$。</li>\n<li><code>insertAtRank(r, o)</code>：需要对原来的元素进行右平移，在最坏的情况下(即 $r &#x3D; 0$ )时间复杂度是 $O(n)$。</li>\n<li><code>removeAtRank(r, o)</code>：需要对原来的元素进行左平移，在最坏的情况下(即 $r &#x3D; 0$ )时间复杂度是 $O(n)$。</li>\n<li><code>size()</code>：直接返回变量 <code>n</code>，因此时间复杂度是 $O(1)$。</li>\n<li><code>isEmpty()</code>：直接返回 <code>n == 0</code>，因此时间复杂度是 $O(1)$。</li>\n<li><code>push(o)</code>：不需要进行平移。<ul>\n<li>如果<strong>不需要扩大数组</strong>时间复杂度是 $O(1)$。</li>\n<li><strong>扩大数组</strong>需要平摊时间(amortized time)获取时间复杂度。具体可以看下面扩大数组中不同策略。</li>\n</ul>\n</li>\n<li><code>pop()</code>：不需要进行平移，因此时间复杂度是 $O(1)$。</li>\n</ul>\n<p>平摊时间(amortized time)是从<strong>一组</strong>操作中每个操作平摊下来的时间。与平均时间(average time)不同，后者主要是针对<strong>一次</strong>操作的平均时间。</p>\n<h4 id=\"扩大数组-Resize-Array\"><a href=\"#扩大数组-Resize-Array\" class=\"headerlink\" title=\"&gt;扩大数组(Resize Array)\"></a>&gt;扩大数组(Resize Array)</h4><p>在<code>insertAtRank(r, o)</code> 和 <code>push(o)</code> 操作中，如果数组已经满了，那么需要替换数组为更大的数组。</p>\n<p>替换数组需要复制原来的数据到新的数据中。假设当前数组的大小为 $c$，每次替换所使用的时间为 $s_2$，那么这个过程需要的时间$T(c) &#x3D; s_2c$，即这个过程的时间复杂度是 $O(c)$。</p>\n<p>扩大数组的方法一共有两种：</p>\n<ul>\n<li><p>增量策略(incremental strategy)：使用固定的常数 <code>c</code> 来进行扩大数组。</p>\n<ul>\n<li>假设执行<code>push</code>的次数为 $n$，那么替换数组的次数一共为 $k &#x3D; floor(n &#x2F; c)$ 次。</li>\n<li>假设$T(n)$是执行<code>push</code> $n$ 次所需要的运行时间，$s_1$是一次<code>push</code>所需要的时间，$s_2$是一次替换数组所需要的时间。<ul>\n<li>$s_1$ 和 $s_2$ 都是常数。</li>\n<li>$T(n) &#x3D; s_1n + s_2(c + 2c + … + kc) &#x3D; s_1n + s_2c\\frac{k(k+1)}{2}$，因此 $T(n)$ 是 $O(n^2)$。</li>\n</ul>\n</li>\n<li>平摊下来每次 <code>push</code> 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(n)$。这个是要比一般 <code>push</code> 操作所需要的时间复杂度 $O(1)$ 是要差的。</li>\n</ul>\n</li>\n<li><p>双倍策略(doubling strategy)：双倍数组的大小。</p>\n<ul>\n<li>假设执行<code>push</code>的次数为 $n$，那么替换数组的次数一共为 $k &#x3D; floor(\\log n)$ 次。</li>\n<li>假设$T(n)$是执行<code>push</code> $n$ 次所需要的运行时间，$s_1$是一次<code>push</code>所需要的时间，$s_2$是一次替换数组所需要的时间。<ul>\n<li>$s_1$ 和 $s_2$ 都是常数。</li>\n<li>$T(n) &#x3D; s_1n + s_2(1 + 2 + 4 + … + 2^{k - 1}) &#x3D; (s_1 + s_2)n - s_2$，因此 $T(n)$ 是 $O(n)$。</li>\n</ul>\n</li>\n<li>平摊下来每次 <code>push</code> 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(1)$。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"树-Tree-ADT\"><a href=\"#树-Tree-ADT\" class=\"headerlink\" title=\"树(Tree) (ADT)\"></a>树(Tree) (ADT)</h2><h3 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>树是一种抽象数据结构(ADT)。</p>\n<blockquote>\n<p>In computer science, a tree is an abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.</p>\n</blockquote>\n<h3 id=\"成员-2\"><a href=\"#成员-2\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>element</code>  元素</li>\n<li><code>parent</code> 父节点</li>\n<li><code>children[]</code> 子节点</li>\n</ul>\n</li>\n<li><code>root : Node*</code> 根节点：不具有父节点的节点。</li>\n<li><code>internal : Node</code> 内节点：具有至少一个子节点的节点。</li>\n<li><code>leaf / external : Node</code> 叶节点&#x2F;外节点：不具有子节点的节点。</li>\n<li><code>ancestors : Node → Node[]</code> 祖先节点：(递归定义) 一个节点其父节点和其父节点的祖先节点的数组&#x2F;集合。</li>\n<li><code>descendant : Node → Node[]</code> 祖孙节点：(递归定义) 一个节点其所有子节点和所有子节点的祖孙节点的数组&#x2F;集合。</li>\n<li><code>depth : Node → Int</code> 节点的深度：该节点的祖先节点的个数(不包括自己)。<ul>\n<li>根节点的深度为0，根节点的子节点深度为1，以此类推。</li>\n</ul>\n</li>\n<li><code>height : Tree → Int</code> 树的高度：最大的叶节点深度。或者说从根节点到叶节点最长的路径(不包括根节点)。<ul>\n<li>只有根节点的树的深度为0。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树ADT主要操作-方法：\"><a href=\"#树ADT主要操作-方法：\" class=\"headerlink\" title=\"树ADT主要操作&#x2F;方法：\"></a>树ADT主要操作&#x2F;方法：</h3><h4 id=\"基础方法-Generic-：\"><a href=\"#基础方法-Generic-：\" class=\"headerlink\" title=\"&gt; 基础方法 (Generic)：\"></a>&gt; 基础方法 (Generic)：</h4><ul>\n<li><code>int size()</code>：返回树的大小。</li>\n<li><code>bool isEmpty()</code>：返回树是否为空。</li>\n<li><code>Iterator iterator()</code>：返回树的遍历所有元素的迭代器。</li>\n<li><code>Iterator positions()</code>：返回树的以一定顺序遍历位置的迭代器。</li>\n</ul>\n<h4 id=\"接入方法-Accessor-：\"><a href=\"#接入方法-Accessor-：\" class=\"headerlink\" title=\"&gt; 接入方法 (Accessor)：\"></a>&gt; 接入方法 (Accessor)：</h4><ul>\n<li><code>Node root()</code>：返回树的根节点。</li>\n<li><code>Node parent(Node)</code>：返回节点的父节点。</li>\n<li><code>Iterator children(Node)</code>：返回节点的子节点迭代器。</li>\n</ul>\n<h4 id=\"查询方法-Query-：\"><a href=\"#查询方法-Query-：\" class=\"headerlink\" title=\"&gt; 查询方法 (Query)：\"></a>&gt; 查询方法 (Query)：</h4><ul>\n<li><code>bool isInternal(Node)</code>：是否是内部节点。</li>\n<li><code>bool isExternal(Node)</code>：是否是叶节点。</li>\n<li><code>bool isRoot(Node)</code>：是否是根节点。</li>\n</ul>\n<h3 id=\"树的遍历-Traversals\"><a href=\"#树的遍历-Traversals\" class=\"headerlink\" title=\"树的遍历 (Traversals)\"></a>树的遍历 (Traversals)</h3><h4 id=\"前序遍历-Preorder-Traversal\"><a href=\"#前序遍历-Preorder-Traversal\" class=\"headerlink\" title=\"&gt; 前序遍历 Preorder Traversal\"></a>&gt; 前序遍历 Preorder Traversal</h4><p>先遍历父节点，再从左到右遍历其子节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm preOrder(v)</span><br><span class=\"line\">  visit(v)</span><br><span class=\"line\">  for each child w of v</span><br><span class=\"line\">    preorder(w)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历-Postorder-Traversal\"><a href=\"#后序遍历-Postorder-Traversal\" class=\"headerlink\" title=\"&gt; 后序遍历 Postorder Traversal\"></a>&gt; 后序遍历 Postorder Traversal</h4><p>先遍历子节点，再遍历父节点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm postOrde(v)</span><br><span class=\"line\">  for each child w of v</span><br><span class=\"line\">    postOrder(w)</span><br><span class=\"line\">  visit(v)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二叉树-Binary-Tree-ADT\"><a href=\"#二叉树-Binary-Tree-ADT\" class=\"headerlink\" title=\"二叉树(Binary Tree) (ADT)\"></a>二叉树(Binary Tree) (ADT)</h2><h3 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>二叉树是一种抽象数据结构(ADT)。</p>\n<ul>\n<li><p>一般定义：</p>\n<blockquote>\n<p> a tree whose each internal node has at most two children, and the children of a node are an ordered pair, though one might be “missing”.</p>\n</blockquote>\n</li>\n<li><p>递归定义：</p>\n<blockquote>\n<p>A tree consisting of a single node, or a tree whose root has an  ordered pair of “children”, each  of which is missing (a null) or is  the root of a binary tree</p>\n</blockquote>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>每个节点最多有两个子节点</li>\n<li>节点之间是有序的，即左子节点和右子节点，尽管有一个是空节点。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"性质-4\"><a href=\"#性质-4\" class=\"headerlink\" title=\"性质\"></a>性质</h3><h4 id=\"合适-完满二叉树-proper-full-binary-tree\"><a href=\"#合适-完满二叉树-proper-full-binary-tree\" class=\"headerlink\" title=\"&gt; 合适&#x2F;完满二叉树 (proper&#x2F;full binary tree)\"></a>&gt; 合适&#x2F;完满二叉树 (proper&#x2F;full binary tree)</h4><blockquote>\n<p>A binary tree is said to be “proper” (a.k.a. “full”) if every internal node has exactly 2 children.<br>如果二叉树的所有内部节点都具有两个子节点，那么称这个二叉树是合适&#x2F;完满二叉树。</p>\n</blockquote>\n<h4 id=\"完美二叉树-perfect-binary-tree\"><a href=\"#完美二叉树-perfect-binary-tree\" class=\"headerlink\" title=\"&gt; 完美二叉树 (perfect binary tree)\"></a>&gt; 完美二叉树 (perfect binary tree)</h4><blockquote>\n<p>A binary tree is perfect if it is proper and all leaves are at the same depth.<br>如果一个满二叉树中所有的子节点都在同一个深度，那么称这个二叉树是完美二叉树。</p>\n</blockquote>\n<ul>\n<li>在深度 $d$ 拥有的节点的个数为 $2^d$</li>\n<li>在深度 $d$ 及其以下的深度总结点个数为 $2^{(d+1)}-1$</li>\n<li>高度为 $h$ 的树总节点为 $n$，那么有 $h &#x3D; \\log_{2}(n+1) - 1$，$n &#x3D; 2^{(h + 1)} - 1$</li>\n</ul>\n<h4 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"&gt; 完全二叉树 (complete binary tree)\"></a>&gt; 完全二叉树 (complete binary tree)</h4><blockquote>\n<p>除了叶节点所处的深度以外，其他深度是一个完美二叉树，并且叶节点是靠右排序的二叉树是完全二叉树。</p>\n</blockquote>\n<h3 id=\"二叉树的遍历-Traversals\"><a href=\"#二叉树的遍历-Traversals\" class=\"headerlink\" title=\"二叉树的遍历 (Traversals)\"></a>二叉树的遍历 (Traversals)</h3><p>除了树通用的前序遍历和后序遍历以外，还有一个中序遍历(Inorder Traversal)：</p>\n<p>先遍历左子节点，再遍历该节点，最后遍历子节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm inOrder(v)</span><br><span class=\"line\">  if hasLeft(v)</span><br><span class=\"line\">    inOrder(v.left)</span><br><span class=\"line\">  visit(v)</span><br><span class=\"line\">  if hasRight(v)</span><br><span class=\"line\">    inOrder(v.right)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的效率分析\"><a href=\"#二叉树的效率分析\" class=\"headerlink\" title=\"二叉树的效率分析\"></a>二叉树的效率分析</h3><ul>\n<li>求树的高度：如果树的大小为 $n$，那么：<ul>\n<li>对于完美二叉树来说，时间复杂度是 $\\Theta(\\log(n))$。</li>\n<li>对于非完美二叉树来说，考虑到一条链，时间复杂度是 $\\Omega(\\log(n))$ 和 $O(n)$。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于数组的二叉树-Array-Based-Representation-of-Binary-Tree-CDT\"><a href=\"#基于数组的二叉树-Array-Based-Representation-of-Binary-Tree-CDT\" class=\"headerlink\" title=\"基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)\"></a>基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)</h3><p>它也可以被称为 **树形数组(tree-as-array)**。它是一种使用数组作为CDT实现二叉树ADT的方式。</p>\n<p>一般使用 <code>int rank(Node)</code> 来表示节点的数组索引。注意，它返回的是<strong>整型</strong>。</p>\n<ul>\n<li><code>rank(root) = 1</code>：根节点的索引是 $1$。</li>\n<li><code>rank(parent(node)) = rank(node) &gt;&gt; 1</code>：每个节点的父节点是该节点的索引除以 $2$。</li>\n<li><code>rank(left_child(node)) = rank(node) &lt;&lt; 1</code>：每个节点的左节点是该节点的索引乘以 $2$。</li>\n<li><code>rank(right_child(node)) = rank(node) &lt;&lt; 1 + 1</code>：每个节点的右节点是该节点的索引乘以 $2$ 加 $1$。</li>\n</ul>\n<p>树形数组的优点：</p>\n<ul>\n<li>能够节省空间。因为不用储存相关的指针，而是使用计算代替。</li>\n<li>储存能够更紧凑，具有更好的内存局部性”better memory locality”。</li>\n<li>很好地解决缓存和内存层次结构的问题——当访问数组元素时，其他条目可以被拉入缓存，因此访问速度更快。</li>\n</ul>\n<hr>\n<h2 id=\"优先队列-Priority-Queue-ADT\"><a href=\"#优先队列-Priority-Queue-ADT\" class=\"headerlink\" title=\"优先队列(Priority Queue) (ADT)\"></a>优先队列(Priority Queue) (ADT)</h2><h3 id=\"介绍-5\"><a href=\"#介绍-5\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>优先队列是一个抽象数据结构(ADT)。优先队列是储存一组具有 <code>(key, value)</code> 的数据结构，并能够有效地返回和操作其中具有最小&#x2F;最大 <code>key</code> 的元素。</p>\n<p>一般我们默认优先队列是**最小优先队列(Min-Priority Queue)**，也就是返回&#x2F;操作拥有最小<code>key</code>的元素。</p>\n<h3 id=\"优先队列ADT主要操作-方法：\"><a href=\"#优先队列ADT主要操作-方法：\" class=\"headerlink\" title=\"优先队列ADT主要操作&#x2F;方法：\"></a>优先队列ADT主要操作&#x2F;方法：</h3><ul>\n<li><code>void insert(k, v)</code>：插入一组<code>(k, v)</code>的元素。</li>\n<li><code>Element removeMin()</code>：删除并返回具有最小<code>key</code>的元素。</li>\n<li><code>Element min()</code>：返回具有最小<code>key</code>的元素。</li>\n<li><code>int size()</code>：返回元素个数。</li>\n<li><code>bool isEmpty()</code>：优先队列返回是否为空。</li>\n</ul>\n<h3 id=\"基于二叉堆-Binary-Heap-的优先队列-CDT\"><a href=\"#基于二叉堆-Binary-Heap-的优先队列-CDT\" class=\"headerlink\" title=\"基于二叉堆(Binary Heap)的优先队列 (CDT)\"></a>基于二叉堆(Binary Heap)的优先队列 (CDT)</h3><p>本笔记中默认的二叉堆是 <strong>小根堆</strong>。</p>\n<blockquote>\n<p> A binary heap is a complete binary tree storing key-value pairs at its nodes.<br>二叉堆是将 <code>(key, value)</code> 对储存在节点的完全二叉树。</p>\n</blockquote>\n<p><em>除了二叉堆以外，还有二项式堆(Binomial Heap)和斐波那契堆(Fibonacci Heap)。</em></p>\n<p>二叉堆具有以下的性质：</p>\n<ul>\n<li>Heap-Order：对于每一个除了根以外的节点，都有 <code>key(v) &gt;= key(parent(v))</code>。<ul>\n<li>即子节点的值不会比父节点更小。</li>\n<li>那么堆顶，即二叉堆的根节点是所有节点中的最小值。</li>\n</ul>\n</li>\n<li>Complete Binary Tree：是一个二叉树。因此如果一共有 $n$ 个节点，则树的高度为 $h &#x3D; \\log n$。</li>\n</ul>\n<h4 id=\"堆的插入-insert\"><a href=\"#堆的插入-insert\" class=\"headerlink\" title=\"堆的插入(insert)\"></a>堆的插入(insert)</h4><p>步骤如下：</p>\n<ol>\n<li>根据完全二叉树性质寻找插入点 $Z$ 作为叶节点。</li>\n<li>储存 $key$ 值给点 $Z$。</li>\n<li>恢复堆序属性(<code>unheap</code>操作)：将插入点 $Z$ 从下到上进行 <strong>冒泡</strong>，如果父节点的 <code>key</code> 值比 $Z$ 大，那么就交换两个节点的位置或元素，直到父节点的 <code>key</code> 值比 $Z$ 小或者已经到达根节点。</li>\n</ol>\n<p>关于 $1$，如果使用结构体模拟树的结构，那么时间复杂度可能会达到 $O(n)$。但是如果使用数组作为CDT模拟二叉树(具体可看上方二叉树中基于数组的二叉树，树形数组)，那么只需要在数组的末尾插入新的节点即可，此时的时间复杂度是 $O(1)$。<br>关于 $3$，因为二叉树的高度是 $h &#x3D; \\log n$，因此 <code>upheap</code> 操作的时间复杂度是 $O(\\log n)$。</p>\n<h4 id=\"堆的删除-remove-pop\"><a href=\"#堆的删除-remove-pop\" class=\"headerlink\" title=\"堆的删除(remove &#x2F; pop)\"></a>堆的删除(remove &#x2F; pop)</h4><p>堆的删除指的是删除堆顶。步骤如下：</p>\n<ol>\n<li>使用最后一个节点 $w$ 代替根节点。</li>\n<li>删除 $w$ 原节点。</li>\n<li>恢复堆属性(<code>Downheap</code>操作)：选择两个子节点中<strong>最小</strong>的子节点，如果该子节点的<code>key</code>值比 $w$ 节点的小，那么就交换两个节点的位置或元素，直到所有子节点的 <code>key</code> 值比 $w$ 大或者已经达到叶节点。</li>\n</ol>\n<hr>\n<h2 id=\"映射-Maps-ADT\"><a href=\"#映射-Maps-ADT\" class=\"headerlink\" title=\"映射(Maps) (ADT)\"></a>映射(Maps) (ADT)</h2><h3 id=\"介绍-6\"><a href=\"#介绍-6\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A map models a collection of <code>(key, value)</code> entries that is searchable by the <code>key</code>.</p>\n</blockquote>\n<p>性质：</p>\n<ul>\n<li>具有搜索、插入、删除元素的功能。</li>\n<li>具有相同 <code>key</code> 值的元素是不被允许的。</li>\n</ul>\n<h3 id=\"映射ADT主要操作-方法：\"><a href=\"#映射ADT主要操作-方法：\" class=\"headerlink\" title=\"映射ADT主要操作&#x2F;方法：\"></a>映射ADT主要操作&#x2F;方法：</h3><ul>\n<li><code>Value get(Key k)</code>：如果存在<code>key</code>相应的元素，则通过 <code>key</code> 获取相应的 <code>value</code>，否则返回 <code>NULL</code>。</li>\n<li><code>Value put(Key k, Value v)</code>：插入 <code>(key, value)</code> 对。如果已经存在 <code>key</code> 在映射里则返回 <code>NULL</code>，否则返回 <code>value</code>值。</li>\n<li><code>Value remove(Key k)</code>：如果存在<code>key</code>相应的元素，则通过 <code>key</code> 来删除并返回该元素的 <code>value</code>，否则返回 <code>NULL</code>。</li>\n<li><code>int size()</code>：返回元素个数。</li>\n<li><code>bool isEmpty()</code>：返回是否为空。</li>\n<li><code>Iterator keys()</code>：返回 <code>key</code> 的迭代器。</li>\n<li><code>Iterator values()</code>：返回 <code>value</code> 的迭代器。</li>\n<li><code>Iteraotr entries()</code>：返回 <code>(key, value)</code> 的迭代器。</li>\n</ul>\n<h3 id=\"基于简单链表的MAP-CDT\"><a href=\"#基于简单链表的MAP-CDT\" class=\"headerlink\" title=\"基于简单链表的MAP (CDT)\"></a>基于简单链表的MAP (CDT)</h3><ul>\n<li><code>get(k)</code>：遍历链表来寻找 <code>key</code>。时间复杂度是 $O(n)$。</li>\n<li><code>put(k, v)</code>：遍历链表来寻找是否有重复的 <code>key</code>，如果没有则插入到链表中。时间复杂度是 $O(n)$。</li>\n<li><code>remove(k, v)</code>：遍历链表来寻找 <code>key</code>。时间复杂度是 $O(n)$。</li>\n</ul>\n<p>因为链表的特性（具有较差的访问能力），因此无论是排序的链表还是未排序的链表（链表无法使用二分查找法），时间复杂度操作都是 $O(n)$。</p>\n<h3 id=\"基于哈希表的MAP-CDT\"><a href=\"#基于哈希表的MAP-CDT\" class=\"headerlink\" title=\"基于哈希表的MAP (CDT)\"></a>基于哈希表的MAP (CDT)</h3><p>基本思想：将每个 <code>key</code> 转化成 <code>index</code> 放入一个较大的数组 <code>Array</code> 中。</p>\n<p>哈希表的特性：</p>\n<ul>\n<li>哈希值 (hash value)：由哈希函数得到的值被称为哈希值。</li>\n<li>哈希码 $h_1$ (hash code)：是一个键值转一个整型的函数，即<code>keys → integers</code>。一些可能的方法：<ul>\n<li>将 <code>key</code> 的内存地址作为哈希码。</li>\n<li>将 <code>key</code> 的 <code>bit</code> 值转化成整型作为哈希码。一般用于内存不大于整型的数据类型，例如<code>byte, short, int, float</code>。</li>\n<li>将 <code>key</code> 的 <code>bit</code> 值划分成相同长度的部分，对这些部分求和(忽略溢出)。适用于内存大于整型的数据类型，例如 <code>double, long</code>。</li>\n<li>多项式累积方法。</li>\n</ul>\n</li>\n<li>压缩函数 $h_2$ (Compression function)：是一个将整型压缩到一定范围的函数，即<code>integers → [0, N-1]</code>。一些可能的方法：<ul>\n<li>除法(Division)：$h_2(x) &#x3D; x \\mod N$。<ul>\n<li>$N$ 通常是一个素数。</li>\n</ul>\n</li>\n<li>乘加除法(Multiply, Add and Divide (MAD))：$h_2(x) &#x3D; (ax + b) \\mod N$。<ul>\n<li>$a, b$ 是非负整数。</li>\n<li>$a \\mod N \\neq 0$，否则无论 $x$ 为多少总会映射到 $b$。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哈希函数 $h$ (hash function)：是一个将对象(Object)映射到一个固定的范围 $[0, N-1]$ 整型的函数。<ul>\n<li>此时有 $h(x) &#x3D; h_2(h_1(x))$。</li>\n<li>哈希函数的主要目的是使用明显<strong>随机</strong>的方式来将 <code>keys</code> <strong>分散</strong>。</li>\n<li>分散的目的是为了减少冲突(Collision)。</li>\n<li>随机的目的是为了减少模式(Pattern)，从而减少冲突。</li>\n</ul>\n</li>\n<li>冲突 (Collision)：当不同的元素获取到相同的索引时，会发生冲突。一些可能的解决方法：<ul>\n<li>分离链(Separate Chaining)：让相同 <code>index</code> 的元素以链表的形式连接起来。</li>\n<li>二叉搜索树(Binary Search Tree)。</li>\n<li>开放地址(Open addressing)：让冲突的新元素放入到下一个可用的数组中。一些可能的方法：<ul>\n<li>线性探索(Linear probing)：使用一个常数 $c$ 来进行冲突元素的新元素寻址，即$h(k) + c$。<ul>\n<li>一般使用循环数组作为哈希表。</li>\n<li>可能会导致未来新元素使用更长的时间来寻址。</li>\n<li>如果数组满了可能会导致死循环，因此要规定最多循环次数。</li>\n<li>如果中间有冲突的数组被删除，可能会导致后面冲突的数组查询失败。<ul>\n<li>一个删除的解决方案是不断检测右边是否具有相同的哈希值，如果相同则将该数值重新插入。</li>\n<li>Lazy deletion延迟删除：将被删除的数值标记为“删除”，只当用到它的时候再进行修复。当被查询到“删除”标记的点时直接跳过而不是停止。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双哈希(Double Hashing)：使用一个额外的哈希函数 $d(k)$ 来辅助寻找新元素。<ul>\n<li>新的哈希值为 $(h(k) + j\\ d(k))\\mod N, j\\in[0, N-1]$，选择第一个空元素作为哈希值。一些可能的 $h(k)$：<ul>\n<li>$d(k) &#x3D; q - (k \\mod q)$，其中 $q &lt; N$ 且 $q$ 是素数。</li>\n</ul>\n</li>\n<li>对于线性探索来说，$d(k) &#x3D; 1$。</li>\n<li>$N$ 必须是素数，以探索所有的可能数组包。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>那么使用哈希表来实现<code>Map</code>主要的思路是：</p>\n<ul>\n<li>寻找哈希函数：将 $(k,v)$ 储存在 $i &#x3D; h(k)$ 索引的数组中。</li>\n<li>处理冲突。</li>\n</ul>\n<h4 id=\"基于分离链-Separate-Chaining-处理冲突的方法\"><a href=\"#基于分离链-Separate-Chaining-处理冲突的方法\" class=\"headerlink\" title=\"基于分离链(Separate Chaining)处理冲突的方法\"></a>基于分离链(Separate Chaining)处理冲突的方法</h4><p>因为分离链定义让相同 <code>index</code> 的元素以链表的形式连接起来，其中链表中每个节点还有一个单独的 <code>key</code> 值用于寻找具体的元素。</p>\n<p>那么链表的每个节点应该具有以下的操作，假设有 $m$ 个冲突的元素：</p>\n<ul>\n<li><code>Element get(k)</code>：获取<code>key = k</code>的元素。其时间复杂度是 $O(m)$。</li>\n<li><code>Element put(k, v)</code>：放入<code>(k, v)</code>对的元素，需要检测是否有相同 <code>key</code> 的元素，如果有则返回<code>null</code>。因此时间复杂度是 $O(m)$。</li>\n<li><code>Element remove(k)</code>：删除<code>key = k</code>的元素。其时间复杂度是 $O(m)$。</li>\n</ul>\n<p>那么使用基于分离链哈希表的<code>map</code>具体实现方式如下：</p>\n<ul>\n<li><code>get(k)</code>：<code>return A[h(k)].get(k)</code>。</li>\n<li><code>put(k, v)</code>：<code>return A[h(k)].put(k)</code>。注意要让 <code>size++</code>。</li>\n<li><code>remove(k)</code>: <code>return A[h(k)].remove(k)</code>。注意要让 <code>size--</code>。</li>\n</ul>\n<p>对于每个操作，最佳访问时间是 $O(1)$，最差访问时间依然是 $O(n)$，即全部都有冲突。但是平均下来，其时间复杂度应该是 $O(n &#x2F; N)$，其中 $N$ 是哈希表数组的容量。</p>\n<h4 id=\"哈希函数的性能分析\"><a href=\"#哈希函数的性能分析\" class=\"headerlink\" title=\"哈希函数的性能分析\"></a>哈希函数的性能分析</h4><p>在最坏的情况下，搜索、插入和删除的时间复杂度都是 $O(n)$。</p>\n<p>一般用负载因子(load factor) $\\alpha &#x3D; n &#x2F; N$ 来表示哈希表的性能。</p>\n<p>哈希表各个操作的期望值基本上都是 $O(1)$。具体证明可自行查阅。</p>\n<hr>\n<h2 id=\"二叉搜索树-Binary-Search-Tree-ADT\"><a href=\"#二叉搜索树-Binary-Search-Tree-ADT\" class=\"headerlink\" title=\"二叉搜索树(Binary Search Tree) (ADT)\"></a>二叉搜索树(Binary Search Tree) (ADT)</h2><blockquote>\n<p>A binary search tree is a binary tree storing <code>(key,value)</code> entries at its internal nodes and satisfying the following “search tree” property.<br>二叉搜索树是一个储存<code>(key,value)</code>值到节点的二叉树，并满足下面的性质：</p>\n</blockquote>\n<p>性质：</p>\n<ul>\n<li>对于任意一个内部节点 $v$，拥有左子节点 $u$ 和 右子节点 $w$，满足 <code>key(u) &lt;= key(v) &lt;= key(w)</code>。</li>\n<li>对于任意一个节点 $v$，其左边子辈的值都比 $v$ 小，右边子辈的值都比 $v$ 大。</li>\n<li>换句话说，二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据<code>key</code>升序的。</li>\n</ul>\n<h3 id=\"二叉搜索树ADT主要操作-方法\"><a href=\"#二叉搜索树ADT主要操作-方法\" class=\"headerlink\" title=\"二叉搜索树ADT主要操作&#x2F;方法\"></a>二叉搜索树ADT主要操作&#x2F;方法</h3><ul>\n<li><code>Node search(Key k)</code>：返回<code>key = k</code>的节点，如果没有则返回<code>null</code>。<ul>\n<li>实现：比较当前节点储存的<code>key</code> 与 <code>k</code> 相比较，如果等于则返回。如果<code>k</code>大则查找右节点，如果<code>k</code>小则查找左节点。如果不存在节点，则返回<code>null</code>。</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n<li>如果是平衡二叉树，则时间复杂度是 $O(\\log n)$。</li>\n</ul>\n</li>\n<li><code>void insert(Key k, Value v)</code>：插入 <code>(k, v)</code> 对。<ul>\n<li>实现：使用二分法找到要插入的位置，将其插入进去。</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n</ul>\n</li>\n<li><code>Node remove(Key k)</code>：删除 <code>key = k</code> 的节点。<ul>\n<li>实现：使用二分查找找到要删除的节点删除，分为下面四个情况：<ul>\n<li>没有找到该节点，此时返回 <code>null</code>。</li>\n<li>该节点是叶节点，此时删除该节点。</li>\n<li>节点具有一个子节点，将该子节点替换到原来的位置。</li>\n<li>节点具有两个子节点，此时根据树的中序遍历找到当前<code>key</code>的下一个<code>key</code>节点 $w$ ($w$ 称为该节点的中序后继)，并使用这个节点 $w$ 替代该节点，再尝试删除 $w$，直到不符合被删除的节点具有两个子节点为止。</li>\n</ul>\n</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树-Balanced-Trees\"><a href=\"#平衡二叉树-Balanced-Trees\" class=\"headerlink\" title=\"平衡二叉树(Balanced Trees)\"></a>平衡二叉树(Balanced Trees)</h3><p>平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。<br>平衡二叉树的高度 $h &#x3D; \\log n$。</p>\n<p>一般使用旋转(notation)的方法来让二叉搜索树逐步变成平衡二叉树。</p>\n<h4 id=\"一次旋转-Single-Rotation\"><a href=\"#一次旋转-Single-Rotation\" class=\"headerlink\" title=\"一次旋转 (Single Rotation)\"></a>一次旋转 (Single Rotation)</h4><p>一次旋转适合三个高度节点之间呈类似于 <code>\\</code> 和 <code>/</code> 的直线形。也就是中间高度的节点是中间值的情况。</p>\n<p>过程如下：</p>\n<ul>\n<li>选择一个节点 $P$。</li>\n<li>选择该节点的一个子节点 $C$。</li>\n<li>交换两个节点：<ul>\n<li>选择 $C$ 中相反方向的子节点 $V$：如果 $C$ 是 $P$ 的左节点，那么就选择 $C$ 的右节点。否则选择左节点。</li>\n<li>处理 $P$ 的父节点：<ul>\n<li>将 $P$ 的父节点相应方向的子节点修改为 $C$。</li>\n<li>将 $C$ 的父节点修改为 $P$ 的父节点。</li>\n<li>如果 $P$ 为根节点，那么修改根节点为 $C$。</li>\n</ul>\n</li>\n<li>处理 $C$ 的子节点 $V$：<ul>\n<li>将 $V$ 的父节点修改为 $P$。</li>\n<li>将 $P$ 原来方向上的子节点 $C$ 的位置修改为 $V$。</li>\n</ul>\n</li>\n<li>处理 $C$ 和 $P$：<ul>\n<li>将 $C$ 原来 $V$ 位置的子节点修改为 $P$。</li>\n<li>将 $P$ 的父节点修改为 $C$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png\" alt=\"平衡二叉树旋转\" width=\"650\">\n\n<p>整个过程时间复杂度是 $O(1)$。</p>\n<h4 id=\"二次旋转-Double-Rotation\"><a href=\"#二次旋转-Double-Rotation\" class=\"headerlink\" title=\"二次旋转 (Double Rotation)\"></a>二次旋转 (Double Rotation)</h4><p>诸如下图中的类似 <code>&gt;</code>和<code>&lt;</code> 形，是无法使用一次旋转的，如果只旋转<code>a</code> 和 <code>c</code> 将无法改变高度。</p>\n<p>此时需要先将<code>&gt;</code>或<code>&lt;</code>形旋转成<code>/</code>或<code>\\</code>形，再进行一次旋转。整个过程被称为二次旋转，如下图。</p>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png\" alt=\"平衡二叉树二次旋转\" width=\"650\">\n\n<p>具体的其他二叉树方法将（例如AVL树、红黑树）不在本笔记中展示。可能会未来在其他笔记中展示。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><hr>\n<h1 id=\"五-算法\"><a href=\"#五-算法\" class=\"headerlink\" title=\"五. 算法\"></a>五. 算法</h1><p>算法的设计思路通常有这么几种：</p>\n<ul>\n<li>暴力搜索(Brute Force)：生成所有潜在解决方案并测试哪些是实际解决方案。时间复杂通常非常高，是属于多项式级其以上的时间复杂度。</li>\n<li>分而治之(Divide and Conquer)：递归地将问题分解成更小的部分并逐步解决它们，然后将它们重新组合在一起。是一种比较高效的设计思路。</li>\n<li>启发式(Heuristics)：是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。</li>\n<li>动态规划(DP)：DP是一种适用于最优解满足“分解性质”情况的通用方法。</li>\n</ul>\n<hr>\n<h2 id=\"排序算法-Sorting-algorithms\"><a href=\"#排序算法-Sorting-algorithms\" class=\"headerlink\" title=\"排序算法(Sorting algorithms)\"></a>排序算法(Sorting algorithms)</h2><p>排序算法的性质：</p>\n<ul>\n<li>排序稳定性(Stability)：如果两个元素键值相等，排序算法会保留这两个元素的相对位置。</li>\n<li>排序自适应性(Adaptive)：如果数组已经接近已排序，那么算法的效率会提高。</li>\n<li>排序接入模式(Access Patterns)<ul>\n<li>Sequential Access：数据的读取和写入是按照其在存储器中存放的顺序进行的。</li>\n<li>Random Access：数据储存中能够在常数时间 $O(1)$ 内直接访问任意位置的数据。</li>\n</ul>\n</li>\n<li>是否需要额外空间。</li>\n</ul>\n<p>如果没有特殊说明，以下算法都默认<strong>从小到大排序&#x2F;升序</strong>、使用 <strong>数组(array)</strong> 作为数据结构。</p>\n<h3 id=\"基于比较的排序算法的一些思考\"><a href=\"#基于比较的排序算法的一些思考\" class=\"headerlink\" title=\"基于比较的排序算法的一些思考\"></a>基于比较的排序算法的一些思考</h3><p>如果一个排序算法仅包含关于成对比较元素的信息，那么就称这个排序是<strong>基于比较</strong>的(comparison-based)。</p>\n<p>并不是所有的排序算法都是基于比较的，例如桶排序(bucket sort)是使用实际的值来进行排序的，其时间复杂度是$O(n)$，但是其实现依赖于其值的范围。是一种使用空间换取时间的方法。</p>\n<p>对于 $n$ 个数的数组来说，它一共拥有 $n!$ 种排序方法。我们使用基于比较的算法来对数组进行排序是通过两两比较来减半它排序方法的可能性。也就是说，基于比较的排序算法本质其实是逐步将 $n!$ 减半成 $1$。</p>\n<p>这意味着我们需要去做 $\\log_2(n!)$ 次比较。实际上 $O(\\log(n!)) &#x3D; O(n \\log n)$。也就是说基于比较的算法不能比 $O(n \\log n)$ 更优。</p>\n<hr>\n<h3 id=\"1-冒泡排序-Bubble-sort\"><a href=\"#1-冒泡排序-Bubble-sort\" class=\"headerlink\" title=\"1. 冒泡排序(Bubble sort)\"></a>1. 冒泡排序(Bubble sort)</h3><h4 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>让大的元素逐渐往后移动。</p>\n<ul>\n<li>外部循环(Outer loop)：扫描整个数组。</li>\n<li>内部循环(Inner loop)：对于数组每个元素与右边邻域对比，如果右边邻域更小则立即交换。</li>\n</ul>\n<h4 id=\"算法思考\"><a href=\"#算法思考\" class=\"headerlink\" title=\"算法思考\"></a>算法思考</h4><p>因为算法中最大元素像水泡一样逐渐向上冒，因此被称为冒泡排序。</p>\n<h4 id=\"复杂性分析\"><a href=\"#复杂性分析\" class=\"headerlink\" title=\"复杂性分析\"></a>复杂性分析</h4><p>考虑到最差的情况，也就是每次循环都会进行交换。外部循环次数为$(n - 1)$，假设当前外部循环$index &#x3D; i$，那么内部循环次数为 $(n - i - 1)$，因此总循环次数为 $\\frac{n(n - 1)}{2}$。</p>\n<p>假设比较和交换原始操作数为 $t$ 为常数，循环以外的原始操作数为 $k$ 为常数，那么总原始操作数为 $\\frac{n(n - 1)}{2} + t(n - 1) + k$。</p>\n<p>根据删除规则，我们可以知道它的时间复杂度是 $O(n^2)$。</p>\n<p>此外，也可以使用递归关系来证明冒泡排序的时间复杂度：</p>\n<p>:::details 使用递归关系证明冒泡排序的时间复杂度</p>\n<p>首先冒泡排序并不是天然递归的，而是一个双重循环。</p>\n<p>但是我们能使用递归思想来将冒泡排序改成递归：如果要将长度为 $n$ 的数组进行排序，首先将这个数组中的最大数值通过冒泡操作交换到当前数组最右边的位置并固定，随后再将剩下 $n - 1$ 的数组进行排序(递归)。</p>\n<p>这样就写出其运行时间的递推公式：<br>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; dn + T(n - 1) \\<br>T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$</p>\n<ul>\n<li>$dn$ 表示通过冒泡操作交换所需要的时间。</li>\n<li>$T(n - 1)$ 表示剩余数组排序所需要的时间。</li>\n</ul>\n<p>我们可以根据等差数列求出 $T(n)$ 的通项公式为：<br>$$T(n) &#x3D; 1 + (\\frac{n(n+1)}{2} - 1) d$$</p>\n<p>那么很明显 $T(n)$ 是 $\\Theta(n^2)$。</p>\n<p>:::</p>\n<h4 id=\"算法的性质。\"><a href=\"#算法的性质。\" class=\"headerlink\" title=\"算法的性质。\"></a>算法的性质。</h4><ul>\n<li>如果相同的元素不进行交换，那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>可以通过添加变量来让算法 <strong>具有</strong> 自适应性（内部循环没有进行任何交换）。</li>\n<li>不需要额外的空间。</li>\n<li>可适用于单向链表的<code>swapElement(Node, Node)</code>，时间复杂度不变。</li>\n</ul>\n<hr>\n<h3 id=\"2-选择排序-Selection-sort\"><a href=\"#2-选择排序-Selection-sort\" class=\"headerlink\" title=\"2. 选择排序(Selection sort)\"></a>2. 选择排序(Selection sort)</h3><h4 id=\"基本思想-1\"><a href=\"#基本思想-1\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>保持数组后面的元素不变作为<strong>已排序</strong>的元素，前面的元素作为<strong>未排序</strong>的元素，选择<strong>未排序</strong>的元素组中最大的元素插入到<strong>已排序</strong>元素组的头部。</p>\n<ul>\n<li>外部循环：扫描整个数组。</li>\n<li>内部循环：扫描整个<strong>未排序部分</strong>的数组。并不会让最大的元素立即交换，而是记录住最大元素的位置。等内部循环扫描完，将被记录的元素：<ul>\n<li>插入到<strong>已排序部分</strong>的数组的最左边。或者：</li>\n<li>与<strong>未排序部分</strong>的数组最右边的元素交换并将其加入到<strong>已排序部分</strong>数组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法思考-1\"><a href=\"#算法思考-1\" class=\"headerlink\" title=\"算法思考\"></a>算法思考</h4><p>与冒泡排序不同，冒泡排序是比较当前元素和其邻域，而该排序是比较当前元素和被记录的元素。<br>为什么要延迟交换而不是立即交换：</p>\n<ul>\n<li>如果交换操作可能会比较昂贵，并不像数组一样是$O(1)$，那么就需要尽可能减少交换次数。</li>\n<li>如果数组非常大，那么需要尽可能地减少交换次数来提高效率。</li>\n</ul>\n<h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><p>相比于冒泡排序，它们具有相同数量的迭代和比较，仅仅是有更少数量的交换。</p>\n<p>因此它的时间复杂度也是$O(n^2)$。</p>\n<h4 id=\"算法的性质。-1\"><a href=\"#算法的性质。-1\" class=\"headerlink\" title=\"算法的性质。\"></a>算法的性质。</h4><ul>\n<li>该算法 <strong>不具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>不需要额外的空间。</li>\n<li>可适用于单向链表的<code>swapElement(Node, Node)</code>，时间复杂度不变。</li>\n</ul>\n<hr>\n<h3 id=\"3-插入排序-Insertion-sort\"><a href=\"#3-插入排序-Insertion-sort\" class=\"headerlink\" title=\"3. 插入排序(Insertion sort)\"></a>3. 插入排序(Insertion sort)</h3><p>保持数组前面元素的排序不变作为<strong>已经排序</strong>的元素，后面的元素作为<strong>未排序</strong>的元素。选择当前<strong>未排序</strong>元素不断交换左边比该元素大的元素，并将其加入到<strong>已经排序</strong>的元素。</p>\n<ul>\n<li>外部循环：扫描整个数组。</li>\n<li>内部循环：获取并记录当前<strong>未排序</strong>元素的最左边元素，从右到左扫描<strong>已经排序</strong>的元素，如果被扫描的元素比记录的元素大，那么就交换，直到被扫描的元素比记录的元素小。</li>\n</ul>\n<h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li>在最坏的情况下，它的外部原始操作数是 $O(n)$，内部原始操作数是 $O(n)$，因此它的总时间复杂度是$O(n * n) &#x3D; O(n^2)$。</li>\n<li>在最佳的情况下，它内部循环操作数是 $O(1)$，那么它的总时间复杂程度是 $O(n * 1) &#x3D; O(n)$。</li>\n</ul>\n<h4 id=\"算法的性质\"><a href=\"#算法的性质\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>如果相同的元素不进行交换，那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>该算法 <strong>具有</strong> 自适应性。</li>\n<li>不需要额外的空间。</li>\n<li>不适用于单向链表。适用于双向链表。</li>\n</ul>\n<hr>\n<h3 id=\"4-归并排序-Merge-sort\"><a href=\"#4-归并排序-Merge-sort\" class=\"headerlink\" title=\"4. 归并排序(Merge sort)\"></a>4. 归并排序(Merge sort)</h3><p>归并排序是一个基于分而治之(divide-and-conquer)的算法，它是先划分再排序。</p>\n<ul>\n<li>分解 (Divide)：将待排序的数组 $S$ 分解为两个部分 $S_1$, $S_2$。<ul>\n<li>分解直到只剩下单个元素或者空元素为止。因为单个元素的数组一定是已经排序好的数组。</li>\n<li>分解只是简单的数学运算，因此时间复杂度是 $O(1)$。</li>\n</ul>\n</li>\n<li>递归 (Recur)：递归地将 $S_1$ 和 $S_2$ 进行排序(带入到分而治之中)。<ul>\n<li>递归分解，回归组合。</li>\n<li>递归全部子集的时间复杂度是 $O(\\log(n))$。</li>\n</ul>\n</li>\n<li>组合 (Conquer)：将已排序的 $S_1$ 和 $S_2$ 合并(merge)。<ul>\n<li>merge是基于两个已经排序好的数组进行的：依次判断两个数组当前第一个数(最小的数)，选择最小的一个放入到新的数组后面，直到有一个数组为空后，将另一个数组剩余的元素依次放入到新的数组后面。</li>\n<li>假设放入的操作时间复杂度是$O(1)$，那么合并的时间复杂度是 $O(n)$。</li>\n</ul>\n</li>\n</ul>\n<p>归并排序递归调用的过程是一个二叉树结构。</p>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png\" alt=\"归并排序\" width=\"450\">\n\n<h4 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><p>综上所述，归并排序的时间复杂度是 $O(n\\log{n})$。<br>此外可以使用递归关系来证明归并排序的时间复杂度，详细请见 <strong>三.Master定理</strong> 中 <strong>递归关系</strong> 中的样例。<br>归并排序需要用到额外的空间，因此其空间复杂度是 $O(n)$。<br><em>也可以使得空间复杂度是 $O(1)$，但是过于混乱一般不作考虑。</em></p>\n<h4 id=\"算法的性质-1\"><a href=\"#算法的性质-1\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>在归并遇见相等数据时，如果优先选择左边数组那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>该算法 <strong>需要</strong> 额外的空间。</li>\n<li>该算法对数据的访问是顺序的(sequential)，因此在硬盘中具有较好的排序效率。</li>\n<li>因为依赖于快速对中间的数据进行访问，因此不太适合使用链表。</li>\n</ul>\n<hr>\n<h3 id=\"5-快速排序-Quick-Sort\"><a href=\"#5-快速排序-Quick-Sort\" class=\"headerlink\" title=\"5. 快速排序(Quick Sort)\"></a>5. 快速排序(Quick Sort)</h3><p>快排是一个基于分而治之的算法，它是先排序后划分。</p>\n<ul>\n<li>分解 (Divide)：称之为<code>partition</code>操作。选择一个元素 $x$ 称之为枢(pivot)，并将数组 $S$ 分为：<ul>\n<li>$L$：元素小于 $x$ 的。</li>\n<li>$GE$ 元素大于等于 $x$ 的。</li>\n<li><code>pivot</code>经常是使用随机选择。</li>\n<li>假设 交换 或者 删除再插入 的时间复杂度是$O(1)$，那么分解的时间复杂度是 $O(n)$。</li>\n</ul>\n</li>\n<li>递归 (Recur)：对 $L$ 和 $GE$ 使用进行递归排序，带入到分而治之中。<ul>\n<li>最差的情况下，选择的枢总是最小&#x2F;最大值，那么此时递归所有的子集时间复杂度是 $O(n)$。</li>\n<li>最佳的情况下，选择的枢总是中间值，那么此时递归所有的子集时间复杂度是 $O(\\log n)$。</li>\n</ul>\n</li>\n<li>组合 (Conquer)：将 $L$ 和 $GE$ 左右连接起来。<ul>\n<li>组合只是简单的连接，时间复杂度是 $O(1)$。</li>\n</ul>\n</li>\n</ul>\n<p>快速排序递归调用的过程是一个二叉树结构。</p>\n<h4 id=\"快速算法的分解-Divide-实现形式\"><a href=\"#快速算法的分解-Divide-实现形式\" class=\"headerlink\" title=\"快速算法的分解(Divide)实现形式\"></a>快速算法的分解(Divide)实现形式</h4><p>该操作称为<code>partition</code>操作。</p>\n<ul>\n<li><p>使用额外的空间进行分解，具体思想如下：</p>\n<ol>\n<li>创建两个数组，分别表示 $L$ 和 $GE$。</li>\n<li>选择一个枢(pivot)。</li>\n<li>从左到右遍历数组，将小于枢的数加入到 $L$，将大于等于枢的数加入到 $GE$。</li>\n</ol>\n</li>\n<li><p>使用双指针的方法进行分解，这个方法是就地(in-place)，步骤如下：</p>\n<ol>\n<li>选择一个枢(pivot)。</li>\n<li>定义两个指针 $j$ 和 $k$，分别初始化指向数组的开头和结尾。</li>\n<li>使用 $j$ 向右扫描，直到找到第一个 $\\geq$ 枢的元素 或者 $j &#x3D;&#x3D; k$ 停止。</li>\n<li>使用 $k$ 向左扫描，直到找到第一个 $&lt;$ 枢的元素 或者 $j &#x3D;&#x3D; k$ 停止。</li>\n<li>交换 $j, k$ 的元素。</li>\n<li>如果 $j &lt; k$，则返回 $3$。</li>\n<li>此时 $j &#x3D;&#x3D; k$，并且此时 $j, k$ 的位置元素等于枢，也是 $GE$ 位置的左边界线。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"算法的思考\"><a href=\"#算法的思考\" class=\"headerlink\" title=\"算法的思考\"></a>算法的思考</h4><p>如果选择枢的方式是固定而不是随机的(例如总是选择第一个值作为枢)，并且出现了 $L$ 子集是空的情况(此时选择的枢是最小值)，那么此时会导致算法出现死循环。因为每次对 $GE$ 子集进行排序时，总是会选择最左边的值(也是最小值)作为枢，从而导致 $L$ 子集是空的情况。</p>\n<blockquote>\n<p>快速排序要避免固定选择枢和出现一方子集是空集的情况，否则可能会导致死循环。</p>\n</blockquote>\n<ul>\n<li>解决方法1：使用随机的方式选择枢。</li>\n<li>解决方法2：将排序分为三个部分，分别是 $L$, ${pivot}$, $E+G$。</li>\n<li>解决方法3：三点取值，选择最左边的数、中间的数和最右边的数中的中位数作为枢。</li>\n</ul>\n<h4 id=\"复杂度分析-3\"><a href=\"#复杂度分析-3\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li>最差的情况下，快速排序的时间复杂度是 $O(n^2)$。</li>\n<li>最佳的情况下，快速排序的时间复杂度是 $O(n\\log{n})$。</li>\n<li>平均情况下，在一半的时间中快速排序选择的枢是中间值，那么时间复杂度是 $O(n\\log{n})$。<ul>\n<li>也可以认为平均情况下，选择的枢值总是让两个子集分解成 $\\frac{1}{3}$ 和 $\\frac{2}{3}$ 两个区域，也就是说递归二叉树的高度是 $\\frac{3}{2}\\log n$。</li>\n<li>*具体证明可以自行查看<a href=\"https://en.wikipedia.org/wiki/Quicksort\">维基百科</a>*。</li>\n</ul>\n</li>\n</ul>\n<p>快速排序不需要用到额外的空间，因此其空间复杂度是 $O(1)$。</p>\n<h4 id=\"算法的性质-2\"><a href=\"#算法的性质-2\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>快速排序 <strong>不具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>该算法 <strong>不需要</strong> 额外的空间，是就地(in-place)的算法。</li>\n<li>该算法对数据的访问是随机的(randomized)。</li>\n<li>因为是使用 交换 或者 删除再插入 操作进行，因此可以使用双向链表。</li>\n</ul>\n<hr>\n<h2 id=\"启发式算法-Heuristics\"><a href=\"#启发式算法-Heuristics\" class=\"headerlink\" title=\"启发式算法(Heuristics)\"></a>启发式算法(Heuristics)</h2><p>启发式算法是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。<br>通常有两种：</p>\n<ol>\n<li>程序中的决策可以给出准确&#x2F;最佳的答案，但通常是为了加快程序运行速度。<ul>\n<li>例如，A*搜索算法中使用可接受的启发式方法(Admissible heuristic)、在快速排序算法中使用随机选择的方式选择枢(pivot)。</li>\n</ul>\n</li>\n<li>程序中的决策可能不会给出最佳答案，但旨在给出以其他方式无法获得的良好答案。<ul>\n<li>一般用于解决一些<code>NP-hard</code>问题，例如 TSP问题、图染色问题等。</li>\n<li>例如 遗传算法、模拟退火。</li>\n<li>具体可以参考<a href=\"/post/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-AIM-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95\">AIM-优化算法</a>笔记。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"贪心算法-Greedy\"><a href=\"#贪心算法-Greedy\" class=\"headerlink\" title=\"贪心算法(Greedy)\"></a>贪心算法(Greedy)</h3><p>贪心算法是一种常见的启发式算法。贪心算法是做出短期内看起来最好的决定，而不考虑未来的策略。</p>\n<p>一些贪心算法可以得到最优解，例如最小生成树(Minimal Spanning Tree, MST)中Prim算法。</p>\n<p>大部分贪心算法无法给出最优解，但是可以给出接近最优的解。</p>\n<h4 id=\"最小生成树问题-Minimal-Spanning-Tre-MST\"><a href=\"#最小生成树问题-Minimal-Spanning-Tre-MST\" class=\"headerlink\" title=\"最小生成树问题(Minimal Spanning Tre, MST)\"></a>最小生成树问题(Minimal Spanning Tre, MST)</h4><p>问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。<br>问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。</p>\n<h5 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h5><p>思路：</p>\n<ol>\n<li>选择任意顶点 $M$。</li>\n<li>选择对外可以连接到的所有的点中最小的那个边，并将边加入到 <code>MST</code>中，将点加入到内部的点中。</li>\n<li>是否全部连接，如果没有则返回 $2$。通过已连接的边个数判断，即 边的个数 $e &#x3D; n - 1$。</li>\n</ol>\n<p>算法实现：</p>\n<ul>\n<li>$1.$ 初始化数组 <code>value[n] = inf</code>，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数<code>m = 0</code>。</li>\n<li>$2.$ 随机选择一个点 $M$。</li>\n<li>$3.$ 使<code>value[M] = 0</code>，并根据 $M$ 连接的所有边 $(M, V)$ 更新 <code>edge</code> 数组。即 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value[M] = 0              # 因为已经被连接，所以更新为0</span><br><span class=\"line\">forall e in edge(M)</span><br><span class=\"line\">  v = e.v                 # 获取边连接的另一个点</span><br><span class=\"line\">  if(e.value &lt; value[v])  # 根据边权值更新对外连接点的大小</span><br><span class=\"line\">    value[v] = e.value </span><br></pre></td></tr></table></figure></li>\n<li>$4.$ 找到 <code>value[v] != 0</code> 中最小的点 $V$，使 <code>value[V] = 0</code>，<code>m++</code>。</li>\n<li>$5.$ 跟 $3$ 一样根据 $V$ 连接的所有边 $(V, U)$ 更新 <code>edge</code> 数组。</li>\n<li>$6.$ 判断是否所有的点已经连通，即 <code>(m - 1) == n</code>，如果没有则返回 $4$。</li>\n</ul>\n<hr>\n<h2 id=\"动态规划-Dynamic-Programming-DP\"><a href=\"#动态规划-Dynamic-Programming-DP\" class=\"headerlink\" title=\"动态规划(Dynamic Programming, DP)\"></a>动态规划(Dynamic Programming, DP)</h2><blockquote>\n<p>DP is a general method that can be suitable when the optimal solutions satisfy a “decomposition property”.<br>DP 是一种适用于最优解满足“分解性质”情况的通用方法。</p>\n</blockquote>\n<p>DP的步骤通常如下：</p>\n<ol>\n<li>将最优解分解为子解相当于将问题分解为子问题，并且子解对于子问题是最优的。</li>\n<li>因此，最优解可以通过更小的子问题的最优解来构建。</li>\n</ol>\n<p><em>与分治法不同的是，DP中的子问题可以重叠，即不同的路径可能会遇见相同的子问题。</em></p>\n<p>因此DP的思想通常是，对于某一个解 $S_n$，如果我想要得到这个解，我该直到哪些解才能得出这个解，并依次获取和尝试合并这些可能解的组合。又或者说，我现在已知某一个解，我是否可以让这个解和其他输入&#x2F;解组合获取一个新的解。其中这个“得到”和“获取”的过程是一个状态转移的过程，这个过程是一个状态转移方程&#x2F;贝尔曼方程(Bellman Equation)。</p>\n<ul>\n<li>例如，假设有这样一个问题：给出一个整型集合 $S$，和一个目标值 $K$，我是否可以找出一个 $S_{sub}$ 的子集，其元素的和等于 $K$。<ul>\n<li>假设我们输入 $S[i], 0 \\leq i \\leq (n-1)$ 是集合第 $i$ 个元素。</li>\n<li>我们使用 $dp[i][m] &#x3D; true, 0 \\leq m \\leq K$ 来表示使用前 $i$ 个元素组成的子集中 $S_{sub}$ 元素和可以等于 $m$。</li>\n<li>如果我们知道 $dp[i - 1][m] &#x3D; true$，那么可以根据它和当前元素 $S[i]$ 得出 $dp[i][m + S[i]] &#x3D; true$。</li>\n<li>如何知道$dp[i - 1][m] &#x3D; true$? 只需要对 $m$ 进行遍历 $(0 \\leq m \\leq K-S[i])$ 依次检查是否为<code>true</code>即可。</li>\n<li>由此我们就可以得到状态转移方程：$dp[i][m] &#x3D; dp[i][m]\\ \\text{ | } \\ dp[i - 1][m - S[i]]$。</li>\n<li>时间复杂度是 $O(kn)$。</li>\n<li>此外我们可以使用滚动数组将其变成一维dp，此时对容量 $m$ 的遍历是倒着的（如果正着就会导致元素 $i$ 被重复计算，此时属于完全背包问题）。</li>\n</ul>\n</li>\n</ul>\n<p><em>与暴力搜索，暴力搜索是将所有可能的答案依次列出来并测试，答案之间可能没有太大的关系。而动态规划是根据状态转移来尝试获取哪些解。</em></p>\n<hr>\n<h2 id=\"最短路算法-Shortest-Path\"><a href=\"#最短路算法-Shortest-Path\" class=\"headerlink\" title=\"最短路算法(Shortest Path)\"></a>最短路算法(Shortest Path)</h2><p>最短路算法分为单源最短路和多源最短路。<br>解决单源最短路的一种方法是 <code>Dijkstra</code> 算法，其时间复杂度是 $O(n\\log n + m)$。如果将其应用在多源最短路的话，那么其时间复杂度是 $O(n(n\\log n + m))$。</p>\n<p>此外，有一个特定的算法用来解决多源最短路，就是<code>Floyd-Warshall (FW)</code>算法，该算法的时间复杂度是 $O(n^3)$。</p>\n<h3 id=\"Floyd-Warshall-FW\"><a href=\"#Floyd-Warshall-FW\" class=\"headerlink\" title=\"Floyd-Warshall (FW)\"></a>Floyd-Warshall (FW)</h3><p>FW算法是一个动态规划的算法，通过逐步加入点来构造子答案从而获取整体最优解的方法。<br>适用于负数边、有向边的情况。</p>\n<ul>\n<li><p>定义：</p>\n<ul>\n<li><p>定义 $d(i,j,k)$：表示点在 $i,j$ 之间使用 ${1,…,k}$ 作为允许使用的潜在中间点的最短路。</p>\n<ul>\n<li>例如 $d(2,5,3)$：在仅使用 ${1,2,3}$ 其中的点作为中间点（这些点可以使用也可以不使用，但不能使用其他的点）时点 $2$ 到点 $5$ 的最短路。</li>\n</ul>\n</li>\n<li><p>定义 $w(i, j)$：表示两个点之间的距离。</p>\n<ul>\n<li>如果不连通则等于 $\\infty$，即 <code>w(i, j) = inf</code>。</li>\n<li>自边等于 $0$，即 <code>w(i, i) = 0</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>初始化：对于所有的两个点之间：$d(i, j, 0) &#x3D; w(i, j)$。</p>\n</li>\n<li><p>状态转移方程：考虑当 <code>k = k + 1</code>时，即对于每两对点之间在前 <code>k</code> 个点已经加入好，那么有：<br>$$d(i, j, k+1) &#x3D; \\min (d(i, j, k), d(i, k+1, k) + d(k+1, j, k))$$</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li>“Big O Notation.” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Big_O_notation. Accessed 19 May 2024.</li>\n<li>“Recurrence Relation.” Wikipedia, The Free Encyclopedia, 8 April 2024, en.wikipedia.org&#x2F;wiki&#x2F;Recurrence_relation. Accessed 20 May 2024.</li>\n<li>“Master Theorem (Analysis of Algorithms).” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Master_theorem_(analysis_of_algorithms). Accessed 22 May 2024.</li>\n<li>“Quicksort.” Wikipedia, The Free Encyclopedia, 12 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Quicksort. Accessed 21 May 2024.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>有关算法效率分析的笔记，包括Big-Oh表示法、Master定理和部分算法与数据结构的算法分析。</p>\n<div style=\"text-align:center\">\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/cover.png\" alt=\"封面\" width=\"300\">\n</div>","more":"<hr>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>原博客：<a href=\"https://www.zexnocs.top/post/%E7%AC%94%E8%AE%B0%2F%E7%AC%94%E8%AE%B0-ADE-%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%88%E7%8E%87\">点击跳转</a></p>\n<p>本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。</p>\n<p>本笔记主要分为下面五个部分：</p>\n<ul>\n<li>一. 算法效率的评估</li>\n<li>二. Big-Oh表示法和其家族</li>\n<li>三. Master定理</li>\n<li>四. 数据结构</li>\n<li>五. 算法</li>\n</ul>\n<h1 id=\"一-算法效率的评估\"><a href=\"#一-算法效率的评估\" class=\"headerlink\" title=\"一. 算法效率的评估\"></a>一. 算法效率的评估</h1><p>如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 <strong>程序的运行时间</strong> 来评估测量算法效率。</p>\n<p>在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 <del>(关于SPFA，它死了)</del> 。</p>\n<p>由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。</p>\n<hr>\n<h2 id=\"方法一：Experiment-实验统计\"><a href=\"#方法一：Experiment-实验统计\" class=\"headerlink\" title=\"方法一：Experiment 实验统计\"></a>方法一：Experiment 实验统计</h2><img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png\" alt=\"实验统计样例\" width=\"300\">\n\n<blockquote>\n<p>实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。</p>\n</blockquote>\n<p>具体步骤如下:</p>\n<ul>\n<li>写一个程序实施该算法</li>\n<li>使用不同的输入大小和输入信息运行程序</li>\n<li>记录实际运行时间</li>\n<li>绘制并使用统计学分析（如回归分析）</li>\n</ul>\n<p>在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注<strong>最差的情况</strong>，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。</p>\n<h3 id=\"缺点-局限性\"><a href=\"#缺点-局限性\" class=\"headerlink\" title=\"缺点 &amp; 局限性\"></a>缺点 &amp; 局限性</h3><ul>\n<li>必须用程序实现该算法，可能会很耗时。</li>\n<li>需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。</li>\n<li>效率的评估受到硬件&#x2F;软件&#x2F;语言环境的影响。</li>\n</ul>\n<hr>\n<h2 id=\"方法二：Theory-理论分析\"><a href=\"#方法二：Theory-理论分析\" class=\"headerlink\" title=\"方法二：Theory 理论分析\"></a>方法二：Theory 理论分析</h2><blockquote>\n<p>理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。</p>\n</blockquote>\n<p>跟实验统计一样，我通常指关注<strong>最差的情况</strong>。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>具有一定的抽象性。</li>\n<li>能够独立于硬件&#x2F;软件&#x2F;语言环境来评估算法的效率。</li>\n<li>能够考虑所有可能的输入。</li>\n</ul>\n<h3 id=\"缺点-局限性-1\"><a href=\"#缺点-局限性-1\" class=\"headerlink\" title=\"缺点 &amp; 局限性\"></a>缺点 &amp; 局限性</h3><ul>\n<li>实施过程可能会比较困难，需要一定的知识基础。</li>\n<li>在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。</li>\n</ul>\n<h3 id=\"评估标准\"><a href=\"#评估标准\" class=\"headerlink\" title=\"评估标准\"></a>评估标准</h3><p>在实验统计中，我们往往使用 <strong>程序的运行时间</strong> 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：<strong>原始运算数量</strong>。</p>\n<h4 id=\"原始运算的定义\"><a href=\"#原始运算的定义\" class=\"headerlink\" title=\"原始运算的定义\"></a>原始运算的定义</h4><blockquote>\n<p>原始运算(primitive operations)是算法执行的基本运算。</p>\n</blockquote>\n<p>在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将<strong>汇编代码</strong>、<strong>算数运算</strong>视作一个原始运算。</p>\n<p>注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：</p>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>伪代码样例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>变量赋值</td>\n<td><code>a ← 0</code></td>\n</tr>\n<tr>\n<td>数组索引</td>\n<td><code>a[10]</code></td>\n</tr>\n<tr>\n<td>变量比较</td>\n<td><code>a == 10</code></td>\n</tr>\n<tr>\n<td>算数运算</td>\n<td><code>a + 1</code></td>\n</tr>\n<tr>\n<td>函数调用</td>\n<td><code>function()</code></td>\n</tr>\n<tr>\n<td>函数返回</td>\n<td><code>return 0</code></td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。</li>\n<li>数组索引需要用到袁术运算是因为它需要在内存中进行索引。</li>\n<li>函数调用属于原始运算是因为它需要在内存中进行索引。</li>\n<li>在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。</li>\n</ul>\n<p>对于其他的运算，都可以拆分为这些原始运算：</p>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>分析</th>\n<th>操作数</th>\n<th>伪代码样例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>for循环，循环次数为$n$</td>\n<td>要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)</td>\n<td>$1+n+2n &#x3D; 3n+1$</td>\n<td><code>for i ← 1 to n do</code></td>\n</tr>\n<tr>\n<td>for循环，循环次数为$(n-1)$</td>\n<td>要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)</td>\n<td>$1+2(n-1)+2(n-1) &#x3D; 4n-3$</td>\n<td><code>for i ← 1 to (n-1) do</code></td>\n</tr>\n<tr>\n<td>while循环，循环次数为$n$</td>\n<td>每次循环只需要判断即可</td>\n<td>$n$</td>\n<td><code>while i &gt; n</code></td>\n</tr>\n<tr>\n<td>while循环，循环次数为$(n-1)$</td>\n<td>每次循环都需要进行判断和减法</td>\n<td>$2(n-1)$</td>\n<td><code>while i &gt; (n-1)</code></td>\n</tr>\n<tr>\n<td>if then判断，then内部原始运算数为$k$</td>\n<td>一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)</td>\n<td>$1 + k$</td>\n<td><code>if ... then ...</code></td>\n</tr>\n</tbody></table>\n<p>:::details 一个计算原始运算数的例子: arrayMax(A, n)</p>\n<p>一个返回数组最大值arrayMax(A, n)的伪代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。</span><br><span class=\"line\">  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值</span><br><span class=\"line\">  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)</span><br><span class=\"line\">    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)</span><br><span class=\"line\">      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)</span><br><span class=\"line\">  return currentMax         # 原始运算为1，函数返回</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，这个算法的原始运算总数为 $2 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 &#x3D; 8n - 4$</p>\n<p>:::</p>\n<p>原始运算的个数并不是固定的，例如在计算操作 $c \\leftarrow A[i]$ 中，你也可以认为是$4$个原始运算：</p>\n<ul>\n<li>获取$A$数组的指针储存在寄存器中。</li>\n<li>获取$i$储存在寄存器中。</li>\n<li>计算$A + i$作为$A[i]$的指针储存在寄存器中。</li>\n<li>复制变量$c$的数值写在$A + i$指针的内存中。</li>\n</ul>\n<p>当然在这个笔记中，你也可以认为只有$2$个原始运算：</p>\n<ul>\n<li>根据$i$索引获取$A[i]$数组位置 (数组索引)。</li>\n<li>将变量$c$的数值赋值给$A[i]$ (变量赋值)。</li>\n</ul>\n<p>但是无论是$4$还是$2$，这个操作永远不可能会是$2n$，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。</p>\n<blockquote>\n<p>原始运算的个数只与算法的效率有关，与正确性无关。</p>\n</blockquote>\n<h4 id=\"使用原始运算估算运行时间\"><a href=\"#使用原始运算估算运行时间\" class=\"headerlink\" title=\"使用原始运算估算运行时间\"></a>使用原始运算估算运行时间</h4><p>增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。</p>\n<blockquote>\n<p>对于算法来说，假设它的最差情况的运行时间为$T(n)$，那么$T(n)$的增长率是该算法的固有属性，是不受硬件&#x2F;软件环境影响的。</p>\n</blockquote>\n<p>我们可以使用原始运算来估算运行时间，假设：</p>\n<ul>\n<li>原始运算的个数为$P(n)$。</li>\n<li>最快的原始运算所需要的时间为$a$，是一个常数。</li>\n<li>最慢的原始运算所需要的时间为$b$，是一个常数。</li>\n</ul>\n<p>可以得出：$$aP(n) \\leq T(n) \\leq bP(n)$$</p>\n<p>由于a和b都是常数，那么我们认为[T(n)]和[P(n)]具有相同的增长率。很明显$T(n)$和$P(n)$的导数肯定是不同的，因此增长率并不等同于导数。</p>\n<p>但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。</p>\n<h1 id=\"二-Big-Oh表示法和其家族\"><a href=\"#二-Big-Oh表示法和其家族\" class=\"headerlink\" title=\"二. Big-Oh表示法和其家族\"></a>二. Big-Oh表示法和其家族</h1><h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>我们需要一种函数分类(Classification of Functions)来通过<strong>缩放</strong>的行为将函数分组在一起，同一组的函数具有这样的相似性：</p>\n<ul>\n<li>删除不必要的细节。</li>\n<li>相对快速、简单。</li>\n<li>处理运行时可能会发生的“奇怪的”函数(例如分段函数)。</li>\n<li>在数学上拥有明确的定义。</li>\n</ul>\n<p>其中一种最佳的方法是使用<a href=\"https://en.wikipedia.org/wiki/Big_O_notation\">Big-Oh表示法和其家族(Big-Oh notation and family)</a>：</p>\n<ul>\n<li>$O$: Big-Oh</li>\n<li>$\\Omega$: Big-Omega</li>\n<li>$\\Theta$: Big-Theta</li>\n<li>$o$: little-oh</li>\n<li>$\\omega$: little-omega</li>\n</ul>\n<p>本笔记只集中于前四个的定义和Big-Oh的相关理论。</p>\n<hr>\n<h2 id=\"Big-Oh：O-n\"><a href=\"#Big-Oh：O-n\" class=\"headerlink\" title=\"Big-Oh：O(n)\"></a>Big-Oh：O(n)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ O(g(n))$ ，当且仅当<br>$$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c \\ g(n)$$</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>量词顺序是 $\\exists \\ \\exists \\ \\forall$</li>\n<li>$c$ 和 $n_0$必须是常数，不能随着$n$变化。不然这是没有意义的。</li>\n<li>注意符号$&gt;,\\geq,\\leq$的区分。相比之下是比较严格的(例如，$n_0$ 不能等于 $0$, $n$ 可以等于 $n_0$)。</li>\n</ul>\n<p>此外，Big-Oh可以会被定义为：<br>$$\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty $$</p>\n<blockquote>\n<p>Big-Oh只规定了$f(n)$的<strong>增长率的上限</strong>(upper bound on the growth rate of the function)。</p>\n</blockquote>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>Big-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于<strong>函数</strong>。也就是说它并不是对算法进行分类，而是对<strong>函数</strong>进行分类。</li>\n<li>一般$f(n)$表示运行时间，$n$表示输入的个数，所以Big-Oh中描述的函数一般为 $f: \\mathbb{N^+} \\to \\mathbb{R^+}$，$g(n)$也类似。</li>\n<li>Big-Oh只规定了$f(n)$的<strong>增长率的上限</strong>，也就是说，当$n$足够大时，$f(n)$的增长速率不大于$g(n)$。</li>\n<li>Big-Oh中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) &#x3D; 1$可以是$O(1)$，但也可以是$O(n)$。因此$g(n)$的增长率越小越能反应出$f(x)$的增长率。</li>\n</ul>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>Big-Oh作为一个二元关系(binary relation)，拥有以下性质：</p>\n<ul>\n<li>Big-Oh具有自反性(Reflexive, e.g. $x R x$)，即 $f(n)$ 是 $O(f(n))$。</li>\n<li>Big-Oh不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)，例如 $f(n) &#x3D; 1$ 是 $O(n)$，但是 $f(n) &#x3D; n$ 不是 $O(1)$。</li>\n<li>Big-Oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。即如果 $\\forall n \\geq n_1, f(n) \\leq c_1g(n)$，且$\\forall n \\geq n_2, g(n) \\leq c_2h(n)$，那么总有 $\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3&#x3D;\\max(n_1,n_2)$。</li>\n</ul>\n<p>综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是$\\subset, \\in, \\leq$,而不是$&#x3D;$，因此有一种表示方法是将Big-Oh视作集合，使用$n \\in O(n)$。此时也有会 $O(lower\\ order) \\subset O(heigher\\ order)$。</p>\n<p><em>此外，也有一种说法是使用$f(n) &#x3D; O(n)$，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。</em></p>\n<h3 id=\"推论-方法\"><a href=\"#推论-方法\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：存在三个函数$f(n)$, $g(n)$, $p(n)$和正数$k, b\\in \\mathbb{N^+}$，如果$f(n)$是$O(g(n))$，且$f(n)&#x3D;k\\ p(n) + b$，那么有$p(n)$是$O(g(n))$。</li>\n</ul>\n<p>:::details 证明推论1</p>\n<p>假设有$c_0 &gt; 0, n_0 &gt; 0$，对于$n_1 \\geq n_0$，有：</p>\n<p>$f(n_1) \\leq c_0 \\ g(n_1)$，那么有：</p>\n<p>$k\\ p(n_1) + b \\leq c_0 \\ g(n_1)$，整理得：</p>\n<p>$p(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}$</p>\n<p>当n足够大时候，假设此时$n_1 \\geq n_2$，有 $cg(n_1) \\geq 2b$</p>\n<p>从而有 $p(n_1) \\leq \\frac{c_0}{2k}g(n_1)$</p>\n<p>设 $c_1&#x3D;\\frac{c}{2k}&gt;0$，我们得到：</p>\n<p>$p(n_1) \\leq c_1\\ g(n_1)$，即</p>\n<p>存在 $c_1$，$n_2$使得 $\\forall n &gt; n_2, p(n) \\leq c_1\\ g(n)$</p>\n<p>因此$p(n)$是$O(g(n))$。</p>\n<p>:::</p>\n<ul>\n<li>推论2 （乘法）：如果$f_1(n)$ 是 $O(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$。</li>\n</ul>\n<p>:::details 证明推论2</p>\n<p>$∵ f_1(n)$ 是 $O(g_1(n))$</p>\n<p>$∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1$</p>\n<p>$∵ f_2(n)$ 是 $O(g_2(n))$</p>\n<p>$∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2$</p>\n<p>$∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0$</p>\n<p>那么有 $n_0 &#x3D; \\max(n_1, n_2)$<br>$f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0$</p>\n<p>因此$f_1(n)f_2(n)$ 是 $O(g_1(n)g_2(n))$</p>\n<p>:::</p>\n<ul>\n<li>推论3 （加法）：如果 $f(n) &#x3D; 1 + h(n)$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(1)$。</li>\n</ul>\n<p>:::details 证明推论3</p>\n<p>$∵$ 当$n \\to \\infty$ 时 $h(n) \\to 0$<br>$∴$ $\\exists n_0 &gt; 0,\\ \\forall n \\geq n_0, h(n) \\leq 1$<br>$∴$ $\\exists n_0 &gt; 0,\\ \\forall n \\geq n_0, f(n) \\leq 2$<br>$∴$ $f(n)$ 是 $O(1)$ 取 $c &#x3D; 2, n_0 &#x3D; n_1$ 且 $h(n_1) &lt;&#x3D; 1$</p>\n<p>:::</p>\n<p>一些常用的 $h(n)$:</p>\n<ul>\n<li>$n^2&#x2F;2^n$</li>\n<li>$n^{2000}&#x2F;2^{\\frac{n}{100}}$</li>\n<li>$(log(n))^{100} &#x2F; n^{0.1}$</li>\n</ul>\n<p>综合推论2和3，可知如果 $f(n) &#x3D; g(n)(1 + h(n))$，且当$n \\to \\infty$ 时 $h(n) \\to 0$，那么 $f(n)$ 是 $O(g(n))$。</p>\n<p>因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：</p>\n<ul>\n<li>删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。</li>\n<li>删除常数(constant)项系数 (根据推论1,总能找到 $k$ 使得系数变成 $1$)。</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>:::details 证明arrayMax(A, n)是 $O(n)$ 的例子 (定义)</p>\n<p>由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 $f(n) &#x3D; 8n - 4$</p>\n<p>设$g(n) &#x3D; n$，因此需要求证 $\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)$，整理可得：</p>\n<p>$$<br>\\begin{cases}<br>n \\leq \\frac{4}{c - 8} &amp; c &gt; 8 \\<br>n \\geq \\frac{4}{c - 8} &amp; c &lt; 8 \\<br>-4 \\leq 0 &amp; c &#x3D; 8<br>\\end{cases}<br>$$</p>\n<p>由于我们规定是 $\\forall n \\geq n_0$，因此我们只能取 $n \\geq 8$。</p>\n<p>当我们取 $n &#x3D; 8$时，很明显任意$n_0 &gt; 0$都可以证明成立。此时我们可以取 $n_0 &#x3D; 1$。</p>\n<p>当我们取 $n &gt; 8$时，很明显任意$n_0 &gt; \\frac{4}{c - 8}$都可以证明成立。此时我们可以取 $n_0 &#x3D; \\frac{4}{c - 8}$。</p>\n<p>实际上，上述情况只需要求出一组$(c,n_0)$即可，因此我们可以直接取$c &#x3D; 8, n_0 &#x3D; 1$。不过这里给出了一种选取$(c,n_0)$的具体方法。</p>\n<p>因此arrayMax(A, n)的时间复杂度是 $O(n)$。</p>\n<p>:::</p>\n<p>:::details 对于分段函数Big-Oh的证明 (定义)</p>\n<p>如何计算下面函数的Big-Oh:<br>$$<br>f(n) &#x3D;<br>\\begin{cases}<br>n &amp; \\text{if } n \\text{ is even} \\<br>1 &amp; \\text{if } n \\text{ is odd}<br>\\end{cases}<br>$$</p>\n<p>因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即$f(n) &#x3D; n$，此时当$c &#x3D; 1, n_0 &#x3D; 1$可以证明出$f(n)$是$O(n)$，而无法证明出$f(n)$是$O(1)$。</p>\n<p>:::</p>\n<p>:::details 求 $f_(n) &#x3D; n^2 + n$ 的Big-Oh (定理2, 3)</p>\n<p>$f(n) &#x3D; n^2 + n &#x3D; n^2(1 + \\frac{1}{n})$</p>\n<p>因为自反性，$n^2$ 是 $O(n^2)$。</p>\n<p>因为当$n \\to \\infty$ 时 $\\frac{1}{n} \\to 0$，根据推理3可知 $1 + \\frac{1}{n}$ 是 $O(1)$。</p>\n<p>因此根据推理2，$f(n)$ 是 $O(n^2 * 1) &#x3D; O(n^2)$</p>\n<p>:::</p>\n<p>:::details 求 $f_(n) &#x3D; 5n^4 + 3n^3$ 的Big-Oh (删除规则)</p>\n<ul>\n<li>删除低阶$3^n$，因此$f(n)$ 是 $O(5n^4)$</li>\n<li>删除常数$5$，因此$f(n)$ 是 $O(n^4)$</li>\n</ul>\n<p>:::</p>\n<h3 id=\"Big-Oh公约\"><a href=\"#Big-Oh公约\" class=\"headerlink\" title=\"Big-Oh公约\"></a>Big-Oh公约</h3><p>遵循这个公约可以更好地去分析算法以及给出最大的信息。</p>\n<ul>\n<li>使用最小且正确的增长率函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(n^2)$，尽管后者也是正确的。</li>\n<li>使用最简的函数表示Big-Oh。例如说 $2n$ 是 $O(n)$ 而不是 $O(2n)$。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>对于 $n^{O(1)}$来说，相当于是 ${ n^f(n)\\ |\\ f(n) \\text{ is } O(1)}$。<br>也就是说 ${n^1, n^2, n^3, …} \\subset n^{O(1)}$，${n^\\frac{1}{2}, n^\\frac{1}{3}, n^\\frac{1}{4}… } \\subset n^{O(1)}$</p>\n<blockquote>\n<p>$n^{O(1)}$ is any function that is no worse than (Big-Oh of) some power law.<br>$n^{O(1)}$表示任何不超过指数级的函数。</p>\n</blockquote>\n<hr>\n<h2 id=\"Big-Omega：Ω-n\"><a href=\"#Big-Omega：Ω-n\" class=\"headerlink\" title=\"Big-Omega：Ω(n)\"></a>Big-Omega：Ω(n)</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Omega (g(n))$ ，当且仅当<br>$$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : f(n) \\geq c \\ g(n)$$</p>\n<p>注意：</p>\n<ul>\n<li>量词顺序是 $\\exists \\ \\exists \\ \\forall$。</li>\n<li>与Big-Oh不同，最后的符号是 $\\geq$ 而不是 $\\leq$。</li>\n</ul>\n<p>此外，Big-Omega可以会被定义为：<br>$$\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} &gt; 0 $$</p>\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>Big-Omega规定了$f(n)$的<strong>增长率的下限</strong>，也就是说，当$n$足够大时，$f(n)$的增长速率不小于$g(n)$。</li>\n<li>Big-Omega中$g(n)$的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于$f(n) &#x3D; n^3 - n$ 可以是 $\\Omega(n^3)$，但也可以是 $\\Omega(n^2)$。因此$g(n)$的增长率越大越能说明$f(n)$的增长率。</li>\n<li>一般可以用来描述算法的最佳情况。</li>\n</ul>\n<h3 id=\"性质-1\"><a href=\"#性质-1\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：</p>\n<ul>\n<li>Big-Omega具有自反性(Reflexive, e.g. $x R x$)。</li>\n<li>Big-Omega不具有对称性(Symmetric, e.g. $x R y \\iff y R x$)。</li>\n<li>Big-Omega具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>Big-Omega更像是 $\\geq$。</p>\n<h3 id=\"推论-方法-1\"><a href=\"#推论-方法-1\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：$f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))$</li>\n<li>推论2 （乘法）：如果$f_1(n)$ 是 $\\Omega(g_1(n))$, $f_2(n)$ 是 $\\Omega(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $\\Omega(g_1(n)g_2(n))$。</li>\n</ul>\n<p>删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是<strong>删除低阶函数</strong>而不是删除高阶函数。</p>\n<p>例如 $f(n) &#x3D; n^3 - n$中，应该删除的是$n$。找到$n^3$后我们就可以找比$n^3$阶级低的函数来代替。</p>\n<hr>\n<h2 id=\"Big-Theta：θ-n\"><a href=\"#Big-Theta：θ-n\" class=\"headerlink\" title=\"Big-Theta：θ(n)\"></a>Big-Theta：θ(n)</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ \\Theta (g(n))$ ，当且仅当</p>\n<blockquote>\n<p>$$\\exists c’ &gt; 0, \\exists c’’&gt;0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : c’\\ g(n) \\leq f(n) \\leq c’’ \\ g(n)$$</p>\n</blockquote>\n<p>此外，Big-Theta可以被定义为：</p>\n<blockquote>\n<p>$$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))$$<br>$$f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))$$</p>\n</blockquote>\n<h3 id=\"性质-2\"><a href=\"#性质-2\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>Big-Theta作为一个二元关系拥有下面的性质：</p>\n<ul>\n<li>Big-Theta具有自反性(Reflexive, e.g. $x R x$)。</li>\n<li>Big-Theta<strong>具有</strong>对称性(Symmetric, e.g. $x R y \\iff y R x$)：如果 $f(n)$ 是 $\\Theta(g(n))$，那么 $g(n)$ 是 $\\Theta(f(n))$。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。</li>\n<li>Big-Theta具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>Big-Theta更像是 $\\approx$。</p>\n<hr>\n<h2 id=\"little-oh：o-n\"><a href=\"#little-oh：o-n\" class=\"headerlink\" title=\"little-oh：o(n)\"></a>little-oh：o(n)</h2><h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>假设有两个正函数$f(n)$和$g(n)$，如果我们称 $f(n) \\ is \\ o(g(n))$ ，当且仅当<br>$$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| &lt; c \\ g(n)$$</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>量词顺序是 $\\forall \\ \\exists \\ \\forall$。</li>\n<li>因为是对于全部的 $c$ 存在 $n_0$，因此 $n_0$ 的数值可以依赖于 $c$。</li>\n<li>与Big-Oh不同，最后的符号是 $&lt;$ 而不是 $\\leq$。</li>\n</ul>\n<p>little-oh也可以被定义为：<br>$$\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} &#x3D; 0$$</p>\n<h3 id=\"性质-3\"><a href=\"#性质-3\" class=\"headerlink\" title=\"性质\"></a>性质</h3><p>little-oh作为一个二元关系(binary relation)，拥有以下性质：</p>\n<ul>\n<li>little-oh<strong>不具有</strong>自反性(Reflexive, e.g. $x R x$)。即$f(n) &#x3D; n$ 不是 $o(n)$。</li>\n<li>little-oh<strong>不具有</strong>对称性(Symmetric, e.g. $x R y \\iff y R x$)。</li>\n<li>little-oh具有传递性(Transitive, e.g. $x R y \\land y R z \\to xRz$)。</li>\n</ul>\n<p>little-oh 更像是严格的 $&lt;$。</p>\n<h3 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>与Big-Oh类似，little-Oh定义是函数的<strong>严格无法到达的上限</strong>。</li>\n<li>little-oh的意思是，当$n$足够大时，$f(n)$的增长速率小于$g(n)$。</li>\n<li>little-oh中 $g(n)$ 阶级越小，越能说明 $f(n)$ 的增长率。</li>\n</ul>\n<h3 id=\"推论-方法-2\"><a href=\"#推论-方法-2\" class=\"headerlink\" title=\"推论 &amp; 方法\"></a>推论 &amp; 方法</h3><ul>\n<li>推论1：如果$f(n)$ 是 $o(g(n))$，那么 $f(n)$ 一定是 $O(g(n))$<br>正如 $&lt;\\ \\to\\ \\leq$ 一样，很明显 $O(g(n)) \\subset o(g(n))$。</li>\n<li>推论2 （乘法1）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $o(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。</li>\n<li>推论3 （乘法2）：如果$f_1(n)$ 是 $o(g_1(n))$, $f_2(n)$ 是 $O(g_2(n))$，那么 $f_1(n)f_2(n)$ 是 $o(g_1(n)g_2(n))$。</li>\n</ul>\n<p>与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。</p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>:::details 证明 $f(n) &#x3D; n ^ 2 + n$ 是 $o(n^3)$</p>\n<p>要证明$f(n) &#x3D; n ^ 2 + n$ 是 $O(n^3)$，则需要证明 $\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : f(n) &lt; c \\ g(n)$。</p>\n<p>代入和整理可得 $\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : cn^2-n-1 &gt; 0$。</p>\n<p>由公式可得，若 $cn^2-n-1 &#x3D; 0$，且$n_r &gt; 0$，可解得 $n_r &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} &gt; 0$。</p>\n<p>且当 $n &gt; n_r$ 时，$cn^2 - n - 1 &gt; 0$ 恒成立，那么可以取 $n_0 &#x3D; n_r + 1 &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$，使得 $\\forall n \\geq n_0 : f(n) &lt; c \\ g(n)$ 恒成立。</p>\n<p>因此，$f(n) &#x3D; n ^ 2 + n$ 是 $O(n^3)$，此时对于所有的 $c$ 取 $n_0 &#x3D; \\frac{1 + \\sqrt{4c + 1}}{2c} + 1$。</p>\n<p>:::</p>\n<h3 id=\"关于Big-Oh和little-oh的定义上的思考：\"><a href=\"#关于Big-Oh和little-oh的定义上的思考：\" class=\"headerlink\" title=\"关于Big-Oh和little-oh的定义上的思考：\"></a>关于Big-Oh和little-oh的定义上的思考：</h3><p>如果将Big-Oh的定义改为：$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| &lt; c \\ g(n)$，称为 $O_&lt;$，而原定义称为 $O_{\\leq}$，<br>那么实际上，对于 $g(n) &gt; 0$， $f(n)$ 是 $O_&lt;(g(n)) \\iff f(n)$ 是 $O_{\\leq}(g(n))$。<br>唯一的区别是对于 $f(n) &#x3D; 0, g(n) &#x3D; 0$ 来说 $0$ 是 $O_{\\leq}(0)$ 而不是 $O_&lt;(0)$。<br>而我们想要定义Big-Oh的渐进符号为 $\\leq$，就得要求 $0$ 是 $O(0)$，因此使用 $\\leq$ 而不是 $&lt;$。</p>\n<p>同理，对于little-oh如果定义改为：$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)|  \\leq c \\ g(n)$，称为 $o_{\\leq}$，而原定义称为 $o_{&lt;}$。<br>此时 $o_{&lt;}$ 与 $o_{\\leq}$ 定义的唯一区别也是当 $f(n) &#x3D; 0, g(n) &#x3D; 0$ 的时候，此时 $0$ 是 $o_{\\leq}(0)$ 而不是 $o_{&lt;}(0)$。<br>而我们想要定义little-oh的渐进符号是 $&lt;$，就得要求 $0$ 不是 $o(0)$，那么使用的是 $&lt;$ 而不是 $\\leq$。</p>\n<p>实际上，对于Big-Oh和little-oh最主要的区别是 $\\exists c$ 和 $\\forall c$。</p>\n<hr>\n<h2 id=\"常用表示表\"><a href=\"#常用表示表\" class=\"headerlink\" title=\"常用表示表\"></a>常用表示表</h2><p>根据阶级(order)从小到大排名。</p>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th>中文名</th>\n<th>英文名</th>\n<th>数量级</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$O(n^c), c &lt; 0$ $or$ $O(\\frac{k}{n})$</td>\n<td>负数幂级</td>\n<td>negative power</td>\n<td>$\\infty$,不存在</td>\n</tr>\n<tr>\n<td>$O(1)$</td>\n<td>常数级</td>\n<td>constant</td>\n<td>$\\infty$</td>\n</tr>\n<tr>\n<td>$O(\\log{\\log{n}})$</td>\n<td>双对数级</td>\n<td>double logarithmic</td>\n<td>$2^{2^{10^6}}$</td>\n</tr>\n<tr>\n<td>$O(\\log{n})$</td>\n<td>对数级</td>\n<td>logarithmic</td>\n<td>$10^{301030}$</td>\n</tr>\n<tr>\n<td>$O((\\log{n})^c), c &gt; 1$</td>\n<td>多重对数级</td>\n<td>polylogarithmic</td>\n<td>$2^{10^{\\frac{6}{c}}}$</td>\n</tr>\n<tr>\n<td>$O(n^c), 0 &lt; c &lt; 1$ $or$ $O(\\sqrt[c]{n})$</td>\n<td>分数幂级</td>\n<td>fractional power</td>\n<td>$10^{6c}$</td>\n</tr>\n<tr>\n<td>$O(n)$</td>\n<td>线性级</td>\n<td>linear</td>\n<td>$10^6$</td>\n</tr>\n<tr>\n<td>$O(n\\log{n}) &#x3D; O(\\log{n!})$</td>\n<td>对数线性&#x2F;拟线性级</td>\n<td>loglinear, n-log-n</td>\n<td>$10^5$</td>\n</tr>\n<tr>\n<td>$O(n^2)$</td>\n<td>二次级</td>\n<td>quadratic</td>\n<td>$10^3$</td>\n</tr>\n<tr>\n<td>$O(n^c), c &gt; 1$</td>\n<td>多项式&#x2F;代数级</td>\n<td>polynomial, algebraic</td>\n<td>$\\sqrt[c]{10^6}$</td>\n</tr>\n<tr>\n<td>$O(c^n)$</td>\n<td>指数级</td>\n<td>exponential</td>\n<td>$6\\log_{c}{10}$</td>\n</tr>\n<tr>\n<td>$O(n!)$</td>\n<td>阶乘级</td>\n<td>factorial</td>\n<td>$9$</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"Big-Oh家族使用样例\"><a href=\"#Big-Oh家族使用样例\" class=\"headerlink\" title=\"Big-Oh家族使用样例\"></a>Big-Oh家族使用样例</h2><ul>\n<li>用于表示一个范围：算法 X 最坏的情况时间复杂度是 $o(n^4)$ 和 $\\Omega(n^3)$，但是实际表现并不确定。</li>\n<li>用于确定一个增长率：算法 X 最佳的情况时间复杂度是 $\\Theta(n^2)$。</li>\n<li>用来表示一个平均值：算法 X 平均情况时间复杂度是 $O(n^3)$。</li>\n</ul>\n<hr>\n<h2 id=\"使用Big-Oh家族分析算法效率注意点\"><a href=\"#使用Big-Oh家族分析算法效率注意点\" class=\"headerlink\" title=\"使用Big-Oh家族分析算法效率注意点\"></a>使用Big-Oh家族分析算法效率注意点</h2><p>Big-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 $n$ <strong>足够大</strong>时渐进的范围,也可以说是 $n$ 的增长率。 </p>\n<p>但是在 $n$ <strong>比较小</strong>时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的<strong>实际工作</strong>时的效率。</p>\n<p>例如：</p>\n<ul>\n<li>$10000n$ 是 $O(n)$，同时 $2^n$ 是 $O(2^n)$，当时当 $n$ 比较小时，例如 $n &#x3D; 6$ 时，前者需要进行的计算数是 $60000$，而后者是 $64$，此时前者的效率是不如后者的。</li>\n<li>$O(1.02^n)$ 尽管是指数级(exponential)，但是它的效率并不逊色。</li>\n</ul>\n<p>但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 $n$ 比小的时候程序所消耗的时间往往是会忽略不计的。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Big-Oh家族定义及其渐进表示法总结</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>表示法</th>\n<th>名字</th>\n<th>描述</th>\n<th>渐进符号</th>\n<th>形式定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$o(g(n))$</td>\n<td>little-Oh</td>\n<td>函数渐进地由$g$支配</td>\n<td>$&lt;$</td>\n<td>$\\forall c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : | f(n) | &lt; c \\ g(n)$</td>\n</tr>\n<tr>\n<td>$O(g(n))$</td>\n<td>Big-Oh</td>\n<td>函数以$g$为渐进边界</td>\n<td>$\\leq$</td>\n<td>$\\exists c &gt; 0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c\\ g(n)$</td>\n</tr>\n<tr>\n<td>$\\Theta(g(n))$</td>\n<td>Big-Theta</td>\n<td>函数由$g$为渐进边界和下边界</td>\n<td>$\\approx$</td>\n<td>$\\exists c’&gt;0,\\exists c’’&gt;0, \\exists n_0 &gt; 0, \\forall n \\geq n_0 : c’g(n) \\leq f(n) \\leq c’’g(n)$</td>\n</tr>\n<tr>\n<td>$\\Omega(g(n))$</td>\n<td>Big-Omega</td>\n<td>函数由$g$为渐进下边界</td>\n<td>$\\geq$</td>\n<td>$\\exists c&gt;0,\\exists n_0&gt;0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)$</td>\n</tr>\n<tr>\n<td>$\\omega(g(n))$</td>\n<td>little-omega</td>\n<td>函数渐进支配$g$</td>\n<td>$&gt;$</td>\n<td>$\\exists c&gt;0,\\forall n_0 &gt; 0, \\exists n \\geq n_0 : f(n) &gt; c\\ g(n)$</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如何求解一个算法的时间复杂度Big-Oh：<ul>\n<li>建立算法函数的伪代码。</li>\n<li>求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。</li>\n<li>根据该函数求出Big-Oh表示。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"三-Master定理\"><a href=\"#三-Master定理\" class=\"headerlink\" title=\"三. Master定理\"></a>三. Master定理</h1><h2 id=\"分而治之-Divide-and-Conquer\"><a href=\"#分而治之-Divide-and-Conquer\" class=\"headerlink\" title=\"分而治之(Divide and Conquer)\"></a>分而治之(Divide and Conquer)</h2><p>分而治之是一个设计算法的思想，它通常能够高速地处理问题。</p>\n<p>分而治之的组成成分如下：</p>\n<ul>\n<li>分解 (Divide)：将输入分为两个或多个不相交的输入子集。</li>\n<li>递归 (Recur)：使用递归解决这些子集的子问题。</li>\n<li>组合 (Conquer)：将所有子集的解组合起来形成输入的解。</li>\n</ul>\n<hr>\n<h2 id=\"递归关系-Recurrence-Relation\"><a href=\"#递归关系-Recurrence-Relation\" class=\"headerlink\" title=\"递归关系 Recurrence Relation\"></a>递归关系 Recurrence Relation</h2><p>定义：</p>\n<blockquote>\n<p>A recurrence relation is a recursively-defined function.<br><a href=\"https://en.wikipedia.org/wiki/Recurrence_relation\">递归关系(Recurrence Relation)</a>是使用递归定义的函数。</p>\n</blockquote>\n<p>假设一个程序的运行时间是 $T(n)$，那么递归关系会在一系列小于n的值中来表达 $T(n)$。</p>\n<p>:::details 例子：归并排序(merge-sort)的递归关系及其时间复杂度的证明</p>\n<p>关于归并排序的具体算法请看下面 <strong>五. 算法</strong> 中 <strong>归并排序</strong>。</p>\n<p>假设归并排序的运行时间为 $T(n)$，那么</p>\n<p>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; 2\\ T(\\frac{n}{2}) + b + an \\T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$</p>\n<ul>\n<li>$2\\ T(\\frac{n}{2})$ 表示数组分成了两个子数组，每个子数组的大小为 $\\frac{n}{2}$。</li>\n<li>$b$ 是分裂的花费。</li>\n<li>$an$ 是 <code>merge</code> 的花费。</li>\n</ul>\n<p>因此我们经过带入可以得到：</p>\n<ul>\n<li>$T(2) &#x3D; 2\\ T(1) + b + 2a &#x3D; 2 + b + 2a$</li>\n<li>$T(4) &#x3D; 2\\ T(4) + b + 4a &#x3D; 2 (2 + b + 2a) + b + 4a &#x3D; 4 + 3b + 8a$</li>\n<li>$T(8) &#x3D; 2\\ T(4) + b + 8a &#x3D; 2 (4 + 3b + 8a) + b + 8a &#x3D; 8 + 7b + 24a$</li>\n</ul>\n<p>由此我们猜测 $T(2^k) &#x3D; 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$<br>我们可以使用数学归纳法(induction)来验证：</p>\n<p>Claim: $T(2^k) &#x3D; 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}$.<br>Base case: $k &#x3D; 0$，$T(1) &#x3D; 1 + 0 * b + 0 * 1 * a &#x3D; 1$ is meet the claim.<br>Step case: Assume that the claim is true at k, and we need to prove that $T(k + 1)$ is true.<br>$$<br>\\begin{aligned}<br>T(2^{k+1}) &amp; &#x3D; 2\\ T(2^k) + b + 2^{k+1}a \\<br> &amp; &#x3D; 2 (2^k + (2^k - 1)b + k\\ 2^ka) + b + 2^{k + 1}a \\<br> &amp; &#x3D; 2^{k+1} + (2^{k+1} - 2)b + b + k\\ 2^{k+1}a + 2^{k + 1}a \\<br> &amp; &#x3D; 2^{k+1} + (2^{k+1} - 1)b + (k + 1)\\ 2^{k+1}a<br>\\end{aligned} $$<br>$Q.E.D.$</p>\n<p>我们假设 $T’(n) &#x3D; n + (n - 1)b + an\\log(n), \\text{for } n &#x3D; 2^k, k\\in \\mathbb{N}$。<br>我们可以证明出 $T(n)$ 是 $\\Theta(T’(n))$。<br>因此，$T(n)$ 是 $\\Theta(n\\log n)$。</p>\n<p>:::</p>\n<hr>\n<h2 id=\"Master定理-Master-Theorem\"><a href=\"#Master定理-Master-Theorem\" class=\"headerlink\" title=\"Master定理 (Master Theorem)\"></a>Master定理 (Master Theorem)</h2><p>考虑存在下面的递归关系：<br>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; a\\ T(\\frac{n}{b}) + f(n) \\<br>T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$<br>这是一个由分而治之设计的算法：分解成 $a$ 个子集，每个子集的大小是 $\\frac{n}{b}$，此外每个递归&#x2F;循环有一些额外的操作 $f(n)$。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">Master定理(Master Theorem)</a>是一个根据 $a, b$ 的数值以及对 $f(n)$ 进行放缩来快速求出$T(n)$的Big-Oh家族的方法。</p>\n<p>下面就对 $f(n), a, b$ 不同情况进行讨论。</p>\n<p><em>注意，本笔记中不形式证明Master定理，具体可以自行查阅。</em></p>\n<h3 id=\"f-n-0-时\"><a href=\"#f-n-0-时\" class=\"headerlink\" title=\"&gt; $f(n) &#x3D; 0$ 时\"></a>&gt; $f(n) &#x3D; 0$ 时</h3><p>此时 $T(n) &#x3D; aT(\\frac{n}{b})$，我们可以使用数学归纳法证明出 $T(b^k) &#x3D; a^k$。</p>\n<p>我们令$n &#x3D; b^k$，根据数学公式我们可以推导出 $a^k &#x3D; (b^k)^{\\log_ba}$，因此我们可以得到<br>$$T(n) &#x3D; n^{\\log_ba}$$</p>\n<p>因此我们可以知道 $T(n)$ 是 $\\Theta(n^{\\log_ba})$。</p>\n<h3 id=\"f-n-neq-0-时\"><a href=\"#f-n-neq-0-时\" class=\"headerlink\" title=\"&gt; $f(n) \\neq 0$ 时\"></a>&gt; $f(n) \\neq 0$ 时</h3><p>此时可以分为三种情况：</p>\n<table>\n<thead>\n<tr>\n<th>$f(n)$ 的形式</th>\n<th>$c$ 与 $\\log_ba$ 的关系</th>\n<th>$T(n)$的Big-Theta</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$f(n)$ 是 $O(n^c)$</td>\n<td>$c &lt; \\log_ba$</td>\n<td>$\\Theta(n^{\\log_ba})$</td>\n<td>$f(n)$ 的 增长率非常小，此时忽略 $f(n)$</td>\n</tr>\n<tr>\n<td>$f(n)$ 是 $\\Theta(n^c(\\log n)^k), k \\geq 0$</td>\n<td>$c &#x3D; \\log_ba$</td>\n<td>$\\Theta(n^c(\\log n)^{k+1})$</td>\n<td>$f(n)$ 的 增长率适中，此时混合使用$a, b, f(n)$</td>\n</tr>\n<tr>\n<td>$f(n)$ 是 $\\Omega(n^c)$, 并满足正则条件</td>\n<td>$c &gt; log_ba$</td>\n<td>$\\Theta(f(n))$</td>\n<td>$f(n)$ 的 增长率非常大，此时只考虑 $f(n)$</td>\n</tr>\n</tbody></table>\n<p>情况三中需要满足正则条件(Regularity Condition)：<br>$$\\exists k &lt; 1 : a f(\\frac{n}{b}) \\leq k f(n)$$</p>\n<p><em>该条件保证了这个条件确保 $f(n)$ 不会增长过快导致 $T(n)$ 完全被非递归部分主导。</em></p>\n<p>注意$f(n)$ 的形式以及$c$ 与 $\\log_ba$ 的关系。</p>\n<ul>\n<li>情况一中可知，$f(n)$的渐进上边界都不如 $n^{\\log_ba}$，那么$f(n)$ 的增长率是可以被忽略的。</li>\n<li>情况二中可知，$f(n)$的增长率是与 $n^{\\log_ba}$ 持平的，因此应该要混合使用$a, b, f(n)$。</li>\n<li>情况三中可知，$f(n)$的渐进下边界都超过了 $n^{\\log_ba}$，因此只考虑 $f(n)$。</li>\n</ul>\n<hr>\n<h1 id=\"四-数据结构\"><a href=\"#四-数据结构\" class=\"headerlink\" title=\"四. 数据结构\"></a>四. 数据结构</h1><h2 id=\"一些定义\"><a href=\"#一些定义\" class=\"headerlink\" title=\"一些定义\"></a>一些定义</h2><ul>\n<li><p>遍历(Traversals)：指访问(visit)一个数据结构的所有元素。</p>\n<ul>\n<li>每一个元素只访问一次。</li>\n<li>访问的顺序是系统的、有序的、有意义的。</li>\n</ul>\n</li>\n<li><p>抽象数据类型(Abstract Data Types, ADTs)：是数据结构的抽象。</p>\n<ul>\n<li>组成成分：<ul>\n<li>储存的数据类型。</li>\n<li>对数据的操作。</li>\n<li>与操作相关的错误条件。</li>\n</ul>\n</li>\n<li>一般ADT的相关操作会使用Big-Oh来限制效率。</li>\n</ul>\n</li>\n<li><p>具体数据类型(Concrete Data Types, CDTs)：是数据结构的实际。</p>\n<ul>\n<li>ADT的实现是通过选择不同的CDT。</li>\n<li>CDT是数据隐藏的和封装的（面向对象）。</li>\n<li>CDT的选择影响运行时间和空间使用。</li>\n</ul>\n</li>\n<li><p>面向对象编程(Object-oriented)的原因：</p>\n<ul>\n<li>区分规范(specification) 和 实施细节(implementation details)</li>\n<li>使用相同的ADT来探索不同的CDTs。</li>\n<li>无需更改ADT的代码来快速更改和提升CDTs。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"单向链表-Singly-Linked-List-CDT\"><a href=\"#单向链表-Singly-Linked-List-CDT\" class=\"headerlink\" title=\"单向链表(Singly Linked List) (CDT)\"></a>单向链表(Singly Linked List) (CDT)</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A singly linked list is a concrete data structure consisting of a sequence of nodes. Each node stores an element and a pointer&#x2F;reference to the next node.</p>\n</blockquote>\n<h3 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>Element</code> 元素</li>\n<li><code>next</code> 指向下一个节点的指针</li>\n</ul>\n</li>\n<li><code>head : Node*</code> 头节点指针</li>\n<li><code>tail : Node*</code> 尾节点指针 (可选)</li>\n</ul>\n<h3 id=\"功能性函数\"><a href=\"#功能性函数\" class=\"headerlink\" title=\"功能性函数\"></a>功能性函数</h3><p>插入类函数：</p>\n<ul>\n<li><code>void insertHead(Object)</code>：插入头结点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void insertTail(Object)</code>：插入尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n</ul>\n<p>删除类函数：</p>\n<ul>\n<li><code>void removeHead()</code>：删除头节点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void removeTail(Object)</code>：删除尾节点<ul>\n<li>无论有没有记录尾节点，时间复杂度：$O(n)$<ul>\n<li>因为要让尾节点的前一个节点的<code>next</code>指针指向<code>NULL</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>交换类函数：</p>\n<ul>\n<li><code>void swapElement(Node, Node)</code>：交换元素而不交换节点的位置<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n<li><code>void swapNode(Node, Node)</code>：交换节点的位置（不常用）<ul>\n<li>时间复杂度 $O(n)$<ul>\n<li>因为要找到这两个<code>Node</code>的上一个<code>Node</code>来修改<code>next</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"双向链表-Doubly-Linked-List-CDT\"><a href=\"#双向链表-Doubly-Linked-List-CDT\" class=\"headerlink\" title=\"双向链表(Doubly Linked List) (CDT)\"></a>双向链表(Doubly Linked List) (CDT)</h2><h3 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A doubly linked list provides a natural extension of a singly linked list.Each node stores an element and a pointer&#x2F;reference to the next node and a pointer&#x2F;reference to the previous node.</p>\n</blockquote>\n<h3 id=\"成员-1\"><a href=\"#成员-1\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>element</code> 元素</li>\n<li><code>next</code> 指向下一个节点的指针</li>\n<li><code>pre</code> 指向上一个节点的指针</li>\n</ul>\n</li>\n<li><code>head : Node* | Node</code> 头节点指针&#x2F;节点</li>\n<li><code>tail : Node* | Node</code> 尾节点指针&#x2F;节点</li>\n</ul>\n<h3 id=\"功能性函数-1\"><a href=\"#功能性函数-1\" class=\"headerlink\" title=\"功能性函数\"></a>功能性函数</h3><p>插入类函数：</p>\n<ul>\n<li><code>void insertHead(Object)</code>：插入头结点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void insertTail(Object)</code>：插入尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n<li><code>void insertAfter(Node, Object)</code>：插入到<code>Node</code>节点后面<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n</ul>\n<p>删除类函数：</p>\n<ul>\n<li><code>void removeHead()</code>：删除头节点<ul>\n<li>时间复杂度：$O(1)$</li>\n</ul>\n</li>\n<li><code>void removeTail(Object)</code>：删除尾节点<ul>\n<li>如果有记录尾节点，时间复杂度： $O(1)$</li>\n<li>如果没有记录尾节点，时间复杂度： $O(n)$</li>\n</ul>\n</li>\n</ul>\n<p>交换类函数：</p>\n<ul>\n<li><code>void swapElement(Node, Node)</code>：交换元素而不交换节点的位置（不常用）<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n<li><code>void swapNode(Node, Node)</code>：交换节点的位置（建议）<ul>\n<li>时间复杂度 $O(1)$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li>有两种双向链表设计方式<ul>\n<li>让<code>head</code>和<code>tail</code>指向实实在在的节点。如果链表为空，则<code>head = NULL, tail = NULL</code>。</li>\n<li>分配<code>head</code>和<code>tail</code>为新的节点，节点的元素为空。如果链表为空，则<code>head.next == tail</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据结构的思考\"><a href=\"#数据结构的思考\" class=\"headerlink\" title=\"数据结构的思考\"></a>数据结构的思考</h3><p>相比于数组 <code>Array</code>，链表数据结构具有较快的插入和删除能力。但是，链表具有较差的查询能力，其查询能力的时间复杂度是 $O(n)$。</p>\n<p>一般具有较快的插入、删除和查询能力的数据结构都比较复杂，例如：</p>\n<ul>\n<li>跳表 (Skip List)：其三个操作的时间复杂度都是 $O(\\log n)$。</li>\n<li>平衡树(Balanced Trees)：其三个操作的时间复杂度都是 $O(\\log n)$。<ul>\n<li>红黑树(Red-Black Tree)</li>\n<li>AVL树(AVL Tree)</li>\n</ul>\n</li>\n<li>哈希表(Hash Table)：其三个操作的平均时间复杂度都是 $O(1)$，最差情况下时间复杂度是 $O(n)$。</li>\n</ul>\n<hr>\n<h2 id=\"向量-Vector-ADT\"><a href=\"#向量-Vector-ADT\" class=\"headerlink\" title=\"向量(Vector) (ADT)\"></a>向量(Vector) (ADT)</h2><h3 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>向量(Vector)是一种抽象数据类型(ADT)。向量的主要目的是创建一个比数组(Array)更泛用的模型。</p>\n<p>其主要的特性是：</p>\n<ul>\n<li>一个元素在向量中的索引(index)被认为是前面元素的个数(number of elements prceding it)。<ul>\n<li>为了不完全依赖于数组，因此我们不使用“索引(index)”概念，而使用“前面元素的个数”概念。</li>\n<li>例如对于一个向量 $A$ 来说，$A[2]$ 表示有 $2$ 个元素在它的前面，分别是 $A[0], A[1]$。</li>\n<li>这个概念也可以被称为**排名(rank)**。</li>\n</ul>\n</li>\n<li>与数组固定大小不同，向量一个自动调节大小的数据结构。</li>\n</ul>\n<h3 id=\"向量ADT主要操作-operator-方法\"><a href=\"#向量ADT主要操作-operator-方法\" class=\"headerlink\" title=\"向量ADT主要操作(operator)&#x2F;方法\"></a>向量ADT主要操作(operator)&#x2F;方法</h3><ul>\n<li><code>Object elemAtRank(int r)</code>：返回 <code>rank</code> 为 <code>r</code> 的元素。</li>\n<li><code>Object replaceAtRank(int r, Object o)</code>：替换掉 <code>rank</code> 为 <code>r</code> 的元素为 <code>o</code>，并返回原来的元素。</li>\n<li><code>void insertAtRank(int r, Object o)</code>：在 <code>rank</code> 为 <code>r</code> 的位置插入新的元素 <code>o</code>。</li>\n<li><code>Object removeAtRank(int r)</code>：删除 <code>rank</code> 为 <code>r</code> 位置的元素。</li>\n<li><code>int size()</code>：返回向量大小。</li>\n<li><code>boolean isEmpty()</code>：返回向量是否为空。</li>\n</ul>\n<h3 id=\"使用向量作为栈-Stack\"><a href=\"#使用向量作为栈-Stack\" class=\"headerlink\" title=\"使用向量作为栈(Stack)\"></a>使用向量作为栈(Stack)</h3><p>栈(Stack)是一个先入后出(first in last out, FILO)的数据结构，其操作主要是：</p>\n<ul>\n<li><code>Object top()</code>：返回栈顶。<ul>\n<li>相当于 <code>elemAtRank(size())</code>。</li>\n</ul>\n</li>\n<li><code>void push(Object o)</code>：在最后的元素(栈顶)后面添加一个新的元素。<ul>\n<li>相当于 <code>insertAtRank(size(), Object o)</code>。</li>\n</ul>\n</li>\n<li><code>void pop()</code>：删除最后的元素(栈顶)。<ul>\n<li>相当于 <code>removeAtRank(size())</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于数组的向量-Array-based-Vector-CDT\"><a href=\"#基于数组的向量-Array-based-Vector-CDT\" class=\"headerlink\" title=\"基于数组的向量(Array-based Vector) (CDT)\"></a>基于数组的向量(Array-based Vector) (CDT)</h3><p>是使用一个大小为<code>N</code>的数组<code>V</code>作为向量的CDT，并使用整型变量<code>n</code>记录向量的大小。</p>\n<h4 id=\"操作-方法时间复杂度分析\"><a href=\"#操作-方法时间复杂度分析\" class=\"headerlink\" title=\"&gt;操作&#x2F;方法时间复杂度分析\"></a>&gt;操作&#x2F;方法时间复杂度分析</h4><ul>\n<li><code>elemAtRank(r)</code>：可以直接返回<code>V[r]</code>，因此其时间复杂度是 $O(1)$。</li>\n<li><code>replaceAtRank(r, o)</code>：时间复杂度是 $O(1)$。</li>\n<li><code>insertAtRank(r, o)</code>：需要对原来的元素进行右平移，在最坏的情况下(即 $r &#x3D; 0$ )时间复杂度是 $O(n)$。</li>\n<li><code>removeAtRank(r, o)</code>：需要对原来的元素进行左平移，在最坏的情况下(即 $r &#x3D; 0$ )时间复杂度是 $O(n)$。</li>\n<li><code>size()</code>：直接返回变量 <code>n</code>，因此时间复杂度是 $O(1)$。</li>\n<li><code>isEmpty()</code>：直接返回 <code>n == 0</code>，因此时间复杂度是 $O(1)$。</li>\n<li><code>push(o)</code>：不需要进行平移。<ul>\n<li>如果<strong>不需要扩大数组</strong>时间复杂度是 $O(1)$。</li>\n<li><strong>扩大数组</strong>需要平摊时间(amortized time)获取时间复杂度。具体可以看下面扩大数组中不同策略。</li>\n</ul>\n</li>\n<li><code>pop()</code>：不需要进行平移，因此时间复杂度是 $O(1)$。</li>\n</ul>\n<p>平摊时间(amortized time)是从<strong>一组</strong>操作中每个操作平摊下来的时间。与平均时间(average time)不同，后者主要是针对<strong>一次</strong>操作的平均时间。</p>\n<h4 id=\"扩大数组-Resize-Array\"><a href=\"#扩大数组-Resize-Array\" class=\"headerlink\" title=\"&gt;扩大数组(Resize Array)\"></a>&gt;扩大数组(Resize Array)</h4><p>在<code>insertAtRank(r, o)</code> 和 <code>push(o)</code> 操作中，如果数组已经满了，那么需要替换数组为更大的数组。</p>\n<p>替换数组需要复制原来的数据到新的数据中。假设当前数组的大小为 $c$，每次替换所使用的时间为 $s_2$，那么这个过程需要的时间$T(c) &#x3D; s_2c$，即这个过程的时间复杂度是 $O(c)$。</p>\n<p>扩大数组的方法一共有两种：</p>\n<ul>\n<li><p>增量策略(incremental strategy)：使用固定的常数 <code>c</code> 来进行扩大数组。</p>\n<ul>\n<li>假设执行<code>push</code>的次数为 $n$，那么替换数组的次数一共为 $k &#x3D; floor(n &#x2F; c)$ 次。</li>\n<li>假设$T(n)$是执行<code>push</code> $n$ 次所需要的运行时间，$s_1$是一次<code>push</code>所需要的时间，$s_2$是一次替换数组所需要的时间。<ul>\n<li>$s_1$ 和 $s_2$ 都是常数。</li>\n<li>$T(n) &#x3D; s_1n + s_2(c + 2c + … + kc) &#x3D; s_1n + s_2c\\frac{k(k+1)}{2}$，因此 $T(n)$ 是 $O(n^2)$。</li>\n</ul>\n</li>\n<li>平摊下来每次 <code>push</code> 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(n)$。这个是要比一般 <code>push</code> 操作所需要的时间复杂度 $O(1)$ 是要差的。</li>\n</ul>\n</li>\n<li><p>双倍策略(doubling strategy)：双倍数组的大小。</p>\n<ul>\n<li>假设执行<code>push</code>的次数为 $n$，那么替换数组的次数一共为 $k &#x3D; floor(\\log n)$ 次。</li>\n<li>假设$T(n)$是执行<code>push</code> $n$ 次所需要的运行时间，$s_1$是一次<code>push</code>所需要的时间，$s_2$是一次替换数组所需要的时间。<ul>\n<li>$s_1$ 和 $s_2$ 都是常数。</li>\n<li>$T(n) &#x3D; s_1n + s_2(1 + 2 + 4 + … + 2^{k - 1}) &#x3D; (s_1 + s_2)n - s_2$，因此 $T(n)$ 是 $O(n)$。</li>\n</ul>\n</li>\n<li>平摊下来每次 <code>push</code> 操作的时间复杂度是 $\\frac{T(n)}{n}$ 是 $O(1)$。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"树-Tree-ADT\"><a href=\"#树-Tree-ADT\" class=\"headerlink\" title=\"树(Tree) (ADT)\"></a>树(Tree) (ADT)</h2><h3 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>树是一种抽象数据结构(ADT)。</p>\n<blockquote>\n<p>In computer science, a tree is an abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.</p>\n</blockquote>\n<h3 id=\"成员-2\"><a href=\"#成员-2\" class=\"headerlink\" title=\"成员\"></a>成员</h3><ul>\n<li><code>Node</code> 节点<ul>\n<li><code>element</code>  元素</li>\n<li><code>parent</code> 父节点</li>\n<li><code>children[]</code> 子节点</li>\n</ul>\n</li>\n<li><code>root : Node*</code> 根节点：不具有父节点的节点。</li>\n<li><code>internal : Node</code> 内节点：具有至少一个子节点的节点。</li>\n<li><code>leaf / external : Node</code> 叶节点&#x2F;外节点：不具有子节点的节点。</li>\n<li><code>ancestors : Node → Node[]</code> 祖先节点：(递归定义) 一个节点其父节点和其父节点的祖先节点的数组&#x2F;集合。</li>\n<li><code>descendant : Node → Node[]</code> 祖孙节点：(递归定义) 一个节点其所有子节点和所有子节点的祖孙节点的数组&#x2F;集合。</li>\n<li><code>depth : Node → Int</code> 节点的深度：该节点的祖先节点的个数(不包括自己)。<ul>\n<li>根节点的深度为0，根节点的子节点深度为1，以此类推。</li>\n</ul>\n</li>\n<li><code>height : Tree → Int</code> 树的高度：最大的叶节点深度。或者说从根节点到叶节点最长的路径(不包括根节点)。<ul>\n<li>只有根节点的树的深度为0。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树ADT主要操作-方法：\"><a href=\"#树ADT主要操作-方法：\" class=\"headerlink\" title=\"树ADT主要操作&#x2F;方法：\"></a>树ADT主要操作&#x2F;方法：</h3><h4 id=\"基础方法-Generic-：\"><a href=\"#基础方法-Generic-：\" class=\"headerlink\" title=\"&gt; 基础方法 (Generic)：\"></a>&gt; 基础方法 (Generic)：</h4><ul>\n<li><code>int size()</code>：返回树的大小。</li>\n<li><code>bool isEmpty()</code>：返回树是否为空。</li>\n<li><code>Iterator iterator()</code>：返回树的遍历所有元素的迭代器。</li>\n<li><code>Iterator positions()</code>：返回树的以一定顺序遍历位置的迭代器。</li>\n</ul>\n<h4 id=\"接入方法-Accessor-：\"><a href=\"#接入方法-Accessor-：\" class=\"headerlink\" title=\"&gt; 接入方法 (Accessor)：\"></a>&gt; 接入方法 (Accessor)：</h4><ul>\n<li><code>Node root()</code>：返回树的根节点。</li>\n<li><code>Node parent(Node)</code>：返回节点的父节点。</li>\n<li><code>Iterator children(Node)</code>：返回节点的子节点迭代器。</li>\n</ul>\n<h4 id=\"查询方法-Query-：\"><a href=\"#查询方法-Query-：\" class=\"headerlink\" title=\"&gt; 查询方法 (Query)：\"></a>&gt; 查询方法 (Query)：</h4><ul>\n<li><code>bool isInternal(Node)</code>：是否是内部节点。</li>\n<li><code>bool isExternal(Node)</code>：是否是叶节点。</li>\n<li><code>bool isRoot(Node)</code>：是否是根节点。</li>\n</ul>\n<h3 id=\"树的遍历-Traversals\"><a href=\"#树的遍历-Traversals\" class=\"headerlink\" title=\"树的遍历 (Traversals)\"></a>树的遍历 (Traversals)</h3><h4 id=\"前序遍历-Preorder-Traversal\"><a href=\"#前序遍历-Preorder-Traversal\" class=\"headerlink\" title=\"&gt; 前序遍历 Preorder Traversal\"></a>&gt; 前序遍历 Preorder Traversal</h4><p>先遍历父节点，再从左到右遍历其子节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm preOrder(v)</span><br><span class=\"line\">  visit(v)</span><br><span class=\"line\">  for each child w of v</span><br><span class=\"line\">    preorder(w)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历-Postorder-Traversal\"><a href=\"#后序遍历-Postorder-Traversal\" class=\"headerlink\" title=\"&gt; 后序遍历 Postorder Traversal\"></a>&gt; 后序遍历 Postorder Traversal</h4><p>先遍历子节点，再遍历父节点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm postOrde(v)</span><br><span class=\"line\">  for each child w of v</span><br><span class=\"line\">    postOrder(w)</span><br><span class=\"line\">  visit(v)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二叉树-Binary-Tree-ADT\"><a href=\"#二叉树-Binary-Tree-ADT\" class=\"headerlink\" title=\"二叉树(Binary Tree) (ADT)\"></a>二叉树(Binary Tree) (ADT)</h2><h3 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>二叉树是一种抽象数据结构(ADT)。</p>\n<ul>\n<li><p>一般定义：</p>\n<blockquote>\n<p> a tree whose each internal node has at most two children, and the children of a node are an ordered pair, though one might be “missing”.</p>\n</blockquote>\n</li>\n<li><p>递归定义：</p>\n<blockquote>\n<p>A tree consisting of a single node, or a tree whose root has an  ordered pair of “children”, each  of which is missing (a null) or is  the root of a binary tree</p>\n</blockquote>\n</li>\n<li><p>特点：</p>\n<ul>\n<li>每个节点最多有两个子节点</li>\n<li>节点之间是有序的，即左子节点和右子节点，尽管有一个是空节点。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"性质-4\"><a href=\"#性质-4\" class=\"headerlink\" title=\"性质\"></a>性质</h3><h4 id=\"合适-完满二叉树-proper-full-binary-tree\"><a href=\"#合适-完满二叉树-proper-full-binary-tree\" class=\"headerlink\" title=\"&gt; 合适&#x2F;完满二叉树 (proper&#x2F;full binary tree)\"></a>&gt; 合适&#x2F;完满二叉树 (proper&#x2F;full binary tree)</h4><blockquote>\n<p>A binary tree is said to be “proper” (a.k.a. “full”) if every internal node has exactly 2 children.<br>如果二叉树的所有内部节点都具有两个子节点，那么称这个二叉树是合适&#x2F;完满二叉树。</p>\n</blockquote>\n<h4 id=\"完美二叉树-perfect-binary-tree\"><a href=\"#完美二叉树-perfect-binary-tree\" class=\"headerlink\" title=\"&gt; 完美二叉树 (perfect binary tree)\"></a>&gt; 完美二叉树 (perfect binary tree)</h4><blockquote>\n<p>A binary tree is perfect if it is proper and all leaves are at the same depth.<br>如果一个满二叉树中所有的子节点都在同一个深度，那么称这个二叉树是完美二叉树。</p>\n</blockquote>\n<ul>\n<li>在深度 $d$ 拥有的节点的个数为 $2^d$</li>\n<li>在深度 $d$ 及其以下的深度总结点个数为 $2^{(d+1)}-1$</li>\n<li>高度为 $h$ 的树总节点为 $n$，那么有 $h &#x3D; \\log_{2}(n+1) - 1$，$n &#x3D; 2^{(h + 1)} - 1$</li>\n</ul>\n<h4 id=\"完全二叉树-complete-binary-tree\"><a href=\"#完全二叉树-complete-binary-tree\" class=\"headerlink\" title=\"&gt; 完全二叉树 (complete binary tree)\"></a>&gt; 完全二叉树 (complete binary tree)</h4><blockquote>\n<p>除了叶节点所处的深度以外，其他深度是一个完美二叉树，并且叶节点是靠右排序的二叉树是完全二叉树。</p>\n</blockquote>\n<h3 id=\"二叉树的遍历-Traversals\"><a href=\"#二叉树的遍历-Traversals\" class=\"headerlink\" title=\"二叉树的遍历 (Traversals)\"></a>二叉树的遍历 (Traversals)</h3><p>除了树通用的前序遍历和后序遍历以外，还有一个中序遍历(Inorder Traversal)：</p>\n<p>先遍历左子节点，再遍历该节点，最后遍历子节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Algorithm inOrder(v)</span><br><span class=\"line\">  if hasLeft(v)</span><br><span class=\"line\">    inOrder(v.left)</span><br><span class=\"line\">  visit(v)</span><br><span class=\"line\">  if hasRight(v)</span><br><span class=\"line\">    inOrder(v.right)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的效率分析\"><a href=\"#二叉树的效率分析\" class=\"headerlink\" title=\"二叉树的效率分析\"></a>二叉树的效率分析</h3><ul>\n<li>求树的高度：如果树的大小为 $n$，那么：<ul>\n<li>对于完美二叉树来说，时间复杂度是 $\\Theta(\\log(n))$。</li>\n<li>对于非完美二叉树来说，考虑到一条链，时间复杂度是 $\\Omega(\\log(n))$ 和 $O(n)$。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于数组的二叉树-Array-Based-Representation-of-Binary-Tree-CDT\"><a href=\"#基于数组的二叉树-Array-Based-Representation-of-Binary-Tree-CDT\" class=\"headerlink\" title=\"基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)\"></a>基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)</h3><p>它也可以被称为 **树形数组(tree-as-array)**。它是一种使用数组作为CDT实现二叉树ADT的方式。</p>\n<p>一般使用 <code>int rank(Node)</code> 来表示节点的数组索引。注意，它返回的是<strong>整型</strong>。</p>\n<ul>\n<li><code>rank(root) = 1</code>：根节点的索引是 $1$。</li>\n<li><code>rank(parent(node)) = rank(node) &gt;&gt; 1</code>：每个节点的父节点是该节点的索引除以 $2$。</li>\n<li><code>rank(left_child(node)) = rank(node) &lt;&lt; 1</code>：每个节点的左节点是该节点的索引乘以 $2$。</li>\n<li><code>rank(right_child(node)) = rank(node) &lt;&lt; 1 + 1</code>：每个节点的右节点是该节点的索引乘以 $2$ 加 $1$。</li>\n</ul>\n<p>树形数组的优点：</p>\n<ul>\n<li>能够节省空间。因为不用储存相关的指针，而是使用计算代替。</li>\n<li>储存能够更紧凑，具有更好的内存局部性”better memory locality”。</li>\n<li>很好地解决缓存和内存层次结构的问题——当访问数组元素时，其他条目可以被拉入缓存，因此访问速度更快。</li>\n</ul>\n<hr>\n<h2 id=\"优先队列-Priority-Queue-ADT\"><a href=\"#优先队列-Priority-Queue-ADT\" class=\"headerlink\" title=\"优先队列(Priority Queue) (ADT)\"></a>优先队列(Priority Queue) (ADT)</h2><h3 id=\"介绍-5\"><a href=\"#介绍-5\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>优先队列是一个抽象数据结构(ADT)。优先队列是储存一组具有 <code>(key, value)</code> 的数据结构，并能够有效地返回和操作其中具有最小&#x2F;最大 <code>key</code> 的元素。</p>\n<p>一般我们默认优先队列是**最小优先队列(Min-Priority Queue)**，也就是返回&#x2F;操作拥有最小<code>key</code>的元素。</p>\n<h3 id=\"优先队列ADT主要操作-方法：\"><a href=\"#优先队列ADT主要操作-方法：\" class=\"headerlink\" title=\"优先队列ADT主要操作&#x2F;方法：\"></a>优先队列ADT主要操作&#x2F;方法：</h3><ul>\n<li><code>void insert(k, v)</code>：插入一组<code>(k, v)</code>的元素。</li>\n<li><code>Element removeMin()</code>：删除并返回具有最小<code>key</code>的元素。</li>\n<li><code>Element min()</code>：返回具有最小<code>key</code>的元素。</li>\n<li><code>int size()</code>：返回元素个数。</li>\n<li><code>bool isEmpty()</code>：优先队列返回是否为空。</li>\n</ul>\n<h3 id=\"基于二叉堆-Binary-Heap-的优先队列-CDT\"><a href=\"#基于二叉堆-Binary-Heap-的优先队列-CDT\" class=\"headerlink\" title=\"基于二叉堆(Binary Heap)的优先队列 (CDT)\"></a>基于二叉堆(Binary Heap)的优先队列 (CDT)</h3><p>本笔记中默认的二叉堆是 <strong>小根堆</strong>。</p>\n<blockquote>\n<p> A binary heap is a complete binary tree storing key-value pairs at its nodes.<br>二叉堆是将 <code>(key, value)</code> 对储存在节点的完全二叉树。</p>\n</blockquote>\n<p><em>除了二叉堆以外，还有二项式堆(Binomial Heap)和斐波那契堆(Fibonacci Heap)。</em></p>\n<p>二叉堆具有以下的性质：</p>\n<ul>\n<li>Heap-Order：对于每一个除了根以外的节点，都有 <code>key(v) &gt;= key(parent(v))</code>。<ul>\n<li>即子节点的值不会比父节点更小。</li>\n<li>那么堆顶，即二叉堆的根节点是所有节点中的最小值。</li>\n</ul>\n</li>\n<li>Complete Binary Tree：是一个二叉树。因此如果一共有 $n$ 个节点，则树的高度为 $h &#x3D; \\log n$。</li>\n</ul>\n<h4 id=\"堆的插入-insert\"><a href=\"#堆的插入-insert\" class=\"headerlink\" title=\"堆的插入(insert)\"></a>堆的插入(insert)</h4><p>步骤如下：</p>\n<ol>\n<li>根据完全二叉树性质寻找插入点 $Z$ 作为叶节点。</li>\n<li>储存 $key$ 值给点 $Z$。</li>\n<li>恢复堆序属性(<code>unheap</code>操作)：将插入点 $Z$ 从下到上进行 <strong>冒泡</strong>，如果父节点的 <code>key</code> 值比 $Z$ 大，那么就交换两个节点的位置或元素，直到父节点的 <code>key</code> 值比 $Z$ 小或者已经到达根节点。</li>\n</ol>\n<p>关于 $1$，如果使用结构体模拟树的结构，那么时间复杂度可能会达到 $O(n)$。但是如果使用数组作为CDT模拟二叉树(具体可看上方二叉树中基于数组的二叉树，树形数组)，那么只需要在数组的末尾插入新的节点即可，此时的时间复杂度是 $O(1)$。<br>关于 $3$，因为二叉树的高度是 $h &#x3D; \\log n$，因此 <code>upheap</code> 操作的时间复杂度是 $O(\\log n)$。</p>\n<h4 id=\"堆的删除-remove-pop\"><a href=\"#堆的删除-remove-pop\" class=\"headerlink\" title=\"堆的删除(remove &#x2F; pop)\"></a>堆的删除(remove &#x2F; pop)</h4><p>堆的删除指的是删除堆顶。步骤如下：</p>\n<ol>\n<li>使用最后一个节点 $w$ 代替根节点。</li>\n<li>删除 $w$ 原节点。</li>\n<li>恢复堆属性(<code>Downheap</code>操作)：选择两个子节点中<strong>最小</strong>的子节点，如果该子节点的<code>key</code>值比 $w$ 节点的小，那么就交换两个节点的位置或元素，直到所有子节点的 <code>key</code> 值比 $w$ 大或者已经达到叶节点。</li>\n</ol>\n<hr>\n<h2 id=\"映射-Maps-ADT\"><a href=\"#映射-Maps-ADT\" class=\"headerlink\" title=\"映射(Maps) (ADT)\"></a>映射(Maps) (ADT)</h2><h3 id=\"介绍-6\"><a href=\"#介绍-6\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><blockquote>\n<p>A map models a collection of <code>(key, value)</code> entries that is searchable by the <code>key</code>.</p>\n</blockquote>\n<p>性质：</p>\n<ul>\n<li>具有搜索、插入、删除元素的功能。</li>\n<li>具有相同 <code>key</code> 值的元素是不被允许的。</li>\n</ul>\n<h3 id=\"映射ADT主要操作-方法：\"><a href=\"#映射ADT主要操作-方法：\" class=\"headerlink\" title=\"映射ADT主要操作&#x2F;方法：\"></a>映射ADT主要操作&#x2F;方法：</h3><ul>\n<li><code>Value get(Key k)</code>：如果存在<code>key</code>相应的元素，则通过 <code>key</code> 获取相应的 <code>value</code>，否则返回 <code>NULL</code>。</li>\n<li><code>Value put(Key k, Value v)</code>：插入 <code>(key, value)</code> 对。如果已经存在 <code>key</code> 在映射里则返回 <code>NULL</code>，否则返回 <code>value</code>值。</li>\n<li><code>Value remove(Key k)</code>：如果存在<code>key</code>相应的元素，则通过 <code>key</code> 来删除并返回该元素的 <code>value</code>，否则返回 <code>NULL</code>。</li>\n<li><code>int size()</code>：返回元素个数。</li>\n<li><code>bool isEmpty()</code>：返回是否为空。</li>\n<li><code>Iterator keys()</code>：返回 <code>key</code> 的迭代器。</li>\n<li><code>Iterator values()</code>：返回 <code>value</code> 的迭代器。</li>\n<li><code>Iteraotr entries()</code>：返回 <code>(key, value)</code> 的迭代器。</li>\n</ul>\n<h3 id=\"基于简单链表的MAP-CDT\"><a href=\"#基于简单链表的MAP-CDT\" class=\"headerlink\" title=\"基于简单链表的MAP (CDT)\"></a>基于简单链表的MAP (CDT)</h3><ul>\n<li><code>get(k)</code>：遍历链表来寻找 <code>key</code>。时间复杂度是 $O(n)$。</li>\n<li><code>put(k, v)</code>：遍历链表来寻找是否有重复的 <code>key</code>，如果没有则插入到链表中。时间复杂度是 $O(n)$。</li>\n<li><code>remove(k, v)</code>：遍历链表来寻找 <code>key</code>。时间复杂度是 $O(n)$。</li>\n</ul>\n<p>因为链表的特性（具有较差的访问能力），因此无论是排序的链表还是未排序的链表（链表无法使用二分查找法），时间复杂度操作都是 $O(n)$。</p>\n<h3 id=\"基于哈希表的MAP-CDT\"><a href=\"#基于哈希表的MAP-CDT\" class=\"headerlink\" title=\"基于哈希表的MAP (CDT)\"></a>基于哈希表的MAP (CDT)</h3><p>基本思想：将每个 <code>key</code> 转化成 <code>index</code> 放入一个较大的数组 <code>Array</code> 中。</p>\n<p>哈希表的特性：</p>\n<ul>\n<li>哈希值 (hash value)：由哈希函数得到的值被称为哈希值。</li>\n<li>哈希码 $h_1$ (hash code)：是一个键值转一个整型的函数，即<code>keys → integers</code>。一些可能的方法：<ul>\n<li>将 <code>key</code> 的内存地址作为哈希码。</li>\n<li>将 <code>key</code> 的 <code>bit</code> 值转化成整型作为哈希码。一般用于内存不大于整型的数据类型，例如<code>byte, short, int, float</code>。</li>\n<li>将 <code>key</code> 的 <code>bit</code> 值划分成相同长度的部分，对这些部分求和(忽略溢出)。适用于内存大于整型的数据类型，例如 <code>double, long</code>。</li>\n<li>多项式累积方法。</li>\n</ul>\n</li>\n<li>压缩函数 $h_2$ (Compression function)：是一个将整型压缩到一定范围的函数，即<code>integers → [0, N-1]</code>。一些可能的方法：<ul>\n<li>除法(Division)：$h_2(x) &#x3D; x \\mod N$。<ul>\n<li>$N$ 通常是一个素数。</li>\n</ul>\n</li>\n<li>乘加除法(Multiply, Add and Divide (MAD))：$h_2(x) &#x3D; (ax + b) \\mod N$。<ul>\n<li>$a, b$ 是非负整数。</li>\n<li>$a \\mod N \\neq 0$，否则无论 $x$ 为多少总会映射到 $b$。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哈希函数 $h$ (hash function)：是一个将对象(Object)映射到一个固定的范围 $[0, N-1]$ 整型的函数。<ul>\n<li>此时有 $h(x) &#x3D; h_2(h_1(x))$。</li>\n<li>哈希函数的主要目的是使用明显<strong>随机</strong>的方式来将 <code>keys</code> <strong>分散</strong>。</li>\n<li>分散的目的是为了减少冲突(Collision)。</li>\n<li>随机的目的是为了减少模式(Pattern)，从而减少冲突。</li>\n</ul>\n</li>\n<li>冲突 (Collision)：当不同的元素获取到相同的索引时，会发生冲突。一些可能的解决方法：<ul>\n<li>分离链(Separate Chaining)：让相同 <code>index</code> 的元素以链表的形式连接起来。</li>\n<li>二叉搜索树(Binary Search Tree)。</li>\n<li>开放地址(Open addressing)：让冲突的新元素放入到下一个可用的数组中。一些可能的方法：<ul>\n<li>线性探索(Linear probing)：使用一个常数 $c$ 来进行冲突元素的新元素寻址，即$h(k) + c$。<ul>\n<li>一般使用循环数组作为哈希表。</li>\n<li>可能会导致未来新元素使用更长的时间来寻址。</li>\n<li>如果数组满了可能会导致死循环，因此要规定最多循环次数。</li>\n<li>如果中间有冲突的数组被删除，可能会导致后面冲突的数组查询失败。<ul>\n<li>一个删除的解决方案是不断检测右边是否具有相同的哈希值，如果相同则将该数值重新插入。</li>\n<li>Lazy deletion延迟删除：将被删除的数值标记为“删除”，只当用到它的时候再进行修复。当被查询到“删除”标记的点时直接跳过而不是停止。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双哈希(Double Hashing)：使用一个额外的哈希函数 $d(k)$ 来辅助寻找新元素。<ul>\n<li>新的哈希值为 $(h(k) + j\\ d(k))\\mod N, j\\in[0, N-1]$，选择第一个空元素作为哈希值。一些可能的 $h(k)$：<ul>\n<li>$d(k) &#x3D; q - (k \\mod q)$，其中 $q &lt; N$ 且 $q$ 是素数。</li>\n</ul>\n</li>\n<li>对于线性探索来说，$d(k) &#x3D; 1$。</li>\n<li>$N$ 必须是素数，以探索所有的可能数组包。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>那么使用哈希表来实现<code>Map</code>主要的思路是：</p>\n<ul>\n<li>寻找哈希函数：将 $(k,v)$ 储存在 $i &#x3D; h(k)$ 索引的数组中。</li>\n<li>处理冲突。</li>\n</ul>\n<h4 id=\"基于分离链-Separate-Chaining-处理冲突的方法\"><a href=\"#基于分离链-Separate-Chaining-处理冲突的方法\" class=\"headerlink\" title=\"基于分离链(Separate Chaining)处理冲突的方法\"></a>基于分离链(Separate Chaining)处理冲突的方法</h4><p>因为分离链定义让相同 <code>index</code> 的元素以链表的形式连接起来，其中链表中每个节点还有一个单独的 <code>key</code> 值用于寻找具体的元素。</p>\n<p>那么链表的每个节点应该具有以下的操作，假设有 $m$ 个冲突的元素：</p>\n<ul>\n<li><code>Element get(k)</code>：获取<code>key = k</code>的元素。其时间复杂度是 $O(m)$。</li>\n<li><code>Element put(k, v)</code>：放入<code>(k, v)</code>对的元素，需要检测是否有相同 <code>key</code> 的元素，如果有则返回<code>null</code>。因此时间复杂度是 $O(m)$。</li>\n<li><code>Element remove(k)</code>：删除<code>key = k</code>的元素。其时间复杂度是 $O(m)$。</li>\n</ul>\n<p>那么使用基于分离链哈希表的<code>map</code>具体实现方式如下：</p>\n<ul>\n<li><code>get(k)</code>：<code>return A[h(k)].get(k)</code>。</li>\n<li><code>put(k, v)</code>：<code>return A[h(k)].put(k)</code>。注意要让 <code>size++</code>。</li>\n<li><code>remove(k)</code>: <code>return A[h(k)].remove(k)</code>。注意要让 <code>size--</code>。</li>\n</ul>\n<p>对于每个操作，最佳访问时间是 $O(1)$，最差访问时间依然是 $O(n)$，即全部都有冲突。但是平均下来，其时间复杂度应该是 $O(n &#x2F; N)$，其中 $N$ 是哈希表数组的容量。</p>\n<h4 id=\"哈希函数的性能分析\"><a href=\"#哈希函数的性能分析\" class=\"headerlink\" title=\"哈希函数的性能分析\"></a>哈希函数的性能分析</h4><p>在最坏的情况下，搜索、插入和删除的时间复杂度都是 $O(n)$。</p>\n<p>一般用负载因子(load factor) $\\alpha &#x3D; n &#x2F; N$ 来表示哈希表的性能。</p>\n<p>哈希表各个操作的期望值基本上都是 $O(1)$。具体证明可自行查阅。</p>\n<hr>\n<h2 id=\"二叉搜索树-Binary-Search-Tree-ADT\"><a href=\"#二叉搜索树-Binary-Search-Tree-ADT\" class=\"headerlink\" title=\"二叉搜索树(Binary Search Tree) (ADT)\"></a>二叉搜索树(Binary Search Tree) (ADT)</h2><blockquote>\n<p>A binary search tree is a binary tree storing <code>(key,value)</code> entries at its internal nodes and satisfying the following “search tree” property.<br>二叉搜索树是一个储存<code>(key,value)</code>值到节点的二叉树，并满足下面的性质：</p>\n</blockquote>\n<p>性质：</p>\n<ul>\n<li>对于任意一个内部节点 $v$，拥有左子节点 $u$ 和 右子节点 $w$，满足 <code>key(u) &lt;= key(v) &lt;= key(w)</code>。</li>\n<li>对于任意一个节点 $v$，其左边子辈的值都比 $v$ 小，右边子辈的值都比 $v$ 大。</li>\n<li>换句话说，二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据<code>key</code>升序的。</li>\n</ul>\n<h3 id=\"二叉搜索树ADT主要操作-方法\"><a href=\"#二叉搜索树ADT主要操作-方法\" class=\"headerlink\" title=\"二叉搜索树ADT主要操作&#x2F;方法\"></a>二叉搜索树ADT主要操作&#x2F;方法</h3><ul>\n<li><code>Node search(Key k)</code>：返回<code>key = k</code>的节点，如果没有则返回<code>null</code>。<ul>\n<li>实现：比较当前节点储存的<code>key</code> 与 <code>k</code> 相比较，如果等于则返回。如果<code>k</code>大则查找右节点，如果<code>k</code>小则查找左节点。如果不存在节点，则返回<code>null</code>。</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n<li>如果是平衡二叉树，则时间复杂度是 $O(\\log n)$。</li>\n</ul>\n</li>\n<li><code>void insert(Key k, Value v)</code>：插入 <code>(k, v)</code> 对。<ul>\n<li>实现：使用二分法找到要插入的位置，将其插入进去。</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n</ul>\n</li>\n<li><code>Node remove(Key k)</code>：删除 <code>key = k</code> 的节点。<ul>\n<li>实现：使用二分查找找到要删除的节点删除，分为下面四个情况：<ul>\n<li>没有找到该节点，此时返回 <code>null</code>。</li>\n<li>该节点是叶节点，此时删除该节点。</li>\n<li>节点具有一个子节点，将该子节点替换到原来的位置。</li>\n<li>节点具有两个子节点，此时根据树的中序遍历找到当前<code>key</code>的下一个<code>key</code>节点 $w$ ($w$ 称为该节点的中序后继)，并使用这个节点 $w$ 替代该节点，再尝试删除 $w$，直到不符合被删除的节点具有两个子节点为止。</li>\n</ul>\n</li>\n<li>时间复杂度是 $O(h)$，其中 $h$ 是树的高度。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树-Balanced-Trees\"><a href=\"#平衡二叉树-Balanced-Trees\" class=\"headerlink\" title=\"平衡二叉树(Balanced Trees)\"></a>平衡二叉树(Balanced Trees)</h3><p>平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。<br>平衡二叉树的高度 $h &#x3D; \\log n$。</p>\n<p>一般使用旋转(notation)的方法来让二叉搜索树逐步变成平衡二叉树。</p>\n<h4 id=\"一次旋转-Single-Rotation\"><a href=\"#一次旋转-Single-Rotation\" class=\"headerlink\" title=\"一次旋转 (Single Rotation)\"></a>一次旋转 (Single Rotation)</h4><p>一次旋转适合三个高度节点之间呈类似于 <code>\\</code> 和 <code>/</code> 的直线形。也就是中间高度的节点是中间值的情况。</p>\n<p>过程如下：</p>\n<ul>\n<li>选择一个节点 $P$。</li>\n<li>选择该节点的一个子节点 $C$。</li>\n<li>交换两个节点：<ul>\n<li>选择 $C$ 中相反方向的子节点 $V$：如果 $C$ 是 $P$ 的左节点，那么就选择 $C$ 的右节点。否则选择左节点。</li>\n<li>处理 $P$ 的父节点：<ul>\n<li>将 $P$ 的父节点相应方向的子节点修改为 $C$。</li>\n<li>将 $C$ 的父节点修改为 $P$ 的父节点。</li>\n<li>如果 $P$ 为根节点，那么修改根节点为 $C$。</li>\n</ul>\n</li>\n<li>处理 $C$ 的子节点 $V$：<ul>\n<li>将 $V$ 的父节点修改为 $P$。</li>\n<li>将 $P$ 原来方向上的子节点 $C$ 的位置修改为 $V$。</li>\n</ul>\n</li>\n<li>处理 $C$ 和 $P$：<ul>\n<li>将 $C$ 原来 $V$ 位置的子节点修改为 $P$。</li>\n<li>将 $P$ 的父节点修改为 $C$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png\" alt=\"平衡二叉树旋转\" width=\"650\">\n\n<p>整个过程时间复杂度是 $O(1)$。</p>\n<h4 id=\"二次旋转-Double-Rotation\"><a href=\"#二次旋转-Double-Rotation\" class=\"headerlink\" title=\"二次旋转 (Double Rotation)\"></a>二次旋转 (Double Rotation)</h4><p>诸如下图中的类似 <code>&gt;</code>和<code>&lt;</code> 形，是无法使用一次旋转的，如果只旋转<code>a</code> 和 <code>c</code> 将无法改变高度。</p>\n<p>此时需要先将<code>&gt;</code>或<code>&lt;</code>形旋转成<code>/</code>或<code>\\</code>形，再进行一次旋转。整个过程被称为二次旋转，如下图。</p>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png\" alt=\"平衡二叉树二次旋转\" width=\"650\">\n\n<p>具体的其他二叉树方法将（例如AVL树、红黑树）不在本笔记中展示。可能会未来在其他笔记中展示。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><hr>\n<h1 id=\"五-算法\"><a href=\"#五-算法\" class=\"headerlink\" title=\"五. 算法\"></a>五. 算法</h1><p>算法的设计思路通常有这么几种：</p>\n<ul>\n<li>暴力搜索(Brute Force)：生成所有潜在解决方案并测试哪些是实际解决方案。时间复杂通常非常高，是属于多项式级其以上的时间复杂度。</li>\n<li>分而治之(Divide and Conquer)：递归地将问题分解成更小的部分并逐步解决它们，然后将它们重新组合在一起。是一种比较高效的设计思路。</li>\n<li>启发式(Heuristics)：是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。</li>\n<li>动态规划(DP)：DP是一种适用于最优解满足“分解性质”情况的通用方法。</li>\n</ul>\n<hr>\n<h2 id=\"排序算法-Sorting-algorithms\"><a href=\"#排序算法-Sorting-algorithms\" class=\"headerlink\" title=\"排序算法(Sorting algorithms)\"></a>排序算法(Sorting algorithms)</h2><p>排序算法的性质：</p>\n<ul>\n<li>排序稳定性(Stability)：如果两个元素键值相等，排序算法会保留这两个元素的相对位置。</li>\n<li>排序自适应性(Adaptive)：如果数组已经接近已排序，那么算法的效率会提高。</li>\n<li>排序接入模式(Access Patterns)<ul>\n<li>Sequential Access：数据的读取和写入是按照其在存储器中存放的顺序进行的。</li>\n<li>Random Access：数据储存中能够在常数时间 $O(1)$ 内直接访问任意位置的数据。</li>\n</ul>\n</li>\n<li>是否需要额外空间。</li>\n</ul>\n<p>如果没有特殊说明，以下算法都默认<strong>从小到大排序&#x2F;升序</strong>、使用 <strong>数组(array)</strong> 作为数据结构。</p>\n<h3 id=\"基于比较的排序算法的一些思考\"><a href=\"#基于比较的排序算法的一些思考\" class=\"headerlink\" title=\"基于比较的排序算法的一些思考\"></a>基于比较的排序算法的一些思考</h3><p>如果一个排序算法仅包含关于成对比较元素的信息，那么就称这个排序是<strong>基于比较</strong>的(comparison-based)。</p>\n<p>并不是所有的排序算法都是基于比较的，例如桶排序(bucket sort)是使用实际的值来进行排序的，其时间复杂度是$O(n)$，但是其实现依赖于其值的范围。是一种使用空间换取时间的方法。</p>\n<p>对于 $n$ 个数的数组来说，它一共拥有 $n!$ 种排序方法。我们使用基于比较的算法来对数组进行排序是通过两两比较来减半它排序方法的可能性。也就是说，基于比较的排序算法本质其实是逐步将 $n!$ 减半成 $1$。</p>\n<p>这意味着我们需要去做 $\\log_2(n!)$ 次比较。实际上 $O(\\log(n!)) &#x3D; O(n \\log n)$。也就是说基于比较的算法不能比 $O(n \\log n)$ 更优。</p>\n<hr>\n<h3 id=\"1-冒泡排序-Bubble-sort\"><a href=\"#1-冒泡排序-Bubble-sort\" class=\"headerlink\" title=\"1. 冒泡排序(Bubble sort)\"></a>1. 冒泡排序(Bubble sort)</h3><h4 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>让大的元素逐渐往后移动。</p>\n<ul>\n<li>外部循环(Outer loop)：扫描整个数组。</li>\n<li>内部循环(Inner loop)：对于数组每个元素与右边邻域对比，如果右边邻域更小则立即交换。</li>\n</ul>\n<h4 id=\"算法思考\"><a href=\"#算法思考\" class=\"headerlink\" title=\"算法思考\"></a>算法思考</h4><p>因为算法中最大元素像水泡一样逐渐向上冒，因此被称为冒泡排序。</p>\n<h4 id=\"复杂性分析\"><a href=\"#复杂性分析\" class=\"headerlink\" title=\"复杂性分析\"></a>复杂性分析</h4><p>考虑到最差的情况，也就是每次循环都会进行交换。外部循环次数为$(n - 1)$，假设当前外部循环$index &#x3D; i$，那么内部循环次数为 $(n - i - 1)$，因此总循环次数为 $\\frac{n(n - 1)}{2}$。</p>\n<p>假设比较和交换原始操作数为 $t$ 为常数，循环以外的原始操作数为 $k$ 为常数，那么总原始操作数为 $\\frac{n(n - 1)}{2} + t(n - 1) + k$。</p>\n<p>根据删除规则，我们可以知道它的时间复杂度是 $O(n^2)$。</p>\n<p>此外，也可以使用递归关系来证明冒泡排序的时间复杂度：</p>\n<p>:::details 使用递归关系证明冒泡排序的时间复杂度</p>\n<p>首先冒泡排序并不是天然递归的，而是一个双重循环。</p>\n<p>但是我们能使用递归思想来将冒泡排序改成递归：如果要将长度为 $n$ 的数组进行排序，首先将这个数组中的最大数值通过冒泡操作交换到当前数组最右边的位置并固定，随后再将剩下 $n - 1$ 的数组进行排序(递归)。</p>\n<p>这样就写出其运行时间的递推公式：<br>$$<br>\\begin{aligned}<br>T(n) &amp; &#x3D; dn + T(n - 1) \\<br>T(1) &amp; &#x3D; 1<br>\\end{aligned}<br>$$</p>\n<ul>\n<li>$dn$ 表示通过冒泡操作交换所需要的时间。</li>\n<li>$T(n - 1)$ 表示剩余数组排序所需要的时间。</li>\n</ul>\n<p>我们可以根据等差数列求出 $T(n)$ 的通项公式为：<br>$$T(n) &#x3D; 1 + (\\frac{n(n+1)}{2} - 1) d$$</p>\n<p>那么很明显 $T(n)$ 是 $\\Theta(n^2)$。</p>\n<p>:::</p>\n<h4 id=\"算法的性质。\"><a href=\"#算法的性质。\" class=\"headerlink\" title=\"算法的性质。\"></a>算法的性质。</h4><ul>\n<li>如果相同的元素不进行交换，那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>可以通过添加变量来让算法 <strong>具有</strong> 自适应性（内部循环没有进行任何交换）。</li>\n<li>不需要额外的空间。</li>\n<li>可适用于单向链表的<code>swapElement(Node, Node)</code>，时间复杂度不变。</li>\n</ul>\n<hr>\n<h3 id=\"2-选择排序-Selection-sort\"><a href=\"#2-选择排序-Selection-sort\" class=\"headerlink\" title=\"2. 选择排序(Selection sort)\"></a>2. 选择排序(Selection sort)</h3><h4 id=\"基本思想-1\"><a href=\"#基本思想-1\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>保持数组后面的元素不变作为<strong>已排序</strong>的元素，前面的元素作为<strong>未排序</strong>的元素，选择<strong>未排序</strong>的元素组中最大的元素插入到<strong>已排序</strong>元素组的头部。</p>\n<ul>\n<li>外部循环：扫描整个数组。</li>\n<li>内部循环：扫描整个<strong>未排序部分</strong>的数组。并不会让最大的元素立即交换，而是记录住最大元素的位置。等内部循环扫描完，将被记录的元素：<ul>\n<li>插入到<strong>已排序部分</strong>的数组的最左边。或者：</li>\n<li>与<strong>未排序部分</strong>的数组最右边的元素交换并将其加入到<strong>已排序部分</strong>数组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法思考-1\"><a href=\"#算法思考-1\" class=\"headerlink\" title=\"算法思考\"></a>算法思考</h4><p>与冒泡排序不同，冒泡排序是比较当前元素和其邻域，而该排序是比较当前元素和被记录的元素。<br>为什么要延迟交换而不是立即交换：</p>\n<ul>\n<li>如果交换操作可能会比较昂贵，并不像数组一样是$O(1)$，那么就需要尽可能减少交换次数。</li>\n<li>如果数组非常大，那么需要尽可能地减少交换次数来提高效率。</li>\n</ul>\n<h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><p>相比于冒泡排序，它们具有相同数量的迭代和比较，仅仅是有更少数量的交换。</p>\n<p>因此它的时间复杂度也是$O(n^2)$。</p>\n<h4 id=\"算法的性质。-1\"><a href=\"#算法的性质。-1\" class=\"headerlink\" title=\"算法的性质。\"></a>算法的性质。</h4><ul>\n<li>该算法 <strong>不具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>不需要额外的空间。</li>\n<li>可适用于单向链表的<code>swapElement(Node, Node)</code>，时间复杂度不变。</li>\n</ul>\n<hr>\n<h3 id=\"3-插入排序-Insertion-sort\"><a href=\"#3-插入排序-Insertion-sort\" class=\"headerlink\" title=\"3. 插入排序(Insertion sort)\"></a>3. 插入排序(Insertion sort)</h3><p>保持数组前面元素的排序不变作为<strong>已经排序</strong>的元素，后面的元素作为<strong>未排序</strong>的元素。选择当前<strong>未排序</strong>元素不断交换左边比该元素大的元素，并将其加入到<strong>已经排序</strong>的元素。</p>\n<ul>\n<li>外部循环：扫描整个数组。</li>\n<li>内部循环：获取并记录当前<strong>未排序</strong>元素的最左边元素，从右到左扫描<strong>已经排序</strong>的元素，如果被扫描的元素比记录的元素大，那么就交换，直到被扫描的元素比记录的元素小。</li>\n</ul>\n<h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li>在最坏的情况下，它的外部原始操作数是 $O(n)$，内部原始操作数是 $O(n)$，因此它的总时间复杂度是$O(n * n) &#x3D; O(n^2)$。</li>\n<li>在最佳的情况下，它内部循环操作数是 $O(1)$，那么它的总时间复杂程度是 $O(n * 1) &#x3D; O(n)$。</li>\n</ul>\n<h4 id=\"算法的性质\"><a href=\"#算法的性质\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>如果相同的元素不进行交换，那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>该算法 <strong>具有</strong> 自适应性。</li>\n<li>不需要额外的空间。</li>\n<li>不适用于单向链表。适用于双向链表。</li>\n</ul>\n<hr>\n<h3 id=\"4-归并排序-Merge-sort\"><a href=\"#4-归并排序-Merge-sort\" class=\"headerlink\" title=\"4. 归并排序(Merge sort)\"></a>4. 归并排序(Merge sort)</h3><p>归并排序是一个基于分而治之(divide-and-conquer)的算法，它是先划分再排序。</p>\n<ul>\n<li>分解 (Divide)：将待排序的数组 $S$ 分解为两个部分 $S_1$, $S_2$。<ul>\n<li>分解直到只剩下单个元素或者空元素为止。因为单个元素的数组一定是已经排序好的数组。</li>\n<li>分解只是简单的数学运算，因此时间复杂度是 $O(1)$。</li>\n</ul>\n</li>\n<li>递归 (Recur)：递归地将 $S_1$ 和 $S_2$ 进行排序(带入到分而治之中)。<ul>\n<li>递归分解，回归组合。</li>\n<li>递归全部子集的时间复杂度是 $O(\\log(n))$。</li>\n</ul>\n</li>\n<li>组合 (Conquer)：将已排序的 $S_1$ 和 $S_2$ 合并(merge)。<ul>\n<li>merge是基于两个已经排序好的数组进行的：依次判断两个数组当前第一个数(最小的数)，选择最小的一个放入到新的数组后面，直到有一个数组为空后，将另一个数组剩余的元素依次放入到新的数组后面。</li>\n<li>假设放入的操作时间复杂度是$O(1)$，那么合并的时间复杂度是 $O(n)$。</li>\n</ul>\n</li>\n</ul>\n<p>归并排序递归调用的过程是一个二叉树结构。</p>\n<img src=\"/articles/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png\" alt=\"归并排序\" width=\"450\">\n\n<h4 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><p>综上所述，归并排序的时间复杂度是 $O(n\\log{n})$。<br>此外可以使用递归关系来证明归并排序的时间复杂度，详细请见 <strong>三.Master定理</strong> 中 <strong>递归关系</strong> 中的样例。<br>归并排序需要用到额外的空间，因此其空间复杂度是 $O(n)$。<br><em>也可以使得空间复杂度是 $O(1)$，但是过于混乱一般不作考虑。</em></p>\n<h4 id=\"算法的性质-1\"><a href=\"#算法的性质-1\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>在归并遇见相等数据时，如果优先选择左边数组那么该算法 <strong>具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>该算法 <strong>需要</strong> 额外的空间。</li>\n<li>该算法对数据的访问是顺序的(sequential)，因此在硬盘中具有较好的排序效率。</li>\n<li>因为依赖于快速对中间的数据进行访问，因此不太适合使用链表。</li>\n</ul>\n<hr>\n<h3 id=\"5-快速排序-Quick-Sort\"><a href=\"#5-快速排序-Quick-Sort\" class=\"headerlink\" title=\"5. 快速排序(Quick Sort)\"></a>5. 快速排序(Quick Sort)</h3><p>快排是一个基于分而治之的算法，它是先排序后划分。</p>\n<ul>\n<li>分解 (Divide)：称之为<code>partition</code>操作。选择一个元素 $x$ 称之为枢(pivot)，并将数组 $S$ 分为：<ul>\n<li>$L$：元素小于 $x$ 的。</li>\n<li>$GE$ 元素大于等于 $x$ 的。</li>\n<li><code>pivot</code>经常是使用随机选择。</li>\n<li>假设 交换 或者 删除再插入 的时间复杂度是$O(1)$，那么分解的时间复杂度是 $O(n)$。</li>\n</ul>\n</li>\n<li>递归 (Recur)：对 $L$ 和 $GE$ 使用进行递归排序，带入到分而治之中。<ul>\n<li>最差的情况下，选择的枢总是最小&#x2F;最大值，那么此时递归所有的子集时间复杂度是 $O(n)$。</li>\n<li>最佳的情况下，选择的枢总是中间值，那么此时递归所有的子集时间复杂度是 $O(\\log n)$。</li>\n</ul>\n</li>\n<li>组合 (Conquer)：将 $L$ 和 $GE$ 左右连接起来。<ul>\n<li>组合只是简单的连接，时间复杂度是 $O(1)$。</li>\n</ul>\n</li>\n</ul>\n<p>快速排序递归调用的过程是一个二叉树结构。</p>\n<h4 id=\"快速算法的分解-Divide-实现形式\"><a href=\"#快速算法的分解-Divide-实现形式\" class=\"headerlink\" title=\"快速算法的分解(Divide)实现形式\"></a>快速算法的分解(Divide)实现形式</h4><p>该操作称为<code>partition</code>操作。</p>\n<ul>\n<li><p>使用额外的空间进行分解，具体思想如下：</p>\n<ol>\n<li>创建两个数组，分别表示 $L$ 和 $GE$。</li>\n<li>选择一个枢(pivot)。</li>\n<li>从左到右遍历数组，将小于枢的数加入到 $L$，将大于等于枢的数加入到 $GE$。</li>\n</ol>\n</li>\n<li><p>使用双指针的方法进行分解，这个方法是就地(in-place)，步骤如下：</p>\n<ol>\n<li>选择一个枢(pivot)。</li>\n<li>定义两个指针 $j$ 和 $k$，分别初始化指向数组的开头和结尾。</li>\n<li>使用 $j$ 向右扫描，直到找到第一个 $\\geq$ 枢的元素 或者 $j &#x3D;&#x3D; k$ 停止。</li>\n<li>使用 $k$ 向左扫描，直到找到第一个 $&lt;$ 枢的元素 或者 $j &#x3D;&#x3D; k$ 停止。</li>\n<li>交换 $j, k$ 的元素。</li>\n<li>如果 $j &lt; k$，则返回 $3$。</li>\n<li>此时 $j &#x3D;&#x3D; k$，并且此时 $j, k$ 的位置元素等于枢，也是 $GE$ 位置的左边界线。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"算法的思考\"><a href=\"#算法的思考\" class=\"headerlink\" title=\"算法的思考\"></a>算法的思考</h4><p>如果选择枢的方式是固定而不是随机的(例如总是选择第一个值作为枢)，并且出现了 $L$ 子集是空的情况(此时选择的枢是最小值)，那么此时会导致算法出现死循环。因为每次对 $GE$ 子集进行排序时，总是会选择最左边的值(也是最小值)作为枢，从而导致 $L$ 子集是空的情况。</p>\n<blockquote>\n<p>快速排序要避免固定选择枢和出现一方子集是空集的情况，否则可能会导致死循环。</p>\n</blockquote>\n<ul>\n<li>解决方法1：使用随机的方式选择枢。</li>\n<li>解决方法2：将排序分为三个部分，分别是 $L$, ${pivot}$, $E+G$。</li>\n<li>解决方法3：三点取值，选择最左边的数、中间的数和最右边的数中的中位数作为枢。</li>\n</ul>\n<h4 id=\"复杂度分析-3\"><a href=\"#复杂度分析-3\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul>\n<li>最差的情况下，快速排序的时间复杂度是 $O(n^2)$。</li>\n<li>最佳的情况下，快速排序的时间复杂度是 $O(n\\log{n})$。</li>\n<li>平均情况下，在一半的时间中快速排序选择的枢是中间值，那么时间复杂度是 $O(n\\log{n})$。<ul>\n<li>也可以认为平均情况下，选择的枢值总是让两个子集分解成 $\\frac{1}{3}$ 和 $\\frac{2}{3}$ 两个区域，也就是说递归二叉树的高度是 $\\frac{3}{2}\\log n$。</li>\n<li>*具体证明可以自行查看<a href=\"https://en.wikipedia.org/wiki/Quicksort\">维基百科</a>*。</li>\n</ul>\n</li>\n</ul>\n<p>快速排序不需要用到额外的空间，因此其空间复杂度是 $O(1)$。</p>\n<h4 id=\"算法的性质-2\"><a href=\"#算法的性质-2\" class=\"headerlink\" title=\"算法的性质\"></a>算法的性质</h4><ul>\n<li>快速排序 <strong>不具有</strong> 稳定性。</li>\n<li>该算法 <strong>不具有</strong> 自适应性。</li>\n<li>该算法 <strong>不需要</strong> 额外的空间，是就地(in-place)的算法。</li>\n<li>该算法对数据的访问是随机的(randomized)。</li>\n<li>因为是使用 交换 或者 删除再插入 操作进行，因此可以使用双向链表。</li>\n</ul>\n<hr>\n<h2 id=\"启发式算法-Heuristics\"><a href=\"#启发式算法-Heuristics\" class=\"headerlink\" title=\"启发式算法(Heuristics)\"></a>启发式算法(Heuristics)</h2><p>启发式算法是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。<br>通常有两种：</p>\n<ol>\n<li>程序中的决策可以给出准确&#x2F;最佳的答案，但通常是为了加快程序运行速度。<ul>\n<li>例如，A*搜索算法中使用可接受的启发式方法(Admissible heuristic)、在快速排序算法中使用随机选择的方式选择枢(pivot)。</li>\n</ul>\n</li>\n<li>程序中的决策可能不会给出最佳答案，但旨在给出以其他方式无法获得的良好答案。<ul>\n<li>一般用于解决一些<code>NP-hard</code>问题，例如 TSP问题、图染色问题等。</li>\n<li>例如 遗传算法、模拟退火。</li>\n<li>具体可以参考<a href=\"/post/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0-AIM-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95\">AIM-优化算法</a>笔记。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"贪心算法-Greedy\"><a href=\"#贪心算法-Greedy\" class=\"headerlink\" title=\"贪心算法(Greedy)\"></a>贪心算法(Greedy)</h3><p>贪心算法是一种常见的启发式算法。贪心算法是做出短期内看起来最好的决定，而不考虑未来的策略。</p>\n<p>一些贪心算法可以得到最优解，例如最小生成树(Minimal Spanning Tree, MST)中Prim算法。</p>\n<p>大部分贪心算法无法给出最优解，但是可以给出接近最优的解。</p>\n<h4 id=\"最小生成树问题-Minimal-Spanning-Tre-MST\"><a href=\"#最小生成树问题-Minimal-Spanning-Tre-MST\" class=\"headerlink\" title=\"最小生成树问题(Minimal Spanning Tre, MST)\"></a>最小生成树问题(Minimal Spanning Tre, MST)</h4><p>问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。<br>问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。</p>\n<h5 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h5><p>思路：</p>\n<ol>\n<li>选择任意顶点 $M$。</li>\n<li>选择对外可以连接到的所有的点中最小的那个边，并将边加入到 <code>MST</code>中，将点加入到内部的点中。</li>\n<li>是否全部连接，如果没有则返回 $2$。通过已连接的边个数判断，即 边的个数 $e &#x3D; n - 1$。</li>\n</ol>\n<p>算法实现：</p>\n<ul>\n<li>$1.$ 初始化数组 <code>value[n] = inf</code>，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数<code>m = 0</code>。</li>\n<li>$2.$ 随机选择一个点 $M$。</li>\n<li>$3.$ 使<code>value[M] = 0</code>，并根据 $M$ 连接的所有边 $(M, V)$ 更新 <code>edge</code> 数组。即 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value[M] = 0              # 因为已经被连接，所以更新为0</span><br><span class=\"line\">forall e in edge(M)</span><br><span class=\"line\">  v = e.v                 # 获取边连接的另一个点</span><br><span class=\"line\">  if(e.value &lt; value[v])  # 根据边权值更新对外连接点的大小</span><br><span class=\"line\">    value[v] = e.value </span><br></pre></td></tr></table></figure></li>\n<li>$4.$ 找到 <code>value[v] != 0</code> 中最小的点 $V$，使 <code>value[V] = 0</code>，<code>m++</code>。</li>\n<li>$5.$ 跟 $3$ 一样根据 $V$ 连接的所有边 $(V, U)$ 更新 <code>edge</code> 数组。</li>\n<li>$6.$ 判断是否所有的点已经连通，即 <code>(m - 1) == n</code>，如果没有则返回 $4$。</li>\n</ul>\n<hr>\n<h2 id=\"动态规划-Dynamic-Programming-DP\"><a href=\"#动态规划-Dynamic-Programming-DP\" class=\"headerlink\" title=\"动态规划(Dynamic Programming, DP)\"></a>动态规划(Dynamic Programming, DP)</h2><blockquote>\n<p>DP is a general method that can be suitable when the optimal solutions satisfy a “decomposition property”.<br>DP 是一种适用于最优解满足“分解性质”情况的通用方法。</p>\n</blockquote>\n<p>DP的步骤通常如下：</p>\n<ol>\n<li>将最优解分解为子解相当于将问题分解为子问题，并且子解对于子问题是最优的。</li>\n<li>因此，最优解可以通过更小的子问题的最优解来构建。</li>\n</ol>\n<p><em>与分治法不同的是，DP中的子问题可以重叠，即不同的路径可能会遇见相同的子问题。</em></p>\n<p>因此DP的思想通常是，对于某一个解 $S_n$，如果我想要得到这个解，我该直到哪些解才能得出这个解，并依次获取和尝试合并这些可能解的组合。又或者说，我现在已知某一个解，我是否可以让这个解和其他输入&#x2F;解组合获取一个新的解。其中这个“得到”和“获取”的过程是一个状态转移的过程，这个过程是一个状态转移方程&#x2F;贝尔曼方程(Bellman Equation)。</p>\n<ul>\n<li>例如，假设有这样一个问题：给出一个整型集合 $S$，和一个目标值 $K$，我是否可以找出一个 $S_{sub}$ 的子集，其元素的和等于 $K$。<ul>\n<li>假设我们输入 $S[i], 0 \\leq i \\leq (n-1)$ 是集合第 $i$ 个元素。</li>\n<li>我们使用 $dp[i][m] &#x3D; true, 0 \\leq m \\leq K$ 来表示使用前 $i$ 个元素组成的子集中 $S_{sub}$ 元素和可以等于 $m$。</li>\n<li>如果我们知道 $dp[i - 1][m] &#x3D; true$，那么可以根据它和当前元素 $S[i]$ 得出 $dp[i][m + S[i]] &#x3D; true$。</li>\n<li>如何知道$dp[i - 1][m] &#x3D; true$? 只需要对 $m$ 进行遍历 $(0 \\leq m \\leq K-S[i])$ 依次检查是否为<code>true</code>即可。</li>\n<li>由此我们就可以得到状态转移方程：$dp[i][m] &#x3D; dp[i][m]\\ \\text{ | } \\ dp[i - 1][m - S[i]]$。</li>\n<li>时间复杂度是 $O(kn)$。</li>\n<li>此外我们可以使用滚动数组将其变成一维dp，此时对容量 $m$ 的遍历是倒着的（如果正着就会导致元素 $i$ 被重复计算，此时属于完全背包问题）。</li>\n</ul>\n</li>\n</ul>\n<p><em>与暴力搜索，暴力搜索是将所有可能的答案依次列出来并测试，答案之间可能没有太大的关系。而动态规划是根据状态转移来尝试获取哪些解。</em></p>\n<hr>\n<h2 id=\"最短路算法-Shortest-Path\"><a href=\"#最短路算法-Shortest-Path\" class=\"headerlink\" title=\"最短路算法(Shortest Path)\"></a>最短路算法(Shortest Path)</h2><p>最短路算法分为单源最短路和多源最短路。<br>解决单源最短路的一种方法是 <code>Dijkstra</code> 算法，其时间复杂度是 $O(n\\log n + m)$。如果将其应用在多源最短路的话，那么其时间复杂度是 $O(n(n\\log n + m))$。</p>\n<p>此外，有一个特定的算法用来解决多源最短路，就是<code>Floyd-Warshall (FW)</code>算法，该算法的时间复杂度是 $O(n^3)$。</p>\n<h3 id=\"Floyd-Warshall-FW\"><a href=\"#Floyd-Warshall-FW\" class=\"headerlink\" title=\"Floyd-Warshall (FW)\"></a>Floyd-Warshall (FW)</h3><p>FW算法是一个动态规划的算法，通过逐步加入点来构造子答案从而获取整体最优解的方法。<br>适用于负数边、有向边的情况。</p>\n<ul>\n<li><p>定义：</p>\n<ul>\n<li><p>定义 $d(i,j,k)$：表示点在 $i,j$ 之间使用 ${1,…,k}$ 作为允许使用的潜在中间点的最短路。</p>\n<ul>\n<li>例如 $d(2,5,3)$：在仅使用 ${1,2,3}$ 其中的点作为中间点（这些点可以使用也可以不使用，但不能使用其他的点）时点 $2$ 到点 $5$ 的最短路。</li>\n</ul>\n</li>\n<li><p>定义 $w(i, j)$：表示两个点之间的距离。</p>\n<ul>\n<li>如果不连通则等于 $\\infty$，即 <code>w(i, j) = inf</code>。</li>\n<li>自边等于 $0$，即 <code>w(i, i) = 0</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>初始化：对于所有的两个点之间：$d(i, j, 0) &#x3D; w(i, j)$。</p>\n</li>\n<li><p>状态转移方程：考虑当 <code>k = k + 1</code>时，即对于每两对点之间在前 <code>k</code> 个点已经加入好，那么有：<br>$$d(i, j, k+1) &#x3D; \\min (d(i, j, k), d(i, k+1, k) + d(k+1, j, k))$$</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li>“Big O Notation.” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Big_O_notation. Accessed 19 May 2024.</li>\n<li>“Recurrence Relation.” Wikipedia, The Free Encyclopedia, 8 April 2024, en.wikipedia.org&#x2F;wiki&#x2F;Recurrence_relation. Accessed 20 May 2024.</li>\n<li>“Master Theorem (Analysis of Algorithms).” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Master_theorem_(analysis_of_algorithms). Accessed 22 May 2024.</li>\n<li>“Quicksort.” Wikipedia, The Free Encyclopedia, 12 May 2024, en.wikipedia.org&#x2F;wiki&#x2F;Quicksort. Accessed 21 May 2024.</li>\n</ol>"},{"title":"四叉树学习笔记","date":"2025-01-09T16:00:00.000Z","updated":"2025-01-09T16:00:00.000Z","author":"XZDXRZ","_content":"\n# 什么是四叉树，我们为什么使用它\n\n在游戏开发的背景下，我们经常会遇到需要检测两个对象是否发生碰撞的情况。通过实现四叉树，我们可以减少需要检查碰撞的对象数量，只关注同一象限或相邻象限内的对象。\n\n<!--more-->\n\n想象一下，我们有一个包含多个游戏对象的二维平面。我们在这个类中定义我们的游戏对象。\n\n```cpp\nclass Object\n{\n    public:\n        Point position;\n        std::string name;\n        Object(Point _position, std::string _name): position(_position), name(_name) {}\n};\n```\n\n其中 `Point` 类定义如下：\n\n```cpp\nclass Point\n{\n    public:\n        int x, y;\n        Point(int _x, int _y): x(_x), y(_y) {}\n};\n```\n\n四叉树是一种树结构，其中每个节点都有四个子节点。每个节点可以通过以下方式定义：\n\n```cpp\nclass Quadtree\n{\n    private:\n        // 定义节点分配的区域\n        Point top_left, bottom_right;\n        // 声明四个子节点\n        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;\n        // 存储在该区域的对象\n        Object *object;\n\n        // 判断该节点是否有子节点\n        bool hasChildren();\n    public:\n        Quadtree(Point _top_left, Point _bottom_right):\\\n            top_left(_top_left), bottom_right(_bottom_right),\\\n            object(NULL), top_left_child(NULL), top_right_child(NULL),\\\n            bottom_left_child(NULL), bottom_right_child(NULL) {}\n\n        ~Quadtree();\n\n        // 向四叉树中插入对象\n        void insert(Object *object);\n        // 在四叉树中搜索对象\n        Object* search(Point point);\n\n        // 判断点是否在特定子节点中\n        bool in_top_left_child(Point point);\n        bool in_top_right_child(Point point);\n        bool in_bottom_left_child(Point point);\n        bool in_bottom_right_child(Point point);\n\n        // 判断点是否在节点的边界内\n        bool in_boundary(Point point);\n};\n```\n\n我们在这里创建了一个庞大的类。别担心，我会逐步详细解释它们。\n\n要定义一个矩形区域，需要其左上角和右下角的坐标。我们使用两个点来定义节点分配的区域。\n\n为了定义四个子节点，我们使用四个指针指向子节点。\n\n同样，为了定义存储在该区域的对象，我们使用一个指针指向该对象。\n\n以下是一些辅助函数的实现。\n\n```cpp\nbool Quadtree::hasChildren()\n{\n    return top_left_child != NULL;\n}\n\nbool Quadtree::in_top_left_child(Point point)\n{\n    return point.x <= top_left_child->bottom_right.x && point.y <= top_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_top_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.x <= top_right_child->bottom_right.x && point.y <= top_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_left_child(Point point)\n{\n    return point.x <= bottom_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.y <= bottom_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.x <= bottom_right_child->bottom_right.x && point.y <= bottom_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_boundary(Point point)\n{\n    return point.x >= top_left.x && point.x <= bottom_right.x && point.y >= top_left.y && point.y <= bottom_right.y;\n}\n```\n\n顺便说一下，因为我们是同时创建四个子节点，所以，当我们需要确定一个节点是否有子节点时，我们可以检查它的任意一个子节点是否存在。\n\n以及创建一个析构函数用于释放内存。\n\n```cpp\nQuadtree::~Quadtree()\n{\n    delete top_left_child;\n    delete top_right_child;\n    delete bottom_left_child;\n    delete bottom_right_child;\n    delete object;\n}\n```\n\n通过递归地将二维平面划分为四个象限，我们可以很容易地构建一个四叉树。\n\n```cpp\nvoid Quadtree::insert(Object* object)\n{\n    // 如果对象不在四叉树的边界内\n    if (!in_boundary(object->position))\n        return;\n\n    // 如果对象在四叉树的单元节点中\n    // 即节点不能再被划分\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n    {\n        if (this->object == NULL)\n            this->object = object;\n        return;\n    }\n\n    // 如果该节点尚未被划分\n    if (!hasChildren())\n    {\n        // 划分节点并创建4个子节点\n        int x = (top_left.x + bottom_right.x) / 2;\n        int y = (top_left.y + bottom_right.y) / 2;\n        top_left_child = new Quadtree(top_left, Point(x, y));\n        top_right_child = new Quadtree(Point(x + 1, top_left.y), Point(bottom_right.x, y));\n        bottom_left_child = new Quadtree(Point(top_left.x, y + 1), Point(x, bottom_right.y));\n        bottom_right_child = new Quadtree(Point(x + 1, y + 1), bottom_right);\n    }\n\n    // 将对象插入到相应的子节点中\n    if (in_top_left_child(object->position))\n        top_left_child->insert(object);\n    else if (in_top_right_child(object->position))\n        top_right_child->insert(object);\n    else if (in_bottom_left_child(object->position))\n        bottom_left_child->insert(object);\n    else\n        bottom_right_child->insert(object);\n}\n```\n\n要将对象插入四叉树，我们应确保对象在四叉树的边界内。\n\n此外，如果对象已经在四叉树的单元节点中，我们只需将对象存储到该节点中。\n\n如果节点尚未被划分，我们需要划分节点并创建四个子节点。然后我们将对象插入到相应的子节点中。\n\n要在四叉树中搜索对象，我们递归地搜索对象所在的区域。\n\n```cpp\nObject* Quadtree::search(Point point)\n{\n    // 如果点不在四叉树的边界内\n    if (!in_boundary(point))\n        return NULL;\n\n    // 如果点在四叉树的单元节点中\n    // 即节点不能再被划分\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n        return object;\n\n    // 如果该节点已经被划分\n    if (hasChildren())\n    {\n        if (in_top_left_child(point))\n            return top_left_child->search(point);\n        else if (in_top_right_child(point))\n            return top_right_child->search(point);\n        else if (in_bottom_left_child(point))\n            return bottom_left_child->search(point);\n        else\n            return bottom_right_child->search(point);\n    }\n\n    return NULL;\n}\n```\n\n搜索的逻辑很简单：当我们将对象插入树中时，我们不断划分树，直到到达单元节点。因此，当我们在树中搜索对象时，我们不断搜索，直到到达单元节点。\n\n让我们用一些实例来测试四叉树。\n\n```cpp\nint main()\n{\n    // 构建一个8x8的四叉树\n    Quadtree qt(Point(0, 0), Point(8, 8));\n\n    // 创建并插入三个对象到四叉树中\n    Object obj1(Point(1, 1), \"Object 1\");\n    Object obj2(Point(2, 5), \"Object 2\");\n    Object obj3(Point(7, 7), \"Object 3\");\n\n    qt.insert(&obj1);\n    qt.insert(&obj2);\n    qt.insert(&obj3);\n\n    // 在四叉树中搜索对象\n    Object* result1 = qt.search(Point(1, 1));\n    Object* result2 = qt.search(Point(2, 5));\n    Object* result3 = qt.search(Point(7, 7));\n    // 搜索一个不在四叉树中的点\n    Object* result4 = qt.search(Point(3, 3));\n\n    std::cout << \"Test Insert and Search:\" << std::endl;\n    std::cout << \"Search (1, 1): \" << (result1 != NULL ? result1->name : \"NULL\") << std::endl;\n    std::cout << \"Search (2, 5): \" << (result2 != NULL ? result2->name : \"NULL\") << std::endl;\n    std::cout << \"Search (7, 7): \" << (result3 != NULL ? result3->name : \"NULL\") << std::endl;\n    std::cout << \"Search (3, 3): \" << (result4 != NULL ? result4->name : \"NULL\") << std::endl;\n    return 0;\n}\n```\n\n结果如下：\n\n```bash\nTest Insert and Search:\nSearch (1, 1): Object 1\nSearch (2, 5): Object 2\nSearch (7, 7): Object 3\nSearch (3, 3): NULL\n```\n\n完整代码如下\n\n```cpp\n#include <iostream>\n#include <string>\n\nclass Point\n{\n    public:\n        int x, y;\n        Point(int _x, int _y): x(_x), y(_y) {}\n};\n\nclass Object\n{\n    public:\n        Point position;\n        std::string name;\n        Object(Point _position, std::string _name): position(_position), name(_name) {}\n};\n\nclass Quadtree\n{\n    private:\n        Point top_left, bottom_right;\n        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;\n        Object *object;\n\n        bool hasChildren();\n    public:\n        Quadtree(Point _top_left, Point _bottom_right):\\\n            top_left(_top_left), bottom_right(_bottom_right),\\\n            object(NULL), top_left_child(NULL), top_right_child(NULL),\\\n            bottom_left_child(NULL), bottom_right_child(NULL) {}\n\n        ~Quadtree();\n\n        void insert(Object *object);\n        Object* search(Point point);\n\n        bool in_top_left_child(Point point);\n        bool in_top_right_child(Point point);\n        bool in_bottom_left_child(Point point);\n        bool in_bottom_right_child(Point point);\n\n        bool in_boundary(Point point);\n};\n\nbool Quadtree::hasChildren()\n{\n    return top_left_child != NULL;\n}\n\nbool Quadtree::in_top_left_child(Point point)\n{\n    return point.x <= top_left_child->bottom_right.x && point.y <= top_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_top_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.x <= top_right_child->bottom_right.x && point.y <= top_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_left_child(Point point)\n{\n    return point.x <= bottom_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.y <= bottom_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.x <= bottom_right_child->bottom_right.x && point.y <= bottom_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_boundary(Point point)\n{\n    return point.x >= top_left.x && point.x <= bottom_right.x && point.y >= top_left.y && point.y <= bottom_right.y;\n}\n\nvoid Quadtree::insert(Object* object)\n{\n    // If the object is not in the boundary of the quadtree\n    if (!in_boundary(object->position))\n        return;\n\n    // If the object is in a unit node of quadtree\n    // that is, the node cannot be partitioned anymore\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n    {\n        if (this->object == NULL)\n            this->object = object;\n        return;\n    }\n\n    // If this node has not been partitioned yet\n    if (!hasChildren())\n    {\n        // Partition the node and create 4 children\n        int x = (top_left.x + bottom_right.x) / 2;\n        int y = (top_left.y + bottom_right.y) / 2;\n        top_left_child = new Quadtree(top_left, Point(x, y));\n        top_right_child = new Quadtree(Point(x + 1, top_left.y), Point(bottom_right.x, y));\n        bottom_left_child = new Quadtree(Point(top_left.x, y + 1), Point(x, bottom_right.y));\n        bottom_right_child = new Quadtree(Point(x + 1, y + 1), bottom_right);\n    }\n\n    // Insert the object into the corresponding child\n    if (in_top_left_child(object->position))\n        top_left_child->insert(object);\n    else if (in_top_right_child(object->position))\n        top_right_child->insert(object);\n    else if (in_bottom_left_child(object->position))\n        bottom_left_child->insert(object);\n    else\n        bottom_right_child->insert(object);\n}\n\nObject* Quadtree::search(Point point)\n{\n    // If the point is not in the boundary of the quadtree\n    if (!in_boundary(point))\n        return NULL;\n\n    // If the point is in a unit node of quadtree\n    // that is, the node cannot be partitioned anymore\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n        return object;\n\n    // If this node has been partitioned\n    if (hasChildren())\n    {\n        if (in_top_left_child(point))\n            return top_left_child->search(point);\n        else if (in_top_right_child(point))\n            return top_right_child->search(point);\n        else if (in_bottom_left_child(point))\n            return bottom_left_child->search(point);\n        else\n            return bottom_right_child->search(point);\n    }\n\n    return NULL;\n}\n\nQuadtree::~Quadtree()\n{\n    delete top_left_child;\n    delete top_right_child;\n    delete bottom_left_child;\n    delete bottom_right_child;\n    delete object;\n}\n\nint main()\n{\n    // Build a 8x8 quadtree\n    Quadtree qt(Point(0, 0), Point(8, 8));\n\n    // Create and Insert three objects into the quadtree\n    Object obj1(Point(1, 1), \"Object 1\");\n    Object obj2(Point(2, 5), \"Object 2\");\n    Object obj3(Point(7, 7), \"Object 3\");\n\n    qt.insert(&obj1);\n    qt.insert(&obj2);\n    qt.insert(&obj3);\n\n    // Search for the objects in the quadtree\n    Object* result1 = qt.search(Point(1, 1));\n    Object* result2 = qt.search(Point(2, 5));\n    Object* result3 = qt.search(Point(7, 7));\n    // search for a point that is not in the quadtree\n    Object* result4 = qt.search(Point(3, 3));\n\n    std::cout << \"Test Insert and Search:\" << std::endl;\n    std::cout << \"Search (1, 1): \" << (result1 != NULL ? result1->name : \"NULL\") << std::endl;\n    std::cout << \"Search (2, 5): \" << (result2 != NULL ? result2->name : \"NULL\") << std::endl;\n    std::cout << \"Search (7, 7): \" << (result3 != NULL ? result3->name : \"NULL\") << std::endl;\n    std::cout << \"Search (3, 3): \" << (result4 != NULL ? result4->name : \"NULL\") << std::endl;\n    return 0;\n}\n```\n","source":"_posts/XZDXRZ/quadtree_notes.md","raw":"---\ntitle: 四叉树学习笔记\ndate: 2025-01-10\nupdated: 2025-01-10\npermalink: articles/XZDXRZ/quadtree_nodes/\ncategories: XZDXRZ\nauthor: XZDXRZ\ntags: [数据结构, C++, 游戏开发]\n---\n\n# 什么是四叉树，我们为什么使用它\n\n在游戏开发的背景下，我们经常会遇到需要检测两个对象是否发生碰撞的情况。通过实现四叉树，我们可以减少需要检查碰撞的对象数量，只关注同一象限或相邻象限内的对象。\n\n<!--more-->\n\n想象一下，我们有一个包含多个游戏对象的二维平面。我们在这个类中定义我们的游戏对象。\n\n```cpp\nclass Object\n{\n    public:\n        Point position;\n        std::string name;\n        Object(Point _position, std::string _name): position(_position), name(_name) {}\n};\n```\n\n其中 `Point` 类定义如下：\n\n```cpp\nclass Point\n{\n    public:\n        int x, y;\n        Point(int _x, int _y): x(_x), y(_y) {}\n};\n```\n\n四叉树是一种树结构，其中每个节点都有四个子节点。每个节点可以通过以下方式定义：\n\n```cpp\nclass Quadtree\n{\n    private:\n        // 定义节点分配的区域\n        Point top_left, bottom_right;\n        // 声明四个子节点\n        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;\n        // 存储在该区域的对象\n        Object *object;\n\n        // 判断该节点是否有子节点\n        bool hasChildren();\n    public:\n        Quadtree(Point _top_left, Point _bottom_right):\\\n            top_left(_top_left), bottom_right(_bottom_right),\\\n            object(NULL), top_left_child(NULL), top_right_child(NULL),\\\n            bottom_left_child(NULL), bottom_right_child(NULL) {}\n\n        ~Quadtree();\n\n        // 向四叉树中插入对象\n        void insert(Object *object);\n        // 在四叉树中搜索对象\n        Object* search(Point point);\n\n        // 判断点是否在特定子节点中\n        bool in_top_left_child(Point point);\n        bool in_top_right_child(Point point);\n        bool in_bottom_left_child(Point point);\n        bool in_bottom_right_child(Point point);\n\n        // 判断点是否在节点的边界内\n        bool in_boundary(Point point);\n};\n```\n\n我们在这里创建了一个庞大的类。别担心，我会逐步详细解释它们。\n\n要定义一个矩形区域，需要其左上角和右下角的坐标。我们使用两个点来定义节点分配的区域。\n\n为了定义四个子节点，我们使用四个指针指向子节点。\n\n同样，为了定义存储在该区域的对象，我们使用一个指针指向该对象。\n\n以下是一些辅助函数的实现。\n\n```cpp\nbool Quadtree::hasChildren()\n{\n    return top_left_child != NULL;\n}\n\nbool Quadtree::in_top_left_child(Point point)\n{\n    return point.x <= top_left_child->bottom_right.x && point.y <= top_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_top_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.x <= top_right_child->bottom_right.x && point.y <= top_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_left_child(Point point)\n{\n    return point.x <= bottom_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.y <= bottom_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.x <= bottom_right_child->bottom_right.x && point.y <= bottom_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_boundary(Point point)\n{\n    return point.x >= top_left.x && point.x <= bottom_right.x && point.y >= top_left.y && point.y <= bottom_right.y;\n}\n```\n\n顺便说一下，因为我们是同时创建四个子节点，所以，当我们需要确定一个节点是否有子节点时，我们可以检查它的任意一个子节点是否存在。\n\n以及创建一个析构函数用于释放内存。\n\n```cpp\nQuadtree::~Quadtree()\n{\n    delete top_left_child;\n    delete top_right_child;\n    delete bottom_left_child;\n    delete bottom_right_child;\n    delete object;\n}\n```\n\n通过递归地将二维平面划分为四个象限，我们可以很容易地构建一个四叉树。\n\n```cpp\nvoid Quadtree::insert(Object* object)\n{\n    // 如果对象不在四叉树的边界内\n    if (!in_boundary(object->position))\n        return;\n\n    // 如果对象在四叉树的单元节点中\n    // 即节点不能再被划分\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n    {\n        if (this->object == NULL)\n            this->object = object;\n        return;\n    }\n\n    // 如果该节点尚未被划分\n    if (!hasChildren())\n    {\n        // 划分节点并创建4个子节点\n        int x = (top_left.x + bottom_right.x) / 2;\n        int y = (top_left.y + bottom_right.y) / 2;\n        top_left_child = new Quadtree(top_left, Point(x, y));\n        top_right_child = new Quadtree(Point(x + 1, top_left.y), Point(bottom_right.x, y));\n        bottom_left_child = new Quadtree(Point(top_left.x, y + 1), Point(x, bottom_right.y));\n        bottom_right_child = new Quadtree(Point(x + 1, y + 1), bottom_right);\n    }\n\n    // 将对象插入到相应的子节点中\n    if (in_top_left_child(object->position))\n        top_left_child->insert(object);\n    else if (in_top_right_child(object->position))\n        top_right_child->insert(object);\n    else if (in_bottom_left_child(object->position))\n        bottom_left_child->insert(object);\n    else\n        bottom_right_child->insert(object);\n}\n```\n\n要将对象插入四叉树，我们应确保对象在四叉树的边界内。\n\n此外，如果对象已经在四叉树的单元节点中，我们只需将对象存储到该节点中。\n\n如果节点尚未被划分，我们需要划分节点并创建四个子节点。然后我们将对象插入到相应的子节点中。\n\n要在四叉树中搜索对象，我们递归地搜索对象所在的区域。\n\n```cpp\nObject* Quadtree::search(Point point)\n{\n    // 如果点不在四叉树的边界内\n    if (!in_boundary(point))\n        return NULL;\n\n    // 如果点在四叉树的单元节点中\n    // 即节点不能再被划分\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n        return object;\n\n    // 如果该节点已经被划分\n    if (hasChildren())\n    {\n        if (in_top_left_child(point))\n            return top_left_child->search(point);\n        else if (in_top_right_child(point))\n            return top_right_child->search(point);\n        else if (in_bottom_left_child(point))\n            return bottom_left_child->search(point);\n        else\n            return bottom_right_child->search(point);\n    }\n\n    return NULL;\n}\n```\n\n搜索的逻辑很简单：当我们将对象插入树中时，我们不断划分树，直到到达单元节点。因此，当我们在树中搜索对象时，我们不断搜索，直到到达单元节点。\n\n让我们用一些实例来测试四叉树。\n\n```cpp\nint main()\n{\n    // 构建一个8x8的四叉树\n    Quadtree qt(Point(0, 0), Point(8, 8));\n\n    // 创建并插入三个对象到四叉树中\n    Object obj1(Point(1, 1), \"Object 1\");\n    Object obj2(Point(2, 5), \"Object 2\");\n    Object obj3(Point(7, 7), \"Object 3\");\n\n    qt.insert(&obj1);\n    qt.insert(&obj2);\n    qt.insert(&obj3);\n\n    // 在四叉树中搜索对象\n    Object* result1 = qt.search(Point(1, 1));\n    Object* result2 = qt.search(Point(2, 5));\n    Object* result3 = qt.search(Point(7, 7));\n    // 搜索一个不在四叉树中的点\n    Object* result4 = qt.search(Point(3, 3));\n\n    std::cout << \"Test Insert and Search:\" << std::endl;\n    std::cout << \"Search (1, 1): \" << (result1 != NULL ? result1->name : \"NULL\") << std::endl;\n    std::cout << \"Search (2, 5): \" << (result2 != NULL ? result2->name : \"NULL\") << std::endl;\n    std::cout << \"Search (7, 7): \" << (result3 != NULL ? result3->name : \"NULL\") << std::endl;\n    std::cout << \"Search (3, 3): \" << (result4 != NULL ? result4->name : \"NULL\") << std::endl;\n    return 0;\n}\n```\n\n结果如下：\n\n```bash\nTest Insert and Search:\nSearch (1, 1): Object 1\nSearch (2, 5): Object 2\nSearch (7, 7): Object 3\nSearch (3, 3): NULL\n```\n\n完整代码如下\n\n```cpp\n#include <iostream>\n#include <string>\n\nclass Point\n{\n    public:\n        int x, y;\n        Point(int _x, int _y): x(_x), y(_y) {}\n};\n\nclass Object\n{\n    public:\n        Point position;\n        std::string name;\n        Object(Point _position, std::string _name): position(_position), name(_name) {}\n};\n\nclass Quadtree\n{\n    private:\n        Point top_left, bottom_right;\n        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;\n        Object *object;\n\n        bool hasChildren();\n    public:\n        Quadtree(Point _top_left, Point _bottom_right):\\\n            top_left(_top_left), bottom_right(_bottom_right),\\\n            object(NULL), top_left_child(NULL), top_right_child(NULL),\\\n            bottom_left_child(NULL), bottom_right_child(NULL) {}\n\n        ~Quadtree();\n\n        void insert(Object *object);\n        Object* search(Point point);\n\n        bool in_top_left_child(Point point);\n        bool in_top_right_child(Point point);\n        bool in_bottom_left_child(Point point);\n        bool in_bottom_right_child(Point point);\n\n        bool in_boundary(Point point);\n};\n\nbool Quadtree::hasChildren()\n{\n    return top_left_child != NULL;\n}\n\nbool Quadtree::in_top_left_child(Point point)\n{\n    return point.x <= top_left_child->bottom_right.x && point.y <= top_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_top_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.x <= top_right_child->bottom_right.x && point.y <= top_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_left_child(Point point)\n{\n    return point.x <= bottom_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.y <= bottom_left_child->bottom_right.y;\n}\n\nbool Quadtree::in_bottom_right_child(Point point)\n{\n    return point.x > top_left_child->bottom_right.x && point.y > top_left_child->bottom_right.y && point.x <= bottom_right_child->bottom_right.x && point.y <= bottom_right_child->bottom_right.y;\n}\n\nbool Quadtree::in_boundary(Point point)\n{\n    return point.x >= top_left.x && point.x <= bottom_right.x && point.y >= top_left.y && point.y <= bottom_right.y;\n}\n\nvoid Quadtree::insert(Object* object)\n{\n    // If the object is not in the boundary of the quadtree\n    if (!in_boundary(object->position))\n        return;\n\n    // If the object is in a unit node of quadtree\n    // that is, the node cannot be partitioned anymore\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n    {\n        if (this->object == NULL)\n            this->object = object;\n        return;\n    }\n\n    // If this node has not been partitioned yet\n    if (!hasChildren())\n    {\n        // Partition the node and create 4 children\n        int x = (top_left.x + bottom_right.x) / 2;\n        int y = (top_left.y + bottom_right.y) / 2;\n        top_left_child = new Quadtree(top_left, Point(x, y));\n        top_right_child = new Quadtree(Point(x + 1, top_left.y), Point(bottom_right.x, y));\n        bottom_left_child = new Quadtree(Point(top_left.x, y + 1), Point(x, bottom_right.y));\n        bottom_right_child = new Quadtree(Point(x + 1, y + 1), bottom_right);\n    }\n\n    // Insert the object into the corresponding child\n    if (in_top_left_child(object->position))\n        top_left_child->insert(object);\n    else if (in_top_right_child(object->position))\n        top_right_child->insert(object);\n    else if (in_bottom_left_child(object->position))\n        bottom_left_child->insert(object);\n    else\n        bottom_right_child->insert(object);\n}\n\nObject* Quadtree::search(Point point)\n{\n    // If the point is not in the boundary of the quadtree\n    if (!in_boundary(point))\n        return NULL;\n\n    // If the point is in a unit node of quadtree\n    // that is, the node cannot be partitioned anymore\n    if (top_left.x == bottom_right.x && top_left.y == bottom_right.y)\n        return object;\n\n    // If this node has been partitioned\n    if (hasChildren())\n    {\n        if (in_top_left_child(point))\n            return top_left_child->search(point);\n        else if (in_top_right_child(point))\n            return top_right_child->search(point);\n        else if (in_bottom_left_child(point))\n            return bottom_left_child->search(point);\n        else\n            return bottom_right_child->search(point);\n    }\n\n    return NULL;\n}\n\nQuadtree::~Quadtree()\n{\n    delete top_left_child;\n    delete top_right_child;\n    delete bottom_left_child;\n    delete bottom_right_child;\n    delete object;\n}\n\nint main()\n{\n    // Build a 8x8 quadtree\n    Quadtree qt(Point(0, 0), Point(8, 8));\n\n    // Create and Insert three objects into the quadtree\n    Object obj1(Point(1, 1), \"Object 1\");\n    Object obj2(Point(2, 5), \"Object 2\");\n    Object obj3(Point(7, 7), \"Object 3\");\n\n    qt.insert(&obj1);\n    qt.insert(&obj2);\n    qt.insert(&obj3);\n\n    // Search for the objects in the quadtree\n    Object* result1 = qt.search(Point(1, 1));\n    Object* result2 = qt.search(Point(2, 5));\n    Object* result3 = qt.search(Point(7, 7));\n    // search for a point that is not in the quadtree\n    Object* result4 = qt.search(Point(3, 3));\n\n    std::cout << \"Test Insert and Search:\" << std::endl;\n    std::cout << \"Search (1, 1): \" << (result1 != NULL ? result1->name : \"NULL\") << std::endl;\n    std::cout << \"Search (2, 5): \" << (result2 != NULL ? result2->name : \"NULL\") << std::endl;\n    std::cout << \"Search (7, 7): \" << (result3 != NULL ? result3->name : \"NULL\") << std::endl;\n    std::cout << \"Search (3, 3): \" << (result4 != NULL ? result4->name : \"NULL\") << std::endl;\n    return 0;\n}\n```\n","slug":"XZDXRZ/quadtree_notes","published":1,"__permalink":"articles/XZDXRZ/quadtree_nodes/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm693l0ag0002i0ut59c09cw0","content":"<h1 id=\"什么是四叉树，我们为什么使用它\"><a href=\"#什么是四叉树，我们为什么使用它\" class=\"headerlink\" title=\"什么是四叉树，我们为什么使用它\"></a>什么是四叉树，我们为什么使用它</h1><p>在游戏开发的背景下，我们经常会遇到需要检测两个对象是否发生碰撞的情况。通过实现四叉树，我们可以减少需要检查碰撞的对象数量，只关注同一象限或相邻象限内的对象。</p>\n<span id=\"more\"></span>\n\n<p>想象一下，我们有一个包含多个游戏对象的二维平面。我们在这个类中定义我们的游戏对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Object</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        Point position;</span><br><span class=\"line\">        std::string name;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>(Point _position, std::string _name): <span class=\"built_in\">position</span>(_position), <span class=\"built_in\">name</span>(_name) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>Point</code> 类定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> _x, <span class=\"type\">int</span> _y): <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>四叉树是一种树结构，其中每个节点都有四个子节点。每个节点可以通过以下方式定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Quadtree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 定义节点分配的区域</span></span><br><span class=\"line\">        Point top_left, bottom_right;</span><br><span class=\"line\">        <span class=\"comment\">// 声明四个子节点</span></span><br><span class=\"line\">        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;</span><br><span class=\"line\">        <span class=\"comment\">// 存储在该区域的对象</span></span><br><span class=\"line\">        Object *object;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断该节点是否有子节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasChildren</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Quadtree</span>(Point _top_left, Point _bottom_right):\\</span><br><span class=\"line\">            <span class=\"built_in\">top_left</span>(_top_left), <span class=\"built_in\">bottom_right</span>(_bottom_right),\\</span><br><span class=\"line\">            <span class=\"built_in\">object</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_right_child</span>(<span class=\"literal\">NULL</span>),\\</span><br><span class=\"line\">            <span class=\"built_in\">bottom_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">bottom_right_child</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">Quadtree</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向四叉树中插入对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Object *object)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在四叉树中搜索对象</span></span><br><span class=\"line\">        <span class=\"function\">Object* <span class=\"title\">search</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断点是否在特定子节点中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断点是否在节点的边界内</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_boundary</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里创建了一个庞大的类。别担心，我会逐步详细解释它们。</p>\n<p>要定义一个矩形区域，需要其左上角和右下角的坐标。我们使用两个点来定义节点分配的区域。</p>\n<p>为了定义四个子节点，我们使用四个指针指向子节点。</p>\n<p>同样，为了定义存储在该区域的对象，我们使用一个指针指向该对象。</p>\n<p>以下是一些辅助函数的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::hasChildren</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_left_child != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= top_left_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.x &lt;= top_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= bottom_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.y &lt;= bottom_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.x &lt;= bottom_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= bottom_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_boundary</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt;= top_left.x &amp;&amp; point.x &lt;= bottom_right.x &amp;&amp; point.y &gt;= top_left.y &amp;&amp; point.y &lt;= bottom_right.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便说一下，因为我们是同时创建四个子节点，所以，当我们需要确定一个节点是否有子节点时，我们可以检查它的任意一个子节点是否存在。</p>\n<p>以及创建一个析构函数用于释放内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Quadtree::~<span class=\"built_in\">Quadtree</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过递归地将二维平面划分为四个象限，我们可以很容易地构建一个四叉树。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Quadtree::insert</span><span class=\"params\">(Object* object)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果对象不在四叉树的边界内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(object-&gt;position))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果对象在四叉树的单元节点中</span></span><br><span class=\"line\">    <span class=\"comment\">// 即节点不能再被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;object == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;object = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果该节点尚未被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 划分节点并创建4个子节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> x = (top_left.x + bottom_right.x) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> y = (top_left.y + bottom_right.y) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        top_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(top_left, <span class=\"built_in\">Point</span>(x, y));</span><br><span class=\"line\">        top_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, top_left.y), <span class=\"built_in\">Point</span>(bottom_right.x, y));</span><br><span class=\"line\">        bottom_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(top_left.x, y + <span class=\"number\">1</span>), <span class=\"built_in\">Point</span>(x, bottom_right.y));</span><br><span class=\"line\">        bottom_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>), bottom_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将对象插入到相应的子节点中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        bottom_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bottom_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要将对象插入四叉树，我们应确保对象在四叉树的边界内。</p>\n<p>此外，如果对象已经在四叉树的单元节点中，我们只需将对象存储到该节点中。</p>\n<p>如果节点尚未被划分，我们需要划分节点并创建四个子节点。然后我们将对象插入到相应的子节点中。</p>\n<p>要在四叉树中搜索对象，我们递归地搜索对象所在的区域。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Object* <span class=\"title\">Quadtree::search</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果点不在四叉树的边界内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(point))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果点在四叉树的单元节点中</span></span><br><span class=\"line\">    <span class=\"comment\">// 即节点不能再被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果该节点已经被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>搜索的逻辑很简单：当我们将对象插入树中时，我们不断划分树，直到到达单元节点。因此，当我们在树中搜索对象时，我们不断搜索，直到到达单元节点。</p>\n<p>让我们用一些实例来测试四叉树。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个8x8的四叉树</span></span><br><span class=\"line\">    <span class=\"function\">Quadtree <span class=\"title\">qt</span><span class=\"params\">(Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>), Point(<span class=\"number\">8</span>, <span class=\"number\">8</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建并插入三个对象到四叉树中</span></span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj1</span><span class=\"params\">(Point(<span class=\"number\">1</span>, <span class=\"number\">1</span>), <span class=\"string\">&quot;Object 1&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj2</span><span class=\"params\">(Point(<span class=\"number\">2</span>, <span class=\"number\">5</span>), <span class=\"string\">&quot;Object 2&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj3</span><span class=\"params\">(Point(<span class=\"number\">7</span>, <span class=\"number\">7</span>), <span class=\"string\">&quot;Object 3&quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj1);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj2);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在四叉树中搜索对象</span></span><br><span class=\"line\">    Object* result1 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    Object* result2 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">    Object* result3 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">7</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 搜索一个不在四叉树中的点</span></span><br><span class=\"line\">    Object* result4 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Test Insert and Search:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (1, 1): &quot;</span> &lt;&lt; (result1 != <span class=\"literal\">NULL</span> ? result1-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (2, 5): &quot;</span> &lt;&lt; (result2 != <span class=\"literal\">NULL</span> ? result2-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (7, 7): &quot;</span> &lt;&lt; (result3 != <span class=\"literal\">NULL</span> ? result3-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (3, 3): &quot;</span> &lt;&lt; (result4 != <span class=\"literal\">NULL</span> ? result4-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test Insert and Search:</span><br><span class=\"line\">Search (1, 1): Object 1</span><br><span class=\"line\">Search (2, 5): Object 2</span><br><span class=\"line\">Search (7, 7): Object 3</span><br><span class=\"line\">Search (3, 3): NULL</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> _x, <span class=\"type\">int</span> _y): <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Object</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        Point position;</span><br><span class=\"line\">        std::string name;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>(Point _position, std::string _name): <span class=\"built_in\">position</span>(_position), <span class=\"built_in\">name</span>(_name) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Quadtree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        Point top_left, bottom_right;</span><br><span class=\"line\">        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;</span><br><span class=\"line\">        Object *object;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasChildren</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Quadtree</span>(Point _top_left, Point _bottom_right):\\</span><br><span class=\"line\">            <span class=\"built_in\">top_left</span>(_top_left), <span class=\"built_in\">bottom_right</span>(_bottom_right),\\</span><br><span class=\"line\">            <span class=\"built_in\">object</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_right_child</span>(<span class=\"literal\">NULL</span>),\\</span><br><span class=\"line\">            <span class=\"built_in\">bottom_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">bottom_right_child</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">Quadtree</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Object *object)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">Object* <span class=\"title\">search</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_boundary</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::hasChildren</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_left_child != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= top_left_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.x &lt;= top_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= bottom_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.y &lt;= bottom_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.x &lt;= bottom_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= bottom_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_boundary</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt;= top_left.x &amp;&amp; point.x &lt;= bottom_right.x &amp;&amp; point.y &gt;= top_left.y &amp;&amp; point.y &lt;= bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Quadtree::insert</span><span class=\"params\">(Object* object)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the object is not in the boundary of the quadtree</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(object-&gt;position))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the object is in a unit node of quadtree</span></span><br><span class=\"line\">    <span class=\"comment\">// that is, the node cannot be partitioned anymore</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;object == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;object = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this node has not been partitioned yet</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Partition the node and create 4 children</span></span><br><span class=\"line\">        <span class=\"type\">int</span> x = (top_left.x + bottom_right.x) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> y = (top_left.y + bottom_right.y) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        top_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(top_left, <span class=\"built_in\">Point</span>(x, y));</span><br><span class=\"line\">        top_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, top_left.y), <span class=\"built_in\">Point</span>(bottom_right.x, y));</span><br><span class=\"line\">        bottom_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(top_left.x, y + <span class=\"number\">1</span>), <span class=\"built_in\">Point</span>(x, bottom_right.y));</span><br><span class=\"line\">        bottom_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>), bottom_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insert the object into the corresponding child</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        bottom_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bottom_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Object* <span class=\"title\">Quadtree::search</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the point is not in the boundary of the quadtree</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(point))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the point is in a unit node of quadtree</span></span><br><span class=\"line\">    <span class=\"comment\">// that is, the node cannot be partitioned anymore</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this node has been partitioned</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Quadtree::~<span class=\"built_in\">Quadtree</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> object;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a 8x8 quadtree</span></span><br><span class=\"line\">    <span class=\"function\">Quadtree <span class=\"title\">qt</span><span class=\"params\">(Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>), Point(<span class=\"number\">8</span>, <span class=\"number\">8</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create and Insert three objects into the quadtree</span></span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj1</span><span class=\"params\">(Point(<span class=\"number\">1</span>, <span class=\"number\">1</span>), <span class=\"string\">&quot;Object 1&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj2</span><span class=\"params\">(Point(<span class=\"number\">2</span>, <span class=\"number\">5</span>), <span class=\"string\">&quot;Object 2&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj3</span><span class=\"params\">(Point(<span class=\"number\">7</span>, <span class=\"number\">7</span>), <span class=\"string\">&quot;Object 3&quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj1);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj2);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Search for the objects in the quadtree</span></span><br><span class=\"line\">    Object* result1 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    Object* result2 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">    Object* result3 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">7</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">    <span class=\"comment\">// search for a point that is not in the quadtree</span></span><br><span class=\"line\">    Object* result4 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Test Insert and Search:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (1, 1): &quot;</span> &lt;&lt; (result1 != <span class=\"literal\">NULL</span> ? result1-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (2, 5): &quot;</span> &lt;&lt; (result2 != <span class=\"literal\">NULL</span> ? result2-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (7, 7): &quot;</span> &lt;&lt; (result3 != <span class=\"literal\">NULL</span> ? result3-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (3, 3): &quot;</span> &lt;&lt; (result4 != <span class=\"literal\">NULL</span> ? result4-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是四叉树，我们为什么使用它\"><a href=\"#什么是四叉树，我们为什么使用它\" class=\"headerlink\" title=\"什么是四叉树，我们为什么使用它\"></a>什么是四叉树，我们为什么使用它</h1><p>在游戏开发的背景下，我们经常会遇到需要检测两个对象是否发生碰撞的情况。通过实现四叉树，我们可以减少需要检查碰撞的对象数量，只关注同一象限或相邻象限内的对象。</p>","more":"<p>想象一下，我们有一个包含多个游戏对象的二维平面。我们在这个类中定义我们的游戏对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Object</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        Point position;</span><br><span class=\"line\">        std::string name;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>(Point _position, std::string _name): <span class=\"built_in\">position</span>(_position), <span class=\"built_in\">name</span>(_name) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>Point</code> 类定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> _x, <span class=\"type\">int</span> _y): <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>四叉树是一种树结构，其中每个节点都有四个子节点。每个节点可以通过以下方式定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Quadtree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 定义节点分配的区域</span></span><br><span class=\"line\">        Point top_left, bottom_right;</span><br><span class=\"line\">        <span class=\"comment\">// 声明四个子节点</span></span><br><span class=\"line\">        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;</span><br><span class=\"line\">        <span class=\"comment\">// 存储在该区域的对象</span></span><br><span class=\"line\">        Object *object;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断该节点是否有子节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasChildren</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Quadtree</span>(Point _top_left, Point _bottom_right):\\</span><br><span class=\"line\">            <span class=\"built_in\">top_left</span>(_top_left), <span class=\"built_in\">bottom_right</span>(_bottom_right),\\</span><br><span class=\"line\">            <span class=\"built_in\">object</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_right_child</span>(<span class=\"literal\">NULL</span>),\\</span><br><span class=\"line\">            <span class=\"built_in\">bottom_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">bottom_right_child</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">Quadtree</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向四叉树中插入对象</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Object *object)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在四叉树中搜索对象</span></span><br><span class=\"line\">        <span class=\"function\">Object* <span class=\"title\">search</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断点是否在特定子节点中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断点是否在节点的边界内</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_boundary</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里创建了一个庞大的类。别担心，我会逐步详细解释它们。</p>\n<p>要定义一个矩形区域，需要其左上角和右下角的坐标。我们使用两个点来定义节点分配的区域。</p>\n<p>为了定义四个子节点，我们使用四个指针指向子节点。</p>\n<p>同样，为了定义存储在该区域的对象，我们使用一个指针指向该对象。</p>\n<p>以下是一些辅助函数的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::hasChildren</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_left_child != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= top_left_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.x &lt;= top_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= bottom_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.y &lt;= bottom_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.x &lt;= bottom_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= bottom_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_boundary</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt;= top_left.x &amp;&amp; point.x &lt;= bottom_right.x &amp;&amp; point.y &gt;= top_left.y &amp;&amp; point.y &lt;= bottom_right.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便说一下，因为我们是同时创建四个子节点，所以，当我们需要确定一个节点是否有子节点时，我们可以检查它的任意一个子节点是否存在。</p>\n<p>以及创建一个析构函数用于释放内存。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Quadtree::~<span class=\"built_in\">Quadtree</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过递归地将二维平面划分为四个象限，我们可以很容易地构建一个四叉树。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Quadtree::insert</span><span class=\"params\">(Object* object)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果对象不在四叉树的边界内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(object-&gt;position))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果对象在四叉树的单元节点中</span></span><br><span class=\"line\">    <span class=\"comment\">// 即节点不能再被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;object == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;object = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果该节点尚未被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 划分节点并创建4个子节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> x = (top_left.x + bottom_right.x) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> y = (top_left.y + bottom_right.y) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        top_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(top_left, <span class=\"built_in\">Point</span>(x, y));</span><br><span class=\"line\">        top_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, top_left.y), <span class=\"built_in\">Point</span>(bottom_right.x, y));</span><br><span class=\"line\">        bottom_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(top_left.x, y + <span class=\"number\">1</span>), <span class=\"built_in\">Point</span>(x, bottom_right.y));</span><br><span class=\"line\">        bottom_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>), bottom_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将对象插入到相应的子节点中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        bottom_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bottom_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要将对象插入四叉树，我们应确保对象在四叉树的边界内。</p>\n<p>此外，如果对象已经在四叉树的单元节点中，我们只需将对象存储到该节点中。</p>\n<p>如果节点尚未被划分，我们需要划分节点并创建四个子节点。然后我们将对象插入到相应的子节点中。</p>\n<p>要在四叉树中搜索对象，我们递归地搜索对象所在的区域。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Object* <span class=\"title\">Quadtree::search</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果点不在四叉树的边界内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(point))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果点在四叉树的单元节点中</span></span><br><span class=\"line\">    <span class=\"comment\">// 即节点不能再被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果该节点已经被划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>搜索的逻辑很简单：当我们将对象插入树中时，我们不断划分树，直到到达单元节点。因此，当我们在树中搜索对象时，我们不断搜索，直到到达单元节点。</p>\n<p>让我们用一些实例来测试四叉树。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建一个8x8的四叉树</span></span><br><span class=\"line\">    <span class=\"function\">Quadtree <span class=\"title\">qt</span><span class=\"params\">(Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>), Point(<span class=\"number\">8</span>, <span class=\"number\">8</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建并插入三个对象到四叉树中</span></span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj1</span><span class=\"params\">(Point(<span class=\"number\">1</span>, <span class=\"number\">1</span>), <span class=\"string\">&quot;Object 1&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj2</span><span class=\"params\">(Point(<span class=\"number\">2</span>, <span class=\"number\">5</span>), <span class=\"string\">&quot;Object 2&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj3</span><span class=\"params\">(Point(<span class=\"number\">7</span>, <span class=\"number\">7</span>), <span class=\"string\">&quot;Object 3&quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj1);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj2);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在四叉树中搜索对象</span></span><br><span class=\"line\">    Object* result1 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    Object* result2 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">    Object* result3 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">7</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 搜索一个不在四叉树中的点</span></span><br><span class=\"line\">    Object* result4 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Test Insert and Search:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (1, 1): &quot;</span> &lt;&lt; (result1 != <span class=\"literal\">NULL</span> ? result1-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (2, 5): &quot;</span> &lt;&lt; (result2 != <span class=\"literal\">NULL</span> ? result2-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (7, 7): &quot;</span> &lt;&lt; (result3 != <span class=\"literal\">NULL</span> ? result3-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (3, 3): &quot;</span> &lt;&lt; (result4 != <span class=\"literal\">NULL</span> ? result4-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test Insert and Search:</span><br><span class=\"line\">Search (1, 1): Object 1</span><br><span class=\"line\">Search (2, 5): Object 2</span><br><span class=\"line\">Search (7, 7): Object 3</span><br><span class=\"line\">Search (3, 3): NULL</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> _x, <span class=\"type\">int</span> _y): <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Object</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        Point position;</span><br><span class=\"line\">        std::string name;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>(Point _position, std::string _name): <span class=\"built_in\">position</span>(_position), <span class=\"built_in\">name</span>(_name) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Quadtree</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        Point top_left, bottom_right;</span><br><span class=\"line\">        Quadtree *top_left_child, *top_right_child, *bottom_left_child, *bottom_right_child;</span><br><span class=\"line\">        Object *object;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasChildren</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Quadtree</span>(Point _top_left, Point _bottom_right):\\</span><br><span class=\"line\">            <span class=\"built_in\">top_left</span>(_top_left), <span class=\"built_in\">bottom_right</span>(_bottom_right),\\</span><br><span class=\"line\">            <span class=\"built_in\">object</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">top_right_child</span>(<span class=\"literal\">NULL</span>),\\</span><br><span class=\"line\">            <span class=\"built_in\">bottom_left_child</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">bottom_right_child</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ~<span class=\"built_in\">Quadtree</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Object *object)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">Object* <span class=\"title\">search</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_top_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_left_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_bottom_right_child</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">in_boundary</span><span class=\"params\">(Point point)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::hasChildren</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_left_child != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= top_left_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_top_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.x &lt;= top_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= top_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_left_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &lt;= bottom_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.y &lt;= bottom_left_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_bottom_right_child</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt; top_left_child-&gt;bottom_right.x &amp;&amp; point.y &gt; top_left_child-&gt;bottom_right.y &amp;&amp; point.x &lt;= bottom_right_child-&gt;bottom_right.x &amp;&amp; point.y &lt;= bottom_right_child-&gt;bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Quadtree::in_boundary</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> point.x &gt;= top_left.x &amp;&amp; point.x &lt;= bottom_right.x &amp;&amp; point.y &gt;= top_left.y &amp;&amp; point.y &lt;= bottom_right.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Quadtree::insert</span><span class=\"params\">(Object* object)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the object is not in the boundary of the quadtree</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(object-&gt;position))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the object is in a unit node of quadtree</span></span><br><span class=\"line\">    <span class=\"comment\">// that is, the node cannot be partitioned anymore</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;object == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;object = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this node has not been partitioned yet</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Partition the node and create 4 children</span></span><br><span class=\"line\">        <span class=\"type\">int</span> x = (top_left.x + bottom_right.x) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> y = (top_left.y + bottom_right.y) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        top_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(top_left, <span class=\"built_in\">Point</span>(x, y));</span><br><span class=\"line\">        top_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, top_left.y), <span class=\"built_in\">Point</span>(bottom_right.x, y));</span><br><span class=\"line\">        bottom_left_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(top_left.x, y + <span class=\"number\">1</span>), <span class=\"built_in\">Point</span>(x, bottom_right.y));</span><br><span class=\"line\">        bottom_right_child = <span class=\"keyword\">new</span> <span class=\"built_in\">Quadtree</span>(<span class=\"built_in\">Point</span>(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>), bottom_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insert the object into the corresponding child</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(object-&gt;position))</span><br><span class=\"line\">        top_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(object-&gt;position))</span><br><span class=\"line\">        bottom_left_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        bottom_right_child-&gt;<span class=\"built_in\">insert</span>(object);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Object* <span class=\"title\">Quadtree::search</span><span class=\"params\">(Point point)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the point is not in the boundary of the quadtree</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">in_boundary</span>(point))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the point is in a unit node of quadtree</span></span><br><span class=\"line\">    <span class=\"comment\">// that is, the node cannot be partitioned anymore</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top_left.x == bottom_right.x &amp;&amp; top_left.y == bottom_right.y)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this node has been partitioned</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">hasChildren</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_top_right_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> top_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">in_bottom_left_child</span>(point))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_left_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> bottom_right_child-&gt;<span class=\"built_in\">search</span>(point);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Quadtree::~<span class=\"built_in\">Quadtree</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> top_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_left_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> bottom_right_child;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> object;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a 8x8 quadtree</span></span><br><span class=\"line\">    <span class=\"function\">Quadtree <span class=\"title\">qt</span><span class=\"params\">(Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>), Point(<span class=\"number\">8</span>, <span class=\"number\">8</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create and Insert three objects into the quadtree</span></span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj1</span><span class=\"params\">(Point(<span class=\"number\">1</span>, <span class=\"number\">1</span>), <span class=\"string\">&quot;Object 1&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj2</span><span class=\"params\">(Point(<span class=\"number\">2</span>, <span class=\"number\">5</span>), <span class=\"string\">&quot;Object 2&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">obj3</span><span class=\"params\">(Point(<span class=\"number\">7</span>, <span class=\"number\">7</span>), <span class=\"string\">&quot;Object 3&quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj1);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj2);</span><br><span class=\"line\">    qt.<span class=\"built_in\">insert</span>(&amp;obj3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Search for the objects in the quadtree</span></span><br><span class=\"line\">    Object* result1 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">    Object* result2 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">    Object* result3 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">7</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">    <span class=\"comment\">// search for a point that is not in the quadtree</span></span><br><span class=\"line\">    Object* result4 = qt.<span class=\"built_in\">search</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Test Insert and Search:&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (1, 1): &quot;</span> &lt;&lt; (result1 != <span class=\"literal\">NULL</span> ? result1-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (2, 5): &quot;</span> &lt;&lt; (result2 != <span class=\"literal\">NULL</span> ? result2-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (7, 7): &quot;</span> &lt;&lt; (result3 != <span class=\"literal\">NULL</span> ? result3-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Search (3, 3): &quot;</span> &lt;&lt; (result4 != <span class=\"literal\">NULL</span> ? result4-&gt;name : <span class=\"string\">&quot;NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"EasyX图片处理","date":"2025-01-22T16:00:00.000Z","updated":"2025-01-22T16:00:00.000Z","author":"zhong","_content":"\n## 1.图片处理函数\n\n````c++\nvoid Resize(\n\tIMAGE* pImg,\n\tint width,\n\tint height\n);\n````\n\n### 参数\n\n**pImg**\n\n指定要调整尺寸的绘图设备。如果为 NULL，则表示默认绘图窗口。\n\n**width**\n\n指定绘图设备的宽度。\n\n**height**\n\n指定绘图设备的高度。\n\n<!-- More -->\n\n## 2.获取存储图片像素色彩地址\n\n```c++\nDWORD* GetImageBuffer(IMAGE* pImg = NULL);\n```\n\n### 参数\n\n**pImg**\n\n绘图设备指针。如果为 NULL，表示默认的绘图窗口。\n\n\n\n### 返回值\n\n返回绘图设备的**显示缓冲区**指针。\n\n\n\n### 注意\n\n获取到的显示缓冲区指针可以直接读写。\n\n在显示缓冲区中，每个点占用 4 个字节，因此：显示缓冲区的大小 = 宽度 × 高度 × 4 (字节)。像素点在显示缓冲区中按照从左到右、从上向下的顺序依次排列。访问显示缓冲区请勿越界，否则会造成难以预料的后果。\n\n显示缓冲区中的每个点对应 `RGBTRIPLE` 类型的结构体：\n\n```cpp\nstruct RGBTRIPLE {\n\tBYTE rgbtBlue;\n\tBYTE rgbtGreen;\n\tBYTE rgbtRed;\n};\n```\n\n`RGBTRIPLE` 在内存中的表示形式为：`0xrrggbb` (`bb`=蓝，`gg`=绿，`rr`=红)，而常用的 `COLORREF` 在内存中的表示形式为：`0xbbggrr`。注意，两者的红色和蓝色是相反的，请用 `BGR` 宏交换红色和蓝色。\n\n如果操作绘图窗口的显示缓冲区，请在操作完毕后，执行 `FlushBatchDraw()` 使操作生效。\n\n\n\n## 3.获取某个像素点位置的方法\n\n```c++\n//分配图片内存\nIMAGE* img = new IMAGE();\n\n//设置图片宽高\nint width;\nint height;\n\n//新建图片img调整画布，设置图片宽度高度(在EasyX中图片需要加载到缓冲区才能进行处理（渲染或调整），类似loadimage函数功能，但区别是该函数可以对图片进行修改)\nResize(img, width, height);\n\n//获取存储图片像素色彩的首个像素的地址\nDWORD* img_color_buffer=GetImageBuffer(img);\n\n//图片矩阵image[y][x]像素索引(x,y从0开始)\nint x,y;\nint img_color_buffer_idx = y * width + x;\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx]; \n```\n\n\n\n## 4.获取`RGB`分量方法\n\n### 方法一\n\n```c++\n//操作显示缓冲区中的颜色\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx];\n   \n//获取显示缓冲区中的颜色ARGB分量（方便观看而加空格，编写不需要加）\nBYTE A=(pix_color & 0xff 00 00 00)>>24;\nBYTE R=(pix_color & 0x00 ff 00 00)>>16;\nBYTE G=(pix_color & 0x00 00 ff 00)>>8;\nBYTE B=(pix_color & 0x00000 00 ff);\n\n//对获取了的ARGB分量的操作\n\n//操作后组合（默认A,R,G,B数据类型为BYTE）\npix_color =(DWORD)( (A << 24) | (R << 16) | (G << 8) | B); \n```\n\n\n\n### 方法二\n\n+ 颜色在**内存中**的表示形式为：`0xbbggrr` (`bb`=蓝，`gg`=绿，`rr`=红)\n+ 但是**显示缓冲区**中的颜色表现形式为 `0xrrggbb`。\n+ 注意，两者的红色和蓝色是相反的。直接操作显示缓冲区时，可以通过`BGR` 宏交换颜色的红色和蓝色部分。\n\n\n\n在C语言中，`COLORREF` 是一个常用的类型，主要用于表示颜色，特别是在 `Windows API` 中用于存储颜色值。\n\n`COLORREF` 是一个32位的无符号整数，通常由三个字节组成，分别表示颜色的红色 (Red)、绿色 (Green)、蓝色 (Blue) 分量。\n\n`COLORREF` 的结构如下：\n\n```c++\ntypedef DWORD COLORREF;\n\n// Color constants.\nconst COLORREF rgbRed   =  0x000000FF;\nconst COLORREF rgbGreen =  0x0000FF00;\nconst COLORREF rgbBlue  =  0x00FF0000;\n\nconst COLORREF rgbBlack =  0x00000000;\nconst COLORREF rgbWhite =  0x00FFFFFF;\n```\n\n它的每一部分通常是按以下顺序存储的：\n\n- 高字节（`0x00FF0000`）：蓝色 (Blue)\n- 中字节（`0x0000FF00`）：绿色 (Green)\n- 低字节（`0x000000FF`）：红色 (Red)\n\n```c++\nBYTE GetRValue(COLORREF rgb);\nBYTE GetGValue(COLORREF rgb);\nBYTE GetBValue(COLORREF rgb);\n```\n\n\n\n\n\n````c++\n//操作显示缓冲区中的颜色\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx]\n   \n//获取显示缓冲区中的颜色RGB分量\nBYTE R=GetBValue(pix_color);\nBYTE G=GetGValue(pix_color);\nBYTE B=GetRValue(pix_color);\n\n//对获取了的RGB分量的操作\n\n//操作后组合(不破坏原来Alpha透明度)\npix_color = BGR(RGB(R, G, B)) |  ((((DWORD)(BYTE)(255)) << 24) & pix_color);\n````\n\n","source":"_posts/zhong/EasyX图片处理.md","raw":"---\ntitle: EasyX图片处理\ndate: 2025-01-23\nupdated: 2025-01-23\npermalink: articles/zhong/easyx_image_processing/\ncategories: zhong\nauthor: zhong\ntags: [EasyX, C++, 游戏开发]\n---\n\n## 1.图片处理函数\n\n````c++\nvoid Resize(\n\tIMAGE* pImg,\n\tint width,\n\tint height\n);\n````\n\n### 参数\n\n**pImg**\n\n指定要调整尺寸的绘图设备。如果为 NULL，则表示默认绘图窗口。\n\n**width**\n\n指定绘图设备的宽度。\n\n**height**\n\n指定绘图设备的高度。\n\n<!-- More -->\n\n## 2.获取存储图片像素色彩地址\n\n```c++\nDWORD* GetImageBuffer(IMAGE* pImg = NULL);\n```\n\n### 参数\n\n**pImg**\n\n绘图设备指针。如果为 NULL，表示默认的绘图窗口。\n\n\n\n### 返回值\n\n返回绘图设备的**显示缓冲区**指针。\n\n\n\n### 注意\n\n获取到的显示缓冲区指针可以直接读写。\n\n在显示缓冲区中，每个点占用 4 个字节，因此：显示缓冲区的大小 = 宽度 × 高度 × 4 (字节)。像素点在显示缓冲区中按照从左到右、从上向下的顺序依次排列。访问显示缓冲区请勿越界，否则会造成难以预料的后果。\n\n显示缓冲区中的每个点对应 `RGBTRIPLE` 类型的结构体：\n\n```cpp\nstruct RGBTRIPLE {\n\tBYTE rgbtBlue;\n\tBYTE rgbtGreen;\n\tBYTE rgbtRed;\n};\n```\n\n`RGBTRIPLE` 在内存中的表示形式为：`0xrrggbb` (`bb`=蓝，`gg`=绿，`rr`=红)，而常用的 `COLORREF` 在内存中的表示形式为：`0xbbggrr`。注意，两者的红色和蓝色是相反的，请用 `BGR` 宏交换红色和蓝色。\n\n如果操作绘图窗口的显示缓冲区，请在操作完毕后，执行 `FlushBatchDraw()` 使操作生效。\n\n\n\n## 3.获取某个像素点位置的方法\n\n```c++\n//分配图片内存\nIMAGE* img = new IMAGE();\n\n//设置图片宽高\nint width;\nint height;\n\n//新建图片img调整画布，设置图片宽度高度(在EasyX中图片需要加载到缓冲区才能进行处理（渲染或调整），类似loadimage函数功能，但区别是该函数可以对图片进行修改)\nResize(img, width, height);\n\n//获取存储图片像素色彩的首个像素的地址\nDWORD* img_color_buffer=GetImageBuffer(img);\n\n//图片矩阵image[y][x]像素索引(x,y从0开始)\nint x,y;\nint img_color_buffer_idx = y * width + x;\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx]; \n```\n\n\n\n## 4.获取`RGB`分量方法\n\n### 方法一\n\n```c++\n//操作显示缓冲区中的颜色\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx];\n   \n//获取显示缓冲区中的颜色ARGB分量（方便观看而加空格，编写不需要加）\nBYTE A=(pix_color & 0xff 00 00 00)>>24;\nBYTE R=(pix_color & 0x00 ff 00 00)>>16;\nBYTE G=(pix_color & 0x00 00 ff 00)>>8;\nBYTE B=(pix_color & 0x00000 00 ff);\n\n//对获取了的ARGB分量的操作\n\n//操作后组合（默认A,R,G,B数据类型为BYTE）\npix_color =(DWORD)( (A << 24) | (R << 16) | (G << 8) | B); \n```\n\n\n\n### 方法二\n\n+ 颜色在**内存中**的表示形式为：`0xbbggrr` (`bb`=蓝，`gg`=绿，`rr`=红)\n+ 但是**显示缓冲区**中的颜色表现形式为 `0xrrggbb`。\n+ 注意，两者的红色和蓝色是相反的。直接操作显示缓冲区时，可以通过`BGR` 宏交换颜色的红色和蓝色部分。\n\n\n\n在C语言中，`COLORREF` 是一个常用的类型，主要用于表示颜色，特别是在 `Windows API` 中用于存储颜色值。\n\n`COLORREF` 是一个32位的无符号整数，通常由三个字节组成，分别表示颜色的红色 (Red)、绿色 (Green)、蓝色 (Blue) 分量。\n\n`COLORREF` 的结构如下：\n\n```c++\ntypedef DWORD COLORREF;\n\n// Color constants.\nconst COLORREF rgbRed   =  0x000000FF;\nconst COLORREF rgbGreen =  0x0000FF00;\nconst COLORREF rgbBlue  =  0x00FF0000;\n\nconst COLORREF rgbBlack =  0x00000000;\nconst COLORREF rgbWhite =  0x00FFFFFF;\n```\n\n它的每一部分通常是按以下顺序存储的：\n\n- 高字节（`0x00FF0000`）：蓝色 (Blue)\n- 中字节（`0x0000FF00`）：绿色 (Green)\n- 低字节（`0x000000FF`）：红色 (Red)\n\n```c++\nBYTE GetRValue(COLORREF rgb);\nBYTE GetGValue(COLORREF rgb);\nBYTE GetBValue(COLORREF rgb);\n```\n\n\n\n\n\n````c++\n//操作显示缓冲区中的颜色\n\n//获取某个像素点位置，该数据类型为DWORD\nDWORD pix_color=img_color_buffer[img_color_buffer_idx]\n   \n//获取显示缓冲区中的颜色RGB分量\nBYTE R=GetBValue(pix_color);\nBYTE G=GetGValue(pix_color);\nBYTE B=GetRValue(pix_color);\n\n//对获取了的RGB分量的操作\n\n//操作后组合(不破坏原来Alpha透明度)\npix_color = BGR(RGB(R, G, B)) |  ((((DWORD)(BYTE)(255)) << 24) & pix_color);\n````\n\n","slug":"zhong/EasyX图片处理","published":1,"__permalink":"articles/zhong/easyx_image_processing/","_id":"cm693v2qg00001outbppqeask","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-图片处理函数\"><a href=\"#1-图片处理函数\" class=\"headerlink\" title=\"1.图片处理函数\"></a>1.图片处理函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Resize</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tIMAGE* pImg,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">int</span> height</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>pImg</strong></p>\n<p>指定要调整尺寸的绘图设备。如果为 NULL，则表示默认绘图窗口。</p>\n<p><strong>width</strong></p>\n<p>指定绘图设备的宽度。</p>\n<p><strong>height</strong></p>\n<p>指定绘图设备的高度。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-获取存储图片像素色彩地址\"><a href=\"#2-获取存储图片像素色彩地址\" class=\"headerlink\" title=\"2.获取存储图片像素色彩地址\"></a>2.获取存储图片像素色彩地址</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD* <span class=\"title\">GetImageBuffer</span><span class=\"params\">(IMAGE* pImg = <span class=\"literal\">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>pImg</strong></p>\n<p>绘图设备指针。如果为 NULL，表示默认的绘图窗口。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回绘图设备的<strong>显示缓冲区</strong>指针。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>获取到的显示缓冲区指针可以直接读写。</p>\n<p>在显示缓冲区中，每个点占用 4 个字节，因此：显示缓冲区的大小 &#x3D; 宽度 × 高度 × 4 (字节)。像素点在显示缓冲区中按照从左到右、从上向下的顺序依次排列。访问显示缓冲区请勿越界，否则会造成难以预料的后果。</p>\n<p>显示缓冲区中的每个点对应 <code>RGBTRIPLE</code> 类型的结构体：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RGBTRIPLE</span> &#123;</span><br><span class=\"line\">\tBYTE rgbtBlue;</span><br><span class=\"line\">\tBYTE rgbtGreen;</span><br><span class=\"line\">\tBYTE rgbtRed;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>RGBTRIPLE</code> 在内存中的表示形式为：<code>0xrrggbb</code> (<code>bb</code>&#x3D;蓝，<code>gg</code>&#x3D;绿，<code>rr</code>&#x3D;红)，而常用的 <code>COLORREF</code> 在内存中的表示形式为：<code>0xbbggrr</code>。注意，两者的红色和蓝色是相反的，请用 <code>BGR</code> 宏交换红色和蓝色。</p>\n<p>如果操作绘图窗口的显示缓冲区，请在操作完毕后，执行 <code>FlushBatchDraw()</code> 使操作生效。</p>\n<h2 id=\"3-获取某个像素点位置的方法\"><a href=\"#3-获取某个像素点位置的方法\" class=\"headerlink\" title=\"3.获取某个像素点位置的方法\"></a>3.获取某个像素点位置的方法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分配图片内存</span></span><br><span class=\"line\">IMAGE* img = <span class=\"keyword\">new</span> <span class=\"built_in\">IMAGE</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置图片宽高</span></span><br><span class=\"line\"><span class=\"type\">int</span> width;</span><br><span class=\"line\"><span class=\"type\">int</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//新建图片img调整画布，设置图片宽度高度(在EasyX中图片需要加载到缓冲区才能进行处理（渲染或调整），类似loadimage函数功能，但区别是该函数可以对图片进行修改)</span></span><br><span class=\"line\"><span class=\"built_in\">Resize</span>(img, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取存储图片像素色彩的首个像素的地址</span></span><br><span class=\"line\">DWORD* img_color_buffer=<span class=\"built_in\">GetImageBuffer</span>(img);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//图片矩阵image[y][x]像素索引(x,y从0开始)</span></span><br><span class=\"line\"><span class=\"type\">int</span> x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> img_color_buffer_idx = y * width + x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx]; </span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-获取RGB分量方法\"><a href=\"#4-获取RGB分量方法\" class=\"headerlink\" title=\"4.获取RGB分量方法\"></a>4.获取<code>RGB</code>分量方法</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//操作显示缓冲区中的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx];</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//获取显示缓冲区中的颜色ARGB分量（方便观看而加空格，编写不需要加）</span></span><br><span class=\"line\">BYTE A=(pix_color &amp; <span class=\"number\">0xff</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">24</span>;</span><br><span class=\"line\">BYTE R=(pix_color &amp; <span class=\"number\">0x00</span> ff <span class=\"number\">00</span> <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">BYTE G=(pix_color &amp; <span class=\"number\">0x00</span> <span class=\"number\">00</span> ff <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">BYTE B=(pix_color &amp; <span class=\"number\">0x00000</span> <span class=\"number\">00</span> ff);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对获取了的ARGB分量的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作后组合（默认A,R,G,B数据类型为BYTE）</span></span><br><span class=\"line\">pix_color =(DWORD)( (A &lt;&lt; <span class=\"number\">24</span>) | (R &lt;&lt; <span class=\"number\">16</span>) | (G &lt;&lt; <span class=\"number\">8</span>) | B); </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><ul>\n<li>颜色在<strong>内存中</strong>的表示形式为：<code>0xbbggrr</code> (<code>bb</code>&#x3D;蓝，<code>gg</code>&#x3D;绿，<code>rr</code>&#x3D;红)</li>\n<li>但是<strong>显示缓冲区</strong>中的颜色表现形式为 <code>0xrrggbb</code>。</li>\n<li>注意，两者的红色和蓝色是相反的。直接操作显示缓冲区时，可以通过<code>BGR</code> 宏交换颜色的红色和蓝色部分。</li>\n</ul>\n<p>在C语言中，<code>COLORREF</code> 是一个常用的类型，主要用于表示颜色，特别是在 <code>Windows API</code> 中用于存储颜色值。</p>\n<p><code>COLORREF</code> 是一个32位的无符号整数，通常由三个字节组成，分别表示颜色的红色 (Red)、绿色 (Green)、蓝色 (Blue) 分量。</p>\n<p><code>COLORREF</code> 的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> DWORD COLORREF;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Color constants.</span></span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbRed   =  <span class=\"number\">0x000000FF</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbGreen =  <span class=\"number\">0x0000FF00</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbBlue  =  <span class=\"number\">0x00FF0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbBlack =  <span class=\"number\">0x00000000</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbWhite =  <span class=\"number\">0x00FFFFFF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>它的每一部分通常是按以下顺序存储的：</p>\n<ul>\n<li>高字节（<code>0x00FF0000</code>）：蓝色 (Blue)</li>\n<li>中字节（<code>0x0000FF00</code>）：绿色 (Green)</li>\n<li>低字节（<code>0x000000FF</code>）：红色 (Red)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetRValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetGValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetBValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//操作显示缓冲区中的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx]</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//获取显示缓冲区中的颜色RGB分量</span></span><br><span class=\"line\">BYTE R=<span class=\"built_in\">GetBValue</span>(pix_color);</span><br><span class=\"line\">BYTE G=<span class=\"built_in\">GetGValue</span>(pix_color);</span><br><span class=\"line\">BYTE B=<span class=\"built_in\">GetRValue</span>(pix_color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对获取了的RGB分量的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作后组合(不破坏原来Alpha透明度)</span></span><br><span class=\"line\">pix_color = <span class=\"built_in\">BGR</span>(<span class=\"built_in\">RGB</span>(R, G, B)) |  ((((DWORD)(BYTE)(<span class=\"number\">255</span>)) &lt;&lt; <span class=\"number\">24</span>) &amp; pix_color);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"1-图片处理函数\"><a href=\"#1-图片处理函数\" class=\"headerlink\" title=\"1.图片处理函数\"></a>1.图片处理函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Resize</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tIMAGE* pImg,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">int</span> width,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"type\">int</span> height</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>pImg</strong></p>\n<p>指定要调整尺寸的绘图设备。如果为 NULL，则表示默认绘图窗口。</p>\n<p><strong>width</strong></p>\n<p>指定绘图设备的宽度。</p>\n<p><strong>height</strong></p>\n<p>指定绘图设备的高度。</p>","more":"<h2 id=\"2-获取存储图片像素色彩地址\"><a href=\"#2-获取存储图片像素色彩地址\" class=\"headerlink\" title=\"2.获取存储图片像素色彩地址\"></a>2.获取存储图片像素色彩地址</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD* <span class=\"title\">GetImageBuffer</span><span class=\"params\">(IMAGE* pImg = <span class=\"literal\">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>pImg</strong></p>\n<p>绘图设备指针。如果为 NULL，表示默认的绘图窗口。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回绘图设备的<strong>显示缓冲区</strong>指针。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>获取到的显示缓冲区指针可以直接读写。</p>\n<p>在显示缓冲区中，每个点占用 4 个字节，因此：显示缓冲区的大小 &#x3D; 宽度 × 高度 × 4 (字节)。像素点在显示缓冲区中按照从左到右、从上向下的顺序依次排列。访问显示缓冲区请勿越界，否则会造成难以预料的后果。</p>\n<p>显示缓冲区中的每个点对应 <code>RGBTRIPLE</code> 类型的结构体：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RGBTRIPLE</span> &#123;</span><br><span class=\"line\">\tBYTE rgbtBlue;</span><br><span class=\"line\">\tBYTE rgbtGreen;</span><br><span class=\"line\">\tBYTE rgbtRed;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>RGBTRIPLE</code> 在内存中的表示形式为：<code>0xrrggbb</code> (<code>bb</code>&#x3D;蓝，<code>gg</code>&#x3D;绿，<code>rr</code>&#x3D;红)，而常用的 <code>COLORREF</code> 在内存中的表示形式为：<code>0xbbggrr</code>。注意，两者的红色和蓝色是相反的，请用 <code>BGR</code> 宏交换红色和蓝色。</p>\n<p>如果操作绘图窗口的显示缓冲区，请在操作完毕后，执行 <code>FlushBatchDraw()</code> 使操作生效。</p>\n<h2 id=\"3-获取某个像素点位置的方法\"><a href=\"#3-获取某个像素点位置的方法\" class=\"headerlink\" title=\"3.获取某个像素点位置的方法\"></a>3.获取某个像素点位置的方法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分配图片内存</span></span><br><span class=\"line\">IMAGE* img = <span class=\"keyword\">new</span> <span class=\"built_in\">IMAGE</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置图片宽高</span></span><br><span class=\"line\"><span class=\"type\">int</span> width;</span><br><span class=\"line\"><span class=\"type\">int</span> height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//新建图片img调整画布，设置图片宽度高度(在EasyX中图片需要加载到缓冲区才能进行处理（渲染或调整），类似loadimage函数功能，但区别是该函数可以对图片进行修改)</span></span><br><span class=\"line\"><span class=\"built_in\">Resize</span>(img, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取存储图片像素色彩的首个像素的地址</span></span><br><span class=\"line\">DWORD* img_color_buffer=<span class=\"built_in\">GetImageBuffer</span>(img);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//图片矩阵image[y][x]像素索引(x,y从0开始)</span></span><br><span class=\"line\"><span class=\"type\">int</span> x,y;</span><br><span class=\"line\"><span class=\"type\">int</span> img_color_buffer_idx = y * width + x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx]; </span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-获取RGB分量方法\"><a href=\"#4-获取RGB分量方法\" class=\"headerlink\" title=\"4.获取RGB分量方法\"></a>4.获取<code>RGB</code>分量方法</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//操作显示缓冲区中的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx];</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//获取显示缓冲区中的颜色ARGB分量（方便观看而加空格，编写不需要加）</span></span><br><span class=\"line\">BYTE A=(pix_color &amp; <span class=\"number\">0xff</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">24</span>;</span><br><span class=\"line\">BYTE R=(pix_color &amp; <span class=\"number\">0x00</span> ff <span class=\"number\">00</span> <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">16</span>;</span><br><span class=\"line\">BYTE G=(pix_color &amp; <span class=\"number\">0x00</span> <span class=\"number\">00</span> ff <span class=\"number\">00</span>)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">BYTE B=(pix_color &amp; <span class=\"number\">0x00000</span> <span class=\"number\">00</span> ff);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对获取了的ARGB分量的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作后组合（默认A,R,G,B数据类型为BYTE）</span></span><br><span class=\"line\">pix_color =(DWORD)( (A &lt;&lt; <span class=\"number\">24</span>) | (R &lt;&lt; <span class=\"number\">16</span>) | (G &lt;&lt; <span class=\"number\">8</span>) | B); </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><ul>\n<li>颜色在<strong>内存中</strong>的表示形式为：<code>0xbbggrr</code> (<code>bb</code>&#x3D;蓝，<code>gg</code>&#x3D;绿，<code>rr</code>&#x3D;红)</li>\n<li>但是<strong>显示缓冲区</strong>中的颜色表现形式为 <code>0xrrggbb</code>。</li>\n<li>注意，两者的红色和蓝色是相反的。直接操作显示缓冲区时，可以通过<code>BGR</code> 宏交换颜色的红色和蓝色部分。</li>\n</ul>\n<p>在C语言中，<code>COLORREF</code> 是一个常用的类型，主要用于表示颜色，特别是在 <code>Windows API</code> 中用于存储颜色值。</p>\n<p><code>COLORREF</code> 是一个32位的无符号整数，通常由三个字节组成，分别表示颜色的红色 (Red)、绿色 (Green)、蓝色 (Blue) 分量。</p>\n<p><code>COLORREF</code> 的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> DWORD COLORREF;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Color constants.</span></span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbRed   =  <span class=\"number\">0x000000FF</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbGreen =  <span class=\"number\">0x0000FF00</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbBlue  =  <span class=\"number\">0x00FF0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbBlack =  <span class=\"number\">0x00000000</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> COLORREF rgbWhite =  <span class=\"number\">0x00FFFFFF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>它的每一部分通常是按以下顺序存储的：</p>\n<ul>\n<li>高字节（<code>0x00FF0000</code>）：蓝色 (Blue)</li>\n<li>中字节（<code>0x0000FF00</code>）：绿色 (Green)</li>\n<li>低字节（<code>0x000000FF</code>）：红色 (Red)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetRValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetGValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br><span class=\"line\"><span class=\"function\">BYTE <span class=\"title\">GetBValue</span><span class=\"params\">(COLORREF rgb)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//操作显示缓冲区中的颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个像素点位置，该数据类型为DWORD</span></span><br><span class=\"line\">DWORD pix_color=img_color_buffer[img_color_buffer_idx]</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//获取显示缓冲区中的颜色RGB分量</span></span><br><span class=\"line\">BYTE R=<span class=\"built_in\">GetBValue</span>(pix_color);</span><br><span class=\"line\">BYTE G=<span class=\"built_in\">GetGValue</span>(pix_color);</span><br><span class=\"line\">BYTE B=<span class=\"built_in\">GetRValue</span>(pix_color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对获取了的RGB分量的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作后组合(不破坏原来Alpha透明度)</span></span><br><span class=\"line\">pix_color = <span class=\"built_in\">BGR</span>(<span class=\"built_in\">RGB</span>(R, G, B)) |  ((((DWORD)(BYTE)(<span class=\"number\">255</span>)) &lt;&lt; <span class=\"number\">24</span>) &amp; pix_color);</span><br></pre></td></tr></table></figure>"},{"title":"简单的单例模式实现","date":"2024-06-24T16:00:00.000Z","updated":"2024-06-24T16:00:00.000Z","_content":"> 跟着大v老师学习的时候学习到了这个设计模式，因为马上要去gamejam，学长跟我说滥用单例就好了（bushi，就因此感兴趣了解一下，顺带巩固一些C++语法知识点,学的时候注意不到，用的时候就印象深刻了。\n>\n> 接下来我会先对照课本复习一下类内的静态变量，然后对照网上的单例文章和课程代码写点东西(因为锁和线程我不了解，就基于大V老师教的简单写写)\n\n<!-- More -->\n\n## 类内的静态成员\n\n#### 静态数据成员\n\n**静态数据成员**：类的静态数据成员拥有一块单独的存储区，所有这个类的对象的静态数据成员都共享这一块空间（这就像银行所有的账户都享有同样的利率）。但静态数据成员是属于类的，他的名称只在类的范围内有效（就是实例化的对象无法调用），并且可以是私有的也可以是公有的，这样可以避免其他全局函数的干扰。\n\n<img src=\"image-20240625125041783.png\" alt=\"image-20240625125041783\" style=\"zoom:67%;\" />\n\n定义：\n\n~~~CPP\nclass SavingAccount\n{\nprivate:\n    static double rate;\t\t\t//定义了一个私有静态成员变量\n}\n~~~\n\n注意：静态数据成员属于类，不属于实例化的对象，从而在实例化对象为对象分配空间时并不包含静态数据成员的空间\n\n静态数据成员的空间必须单独分配且只分配一次，为静态数据成员分配空间成为静态数据成员的定义（一般在cpp实现文件中）\n\n~~~CPP\n//SavingAccount.cpp\n\n//作用域::静态成员变量名\ndouble SavingAccount::rate=0.05;\t\t//为rate分配空间，并赋予了初值，若没有这个定义，链接时会报错\n~~~\n\n由于静态数据成员是属于类的，因此可以通过作用域运算符用类名直接调用，如**”类名::静态数据成员名“**。\n\n从每个对象的角度来看，似乎是实例化对象的一部分，可以像普通的成员一样用对象引用$Account1.rate$。但是指向的都是同一块空间。 \n\n---\n\n#### 静态成员函数\n\n**静态成员函数：**专门用于操作静态数据成员。\n\n于普通函数一样就是在声明的前面加上static，静态成员函数的定义既可以写在类内，也可以写在类外。（在类外定义的时候不需要加static）\n\n例如，我要修改savingaccount的rate\n\n~~~CPP\nstatic void SetRate(double newRate)\n{\n    rate=newRate;\n}\n~~~\n\n注意：静态成员函数是为类服务的，从而实例化对象调用的时候静态函数不会像普通函数一样有隐式的$*this$​指针可以访问实例化对象内的普通成员变量和普通成员函数。\n\n（大概率静态成员函数和静态数据成员变量都存放在一个存储空间且有联系）静态成员函数只能调用静态数据成员和静态成员函数。\n\n\n\n调用的话，有实例化对象可以实例化对象调用\n\n~~~CPP\nAccount.SetRate(0);\n~~~\n\n就算没有实例化对象，也可以使用类名来调用，**”类名::静态成员函数名（）“**\n\n~~~CPP\nSavingAccount::SetRate(0);\n~~~\n\n---\n\n#### 静态常量数据成员\n\n当有时候整个类需要共享一个**常量**，就可以用static const来声明。\n\n首先区分一下**常量数据成员**和**静态常量数据成员**\n\n**常量数据成员**是针对不同的实例化对象的，每个实例化对象的常量数据成员各不相同，const声明\n\n**静态常量数据成员**是属于整个类，所有实例化对象都一样，是static const声明的\n\n\n\n初始化：\n\n**普通数据成员**可以在对象定义的构造函数初始化\n\n**静态数据成员**实在静态数据成员定义的时候初始化，一般是在类外定义。\n\n**常量静态数据成员**竟然可以在类内定义的时候初始化（**只能是整型**），注意不是构造函数，是在类内声明的时候直接赋值\n\n~~~CPP\nclass SavingAccount\n{\n    static const int rate=10;\n}//类似这样\n~~~\n\n**注意：如果静态常量数据成员是非整型，则不能在类内赋初值，在类中只能声明，在类外定义**\n\n~~~CPP\nstatic const double st;\t//类内声明\n\n//类外定义的时候可以不写static,和函数一样\nconst SavingAccount::st=1.5;\n~~~\n\n所以不管什么还是建议在类外定义，以防记混报错。\n\n---\n\n## 单例化的一些概念\n\n> 简单看了一下，不太懂锁和线程这方面的知识点，所以就对着文章简单写点吧，后面了解了有机会再细说\n\n#### 1. 什么是单例模式\n\n> **单例模式是指在内存中只会创建且仅创建一次对象的设计模式。**在程序中**多次使用同一个对象且作用相同**时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中**创建一个对象**，让所有需要调用的地方都共享这一单例对象。\n\n<img src=\"format,png.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n#### 2. 单例模式的类型\n\n单例模式有两种类型：\n\n- 懒汉式：在**真正需要使用**对象时才去创建该单例类对象\n- 饿汉式：在**类加载**时已经创建好该单例对象，等待被程序使用\n\n1. **懒汉式单例模式：**在首次获取实例时创建。这种方式在多线程环境下存在线程安全问题，需要通过加锁或双重检查等方式解决。\n\n<img src=\"format,png-1719298517759-3.png\" alt=\"image.png\" style=\"zoom: 80%;\" />\n\n~~~CPP\npublic class Singleton \n{\n    \n    private static Singleton singleton;\n    \n    private Singleton(){}\n    \n    public static Singleton getInstance() \n    {\n        if (singleton == null) \n        {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n~~~\n\n2. **饿汉式单例模式**：在类加载时就创建实例。这种方式在多线程环境下是线程安全的，但可能会浪费内存空间。\n\n<img src=\"format,png-1719298652881-6.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n~~~CPP\npublic class Singleton\n{\n    \n    private static final Singleton singleton = new Singleton();\n    \n    private Singleton(){}\n    \n    public static Singleton getInstance() \n    {\n        return singleton;\n    }\n}\n~~~\n\n后面的我也不懂了，有兴趣就去csdn去看看吧\n\n[原文链接](https://blog.csdn.net/weixin_41949328/article/details/107296517)\n\n---\n\n## 课程代码的单例实现（Manager类）\n\n这个gameManager和Manager关系就感觉有点绕\n\n就像大V老师说的通过继承的方式，让子类能自动的形成构造->就对基类引入了模板。\n\n通过对基类的单例实现，然后将子类是继承基类（用子类作为模板参数传入的基类）实现。\n\n我的理解就如同下图\n\n<img src=\"image-20240625135923590.png\" alt=\"image-20240625135923590\" style=\"zoom:80%;\" />\n\n这样就是实现了继承子类都可以实现单例的功能\n\n先看**manager.h**的内容吧\n\n~~~CPP\n#ifndef  _MANAGER_H_\n#define _MANAGER_H_\ntemplate<typename T>\nclass Manager\n{\npublic:\n    //静态成员函数只可以修改静态数据成员和静态成员函数\n    //通过静态成员函数instance（）可以实现单例的构造\n\tstatic T* instance()\n\t{\n\t\tif (!manager)\t\t\t\t//如果静态数据成员（单例对象）未实例化，则实例化\n\t\t\tmanager = new T();\n\t\treturn manager;\t\t\t\t//返回静态成员指针\n\t}\n\t~Manager()=default;\n\nprivate:\n\tstatic T* manager;\t\t\t\t//声明静态成员变量\t\n\n\nprotected:\n    //将构造函数访问特性设置为protected，那么就无法再外界构造对象，保证了单例化的唯一性\n\tManager() = default;\n    //删除复制构造函数和=号的运算符重载，也是为了防止外界构造对象\n\tManager(const Manager&) = delete;\n\tManager& operator=(const Manager&) = delete;\n};\n\n//将单例的对象设置为静态数据成员，这里是静态数据成员的定义，换种角度就是为其分配空间，不然会报错\ntemplate<typename T>\nT* Manager<T>::manager = nullptr;\n\n#endif // ! _MANAGER_H_\n~~~\n\n注意：以上都是模板参数，最后生成的静态数据成员都是子类对象，一些细节也在里面说明了。\n\n我们再来看看**\"game_scene.h\"**\n\n~~~CPP\n\n#ifndef _GAME_MANAGER_H_\n#define _GAME_MANAGER_H_\n#include \"manager.h\"\nclass GameManager:public Manager<GameManager>\n{\n\t//因为在继承的时候会调用GameManager类的构造函数，所以需要声明一下友元\n\tfriend class Manager<GameManager>;\nprotected:\n\tGameManager(){}\n\t~GameManager(){}\n\n};\n\n#endif // !_GAME_MANAGER_H_\n\n~~~\n\n最后看main.cpp\n\n~~~CPP\n#define SDL_MAIN_HANDLED\n#include<iostream>\n#include \"game_manager.h\"\n\nint main(int argc,char** argv)\n{\n    //这就很好理解了，instance接受的其实就是单例化静态成员的那块空间的地址，这样main函数里就可以用了\n\tGameManager* instance = GameManager::instance();\n    \n    return 0;\n}\n~~~\n\n大体上课程就是如此实现单例化和继承单例化功能，从而保证对象的唯一性。\n\n---\n\n","source":"_posts/yang/单例模式.md","raw":"---\ntitle: 简单的单例模式实现\ndate: 2024-06-25\nupdated: 2024-06-25\npermalink: articles/yang12342/单例模式/\ncategories: yang12342\ntags: [设计模式,塔防课程，c++]\n---\n> 跟着大v老师学习的时候学习到了这个设计模式，因为马上要去gamejam，学长跟我说滥用单例就好了（bushi，就因此感兴趣了解一下，顺带巩固一些C++语法知识点,学的时候注意不到，用的时候就印象深刻了。\n>\n> 接下来我会先对照课本复习一下类内的静态变量，然后对照网上的单例文章和课程代码写点东西(因为锁和线程我不了解，就基于大V老师教的简单写写)\n\n<!-- More -->\n\n## 类内的静态成员\n\n#### 静态数据成员\n\n**静态数据成员**：类的静态数据成员拥有一块单独的存储区，所有这个类的对象的静态数据成员都共享这一块空间（这就像银行所有的账户都享有同样的利率）。但静态数据成员是属于类的，他的名称只在类的范围内有效（就是实例化的对象无法调用），并且可以是私有的也可以是公有的，这样可以避免其他全局函数的干扰。\n\n<img src=\"image-20240625125041783.png\" alt=\"image-20240625125041783\" style=\"zoom:67%;\" />\n\n定义：\n\n~~~CPP\nclass SavingAccount\n{\nprivate:\n    static double rate;\t\t\t//定义了一个私有静态成员变量\n}\n~~~\n\n注意：静态数据成员属于类，不属于实例化的对象，从而在实例化对象为对象分配空间时并不包含静态数据成员的空间\n\n静态数据成员的空间必须单独分配且只分配一次，为静态数据成员分配空间成为静态数据成员的定义（一般在cpp实现文件中）\n\n~~~CPP\n//SavingAccount.cpp\n\n//作用域::静态成员变量名\ndouble SavingAccount::rate=0.05;\t\t//为rate分配空间，并赋予了初值，若没有这个定义，链接时会报错\n~~~\n\n由于静态数据成员是属于类的，因此可以通过作用域运算符用类名直接调用，如**”类名::静态数据成员名“**。\n\n从每个对象的角度来看，似乎是实例化对象的一部分，可以像普通的成员一样用对象引用$Account1.rate$。但是指向的都是同一块空间。 \n\n---\n\n#### 静态成员函数\n\n**静态成员函数：**专门用于操作静态数据成员。\n\n于普通函数一样就是在声明的前面加上static，静态成员函数的定义既可以写在类内，也可以写在类外。（在类外定义的时候不需要加static）\n\n例如，我要修改savingaccount的rate\n\n~~~CPP\nstatic void SetRate(double newRate)\n{\n    rate=newRate;\n}\n~~~\n\n注意：静态成员函数是为类服务的，从而实例化对象调用的时候静态函数不会像普通函数一样有隐式的$*this$​指针可以访问实例化对象内的普通成员变量和普通成员函数。\n\n（大概率静态成员函数和静态数据成员变量都存放在一个存储空间且有联系）静态成员函数只能调用静态数据成员和静态成员函数。\n\n\n\n调用的话，有实例化对象可以实例化对象调用\n\n~~~CPP\nAccount.SetRate(0);\n~~~\n\n就算没有实例化对象，也可以使用类名来调用，**”类名::静态成员函数名（）“**\n\n~~~CPP\nSavingAccount::SetRate(0);\n~~~\n\n---\n\n#### 静态常量数据成员\n\n当有时候整个类需要共享一个**常量**，就可以用static const来声明。\n\n首先区分一下**常量数据成员**和**静态常量数据成员**\n\n**常量数据成员**是针对不同的实例化对象的，每个实例化对象的常量数据成员各不相同，const声明\n\n**静态常量数据成员**是属于整个类，所有实例化对象都一样，是static const声明的\n\n\n\n初始化：\n\n**普通数据成员**可以在对象定义的构造函数初始化\n\n**静态数据成员**实在静态数据成员定义的时候初始化，一般是在类外定义。\n\n**常量静态数据成员**竟然可以在类内定义的时候初始化（**只能是整型**），注意不是构造函数，是在类内声明的时候直接赋值\n\n~~~CPP\nclass SavingAccount\n{\n    static const int rate=10;\n}//类似这样\n~~~\n\n**注意：如果静态常量数据成员是非整型，则不能在类内赋初值，在类中只能声明，在类外定义**\n\n~~~CPP\nstatic const double st;\t//类内声明\n\n//类外定义的时候可以不写static,和函数一样\nconst SavingAccount::st=1.5;\n~~~\n\n所以不管什么还是建议在类外定义，以防记混报错。\n\n---\n\n## 单例化的一些概念\n\n> 简单看了一下，不太懂锁和线程这方面的知识点，所以就对着文章简单写点吧，后面了解了有机会再细说\n\n#### 1. 什么是单例模式\n\n> **单例模式是指在内存中只会创建且仅创建一次对象的设计模式。**在程序中**多次使用同一个对象且作用相同**时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中**创建一个对象**，让所有需要调用的地方都共享这一单例对象。\n\n<img src=\"format,png.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n#### 2. 单例模式的类型\n\n单例模式有两种类型：\n\n- 懒汉式：在**真正需要使用**对象时才去创建该单例类对象\n- 饿汉式：在**类加载**时已经创建好该单例对象，等待被程序使用\n\n1. **懒汉式单例模式：**在首次获取实例时创建。这种方式在多线程环境下存在线程安全问题，需要通过加锁或双重检查等方式解决。\n\n<img src=\"format,png-1719298517759-3.png\" alt=\"image.png\" style=\"zoom: 80%;\" />\n\n~~~CPP\npublic class Singleton \n{\n    \n    private static Singleton singleton;\n    \n    private Singleton(){}\n    \n    public static Singleton getInstance() \n    {\n        if (singleton == null) \n        {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n~~~\n\n2. **饿汉式单例模式**：在类加载时就创建实例。这种方式在多线程环境下是线程安全的，但可能会浪费内存空间。\n\n<img src=\"format,png-1719298652881-6.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n~~~CPP\npublic class Singleton\n{\n    \n    private static final Singleton singleton = new Singleton();\n    \n    private Singleton(){}\n    \n    public static Singleton getInstance() \n    {\n        return singleton;\n    }\n}\n~~~\n\n后面的我也不懂了，有兴趣就去csdn去看看吧\n\n[原文链接](https://blog.csdn.net/weixin_41949328/article/details/107296517)\n\n---\n\n## 课程代码的单例实现（Manager类）\n\n这个gameManager和Manager关系就感觉有点绕\n\n就像大V老师说的通过继承的方式，让子类能自动的形成构造->就对基类引入了模板。\n\n通过对基类的单例实现，然后将子类是继承基类（用子类作为模板参数传入的基类）实现。\n\n我的理解就如同下图\n\n<img src=\"image-20240625135923590.png\" alt=\"image-20240625135923590\" style=\"zoom:80%;\" />\n\n这样就是实现了继承子类都可以实现单例的功能\n\n先看**manager.h**的内容吧\n\n~~~CPP\n#ifndef  _MANAGER_H_\n#define _MANAGER_H_\ntemplate<typename T>\nclass Manager\n{\npublic:\n    //静态成员函数只可以修改静态数据成员和静态成员函数\n    //通过静态成员函数instance（）可以实现单例的构造\n\tstatic T* instance()\n\t{\n\t\tif (!manager)\t\t\t\t//如果静态数据成员（单例对象）未实例化，则实例化\n\t\t\tmanager = new T();\n\t\treturn manager;\t\t\t\t//返回静态成员指针\n\t}\n\t~Manager()=default;\n\nprivate:\n\tstatic T* manager;\t\t\t\t//声明静态成员变量\t\n\n\nprotected:\n    //将构造函数访问特性设置为protected，那么就无法再外界构造对象，保证了单例化的唯一性\n\tManager() = default;\n    //删除复制构造函数和=号的运算符重载，也是为了防止外界构造对象\n\tManager(const Manager&) = delete;\n\tManager& operator=(const Manager&) = delete;\n};\n\n//将单例的对象设置为静态数据成员，这里是静态数据成员的定义，换种角度就是为其分配空间，不然会报错\ntemplate<typename T>\nT* Manager<T>::manager = nullptr;\n\n#endif // ! _MANAGER_H_\n~~~\n\n注意：以上都是模板参数，最后生成的静态数据成员都是子类对象，一些细节也在里面说明了。\n\n我们再来看看**\"game_scene.h\"**\n\n~~~CPP\n\n#ifndef _GAME_MANAGER_H_\n#define _GAME_MANAGER_H_\n#include \"manager.h\"\nclass GameManager:public Manager<GameManager>\n{\n\t//因为在继承的时候会调用GameManager类的构造函数，所以需要声明一下友元\n\tfriend class Manager<GameManager>;\nprotected:\n\tGameManager(){}\n\t~GameManager(){}\n\n};\n\n#endif // !_GAME_MANAGER_H_\n\n~~~\n\n最后看main.cpp\n\n~~~CPP\n#define SDL_MAIN_HANDLED\n#include<iostream>\n#include \"game_manager.h\"\n\nint main(int argc,char** argv)\n{\n    //这就很好理解了，instance接受的其实就是单例化静态成员的那块空间的地址，这样main函数里就可以用了\n\tGameManager* instance = GameManager::instance();\n    \n    return 0;\n}\n~~~\n\n大体上课程就是如此实现单例化和继承单例化功能，从而保证对象的唯一性。\n\n---\n\n","slug":"yang/单例模式","published":1,"__permalink":"articles/yang12342/单例模式/","comments":1,"layout":"post","photos":[],"link":"","_id":"cm69406jy000a1out9xjf7mm6","content":"<blockquote>\n<p>跟着大v老师学习的时候学习到了这个设计模式，因为马上要去gamejam，学长跟我说滥用单例就好了（bushi，就因此感兴趣了解一下，顺带巩固一些C++语法知识点,学的时候注意不到，用的时候就印象深刻了。</p>\n<p>接下来我会先对照课本复习一下类内的静态变量，然后对照网上的单例文章和课程代码写点东西(因为锁和线程我不了解，就基于大V老师教的简单写写)</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"类内的静态成员\"><a href=\"#类内的静态成员\" class=\"headerlink\" title=\"类内的静态成员\"></a>类内的静态成员</h2><h4 id=\"静态数据成员\"><a href=\"#静态数据成员\" class=\"headerlink\" title=\"静态数据成员\"></a>静态数据成员</h4><p><strong>静态数据成员</strong>：类的静态数据成员拥有一块单独的存储区，所有这个类的对象的静态数据成员都共享这一块空间（这就像银行所有的账户都享有同样的利率）。但静态数据成员是属于类的，他的名称只在类的范围内有效（就是实例化的对象无法调用），并且可以是私有的也可以是公有的，这样可以避免其他全局函数的干扰。</p>\n<img src=\"image-20240625125041783.png\" alt=\"image-20240625125041783\" style=\"zoom:67%;\" />\n\n<p>定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SavingAccount</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">double</span> rate;\t\t\t<span class=\"comment\">//定义了一个私有静态成员变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：静态数据成员属于类，不属于实例化的对象，从而在实例化对象为对象分配空间时并不包含静态数据成员的空间</p>\n<p>静态数据成员的空间必须单独分配且只分配一次，为静态数据成员分配空间成为静态数据成员的定义（一般在cpp实现文件中）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SavingAccount.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//作用域::静态成员变量名</span></span><br><span class=\"line\"><span class=\"type\">double</span> SavingAccount::rate=<span class=\"number\">0.05</span>;\t\t<span class=\"comment\">//为rate分配空间，并赋予了初值，若没有这个定义，链接时会报错</span></span><br></pre></td></tr></table></figure>\n\n<p>由于静态数据成员是属于类的，因此可以通过作用域运算符用类名直接调用，如<strong>”类名::静态数据成员名“</strong>。</p>\n<p>从每个对象的角度来看，似乎是实例化对象的一部分，可以像普通的成员一样用对象引用$Account1.rate$。但是指向的都是同一块空间。 </p>\n<hr>\n<h4 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h4><p><strong>静态成员函数：</strong>专门用于操作静态数据成员。</p>\n<p>于普通函数一样就是在声明的前面加上static，静态成员函数的定义既可以写在类内，也可以写在类外。（在类外定义的时候不需要加static）</p>\n<p>例如，我要修改savingaccount的rate</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">SetRate</span><span class=\"params\">(<span class=\"type\">double</span> newRate)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    rate=newRate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：静态成员函数是为类服务的，从而实例化对象调用的时候静态函数不会像普通函数一样有隐式的$*this$​指针可以访问实例化对象内的普通成员变量和普通成员函数。</p>\n<p>（大概率静态成员函数和静态数据成员变量都存放在一个存储空间且有联系）静态成员函数只能调用静态数据成员和静态成员函数。</p>\n<p>调用的话，有实例化对象可以实例化对象调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Account.<span class=\"built_in\">SetRate</span>(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>就算没有实例化对象，也可以使用类名来调用，<strong>”类名::静态成员函数名（）“</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SavingAccount::<span class=\"built_in\">SetRate</span>(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"静态常量数据成员\"><a href=\"#静态常量数据成员\" class=\"headerlink\" title=\"静态常量数据成员\"></a>静态常量数据成员</h4><p>当有时候整个类需要共享一个<strong>常量</strong>，就可以用static const来声明。</p>\n<p>首先区分一下<strong>常量数据成员</strong>和<strong>静态常量数据成员</strong></p>\n<p><strong>常量数据成员</strong>是针对不同的实例化对象的，每个实例化对象的常量数据成员各不相同，const声明</p>\n<p><strong>静态常量数据成员</strong>是属于整个类，所有实例化对象都一样，是static const声明的</p>\n<p>初始化：</p>\n<p><strong>普通数据成员</strong>可以在对象定义的构造函数初始化</p>\n<p><strong>静态数据成员</strong>实在静态数据成员定义的时候初始化，一般是在类外定义。</p>\n<p><strong>常量静态数据成员</strong>竟然可以在类内定义的时候初始化（<strong>只能是整型</strong>），注意不是构造函数，是在类内声明的时候直接赋值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SavingAccount</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> rate=<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//类似这样</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：如果静态常量数据成员是非整型，则不能在类内赋初值，在类中只能声明，在类外定义</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">double</span> st;\t<span class=\"comment\">//类内声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义的时候可以不写static,和函数一样</span></span><br><span class=\"line\"><span class=\"type\">const</span> SavingAccount::st=<span class=\"number\">1.5</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以不管什么还是建议在类外定义，以防记混报错。</p>\n<hr>\n<h2 id=\"单例化的一些概念\"><a href=\"#单例化的一些概念\" class=\"headerlink\" title=\"单例化的一些概念\"></a>单例化的一些概念</h2><blockquote>\n<p>简单看了一下，不太懂锁和线程这方面的知识点，所以就对着文章简单写点吧，后面了解了有机会再细说</p>\n</blockquote>\n<h4 id=\"1-什么是单例模式\"><a href=\"#1-什么是单例模式\" class=\"headerlink\" title=\"1. 什么是单例模式\"></a>1. 什么是单例模式</h4><blockquote>\n<p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>\n</blockquote>\n<img src=\"format,png.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"2-单例模式的类型\"><a href=\"#2-单例模式的类型\" class=\"headerlink\" title=\"2. 单例模式的类型\"></a>2. 单例模式的类型</h4><p>单例模式有两种类型：</p>\n<ul>\n<li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li>\n<li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li>\n</ul>\n<ol>\n<li><strong>懒汉式单例模式：</strong>在首次获取实例时创建。这种方式在多线程环境下存在线程安全问题，需要通过加锁或双重检查等方式解决。</li>\n</ol>\n<img src=\"format,png-1719298517759-3.png\" alt=\"image.png\" style=\"zoom: 80%;\" />\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">static</span> Singleton singleton;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == null) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>饿汉式单例模式</strong>：在类加载时就创建实例。这种方式在多线程环境下是线程安全的，但可能会浪费内存空间。</li>\n</ol>\n<img src=\"format,png-1719298652881-6.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后面的我也不懂了，有兴趣就去csdn去看看吧</p>\n<p><a href=\"https://blog.csdn.net/weixin_41949328/article/details/107296517\">原文链接</a></p>\n<hr>\n<h2 id=\"课程代码的单例实现（Manager类）\"><a href=\"#课程代码的单例实现（Manager类）\" class=\"headerlink\" title=\"课程代码的单例实现（Manager类）\"></a>课程代码的单例实现（Manager类）</h2><p>这个gameManager和Manager关系就感觉有点绕</p>\n<p>就像大V老师说的通过继承的方式，让子类能自动的形成构造-&gt;就对基类引入了模板。</p>\n<p>通过对基类的单例实现，然后将子类是继承基类（用子类作为模板参数传入的基类）实现。</p>\n<p>我的理解就如同下图</p>\n<img src=\"image-20240625135923590.png\" alt=\"image-20240625135923590\" style=\"zoom:80%;\" />\n\n<p>这样就是实现了继承子类都可以实现单例的功能</p>\n<p>先看<strong>manager.h</strong>的内容吧</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span>  _MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _MANAGER_H_</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Manager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//静态成员函数只可以修改静态数据成员和静态成员函数</span></span><br><span class=\"line\">    <span class=\"comment\">//通过静态成员函数instance（）可以实现单例的构造</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">static</span> T* <span class=\"title\">instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!manager)\t\t\t\t<span class=\"comment\">//如果静态数据成员（单例对象）未实例化，则实例化</span></span><br><span class=\"line\">\t\t\tmanager = <span class=\"keyword\">new</span> <span class=\"built_in\">T</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> manager;\t\t\t\t<span class=\"comment\">//返回静态成员指针</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Manager</span>()=<span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> T* manager;\t\t\t\t<span class=\"comment\">//声明静态成员变量\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将构造函数访问特性设置为protected，那么就无法再外界构造对象，保证了单例化的唯一性</span></span><br><span class=\"line\">\t<span class=\"built_in\">Manager</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"comment\">//删除复制构造函数和=号的运算符重载，也是为了防止外界构造对象</span></span><br><span class=\"line\">\t<span class=\"built_in\">Manager</span>(<span class=\"type\">const</span> Manager&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">\tManager&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Manager&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将单例的对象设置为静态数据成员，这里是静态数据成员的定义，换种角度就是为其分配空间，不然会报错</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Manager&lt;T&gt;::manager = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// ! _MANAGER_H_</span></span></span><br></pre></td></tr></table></figure>\n\n<p>注意：以上都是模板参数，最后生成的静态数据成员都是子类对象，一些细节也在里面说明了。</p>\n<p>我们再来看看**”game_scene.h”**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _GAME_MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _GAME_MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;manager.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GameManager</span>:<span class=\"keyword\">public</span> Manager&lt;GameManager&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//因为在继承的时候会调用GameManager类的构造函数，所以需要声明一下友元</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Manager</span>&lt;GameManager&gt;;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">GameManager</span>()&#123;&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">GameManager</span>()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_GAME_MANAGER_H_</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>最后看main.cpp</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SDL_MAIN_HANDLED</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;game_manager.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这就很好理解了，instance接受的其实就是单例化静态成员的那块空间的地址，这样main函数里就可以用了</span></span><br><span class=\"line\">\tGameManager* instance = GameManager::<span class=\"built_in\">instance</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大体上课程就是如此实现单例化和继承单例化功能，从而保证对象的唯一性。</p>\n<hr>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>跟着大v老师学习的时候学习到了这个设计模式，因为马上要去gamejam，学长跟我说滥用单例就好了（bushi，就因此感兴趣了解一下，顺带巩固一些C++语法知识点,学的时候注意不到，用的时候就印象深刻了。</p>\n<p>接下来我会先对照课本复习一下类内的静态变量，然后对照网上的单例文章和课程代码写点东西(因为锁和线程我不了解，就基于大V老师教的简单写写)</p>\n</blockquote>","more":"<h2 id=\"类内的静态成员\"><a href=\"#类内的静态成员\" class=\"headerlink\" title=\"类内的静态成员\"></a>类内的静态成员</h2><h4 id=\"静态数据成员\"><a href=\"#静态数据成员\" class=\"headerlink\" title=\"静态数据成员\"></a>静态数据成员</h4><p><strong>静态数据成员</strong>：类的静态数据成员拥有一块单独的存储区，所有这个类的对象的静态数据成员都共享这一块空间（这就像银行所有的账户都享有同样的利率）。但静态数据成员是属于类的，他的名称只在类的范围内有效（就是实例化的对象无法调用），并且可以是私有的也可以是公有的，这样可以避免其他全局函数的干扰。</p>\n<img src=\"image-20240625125041783.png\" alt=\"image-20240625125041783\" style=\"zoom:67%;\" />\n\n<p>定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SavingAccount</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">double</span> rate;\t\t\t<span class=\"comment\">//定义了一个私有静态成员变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：静态数据成员属于类，不属于实例化的对象，从而在实例化对象为对象分配空间时并不包含静态数据成员的空间</p>\n<p>静态数据成员的空间必须单独分配且只分配一次，为静态数据成员分配空间成为静态数据成员的定义（一般在cpp实现文件中）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SavingAccount.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//作用域::静态成员变量名</span></span><br><span class=\"line\"><span class=\"type\">double</span> SavingAccount::rate=<span class=\"number\">0.05</span>;\t\t<span class=\"comment\">//为rate分配空间，并赋予了初值，若没有这个定义，链接时会报错</span></span><br></pre></td></tr></table></figure>\n\n<p>由于静态数据成员是属于类的，因此可以通过作用域运算符用类名直接调用，如<strong>”类名::静态数据成员名“</strong>。</p>\n<p>从每个对象的角度来看，似乎是实例化对象的一部分，可以像普通的成员一样用对象引用$Account1.rate$。但是指向的都是同一块空间。 </p>\n<hr>\n<h4 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h4><p><strong>静态成员函数：</strong>专门用于操作静态数据成员。</p>\n<p>于普通函数一样就是在声明的前面加上static，静态成员函数的定义既可以写在类内，也可以写在类外。（在类外定义的时候不需要加static）</p>\n<p>例如，我要修改savingaccount的rate</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">SetRate</span><span class=\"params\">(<span class=\"type\">double</span> newRate)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    rate=newRate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：静态成员函数是为类服务的，从而实例化对象调用的时候静态函数不会像普通函数一样有隐式的$*this$​指针可以访问实例化对象内的普通成员变量和普通成员函数。</p>\n<p>（大概率静态成员函数和静态数据成员变量都存放在一个存储空间且有联系）静态成员函数只能调用静态数据成员和静态成员函数。</p>\n<p>调用的话，有实例化对象可以实例化对象调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Account.<span class=\"built_in\">SetRate</span>(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>就算没有实例化对象，也可以使用类名来调用，<strong>”类名::静态成员函数名（）“</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SavingAccount::<span class=\"built_in\">SetRate</span>(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"静态常量数据成员\"><a href=\"#静态常量数据成员\" class=\"headerlink\" title=\"静态常量数据成员\"></a>静态常量数据成员</h4><p>当有时候整个类需要共享一个<strong>常量</strong>，就可以用static const来声明。</p>\n<p>首先区分一下<strong>常量数据成员</strong>和<strong>静态常量数据成员</strong></p>\n<p><strong>常量数据成员</strong>是针对不同的实例化对象的，每个实例化对象的常量数据成员各不相同，const声明</p>\n<p><strong>静态常量数据成员</strong>是属于整个类，所有实例化对象都一样，是static const声明的</p>\n<p>初始化：</p>\n<p><strong>普通数据成员</strong>可以在对象定义的构造函数初始化</p>\n<p><strong>静态数据成员</strong>实在静态数据成员定义的时候初始化，一般是在类外定义。</p>\n<p><strong>常量静态数据成员</strong>竟然可以在类内定义的时候初始化（<strong>只能是整型</strong>），注意不是构造函数，是在类内声明的时候直接赋值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SavingAccount</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> rate=<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//类似这样</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：如果静态常量数据成员是非整型，则不能在类内赋初值，在类中只能声明，在类外定义</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">double</span> st;\t<span class=\"comment\">//类内声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类外定义的时候可以不写static,和函数一样</span></span><br><span class=\"line\"><span class=\"type\">const</span> SavingAccount::st=<span class=\"number\">1.5</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以不管什么还是建议在类外定义，以防记混报错。</p>\n<hr>\n<h2 id=\"单例化的一些概念\"><a href=\"#单例化的一些概念\" class=\"headerlink\" title=\"单例化的一些概念\"></a>单例化的一些概念</h2><blockquote>\n<p>简单看了一下，不太懂锁和线程这方面的知识点，所以就对着文章简单写点吧，后面了解了有机会再细说</p>\n</blockquote>\n<h4 id=\"1-什么是单例模式\"><a href=\"#1-什么是单例模式\" class=\"headerlink\" title=\"1. 什么是单例模式\"></a>1. 什么是单例模式</h4><blockquote>\n<p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>\n</blockquote>\n<img src=\"format,png.png\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"2-单例模式的类型\"><a href=\"#2-单例模式的类型\" class=\"headerlink\" title=\"2. 单例模式的类型\"></a>2. 单例模式的类型</h4><p>单例模式有两种类型：</p>\n<ul>\n<li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li>\n<li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li>\n</ul>\n<ol>\n<li><strong>懒汉式单例模式：</strong>在首次获取实例时创建。这种方式在多线程环境下存在线程安全问题，需要通过加锁或双重检查等方式解决。</li>\n</ol>\n<img src=\"format,png-1719298517759-3.png\" alt=\"image.png\" style=\"zoom: 80%;\" />\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">static</span> Singleton singleton;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == null) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>饿汉式单例模式</strong>：在类加载时就创建实例。这种方式在多线程环境下是线程安全的，但可能会浪费内存空间。</li>\n</ol>\n<img src=\"format,png-1719298652881-6.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后面的我也不懂了，有兴趣就去csdn去看看吧</p>\n<p><a href=\"https://blog.csdn.net/weixin_41949328/article/details/107296517\">原文链接</a></p>\n<hr>\n<h2 id=\"课程代码的单例实现（Manager类）\"><a href=\"#课程代码的单例实现（Manager类）\" class=\"headerlink\" title=\"课程代码的单例实现（Manager类）\"></a>课程代码的单例实现（Manager类）</h2><p>这个gameManager和Manager关系就感觉有点绕</p>\n<p>就像大V老师说的通过继承的方式，让子类能自动的形成构造-&gt;就对基类引入了模板。</p>\n<p>通过对基类的单例实现，然后将子类是继承基类（用子类作为模板参数传入的基类）实现。</p>\n<p>我的理解就如同下图</p>\n<img src=\"image-20240625135923590.png\" alt=\"image-20240625135923590\" style=\"zoom:80%;\" />\n\n<p>这样就是实现了继承子类都可以实现单例的功能</p>\n<p>先看<strong>manager.h</strong>的内容吧</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span>  _MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _MANAGER_H_</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Manager</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//静态成员函数只可以修改静态数据成员和静态成员函数</span></span><br><span class=\"line\">    <span class=\"comment\">//通过静态成员函数instance（）可以实现单例的构造</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">static</span> T* <span class=\"title\">instance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!manager)\t\t\t\t<span class=\"comment\">//如果静态数据成员（单例对象）未实例化，则实例化</span></span><br><span class=\"line\">\t\t\tmanager = <span class=\"keyword\">new</span> <span class=\"built_in\">T</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> manager;\t\t\t\t<span class=\"comment\">//返回静态成员指针</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Manager</span>()=<span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">static</span> T* manager;\t\t\t\t<span class=\"comment\">//声明静态成员变量\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将构造函数访问特性设置为protected，那么就无法再外界构造对象，保证了单例化的唯一性</span></span><br><span class=\"line\">\t<span class=\"built_in\">Manager</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"comment\">//删除复制构造函数和=号的运算符重载，也是为了防止外界构造对象</span></span><br><span class=\"line\">\t<span class=\"built_in\">Manager</span>(<span class=\"type\">const</span> Manager&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">\tManager&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Manager&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将单例的对象设置为静态数据成员，这里是静态数据成员的定义，换种角度就是为其分配空间，不然会报错</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Manager&lt;T&gt;::manager = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// ! _MANAGER_H_</span></span></span><br></pre></td></tr></table></figure>\n\n<p>注意：以上都是模板参数，最后生成的静态数据成员都是子类对象，一些细节也在里面说明了。</p>\n<p>我们再来看看**”game_scene.h”**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _GAME_MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _GAME_MANAGER_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;manager.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GameManager</span>:<span class=\"keyword\">public</span> Manager&lt;GameManager&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//因为在继承的时候会调用GameManager类的构造函数，所以需要声明一下友元</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Manager</span>&lt;GameManager&gt;;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">GameManager</span>()&#123;&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">GameManager</span>()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !_GAME_MANAGER_H_</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>最后看main.cpp</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SDL_MAIN_HANDLED</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;game_manager.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这就很好理解了，instance接受的其实就是单例化静态成员的那块空间的地址，这样main函数里就可以用了</span></span><br><span class=\"line\">\tGameManager* instance = GameManager::<span class=\"built_in\">instance</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大体上课程就是如此实现单例化和继承单例化功能，从而保证对象的唯一性。</p>\n<hr>"},{"title":"自制ECS库-MyECS","date":"2025-03-23T16:00:00.000Z","updated":"2024-03-23T16:00:00.000Z","_content":"\n## 0.前言\n因受到entt启发，以学习为目的，我仿照entt制作了一个纯头文件ecs库，目前许多功能还在实验中。其大部分接口与逻辑与entt相同，但在底层实现上一些差别。该博客主要是对ECS的介绍，对MyECS库的介绍并附带一些对entt的一些思考之类的。最后本人水平知识有限，请大佬轻喷（doge），非常欢迎大家来交流学习。\n\n\n**github网址 ↓**\n\nMyEcs:  &emsp;https://github.com/Flaaax/MyECS\n\nentt:   &emsp;&emsp;https://github.com/skypjack/entt\n\n<!-- More -->\n\n## 1.什么是ECS？\n*ECS*是一种游戏架构，全称*Entity Component System*（实体组件系统），通常用于游戏开发，并显著区别于经典的 *OOP*(*面向对象编程*) 架构。其定义分为三个部分Entity，Component和System。\n#### 1.Entity\n每个*Entity*仅为一个**唯一标识符** ，通常是一个无符号整数，不包含逻辑或者额外的东西，而不是像 *OOP Style* 一样的有着繁杂接口，超多成员的基类。\n\n在*OOP*中，一个*Entity*可能长这样：\n```cpp\nclass Entity{\nprotected:\n    int health;\n    int damage;\n    //100+ members...\n\npublic:\n    virtual ~Entity(){}\n    virtual void update(float dt){}\n    virtual void handleEvent(const Event& e){}\n    virtual void render(Window& w){}\n    //1000+ virtual functions...\n}\n```\n然而，*ECS*中的*Entity*仅作为一个标识符，看起来就简单多了：\n```cpp\nusing Entity = size_t;          //unsigned integer\n```\n（当然，这只是个示例，实际上还要考虑版本控制等）\n\n那么它的数据和逻辑放哪呢？在*ECS*，一个*Entity*会关联一些*Component*，它们负责存储数据，而*System*负责处理这些数据逻辑。请继续往下看。\n\n #### 2.Component\n *Component*是一些**仅存储数据**的容器，例如**位置**，**速度**，**血量**等。每个*Entity*都可以关联多种*Component*来为其添加属性，换言之，对于一类*Component*，每个*Entity*都唯一对应了这一类的一个实例（如果它们有关联的话）\n \n 在*MyECS*的实现中，你不需要为*Components*做额外操作。直接定义它们，然后立刻使用。\n\n ```cpp\nstruct Position{         //无需任何修饰\n    float x, y;\n};\n\nstruct Health{\n    int health = 0;\n}\n\n//example\nvoid main(){\n    using namespace myecs;\n    Registry reg;\n    entity e = reg.create();\n\n    reg.emplace<Position>(e, 1.f, 2.f);       //直接使用\n    reg.emplace<Health>(e, Health{10});       //Very OK\n\n    Position& pos = reg.get<Position>(e);     //再次获取\n    std::cout << \"e's Position: \" << pos.x << \" \" << pos.y << std::endl;\n}\n```\n\n> 就像*entt*一样，我在*MyECS*舍弃了继承关系和一部分安全性，换来了非常大的便利。\n\n为什么我们不像*OOP*一样把所有东西都放在一个类里呢？因为你可以选择一个*Entity*持有哪些*Components*，不再需要负担你不需要的东西。在*OOP*，很多时候你必须在基类添加过多数据成员，而它们很多都被子类浪费了。例如，大部分实体都需要“位置”和“渲染”，但不是所有都需要“生命”。*Component*的设计很好地解决了这一问题。\n\n#### 3.System\n有了数据，现在只需为它们添加逻辑。在*OOP*，这部分通过继承*Entity*的虚函数来处理，但在*ECS*这正是*System*做的事。一个*ECS*可以有多个*System*，比如下面这些：\n```cpp\nclass PhysicsSystem{\npublic:\n    void updatePosition(Registry& reg, float dt){\n        for(entity e: reg.view<Position, Velocity>){\n            reg.get<Position>(e) += reg.get<Velocity>(e) * dt;\n            if(Acceleration* acc = reg.try_get<Acceleration>(e)){\n                reg.get<Velocity>(e) += (*acc) * dt;\n            }\n        }\n    }\n}\n\nclass RenderSystem{\npublic:\n    void render(Registry& reg, Window& window){\n        for(entity e: reg.view<Sprite>){\n            window.draw(reg.get<Sprite>(e));\n        }\n    }\n}\n```\n在纯粹的*ECS*中，所有逻辑都应该交给*System*来做，这些*System*不持有任何数据，仅负责处理数据。如果你有额外需求，那么就多设计几个*System*。当然，*MyECS*库并不会在乎这一点，你仍可以在任何地方添加你的逻辑，只要确保你知道自己在做什么。\n\n\n## 2.为什么选择ECS而不是OOP？\n~~因为写着很爽（划掉~~\n\n*ECS* 能够抛开繁琐的继承关系，将实体化为组件的组合，这样结构更清晰，对代码编写者更友好。事实上，这也是我选择学习*ECS*的一个重要原因。\n\n其它原因也包括比*OOP*效率更高，缓存更友好等 （这在后面会解释）\n\n总之，在某些场合下，*ECS*确实能比*OOP*发挥更大的优势\n\n\n## 3.ECS的优缺点\n#### 优点：\n1.代码结构清晰，更好编写，别提多爽了\n\n2.缓存命中率高，更好发挥cpu性能\n\n#### 缺点：\n1.适用范围有限。与许多知乎“大佬”的意见不同的是，并不是所有情况都应该使用*ECS*，*ECS*也绝无可能取代*OOP*。不适合的例子就如**卡牌游戏**，**UI系统**等，而适合的例子有类似《**Noita**》的复杂弹幕游戏。\n\n2.学习难度略大，因为*ECS*的架构与传统*OOP*差别过大，需要一定努力来适应新的模式并抛弃以前的继承式思维，当然这点因人而异了。\n***\n\n总之，希望以上内容帮助你判断你是否需要学习*ECS*并在你的新游戏里实践它。\n\n感觉这次也写的够多了，关于*MyECS*的介绍就放到下期吧（）   感谢阅读，最后再贴一遍网址：\n\nMyEcs:  &emsp;https://github.com/Flaaax/MyECS\n\nentt:   &emsp;&emsp;https://github.com/skypjack/entt\n","source":"_posts/Flaaax/MyECS.md","raw":"---\ntitle: 自制ECS库-MyECS\ndate: 2025-3-24\nupdated: 2024-3-24\npermalink: articles/Flaaax/MyECS/\ncategories: Flaaax\ntags: [ECS, 游戏开发, C++]\n---\n\n## 0.前言\n因受到entt启发，以学习为目的，我仿照entt制作了一个纯头文件ecs库，目前许多功能还在实验中。其大部分接口与逻辑与entt相同，但在底层实现上一些差别。该博客主要是对ECS的介绍，对MyECS库的介绍并附带一些对entt的一些思考之类的。最后本人水平知识有限，请大佬轻喷（doge），非常欢迎大家来交流学习。\n\n\n**github网址 ↓**\n\nMyEcs:  &emsp;https://github.com/Flaaax/MyECS\n\nentt:   &emsp;&emsp;https://github.com/skypjack/entt\n\n<!-- More -->\n\n## 1.什么是ECS？\n*ECS*是一种游戏架构，全称*Entity Component System*（实体组件系统），通常用于游戏开发，并显著区别于经典的 *OOP*(*面向对象编程*) 架构。其定义分为三个部分Entity，Component和System。\n#### 1.Entity\n每个*Entity*仅为一个**唯一标识符** ，通常是一个无符号整数，不包含逻辑或者额外的东西，而不是像 *OOP Style* 一样的有着繁杂接口，超多成员的基类。\n\n在*OOP*中，一个*Entity*可能长这样：\n```cpp\nclass Entity{\nprotected:\n    int health;\n    int damage;\n    //100+ members...\n\npublic:\n    virtual ~Entity(){}\n    virtual void update(float dt){}\n    virtual void handleEvent(const Event& e){}\n    virtual void render(Window& w){}\n    //1000+ virtual functions...\n}\n```\n然而，*ECS*中的*Entity*仅作为一个标识符，看起来就简单多了：\n```cpp\nusing Entity = size_t;          //unsigned integer\n```\n（当然，这只是个示例，实际上还要考虑版本控制等）\n\n那么它的数据和逻辑放哪呢？在*ECS*，一个*Entity*会关联一些*Component*，它们负责存储数据，而*System*负责处理这些数据逻辑。请继续往下看。\n\n #### 2.Component\n *Component*是一些**仅存储数据**的容器，例如**位置**，**速度**，**血量**等。每个*Entity*都可以关联多种*Component*来为其添加属性，换言之，对于一类*Component*，每个*Entity*都唯一对应了这一类的一个实例（如果它们有关联的话）\n \n 在*MyECS*的实现中，你不需要为*Components*做额外操作。直接定义它们，然后立刻使用。\n\n ```cpp\nstruct Position{         //无需任何修饰\n    float x, y;\n};\n\nstruct Health{\n    int health = 0;\n}\n\n//example\nvoid main(){\n    using namespace myecs;\n    Registry reg;\n    entity e = reg.create();\n\n    reg.emplace<Position>(e, 1.f, 2.f);       //直接使用\n    reg.emplace<Health>(e, Health{10});       //Very OK\n\n    Position& pos = reg.get<Position>(e);     //再次获取\n    std::cout << \"e's Position: \" << pos.x << \" \" << pos.y << std::endl;\n}\n```\n\n> 就像*entt*一样，我在*MyECS*舍弃了继承关系和一部分安全性，换来了非常大的便利。\n\n为什么我们不像*OOP*一样把所有东西都放在一个类里呢？因为你可以选择一个*Entity*持有哪些*Components*，不再需要负担你不需要的东西。在*OOP*，很多时候你必须在基类添加过多数据成员，而它们很多都被子类浪费了。例如，大部分实体都需要“位置”和“渲染”，但不是所有都需要“生命”。*Component*的设计很好地解决了这一问题。\n\n#### 3.System\n有了数据，现在只需为它们添加逻辑。在*OOP*，这部分通过继承*Entity*的虚函数来处理，但在*ECS*这正是*System*做的事。一个*ECS*可以有多个*System*，比如下面这些：\n```cpp\nclass PhysicsSystem{\npublic:\n    void updatePosition(Registry& reg, float dt){\n        for(entity e: reg.view<Position, Velocity>){\n            reg.get<Position>(e) += reg.get<Velocity>(e) * dt;\n            if(Acceleration* acc = reg.try_get<Acceleration>(e)){\n                reg.get<Velocity>(e) += (*acc) * dt;\n            }\n        }\n    }\n}\n\nclass RenderSystem{\npublic:\n    void render(Registry& reg, Window& window){\n        for(entity e: reg.view<Sprite>){\n            window.draw(reg.get<Sprite>(e));\n        }\n    }\n}\n```\n在纯粹的*ECS*中，所有逻辑都应该交给*System*来做，这些*System*不持有任何数据，仅负责处理数据。如果你有额外需求，那么就多设计几个*System*。当然，*MyECS*库并不会在乎这一点，你仍可以在任何地方添加你的逻辑，只要确保你知道自己在做什么。\n\n\n## 2.为什么选择ECS而不是OOP？\n~~因为写着很爽（划掉~~\n\n*ECS* 能够抛开繁琐的继承关系，将实体化为组件的组合，这样结构更清晰，对代码编写者更友好。事实上，这也是我选择学习*ECS*的一个重要原因。\n\n其它原因也包括比*OOP*效率更高，缓存更友好等 （这在后面会解释）\n\n总之，在某些场合下，*ECS*确实能比*OOP*发挥更大的优势\n\n\n## 3.ECS的优缺点\n#### 优点：\n1.代码结构清晰，更好编写，别提多爽了\n\n2.缓存命中率高，更好发挥cpu性能\n\n#### 缺点：\n1.适用范围有限。与许多知乎“大佬”的意见不同的是，并不是所有情况都应该使用*ECS*，*ECS*也绝无可能取代*OOP*。不适合的例子就如**卡牌游戏**，**UI系统**等，而适合的例子有类似《**Noita**》的复杂弹幕游戏。\n\n2.学习难度略大，因为*ECS*的架构与传统*OOP*差别过大，需要一定努力来适应新的模式并抛弃以前的继承式思维，当然这点因人而异了。\n***\n\n总之，希望以上内容帮助你判断你是否需要学习*ECS*并在你的新游戏里实践它。\n\n感觉这次也写的够多了，关于*MyECS*的介绍就放到下期吧（）   感谢阅读，最后再贴一遍网址：\n\nMyEcs:  &emsp;https://github.com/Flaaax/MyECS\n\nentt:   &emsp;&emsp;https://github.com/skypjack/entt\n","slug":"Flaaax/MyECS","published":1,"__permalink":"articles/Flaaax/MyECS/","comments":1,"layout":"post","photos":[],"link":"","_id":"cme5bvpej0000nofw8eiw0me0","content":"<h2 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h2><p>因受到entt启发，以学习为目的，我仿照entt制作了一个纯头文件ecs库，目前许多功能还在实验中。其大部分接口与逻辑与entt相同，但在底层实现上一些差别。该博客主要是对ECS的介绍，对MyECS库的介绍并附带一些对entt的一些思考之类的。最后本人水平知识有限，请大佬轻喷（doge），非常欢迎大家来交流学习。</p>\n<p><strong>github网址 ↓</strong></p>\n<p>MyEcs:  &emsp;<a href=\"https://github.com/Flaaax/MyECS\">https://github.com/Flaaax/MyECS</a></p>\n<p>entt:   &emsp;&emsp;<a href=\"https://github.com/skypjack/entt\">https://github.com/skypjack/entt</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-什么是ECS？\"><a href=\"#1-什么是ECS？\" class=\"headerlink\" title=\"1.什么是ECS？\"></a>1.什么是ECS？</h2><p><em>ECS</em>是一种游戏架构，全称<em>Entity Component System</em>（实体组件系统），通常用于游戏开发，并显著区别于经典的 <em>OOP</em>(<em>面向对象编程</em>) 架构。其定义分为三个部分Entity，Component和System。</p>\n<h4 id=\"1-Entity\"><a href=\"#1-Entity\" class=\"headerlink\" title=\"1.Entity\"></a>1.Entity</h4><p>每个<em>Entity</em>仅为一个<strong>唯一标识符</strong> ，通常是一个无符号整数，不包含逻辑或者额外的东西，而不是像 <em>OOP Style</em> 一样的有着繁杂接口，超多成员的基类。</p>\n<p>在<em>OOP</em>中，一个<em>Entity</em>可能长这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Entity</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> health;</span><br><span class=\"line\">    <span class=\"type\">int</span> damage;</span><br><span class=\"line\">    <span class=\"comment\">//100+ members...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Entity</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">float</span> dt)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(<span class=\"type\">const</span> Event&amp; e)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Window&amp; w)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//1000+ virtual functions...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，<em>ECS</em>中的<em>Entity</em>仅作为一个标识符，看起来就简单多了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Entity = <span class=\"type\">size_t</span>;          <span class=\"comment\">//unsigned integer</span></span><br></pre></td></tr></table></figure>\n<p>（当然，这只是个示例，实际上还要考虑版本控制等）</p>\n<p>那么它的数据和逻辑放哪呢？在<em>ECS</em>，一个<em>Entity</em>会关联一些<em>Component</em>，它们负责存储数据，而<em>System</em>负责处理这些数据逻辑。请继续往下看。</p>\n<h4 id=\"2-Component\"><a href=\"#2-Component\" class=\"headerlink\" title=\"2.Component\"></a>2.Component</h4><p> <em>Component</em>是一些<strong>仅存储数据</strong>的容器，例如<strong>位置</strong>，<strong>速度</strong>，<strong>血量</strong>等。每个<em>Entity</em>都可以关联多种<em>Component</em>来为其添加属性，换言之，对于一类<em>Component</em>，每个<em>Entity</em>都唯一对应了这一类的一个实例（如果它们有关联的话）</p>\n<p> 在<em>MyECS</em>的实现中，你不需要为<em>Components</em>做额外操作。直接定义它们，然后立刻使用。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Position</span>&#123;         <span class=\"comment\">//无需任何修饰</span></span><br><span class=\"line\">    <span class=\"type\">float</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Health</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> health = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//example</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> myecs;</span><br><span class=\"line\">    Registry reg;</span><br><span class=\"line\">    entity e = reg.<span class=\"built_in\">create</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    reg.<span class=\"built_in\">emplace</span>&lt;Position&gt;(e, <span class=\"number\">1.f</span>, <span class=\"number\">2.f</span>);       <span class=\"comment\">//直接使用</span></span><br><span class=\"line\">    reg.<span class=\"built_in\">emplace</span>&lt;Health&gt;(e, Health&#123;<span class=\"number\">10</span>&#125;);       <span class=\"comment\">//Very OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Position&amp; pos = reg.<span class=\"built_in\">get</span>&lt;Position&gt;(e);     <span class=\"comment\">//再次获取</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;e&#x27;s Position: &quot;</span> &lt;&lt; pos.x &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; pos.y &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>就像<em>entt</em>一样，我在<em>MyECS</em>舍弃了继承关系和一部分安全性，换来了非常大的便利。</p>\n</blockquote>\n<p>为什么我们不像<em>OOP</em>一样把所有东西都放在一个类里呢？因为你可以选择一个<em>Entity</em>持有哪些<em>Components</em>，不再需要负担你不需要的东西。在<em>OOP</em>，很多时候你必须在基类添加过多数据成员，而它们很多都被子类浪费了。例如，大部分实体都需要“位置”和“渲染”，但不是所有都需要“生命”。<em>Component</em>的设计很好地解决了这一问题。</p>\n<h4 id=\"3-System\"><a href=\"#3-System\" class=\"headerlink\" title=\"3.System\"></a>3.System</h4><p>有了数据，现在只需为它们添加逻辑。在<em>OOP</em>，这部分通过继承<em>Entity</em>的虚函数来处理，但在<em>ECS</em>这正是<em>System</em>做的事。一个<em>ECS</em>可以有多个<em>System</em>，比如下面这些：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PhysicsSystem</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updatePosition</span><span class=\"params\">(Registry&amp; reg, <span class=\"type\">float</span> dt)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(entity e: reg.view&lt;Position, Velocity&gt;)&#123;</span><br><span class=\"line\">            reg.<span class=\"built_in\">get</span>&lt;Position&gt;(e) += reg.<span class=\"built_in\">get</span>&lt;Velocity&gt;(e) * dt;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Acceleration* acc = reg.<span class=\"built_in\">try_get</span>&lt;Acceleration&gt;(e))&#123;</span><br><span class=\"line\">                reg.<span class=\"built_in\">get</span>&lt;Velocity&gt;(e) += (*acc) * dt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RenderSystem</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Registry&amp; reg, Window&amp; window)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(entity e: reg.view&lt;Sprite&gt;)&#123;</span><br><span class=\"line\">            window.<span class=\"built_in\">draw</span>(reg.<span class=\"built_in\">get</span>&lt;Sprite&gt;(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在纯粹的<em>ECS</em>中，所有逻辑都应该交给<em>System</em>来做，这些<em>System</em>不持有任何数据，仅负责处理数据。如果你有额外需求，那么就多设计几个<em>System</em>。当然，<em>MyECS</em>库并不会在乎这一点，你仍可以在任何地方添加你的逻辑，只要确保你知道自己在做什么。</p>\n<h2 id=\"2-为什么选择ECS而不是OOP？\"><a href=\"#2-为什么选择ECS而不是OOP？\" class=\"headerlink\" title=\"2.为什么选择ECS而不是OOP？\"></a>2.为什么选择ECS而不是OOP？</h2><p><del>因为写着很爽（划掉</del></p>\n<p><em>ECS</em> 能够抛开繁琐的继承关系，将实体化为组件的组合，这样结构更清晰，对代码编写者更友好。事实上，这也是我选择学习<em>ECS</em>的一个重要原因。</p>\n<p>其它原因也包括比<em>OOP</em>效率更高，缓存更友好等 （这在后面会解释）</p>\n<p>总之，在某些场合下，<em>ECS</em>确实能比<em>OOP</em>发挥更大的优势</p>\n<h2 id=\"3-ECS的优缺点\"><a href=\"#3-ECS的优缺点\" class=\"headerlink\" title=\"3.ECS的优缺点\"></a>3.ECS的优缺点</h2><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><p>1.代码结构清晰，更好编写，别提多爽了</p>\n<p>2.缓存命中率高，更好发挥cpu性能</p>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><p>1.适用范围有限。与许多知乎“大佬”的意见不同的是，并不是所有情况都应该使用<em>ECS</em>，<em>ECS</em>也绝无可能取代<em>OOP</em>。不适合的例子就如<strong>卡牌游戏</strong>，<strong>UI系统</strong>等，而适合的例子有类似《<strong>Noita</strong>》的复杂弹幕游戏。</p>\n<p>2.学习难度略大，因为<em>ECS</em>的架构与传统<em>OOP</em>差别过大，需要一定努力来适应新的模式并抛弃以前的继承式思维，当然这点因人而异了。</p>\n<hr>\n<p>总之，希望以上内容帮助你判断你是否需要学习<em>ECS</em>并在你的新游戏里实践它。</p>\n<p>感觉这次也写的够多了，关于<em>MyECS</em>的介绍就放到下期吧（）   感谢阅读，最后再贴一遍网址：</p>\n<p>MyEcs:  &emsp;<a href=\"https://github.com/Flaaax/MyECS\">https://github.com/Flaaax/MyECS</a></p>\n<p>entt:   &emsp;&emsp;<a href=\"https://github.com/skypjack/entt\">https://github.com/skypjack/entt</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0.前言\"></a>0.前言</h2><p>因受到entt启发，以学习为目的，我仿照entt制作了一个纯头文件ecs库，目前许多功能还在实验中。其大部分接口与逻辑与entt相同，但在底层实现上一些差别。该博客主要是对ECS的介绍，对MyECS库的介绍并附带一些对entt的一些思考之类的。最后本人水平知识有限，请大佬轻喷（doge），非常欢迎大家来交流学习。</p>\n<p><strong>github网址 ↓</strong></p>\n<p>MyEcs:  &emsp;<a href=\"https://github.com/Flaaax/MyECS\">https://github.com/Flaaax/MyECS</a></p>\n<p>entt:   &emsp;&emsp;<a href=\"https://github.com/skypjack/entt\">https://github.com/skypjack/entt</a></p>","more":"<h2 id=\"1-什么是ECS？\"><a href=\"#1-什么是ECS？\" class=\"headerlink\" title=\"1.什么是ECS？\"></a>1.什么是ECS？</h2><p><em>ECS</em>是一种游戏架构，全称<em>Entity Component System</em>（实体组件系统），通常用于游戏开发，并显著区别于经典的 <em>OOP</em>(<em>面向对象编程</em>) 架构。其定义分为三个部分Entity，Component和System。</p>\n<h4 id=\"1-Entity\"><a href=\"#1-Entity\" class=\"headerlink\" title=\"1.Entity\"></a>1.Entity</h4><p>每个<em>Entity</em>仅为一个<strong>唯一标识符</strong> ，通常是一个无符号整数，不包含逻辑或者额外的东西，而不是像 <em>OOP Style</em> 一样的有着繁杂接口，超多成员的基类。</p>\n<p>在<em>OOP</em>中，一个<em>Entity</em>可能长这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Entity</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> health;</span><br><span class=\"line\">    <span class=\"type\">int</span> damage;</span><br><span class=\"line\">    <span class=\"comment\">//100+ members...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Entity</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">float</span> dt)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(<span class=\"type\">const</span> Event&amp; e)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Window&amp; w)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//1000+ virtual functions...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，<em>ECS</em>中的<em>Entity</em>仅作为一个标识符，看起来就简单多了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Entity = <span class=\"type\">size_t</span>;          <span class=\"comment\">//unsigned integer</span></span><br></pre></td></tr></table></figure>\n<p>（当然，这只是个示例，实际上还要考虑版本控制等）</p>\n<p>那么它的数据和逻辑放哪呢？在<em>ECS</em>，一个<em>Entity</em>会关联一些<em>Component</em>，它们负责存储数据，而<em>System</em>负责处理这些数据逻辑。请继续往下看。</p>\n<h4 id=\"2-Component\"><a href=\"#2-Component\" class=\"headerlink\" title=\"2.Component\"></a>2.Component</h4><p> <em>Component</em>是一些<strong>仅存储数据</strong>的容器，例如<strong>位置</strong>，<strong>速度</strong>，<strong>血量</strong>等。每个<em>Entity</em>都可以关联多种<em>Component</em>来为其添加属性，换言之，对于一类<em>Component</em>，每个<em>Entity</em>都唯一对应了这一类的一个实例（如果它们有关联的话）</p>\n<p> 在<em>MyECS</em>的实现中，你不需要为<em>Components</em>做额外操作。直接定义它们，然后立刻使用。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Position</span>&#123;         <span class=\"comment\">//无需任何修饰</span></span><br><span class=\"line\">    <span class=\"type\">float</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Health</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> health = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//example</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> myecs;</span><br><span class=\"line\">    Registry reg;</span><br><span class=\"line\">    entity e = reg.<span class=\"built_in\">create</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    reg.<span class=\"built_in\">emplace</span>&lt;Position&gt;(e, <span class=\"number\">1.f</span>, <span class=\"number\">2.f</span>);       <span class=\"comment\">//直接使用</span></span><br><span class=\"line\">    reg.<span class=\"built_in\">emplace</span>&lt;Health&gt;(e, Health&#123;<span class=\"number\">10</span>&#125;);       <span class=\"comment\">//Very OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Position&amp; pos = reg.<span class=\"built_in\">get</span>&lt;Position&gt;(e);     <span class=\"comment\">//再次获取</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;e&#x27;s Position: &quot;</span> &lt;&lt; pos.x &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; pos.y &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>就像<em>entt</em>一样，我在<em>MyECS</em>舍弃了继承关系和一部分安全性，换来了非常大的便利。</p>\n</blockquote>\n<p>为什么我们不像<em>OOP</em>一样把所有东西都放在一个类里呢？因为你可以选择一个<em>Entity</em>持有哪些<em>Components</em>，不再需要负担你不需要的东西。在<em>OOP</em>，很多时候你必须在基类添加过多数据成员，而它们很多都被子类浪费了。例如，大部分实体都需要“位置”和“渲染”，但不是所有都需要“生命”。<em>Component</em>的设计很好地解决了这一问题。</p>\n<h4 id=\"3-System\"><a href=\"#3-System\" class=\"headerlink\" title=\"3.System\"></a>3.System</h4><p>有了数据，现在只需为它们添加逻辑。在<em>OOP</em>，这部分通过继承<em>Entity</em>的虚函数来处理，但在<em>ECS</em>这正是<em>System</em>做的事。一个<em>ECS</em>可以有多个<em>System</em>，比如下面这些：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PhysicsSystem</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updatePosition</span><span class=\"params\">(Registry&amp; reg, <span class=\"type\">float</span> dt)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(entity e: reg.view&lt;Position, Velocity&gt;)&#123;</span><br><span class=\"line\">            reg.<span class=\"built_in\">get</span>&lt;Position&gt;(e) += reg.<span class=\"built_in\">get</span>&lt;Velocity&gt;(e) * dt;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Acceleration* acc = reg.<span class=\"built_in\">try_get</span>&lt;Acceleration&gt;(e))&#123;</span><br><span class=\"line\">                reg.<span class=\"built_in\">get</span>&lt;Velocity&gt;(e) += (*acc) * dt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RenderSystem</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Registry&amp; reg, Window&amp; window)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(entity e: reg.view&lt;Sprite&gt;)&#123;</span><br><span class=\"line\">            window.<span class=\"built_in\">draw</span>(reg.<span class=\"built_in\">get</span>&lt;Sprite&gt;(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在纯粹的<em>ECS</em>中，所有逻辑都应该交给<em>System</em>来做，这些<em>System</em>不持有任何数据，仅负责处理数据。如果你有额外需求，那么就多设计几个<em>System</em>。当然，<em>MyECS</em>库并不会在乎这一点，你仍可以在任何地方添加你的逻辑，只要确保你知道自己在做什么。</p>\n<h2 id=\"2-为什么选择ECS而不是OOP？\"><a href=\"#2-为什么选择ECS而不是OOP？\" class=\"headerlink\" title=\"2.为什么选择ECS而不是OOP？\"></a>2.为什么选择ECS而不是OOP？</h2><p><del>因为写着很爽（划掉</del></p>\n<p><em>ECS</em> 能够抛开繁琐的继承关系，将实体化为组件的组合，这样结构更清晰，对代码编写者更友好。事实上，这也是我选择学习<em>ECS</em>的一个重要原因。</p>\n<p>其它原因也包括比<em>OOP</em>效率更高，缓存更友好等 （这在后面会解释）</p>\n<p>总之，在某些场合下，<em>ECS</em>确实能比<em>OOP</em>发挥更大的优势</p>\n<h2 id=\"3-ECS的优缺点\"><a href=\"#3-ECS的优缺点\" class=\"headerlink\" title=\"3.ECS的优缺点\"></a>3.ECS的优缺点</h2><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><p>1.代码结构清晰，更好编写，别提多爽了</p>\n<p>2.缓存命中率高，更好发挥cpu性能</p>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><p>1.适用范围有限。与许多知乎“大佬”的意见不同的是，并不是所有情况都应该使用<em>ECS</em>，<em>ECS</em>也绝无可能取代<em>OOP</em>。不适合的例子就如<strong>卡牌游戏</strong>，<strong>UI系统</strong>等，而适合的例子有类似《<strong>Noita</strong>》的复杂弹幕游戏。</p>\n<p>2.学习难度略大，因为<em>ECS</em>的架构与传统<em>OOP</em>差别过大，需要一定努力来适应新的模式并抛弃以前的继承式思维，当然这点因人而异了。</p>\n<hr>\n<p>总之，希望以上内容帮助你判断你是否需要学习<em>ECS</em>并在你的新游戏里实践它。</p>\n<p>感觉这次也写的够多了，关于<em>MyECS</em>的介绍就放到下期吧（）   感谢阅读，最后再贴一遍网址：</p>\n<p>MyEcs:  &emsp;<a href=\"https://github.com/Flaaax/MyECS\">https://github.com/Flaaax/MyECS</a></p>\n<p>entt:   &emsp;&emsp;<a href=\"https://github.com/skypjack/entt\">https://github.com/skypjack/entt</a></p>"},{"title":"二面放一起了","date":"2025-02-26T16:00:00.000Z","updated":"2025-02-26T16:00:00.000Z","_content":"杭州一家小公司的两次面试，第一次15分钟就通过，第二次拷打了半小时\n<!-- More -->\n# Unity客户端连续两面\n## 一面\nQ:自我介绍一下\n\nA：介绍了下自己学了多久unity,然后说学校离这里很近\n\nQ:看简历ing....先来聊一下项目好了，你简历上说做了AssetBundle框架是吧，简单介绍一下assetbundle是干什么的？\n\nA:我的理解是类似zip一样的一种压缩文件，我项目里用的是lz4压缩，这样可以一块一块的加载资源嘛。\n\nQ：和Resource.load()的区别？\n\nA:Resource.load()用的是红黑树，然后不加载完的话就没有办法进入游戏，所以用ab更好\n\nQ:我看你简历上面其他项目......为什么想到做ab这块的内容，因为这块是比较后期的内容了吧\n\nA:因为我想学学怎么做游戏优化，然后搜了一下发现资源管理这块比较重要，就去学了，然后学ab的时候看unity社区里边的那个xlua热更新就跟着一起学了\n\nQ:热更新流程?\n\nA:额......能问的再具体一点吗？\n\nQ:就比方我要更新一个函数？\n\nA:在c#这边给可能要更新的函数打上hotfix特性，然后去lua里边写逻辑，运行的时候程序会检查那个delegatebridge变量是否存在，有的话就说明这部分内容被替换了\n\nQ:那如果我还要更新lua的代码呢\n\nA:就是lua是用require模块，如果要更新的话我就去package.load里面把旧模块设置为nil，更新新模块，然后把新模块复制给旧模块，把旧模块放回去就好了\n\nQ:你c#学的怎么样？\n\nA:额......直接问几个问题看看？我不知道我算是什么水平\n\nQ:值类型和引用类型\n\nA:值类型存在栈上面是具体的值，然后引用类型存在堆上面返回的是地址\n\nQ:装箱拆箱过程\n\nA:装箱就是在堆上划拉一空间，然后把值放进去返回地址，拆箱就是反过来，然后会多一个检测是否是值类型的操作\n\nQ:讲一下委托和事件\n\nA:委托就是函数的容器，我理解的是装的是函数指针，然后事件是在委托基础上再封装了一层，只能+=或者-=,就比如说我们前面的委托已经装了函数，这个时候如果另一个人用了=那前面的就全都失效了，这时候就得用事件\n\nQ:讲一下反射\n\nA:反射就是可以动态地获取程序集里面的元数据，比如说构造函数，类型什么的，我不需要知道这个类是怎么写的\n\nQ:unity里边有什么地方用了反射\n\nA:（想了一会儿）Mono挂组件\n\nQ:ugui有用过吗？怎么排序\n\nA：sort layer\n\nQ:那个排的是layer\n\nA:记不太清楚了，这块做的比较少\n\n### 反问环节\n\nQ:评价一下我面试的表现\n\nQ：基础还可以。\n\nA:学习方向,去做更复杂的项目还是去看看图形学相关的内容\n\nQ:学ui的mvc框架，图形学只是加分项\n\nA:进公司有没有mentor?\n\nQ：有，不过我们小公司的话是没有大厂那种岗前培训的，就是来了先干活然后不懂公司里直接问。\n\n## 二面\n\nQ:手撕算法随机分布的1w个数，找最大的100个\n\nA:快排\n\nQ:时间复杂度空间复杂度\n\nA:O(nlogn)空间是原地的\n\nQ:那如果是10亿个数呢\n\nA:没思路\n\nQ:说明题刷的少了，C++面向对象的三大特性？\n\nA:封装继承多态\n\nQ:多态怎么实现的？\n\nA:用virtual关键字声明，然后每个声明了虚函数的类都会有虚函数表\n\nQ:继续\n\nA:运行的时候对象会根据虚指针指向虚函数表的内容返回对应的函数指针，就是函数入口\n\nQ:如果我用一个基类指针指向派生类对象，调用函数返回的内容？\n\nA:是子类重写的函数\n\nQ:如果这个函数父类没有写呢？\n\nA:不能这么写\n\nQ:linux熟悉吗？\n\nA:不太熟\n\nQ:服务器方面？\n\nA:阿巴阿巴......（沉默）\n\nQ：看一下项目,做的确实是比较简单\n\n然后聊了我学校里边的课与我的安排,我又聊了点c++11的东西\n\nQ：讲一下11有哪些新特性\n\nA:移动语义\n\nQ:有什么作用\n\nA:直接转移对象的所有权，避免深拷贝\n\nQ:还有什么新特性\n\nA:左值右值，智能指针，顺带扯了一嘴我ab包的项目就是沿用了智能指针里边引用计数的思路\n\nQ:设计模式\n\nA:写了饿汉式和懒汉式的单例\n\nQ:还有没有别的方法实现\n\nA:用局部静态变量\n\nQ:单例模式有什么缺点\n\nA:全局污染，只适合用来写管理器这样的类\n\n### 反问环节\n\nQ:评价\n\nA:题应该是还没刷，其他和一面一样\n\nQ:如果能进公司谁带\n\nA:一面面试官\n\nQ:上班制度\n\nA:9:00-6:30可以弹性一小时","source":"_posts/HIBIKI/unity客户端面经.md","raw":"---\ntitle: 二面放一起了\ndate: 2025-02-27\nupdated: 2025-02-27\npermalink: articles/HIBIKI/Interview/\ncategories: HIBIKI\ntags: [面经]\n---\n杭州一家小公司的两次面试，第一次15分钟就通过，第二次拷打了半小时\n<!-- More -->\n# Unity客户端连续两面\n## 一面\nQ:自我介绍一下\n\nA：介绍了下自己学了多久unity,然后说学校离这里很近\n\nQ:看简历ing....先来聊一下项目好了，你简历上说做了AssetBundle框架是吧，简单介绍一下assetbundle是干什么的？\n\nA:我的理解是类似zip一样的一种压缩文件，我项目里用的是lz4压缩，这样可以一块一块的加载资源嘛。\n\nQ：和Resource.load()的区别？\n\nA:Resource.load()用的是红黑树，然后不加载完的话就没有办法进入游戏，所以用ab更好\n\nQ:我看你简历上面其他项目......为什么想到做ab这块的内容，因为这块是比较后期的内容了吧\n\nA:因为我想学学怎么做游戏优化，然后搜了一下发现资源管理这块比较重要，就去学了，然后学ab的时候看unity社区里边的那个xlua热更新就跟着一起学了\n\nQ:热更新流程?\n\nA:额......能问的再具体一点吗？\n\nQ:就比方我要更新一个函数？\n\nA:在c#这边给可能要更新的函数打上hotfix特性，然后去lua里边写逻辑，运行的时候程序会检查那个delegatebridge变量是否存在，有的话就说明这部分内容被替换了\n\nQ:那如果我还要更新lua的代码呢\n\nA:就是lua是用require模块，如果要更新的话我就去package.load里面把旧模块设置为nil，更新新模块，然后把新模块复制给旧模块，把旧模块放回去就好了\n\nQ:你c#学的怎么样？\n\nA:额......直接问几个问题看看？我不知道我算是什么水平\n\nQ:值类型和引用类型\n\nA:值类型存在栈上面是具体的值，然后引用类型存在堆上面返回的是地址\n\nQ:装箱拆箱过程\n\nA:装箱就是在堆上划拉一空间，然后把值放进去返回地址，拆箱就是反过来，然后会多一个检测是否是值类型的操作\n\nQ:讲一下委托和事件\n\nA:委托就是函数的容器，我理解的是装的是函数指针，然后事件是在委托基础上再封装了一层，只能+=或者-=,就比如说我们前面的委托已经装了函数，这个时候如果另一个人用了=那前面的就全都失效了，这时候就得用事件\n\nQ:讲一下反射\n\nA:反射就是可以动态地获取程序集里面的元数据，比如说构造函数，类型什么的，我不需要知道这个类是怎么写的\n\nQ:unity里边有什么地方用了反射\n\nA:（想了一会儿）Mono挂组件\n\nQ:ugui有用过吗？怎么排序\n\nA：sort layer\n\nQ:那个排的是layer\n\nA:记不太清楚了，这块做的比较少\n\n### 反问环节\n\nQ:评价一下我面试的表现\n\nQ：基础还可以。\n\nA:学习方向,去做更复杂的项目还是去看看图形学相关的内容\n\nQ:学ui的mvc框架，图形学只是加分项\n\nA:进公司有没有mentor?\n\nQ：有，不过我们小公司的话是没有大厂那种岗前培训的，就是来了先干活然后不懂公司里直接问。\n\n## 二面\n\nQ:手撕算法随机分布的1w个数，找最大的100个\n\nA:快排\n\nQ:时间复杂度空间复杂度\n\nA:O(nlogn)空间是原地的\n\nQ:那如果是10亿个数呢\n\nA:没思路\n\nQ:说明题刷的少了，C++面向对象的三大特性？\n\nA:封装继承多态\n\nQ:多态怎么实现的？\n\nA:用virtual关键字声明，然后每个声明了虚函数的类都会有虚函数表\n\nQ:继续\n\nA:运行的时候对象会根据虚指针指向虚函数表的内容返回对应的函数指针，就是函数入口\n\nQ:如果我用一个基类指针指向派生类对象，调用函数返回的内容？\n\nA:是子类重写的函数\n\nQ:如果这个函数父类没有写呢？\n\nA:不能这么写\n\nQ:linux熟悉吗？\n\nA:不太熟\n\nQ:服务器方面？\n\nA:阿巴阿巴......（沉默）\n\nQ：看一下项目,做的确实是比较简单\n\n然后聊了我学校里边的课与我的安排,我又聊了点c++11的东西\n\nQ：讲一下11有哪些新特性\n\nA:移动语义\n\nQ:有什么作用\n\nA:直接转移对象的所有权，避免深拷贝\n\nQ:还有什么新特性\n\nA:左值右值，智能指针，顺带扯了一嘴我ab包的项目就是沿用了智能指针里边引用计数的思路\n\nQ:设计模式\n\nA:写了饿汉式和懒汉式的单例\n\nQ:还有没有别的方法实现\n\nA:用局部静态变量\n\nQ:单例模式有什么缺点\n\nA:全局污染，只适合用来写管理器这样的类\n\n### 反问环节\n\nQ:评价\n\nA:题应该是还没刷，其他和一面一样\n\nQ:如果能进公司谁带\n\nA:一面面试官\n\nQ:上班制度\n\nA:9:00-6:30可以弹性一小时","slug":"HIBIKI/unity客户端面经","published":1,"__permalink":"articles/HIBIKI/Interview/","comments":1,"layout":"post","photos":[],"link":"","_id":"cme5bvpen0001nofwea6je2wz","content":"<p>杭州一家小公司的两次面试，第一次15分钟就通过，第二次拷打了半小时</p>\n<span id=\"more\"></span>\n<h1 id=\"Unity客户端连续两面\"><a href=\"#Unity客户端连续两面\" class=\"headerlink\" title=\"Unity客户端连续两面\"></a>Unity客户端连续两面</h1><h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>Q:自我介绍一下</p>\n<p>A：介绍了下自己学了多久unity,然后说学校离这里很近</p>\n<p>Q:看简历ing….先来聊一下项目好了，你简历上说做了AssetBundle框架是吧，简单介绍一下assetbundle是干什么的？</p>\n<p>A:我的理解是类似zip一样的一种压缩文件，我项目里用的是lz4压缩，这样可以一块一块的加载资源嘛。</p>\n<p>Q：和Resource.load()的区别？</p>\n<p>A:Resource.load()用的是红黑树，然后不加载完的话就没有办法进入游戏，所以用ab更好</p>\n<p>Q:我看你简历上面其他项目……为什么想到做ab这块的内容，因为这块是比较后期的内容了吧</p>\n<p>A:因为我想学学怎么做游戏优化，然后搜了一下发现资源管理这块比较重要，就去学了，然后学ab的时候看unity社区里边的那个xlua热更新就跟着一起学了</p>\n<p>Q:热更新流程?</p>\n<p>A:额……能问的再具体一点吗？</p>\n<p>Q:就比方我要更新一个函数？</p>\n<p>A:在c#这边给可能要更新的函数打上hotfix特性，然后去lua里边写逻辑，运行的时候程序会检查那个delegatebridge变量是否存在，有的话就说明这部分内容被替换了</p>\n<p>Q:那如果我还要更新lua的代码呢</p>\n<p>A:就是lua是用require模块，如果要更新的话我就去package.load里面把旧模块设置为nil，更新新模块，然后把新模块复制给旧模块，把旧模块放回去就好了</p>\n<p>Q:你c#学的怎么样？</p>\n<p>A:额……直接问几个问题看看？我不知道我算是什么水平</p>\n<p>Q:值类型和引用类型</p>\n<p>A:值类型存在栈上面是具体的值，然后引用类型存在堆上面返回的是地址</p>\n<p>Q:装箱拆箱过程</p>\n<p>A:装箱就是在堆上划拉一空间，然后把值放进去返回地址，拆箱就是反过来，然后会多一个检测是否是值类型的操作</p>\n<p>Q:讲一下委托和事件</p>\n<p>A:委托就是函数的容器，我理解的是装的是函数指针，然后事件是在委托基础上再封装了一层，只能+&#x3D;或者-&#x3D;,就比如说我们前面的委托已经装了函数，这个时候如果另一个人用了&#x3D;那前面的就全都失效了，这时候就得用事件</p>\n<p>Q:讲一下反射</p>\n<p>A:反射就是可以动态地获取程序集里面的元数据，比如说构造函数，类型什么的，我不需要知道这个类是怎么写的</p>\n<p>Q:unity里边有什么地方用了反射</p>\n<p>A:（想了一会儿）Mono挂组件</p>\n<p>Q:ugui有用过吗？怎么排序</p>\n<p>A：sort layer</p>\n<p>Q:那个排的是layer</p>\n<p>A:记不太清楚了，这块做的比较少</p>\n<h3 id=\"反问环节\"><a href=\"#反问环节\" class=\"headerlink\" title=\"反问环节\"></a>反问环节</h3><p>Q:评价一下我面试的表现</p>\n<p>Q：基础还可以。</p>\n<p>A:学习方向,去做更复杂的项目还是去看看图形学相关的内容</p>\n<p>Q:学ui的mvc框架，图形学只是加分项</p>\n<p>A:进公司有没有mentor?</p>\n<p>Q：有，不过我们小公司的话是没有大厂那种岗前培训的，就是来了先干活然后不懂公司里直接问。</p>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>Q:手撕算法随机分布的1w个数，找最大的100个</p>\n<p>A:快排</p>\n<p>Q:时间复杂度空间复杂度</p>\n<p>A:O(nlogn)空间是原地的</p>\n<p>Q:那如果是10亿个数呢</p>\n<p>A:没思路</p>\n<p>Q:说明题刷的少了，C++面向对象的三大特性？</p>\n<p>A:封装继承多态</p>\n<p>Q:多态怎么实现的？</p>\n<p>A:用virtual关键字声明，然后每个声明了虚函数的类都会有虚函数表</p>\n<p>Q:继续</p>\n<p>A:运行的时候对象会根据虚指针指向虚函数表的内容返回对应的函数指针，就是函数入口</p>\n<p>Q:如果我用一个基类指针指向派生类对象，调用函数返回的内容？</p>\n<p>A:是子类重写的函数</p>\n<p>Q:如果这个函数父类没有写呢？</p>\n<p>A:不能这么写</p>\n<p>Q:linux熟悉吗？</p>\n<p>A:不太熟</p>\n<p>Q:服务器方面？</p>\n<p>A:阿巴阿巴……（沉默）</p>\n<p>Q：看一下项目,做的确实是比较简单</p>\n<p>然后聊了我学校里边的课与我的安排,我又聊了点c++11的东西</p>\n<p>Q：讲一下11有哪些新特性</p>\n<p>A:移动语义</p>\n<p>Q:有什么作用</p>\n<p>A:直接转移对象的所有权，避免深拷贝</p>\n<p>Q:还有什么新特性</p>\n<p>A:左值右值，智能指针，顺带扯了一嘴我ab包的项目就是沿用了智能指针里边引用计数的思路</p>\n<p>Q:设计模式</p>\n<p>A:写了饿汉式和懒汉式的单例</p>\n<p>Q:还有没有别的方法实现</p>\n<p>A:用局部静态变量</p>\n<p>Q:单例模式有什么缺点</p>\n<p>A:全局污染，只适合用来写管理器这样的类</p>\n<h3 id=\"反问环节-1\"><a href=\"#反问环节-1\" class=\"headerlink\" title=\"反问环节\"></a>反问环节</h3><p>Q:评价</p>\n<p>A:题应该是还没刷，其他和一面一样</p>\n<p>Q:如果能进公司谁带</p>\n<p>A:一面面试官</p>\n<p>Q:上班制度</p>\n<p>A:9:00-6:30可以弹性一小时</p>\n","site":{"data":{}},"excerpt":"<p>杭州一家小公司的两次面试，第一次15分钟就通过，第二次拷打了半小时</p>","more":"<h1 id=\"Unity客户端连续两面\"><a href=\"#Unity客户端连续两面\" class=\"headerlink\" title=\"Unity客户端连续两面\"></a>Unity客户端连续两面</h1><h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><p>Q:自我介绍一下</p>\n<p>A：介绍了下自己学了多久unity,然后说学校离这里很近</p>\n<p>Q:看简历ing….先来聊一下项目好了，你简历上说做了AssetBundle框架是吧，简单介绍一下assetbundle是干什么的？</p>\n<p>A:我的理解是类似zip一样的一种压缩文件，我项目里用的是lz4压缩，这样可以一块一块的加载资源嘛。</p>\n<p>Q：和Resource.load()的区别？</p>\n<p>A:Resource.load()用的是红黑树，然后不加载完的话就没有办法进入游戏，所以用ab更好</p>\n<p>Q:我看你简历上面其他项目……为什么想到做ab这块的内容，因为这块是比较后期的内容了吧</p>\n<p>A:因为我想学学怎么做游戏优化，然后搜了一下发现资源管理这块比较重要，就去学了，然后学ab的时候看unity社区里边的那个xlua热更新就跟着一起学了</p>\n<p>Q:热更新流程?</p>\n<p>A:额……能问的再具体一点吗？</p>\n<p>Q:就比方我要更新一个函数？</p>\n<p>A:在c#这边给可能要更新的函数打上hotfix特性，然后去lua里边写逻辑，运行的时候程序会检查那个delegatebridge变量是否存在，有的话就说明这部分内容被替换了</p>\n<p>Q:那如果我还要更新lua的代码呢</p>\n<p>A:就是lua是用require模块，如果要更新的话我就去package.load里面把旧模块设置为nil，更新新模块，然后把新模块复制给旧模块，把旧模块放回去就好了</p>\n<p>Q:你c#学的怎么样？</p>\n<p>A:额……直接问几个问题看看？我不知道我算是什么水平</p>\n<p>Q:值类型和引用类型</p>\n<p>A:值类型存在栈上面是具体的值，然后引用类型存在堆上面返回的是地址</p>\n<p>Q:装箱拆箱过程</p>\n<p>A:装箱就是在堆上划拉一空间，然后把值放进去返回地址，拆箱就是反过来，然后会多一个检测是否是值类型的操作</p>\n<p>Q:讲一下委托和事件</p>\n<p>A:委托就是函数的容器，我理解的是装的是函数指针，然后事件是在委托基础上再封装了一层，只能+&#x3D;或者-&#x3D;,就比如说我们前面的委托已经装了函数，这个时候如果另一个人用了&#x3D;那前面的就全都失效了，这时候就得用事件</p>\n<p>Q:讲一下反射</p>\n<p>A:反射就是可以动态地获取程序集里面的元数据，比如说构造函数，类型什么的，我不需要知道这个类是怎么写的</p>\n<p>Q:unity里边有什么地方用了反射</p>\n<p>A:（想了一会儿）Mono挂组件</p>\n<p>Q:ugui有用过吗？怎么排序</p>\n<p>A：sort layer</p>\n<p>Q:那个排的是layer</p>\n<p>A:记不太清楚了，这块做的比较少</p>\n<h3 id=\"反问环节\"><a href=\"#反问环节\" class=\"headerlink\" title=\"反问环节\"></a>反问环节</h3><p>Q:评价一下我面试的表现</p>\n<p>Q：基础还可以。</p>\n<p>A:学习方向,去做更复杂的项目还是去看看图形学相关的内容</p>\n<p>Q:学ui的mvc框架，图形学只是加分项</p>\n<p>A:进公司有没有mentor?</p>\n<p>Q：有，不过我们小公司的话是没有大厂那种岗前培训的，就是来了先干活然后不懂公司里直接问。</p>\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><p>Q:手撕算法随机分布的1w个数，找最大的100个</p>\n<p>A:快排</p>\n<p>Q:时间复杂度空间复杂度</p>\n<p>A:O(nlogn)空间是原地的</p>\n<p>Q:那如果是10亿个数呢</p>\n<p>A:没思路</p>\n<p>Q:说明题刷的少了，C++面向对象的三大特性？</p>\n<p>A:封装继承多态</p>\n<p>Q:多态怎么实现的？</p>\n<p>A:用virtual关键字声明，然后每个声明了虚函数的类都会有虚函数表</p>\n<p>Q:继续</p>\n<p>A:运行的时候对象会根据虚指针指向虚函数表的内容返回对应的函数指针，就是函数入口</p>\n<p>Q:如果我用一个基类指针指向派生类对象，调用函数返回的内容？</p>\n<p>A:是子类重写的函数</p>\n<p>Q:如果这个函数父类没有写呢？</p>\n<p>A:不能这么写</p>\n<p>Q:linux熟悉吗？</p>\n<p>A:不太熟</p>\n<p>Q:服务器方面？</p>\n<p>A:阿巴阿巴……（沉默）</p>\n<p>Q：看一下项目,做的确实是比较简单</p>\n<p>然后聊了我学校里边的课与我的安排,我又聊了点c++11的东西</p>\n<p>Q：讲一下11有哪些新特性</p>\n<p>A:移动语义</p>\n<p>Q:有什么作用</p>\n<p>A:直接转移对象的所有权，避免深拷贝</p>\n<p>Q:还有什么新特性</p>\n<p>A:左值右值，智能指针，顺带扯了一嘴我ab包的项目就是沿用了智能指针里边引用计数的思路</p>\n<p>Q:设计模式</p>\n<p>A:写了饿汉式和懒汉式的单例</p>\n<p>Q:还有没有别的方法实现</p>\n<p>A:用局部静态变量</p>\n<p>Q:单例模式有什么缺点</p>\n<p>A:全局污染，只适合用来写管理器这样的类</p>\n<h3 id=\"反问环节-1\"><a href=\"#反问环节-1\" class=\"headerlink\" title=\"反问环节\"></a>反问环节</h3><p>Q:评价</p>\n<p>A:题应该是还没刷，其他和一面一样</p>\n<p>Q:如果能进公司谁带</p>\n<p>A:一面面试官</p>\n<p>Q:上班制度</p>\n<p>A:9:00-6:30可以弹性一小时</p>"},{"title":"如何让2D角色更丝滑的移动(C++/SDL2)开罐即食","date":"2025-08-09T16:00:00.000Z","update":"2025-08-09T16:00:00.000Z","_content":"\n<div align=\"center\">\n\n![](articles/InH/picture/cov.png)\n\n</div>\n\n本文你将会见到四种常见的让2D角色实现平滑移动的方式，用最简明的代码带来最佳的手感体验！\n\n<!-- More --> \n\n## 如何让2D角色更丝滑的移动(C++/SDL2)开罐即食\n\n​\t你是否觉得你的游戏角色移动的时候很死板，按住就走，松开就停，非常的死板没有活力，那就跟我一起从velocity的角度切入来看看有哪些有趣的算法可以优化我们的操作手感，让角色移动变的生动有趣~\n\n#### 1.线性逼近（Lerp/Approach）\n\n​\t即每帧更新计算目标值与当前值的差，将差值按一定比例加回到当前值，使当前值逐步像目标值逼近，并在到达阈值的时候跳转到目标值避免无限逼近而影响状态机等外界对速度值的判断，这使人物速度启动拥有了缓入缓出的效果，避免了手感生硬。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto approach = [&](float current, float target, float delta) -> float {\n    float diff = target - current;\n    if (std::abs(diff) < THRESHOLD) // 阈值\n        return target;\n    return current + diff * 6.0f * delta; // 数值越大越快\n};\n// 用法\nvelocity.x = approach(velocity.x, target_velocity.x, delta);\nvelocity.y = approach(velocity.y, target_velocity.y, delta);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值\n```\n\n#### 2.指数平滑（Exponential Smoothing）\n\n​\t即每帧更新计算目标值与当前值的差，然后计算平滑因子factor，其原理是当低帧率时delta较大，factor也会较大，从而让后序计算更快的接近目标值，当高帧率时delta较小，factor也会较小，从而让后序计算更慢的接近目标值，但是因为一个是低帧一个是高帧本身刷新速度不一样，两项一结合就得到了此不受帧率影响的平滑移动的小算法，经过测试手感较优且稳定。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto exp_smooth = [&](float current, float target) -> float {\n    float diff = target - current;\n    if (std::abs(diff) < THRESHOLD)\n        return target;\n    float factor = 1.0f - std::exp(-smoothing * delta);\n    return current + diff * factor;\n    };\n// 用法\nvelocity.x = exp_smooth(velocity.x, target_velocity.x);\nvelocity.y = exp_smooth(velocity.y, target_velocity.y);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值\n    float smoothing = 6.0f; //控制收敛速度\n```\n\n#### 3.临界阻尼弹簧（SmoothDamp）\n\n​\t即每帧更新计算目标值与当前值的差，计算omega类似弹簧振动的角速度，x为单位时间的衰减量，之后通过多项式模拟exp指数来决定阻尼衰减速度，temp把当前位置偏差和当前速度结合成一个“预测的位移”,更新velRef时 ：(velRef - omega * temp) 是做一个速度衰减，(* exp)应用阻尼系数，逐渐趋近 0。(target + (change + temp) * exp)表示把衰减后的位移加到目标上。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto smooth_damp = [&](float current, float target, float& velRef) -> float {\n    // 阈值判断：如果足够接近，直接返回目标值并清零速度\n    if (std::abs(target - current) < THRESHOLD) {\n        velRef = 0.0f;\n        return target;\n    }\n    float omega = 10.0f / smoothTime;\n    float x = omega * delta;\n    // 多项式近似 e^(-omega * delta)\n    float exp = 1.0f / (1.0f + x + 0.48f * x * x + 0.235f * x * x * x);\n    \n    float change = current - target;\n    float temp = (velRef + omega * change) * delta;\n    velRef = (velRef - omega * temp) * exp;\n    return target + (change + temp) * exp;\n    };\n// 用法\nvelocity.x = smooth_damp(velocity.x, target_velocity.x, velHelperX);\nvelocity.y = smooth_damp(velocity.y, target_velocity.y, velHelperY);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值  \n\n\tfloat smoothTime = 0.2f;  //到达目标的大致时间（秒）\n    float velHelperX = 0.0f;  //X轴内部阻尼速度\n    float velHelperY = 0.0f;  //Y轴内部阻尼速度\n```\n\n#### 4.缓动（Smoothstep ）\n\n​\tt被传给 smoothstep，变成平滑的插值权重，smoothstep会根据 t 输出一个非线性缓动比例，起始和结束时速度较缓，中间较快，避免突变，这个平滑比例再用来线性插值当前值和目标值。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto smoothstep = [&](float t) -> float {\n    return t * t * (3.0f - 2.0f * t);\n    };\n\nauto ease_to = [&](float current, float target, float t) -> float {\n    if (std::abs(current) < THRESHOLD)\n        return target;\n    float s = smoothstep(std::clamp(t, 0.0f, 1.0f));\n    return current + (target - current) * s;\n    };\n\n// 用法\nif (can_move) {\n    velocity.x = ease_to(velocity.x, target_velocity.x, 0.1f);\n    velocity.y = ease_to(velocity.y, target_velocity.y, 0.1f);//t为归一化进度系数\n}\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值 \n```\n\n## 总结：\n\n​\t指数平滑 和 临界阻尼弹簧，这种基于指数衰减的算法，让2D角色获得了更自然、流畅且帧率无关的较好手感也比较符合我对游戏操作的直觉，所以给这两个小算法打满分！！，大家也快去试验一下吧！\n\n","source":"_posts/InH/如何让2D角色更丝滑的移动(C++SDL2)开罐即食.md","raw":"---\ntitle: 如何让2D角色更丝滑的移动(C++/SDL2)开罐即食\ndate: 2025-08-10\nupdate: 2025-08-10\npermalink: articles/InH/SmoothMove/\ncategories: InH\ntags: [学习心得]\n---\n\n<div align=\"center\">\n\n![](articles/InH/picture/cov.png)\n\n</div>\n\n本文你将会见到四种常见的让2D角色实现平滑移动的方式，用最简明的代码带来最佳的手感体验！\n\n<!-- More --> \n\n## 如何让2D角色更丝滑的移动(C++/SDL2)开罐即食\n\n​\t你是否觉得你的游戏角色移动的时候很死板，按住就走，松开就停，非常的死板没有活力，那就跟我一起从velocity的角度切入来看看有哪些有趣的算法可以优化我们的操作手感，让角色移动变的生动有趣~\n\n#### 1.线性逼近（Lerp/Approach）\n\n​\t即每帧更新计算目标值与当前值的差，将差值按一定比例加回到当前值，使当前值逐步像目标值逼近，并在到达阈值的时候跳转到目标值避免无限逼近而影响状态机等外界对速度值的判断，这使人物速度启动拥有了缓入缓出的效果，避免了手感生硬。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto approach = [&](float current, float target, float delta) -> float {\n    float diff = target - current;\n    if (std::abs(diff) < THRESHOLD) // 阈值\n        return target;\n    return current + diff * 6.0f * delta; // 数值越大越快\n};\n// 用法\nvelocity.x = approach(velocity.x, target_velocity.x, delta);\nvelocity.y = approach(velocity.y, target_velocity.y, delta);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值\n```\n\n#### 2.指数平滑（Exponential Smoothing）\n\n​\t即每帧更新计算目标值与当前值的差，然后计算平滑因子factor，其原理是当低帧率时delta较大，factor也会较大，从而让后序计算更快的接近目标值，当高帧率时delta较小，factor也会较小，从而让后序计算更慢的接近目标值，但是因为一个是低帧一个是高帧本身刷新速度不一样，两项一结合就得到了此不受帧率影响的平滑移动的小算法，经过测试手感较优且稳定。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto exp_smooth = [&](float current, float target) -> float {\n    float diff = target - current;\n    if (std::abs(diff) < THRESHOLD)\n        return target;\n    float factor = 1.0f - std::exp(-smoothing * delta);\n    return current + diff * factor;\n    };\n// 用法\nvelocity.x = exp_smooth(velocity.x, target_velocity.x);\nvelocity.y = exp_smooth(velocity.y, target_velocity.y);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值\n    float smoothing = 6.0f; //控制收敛速度\n```\n\n#### 3.临界阻尼弹簧（SmoothDamp）\n\n​\t即每帧更新计算目标值与当前值的差，计算omega类似弹簧振动的角速度，x为单位时间的衰减量，之后通过多项式模拟exp指数来决定阻尼衰减速度，temp把当前位置偏差和当前速度结合成一个“预测的位移”,更新velRef时 ：(velRef - omega * temp) 是做一个速度衰减，(* exp)应用阻尼系数，逐渐趋近 0。(target + (change + temp) * exp)表示把衰减后的位移加到目标上。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto smooth_damp = [&](float current, float target, float& velRef) -> float {\n    // 阈值判断：如果足够接近，直接返回目标值并清零速度\n    if (std::abs(target - current) < THRESHOLD) {\n        velRef = 0.0f;\n        return target;\n    }\n    float omega = 10.0f / smoothTime;\n    float x = omega * delta;\n    // 多项式近似 e^(-omega * delta)\n    float exp = 1.0f / (1.0f + x + 0.48f * x * x + 0.235f * x * x * x);\n    \n    float change = current - target;\n    float temp = (velRef + omega * change) * delta;\n    velRef = (velRef - omega * temp) * exp;\n    return target + (change + temp) * exp;\n    };\n// 用法\nvelocity.x = smooth_damp(velocity.x, target_velocity.x, velHelperX);\nvelocity.y = smooth_damp(velocity.y, target_velocity.y, velHelperY);\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值  \n\n\tfloat smoothTime = 0.2f;  //到达目标的大致时间（秒）\n    float velHelperX = 0.0f;  //X轴内部阻尼速度\n    float velHelperY = 0.0f;  //Y轴内部阻尼速度\n```\n\n#### 4.缓动（Smoothstep ）\n\n​\tt被传给 smoothstep，变成平滑的插值权重，smoothstep会根据 t 输出一个非线性缓动比例，起始和结束时速度较缓，中间较快，避免突变，这个平滑比例再用来线性插值当前值和目标值。\n\n```c++\ntarget_velocity.x = move_dir.x * SPEED_RUN;\ntarget_velocity.y = move_dir.y * SPEED_RUN;\n\nauto smoothstep = [&](float t) -> float {\n    return t * t * (3.0f - 2.0f * t);\n    };\n\nauto ease_to = [&](float current, float target, float t) -> float {\n    if (std::abs(current) < THRESHOLD)\n        return target;\n    float s = smoothstep(std::clamp(t, 0.0f, 1.0f));\n    return current + (target - current) * s;\n    };\n\n// 用法\nif (can_move) {\n    velocity.x = ease_to(velocity.x, target_velocity.x, 0.1f);\n    velocity.y = ease_to(velocity.y, target_velocity.y, 0.1f);//t为归一化进度系数\n}\n```\n\n​\t所需要私有字段\n\n```c++\n    float SPEED_RUN = 200.0f;  //最大奔跑速度\n    SDL_FPoint target_velocity = { 0 }; //目标速度\n    const float THRESHOLD = 15.0f; //速度阈值，指接近这个数值直接跳转目标值 \n```\n\n## 总结：\n\n​\t指数平滑 和 临界阻尼弹簧，这种基于指数衰减的算法，让2D角色获得了更自然、流畅且帧率无关的较好手感也比较符合我对游戏操作的直觉，所以给这两个小算法打满分！！，大家也快去试验一下吧！\n\n","slug":"InH/如何让2D角色更丝滑的移动(C++SDL2)开罐即食","published":1,"updated":"2025-08-10T06:19:49.903Z","__permalink":"articles/InH/SmoothMove/","comments":1,"layout":"post","photos":[],"link":"","_id":"cme5bvpfb0004nofwbkxuenog","content":"<div align=\"center\">\n\n<p><img src=\"/articles/InH/picture/cov.png\"></p>\n</div>\n\n<p>本文你将会见到四种常见的让2D角色实现平滑移动的方式，用最简明的代码带来最佳的手感体验！</p>\n<span id=\"more\"></span> \n\n<h2 id=\"如何让2D角色更丝滑的移动-C-SDL2-开罐即食\"><a href=\"#如何让2D角色更丝滑的移动-C-SDL2-开罐即食\" class=\"headerlink\" title=\"如何让2D角色更丝滑的移动(C++&#x2F;SDL2)开罐即食\"></a>如何让2D角色更丝滑的移动(C++&#x2F;SDL2)开罐即食</h2><p>​\t你是否觉得你的游戏角色移动的时候很死板，按住就走，松开就停，非常的死板没有活力，那就跟我一起从velocity的角度切入来看看有哪些有趣的算法可以优化我们的操作手感，让角色移动变的生动有趣~</p>\n<h4 id=\"1-线性逼近（Lerp-Approach）\"><a href=\"#1-线性逼近（Lerp-Approach）\" class=\"headerlink\" title=\"1.线性逼近（Lerp&#x2F;Approach）\"></a>1.线性逼近（Lerp&#x2F;Approach）</h4><p>​\t即每帧更新计算目标值与当前值的差，将差值按一定比例加回到当前值，使当前值逐步像目标值逼近，并在到达阈值的时候跳转到目标值避免无限逼近而影响状态机等外界对速度值的判断，这使人物速度启动拥有了缓入缓出的效果，避免了手感生硬。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> approach = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span> delta) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = target - current;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(diff) &lt; THRESHOLD) <span class=\"comment\">// 阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + diff * <span class=\"number\">6.0f</span> * delta; <span class=\"comment\">// 数值越大越快</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">approach</span>(velocity.x, target_velocity.x, delta);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">approach</span>(velocity.y, target_velocity.y, delta);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-指数平滑（Exponential-Smoothing）\"><a href=\"#2-指数平滑（Exponential-Smoothing）\" class=\"headerlink\" title=\"2.指数平滑（Exponential Smoothing）\"></a>2.指数平滑（Exponential Smoothing）</h4><p>​\t即每帧更新计算目标值与当前值的差，然后计算平滑因子factor，其原理是当低帧率时delta较大，factor也会较大，从而让后序计算更快的接近目标值，当高帧率时delta较小，factor也会较小，从而让后序计算更慢的接近目标值，但是因为一个是低帧一个是高帧本身刷新速度不一样，两项一结合就得到了此不受帧率影响的平滑移动的小算法，经过测试手感较优且稳定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> exp_smooth = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = target - current;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(diff) &lt; THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"type\">float</span> factor = <span class=\"number\">1.0f</span> - std::<span class=\"built_in\">exp</span>(-smoothing * delta);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + diff * factor;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">exp_smooth</span>(velocity.x, target_velocity.x);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">exp_smooth</span>(velocity.y, target_velocity.y);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值</span></span><br><span class=\"line\"><span class=\"type\">float</span> smoothing = <span class=\"number\">6.0f</span>; <span class=\"comment\">//控制收敛速度</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-临界阻尼弹簧（SmoothDamp）\"><a href=\"#3-临界阻尼弹簧（SmoothDamp）\" class=\"headerlink\" title=\"3.临界阻尼弹簧（SmoothDamp）\"></a>3.临界阻尼弹簧（SmoothDamp）</h4><p>​\t即每帧更新计算目标值与当前值的差，计算omega类似弹簧振动的角速度，x为单位时间的衰减量，之后通过多项式模拟exp指数来决定阻尼衰减速度，temp把当前位置偏差和当前速度结合成一个“预测的位移”,更新velRef时 ：(velRef - omega * temp) 是做一个速度衰减，(* exp)应用阻尼系数，逐渐趋近 0。(target + (change + temp) * exp)表示把衰减后的位移加到目标上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> smooth_damp = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span>&amp; velRef) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 阈值判断：如果足够接近，直接返回目标值并清零速度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(target - current) &lt; THRESHOLD) &#123;</span><br><span class=\"line\">        velRef = <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">float</span> omega = <span class=\"number\">10.0f</span> / smoothTime;</span><br><span class=\"line\">    <span class=\"type\">float</span> x = omega * delta;</span><br><span class=\"line\">    <span class=\"comment\">// 多项式近似 e^(-omega * delta)</span></span><br><span class=\"line\">    <span class=\"type\">float</span> exp = <span class=\"number\">1.0f</span> / (<span class=\"number\">1.0f</span> + x + <span class=\"number\">0.48f</span> * x * x + <span class=\"number\">0.235f</span> * x * x * x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> change = current - target;</span><br><span class=\"line\">    <span class=\"type\">float</span> temp = (velRef + omega * change) * delta;</span><br><span class=\"line\">    velRef = (velRef - omega * temp) * exp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target + (change + temp) * exp;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">smooth_damp</span>(velocity.x, target_velocity.x, velHelperX);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">smooth_damp</span>(velocity.y, target_velocity.y, velHelperY);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">   SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> smoothTime = <span class=\"number\">0.2f</span>;  <span class=\"comment\">//到达目标的大致时间（秒）</span></span><br><span class=\"line\">   <span class=\"type\">float</span> velHelperX = <span class=\"number\">0.0f</span>;  <span class=\"comment\">//X轴内部阻尼速度</span></span><br><span class=\"line\">   <span class=\"type\">float</span> velHelperY = <span class=\"number\">0.0f</span>;  <span class=\"comment\">//Y轴内部阻尼速度</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-缓动（Smoothstep-）\"><a href=\"#4-缓动（Smoothstep-）\" class=\"headerlink\" title=\"4.缓动（Smoothstep ）\"></a>4.缓动（Smoothstep ）</h4><p>​\tt被传给 smoothstep，变成平滑的插值权重，smoothstep会根据 t 输出一个非线性缓动比例，起始和结束时速度较缓，中间较快，避免突变，这个平滑比例再用来线性插值当前值和目标值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> smoothstep = [&amp;](<span class=\"type\">float</span> t) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0f</span> - <span class=\"number\">2.0f</span> * t);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ease_to = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span> t) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(current) &lt; THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"type\">float</span> s = <span class=\"built_in\">smoothstep</span>(std::<span class=\"built_in\">clamp</span>(t, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + (target - current) * s;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (can_move) &#123;</span><br><span class=\"line\">    velocity.x = <span class=\"built_in\">ease_to</span>(velocity.x, target_velocity.x, <span class=\"number\">0.1f</span>);</span><br><span class=\"line\">    velocity.y = <span class=\"built_in\">ease_to</span>(velocity.y, target_velocity.y, <span class=\"number\">0.1f</span>);<span class=\"comment\">//t为归一化进度系数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值 </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>​\t指数平滑 和 临界阻尼弹簧，这种基于指数衰减的算法，让2D角色获得了更自然、流畅且帧率无关的较好手感也比较符合我对游戏操作的直觉，所以给这两个小算法打满分！！，大家也快去试验一下吧！</p>\n","site":{"data":{}},"excerpt":"<div align=\"center\">\n\n<p><img src=\"/articles/InH/picture/cov.png\"></p>\n</div>\n\n<p>本文你将会见到四种常见的让2D角色实现平滑移动的方式，用最简明的代码带来最佳的手感体验！</p>","more":"<h2 id=\"如何让2D角色更丝滑的移动-C-SDL2-开罐即食\"><a href=\"#如何让2D角色更丝滑的移动-C-SDL2-开罐即食\" class=\"headerlink\" title=\"如何让2D角色更丝滑的移动(C++&#x2F;SDL2)开罐即食\"></a>如何让2D角色更丝滑的移动(C++&#x2F;SDL2)开罐即食</h2><p>​\t你是否觉得你的游戏角色移动的时候很死板，按住就走，松开就停，非常的死板没有活力，那就跟我一起从velocity的角度切入来看看有哪些有趣的算法可以优化我们的操作手感，让角色移动变的生动有趣~</p>\n<h4 id=\"1-线性逼近（Lerp-Approach）\"><a href=\"#1-线性逼近（Lerp-Approach）\" class=\"headerlink\" title=\"1.线性逼近（Lerp&#x2F;Approach）\"></a>1.线性逼近（Lerp&#x2F;Approach）</h4><p>​\t即每帧更新计算目标值与当前值的差，将差值按一定比例加回到当前值，使当前值逐步像目标值逼近，并在到达阈值的时候跳转到目标值避免无限逼近而影响状态机等外界对速度值的判断，这使人物速度启动拥有了缓入缓出的效果，避免了手感生硬。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> approach = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span> delta) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = target - current;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(diff) &lt; THRESHOLD) <span class=\"comment\">// 阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + diff * <span class=\"number\">6.0f</span> * delta; <span class=\"comment\">// 数值越大越快</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">approach</span>(velocity.x, target_velocity.x, delta);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">approach</span>(velocity.y, target_velocity.y, delta);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-指数平滑（Exponential-Smoothing）\"><a href=\"#2-指数平滑（Exponential-Smoothing）\" class=\"headerlink\" title=\"2.指数平滑（Exponential Smoothing）\"></a>2.指数平滑（Exponential Smoothing）</h4><p>​\t即每帧更新计算目标值与当前值的差，然后计算平滑因子factor，其原理是当低帧率时delta较大，factor也会较大，从而让后序计算更快的接近目标值，当高帧率时delta较小，factor也会较小，从而让后序计算更慢的接近目标值，但是因为一个是低帧一个是高帧本身刷新速度不一样，两项一结合就得到了此不受帧率影响的平滑移动的小算法，经过测试手感较优且稳定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> exp_smooth = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = target - current;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(diff) &lt; THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"type\">float</span> factor = <span class=\"number\">1.0f</span> - std::<span class=\"built_in\">exp</span>(-smoothing * delta);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + diff * factor;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">exp_smooth</span>(velocity.x, target_velocity.x);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">exp_smooth</span>(velocity.y, target_velocity.y);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值</span></span><br><span class=\"line\"><span class=\"type\">float</span> smoothing = <span class=\"number\">6.0f</span>; <span class=\"comment\">//控制收敛速度</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-临界阻尼弹簧（SmoothDamp）\"><a href=\"#3-临界阻尼弹簧（SmoothDamp）\" class=\"headerlink\" title=\"3.临界阻尼弹簧（SmoothDamp）\"></a>3.临界阻尼弹簧（SmoothDamp）</h4><p>​\t即每帧更新计算目标值与当前值的差，计算omega类似弹簧振动的角速度，x为单位时间的衰减量，之后通过多项式模拟exp指数来决定阻尼衰减速度，temp把当前位置偏差和当前速度结合成一个“预测的位移”,更新velRef时 ：(velRef - omega * temp) 是做一个速度衰减，(* exp)应用阻尼系数，逐渐趋近 0。(target + (change + temp) * exp)表示把衰减后的位移加到目标上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> smooth_damp = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span>&amp; velRef) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 阈值判断：如果足够接近，直接返回目标值并清零速度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(target - current) &lt; THRESHOLD) &#123;</span><br><span class=\"line\">        velRef = <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">float</span> omega = <span class=\"number\">10.0f</span> / smoothTime;</span><br><span class=\"line\">    <span class=\"type\">float</span> x = omega * delta;</span><br><span class=\"line\">    <span class=\"comment\">// 多项式近似 e^(-omega * delta)</span></span><br><span class=\"line\">    <span class=\"type\">float</span> exp = <span class=\"number\">1.0f</span> / (<span class=\"number\">1.0f</span> + x + <span class=\"number\">0.48f</span> * x * x + <span class=\"number\">0.235f</span> * x * x * x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> change = current - target;</span><br><span class=\"line\">    <span class=\"type\">float</span> temp = (velRef + omega * change) * delta;</span><br><span class=\"line\">    velRef = (velRef - omega * temp) * exp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target + (change + temp) * exp;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\">velocity.x = <span class=\"built_in\">smooth_damp</span>(velocity.x, target_velocity.x, velHelperX);</span><br><span class=\"line\">velocity.y = <span class=\"built_in\">smooth_damp</span>(velocity.y, target_velocity.y, velHelperY);</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">   SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> smoothTime = <span class=\"number\">0.2f</span>;  <span class=\"comment\">//到达目标的大致时间（秒）</span></span><br><span class=\"line\">   <span class=\"type\">float</span> velHelperX = <span class=\"number\">0.0f</span>;  <span class=\"comment\">//X轴内部阻尼速度</span></span><br><span class=\"line\">   <span class=\"type\">float</span> velHelperY = <span class=\"number\">0.0f</span>;  <span class=\"comment\">//Y轴内部阻尼速度</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-缓动（Smoothstep-）\"><a href=\"#4-缓动（Smoothstep-）\" class=\"headerlink\" title=\"4.缓动（Smoothstep ）\"></a>4.缓动（Smoothstep ）</h4><p>​\tt被传给 smoothstep，变成平滑的插值权重，smoothstep会根据 t 输出一个非线性缓动比例，起始和结束时速度较缓，中间较快，避免突变，这个平滑比例再用来线性插值当前值和目标值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_velocity.x = move_dir.x * SPEED_RUN;</span><br><span class=\"line\">target_velocity.y = move_dir.y * SPEED_RUN;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> smoothstep = [&amp;](<span class=\"type\">float</span> t) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0f</span> - <span class=\"number\">2.0f</span> * t);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ease_to = [&amp;](<span class=\"type\">float</span> current, <span class=\"type\">float</span> target, <span class=\"type\">float</span> t) -&gt; <span class=\"type\">float</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(current) &lt; THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    <span class=\"type\">float</span> s = <span class=\"built_in\">smoothstep</span>(std::<span class=\"built_in\">clamp</span>(t, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current + (target - current) * s;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (can_move) &#123;</span><br><span class=\"line\">    velocity.x = <span class=\"built_in\">ease_to</span>(velocity.x, target_velocity.x, <span class=\"number\">0.1f</span>);</span><br><span class=\"line\">    velocity.y = <span class=\"built_in\">ease_to</span>(velocity.y, target_velocity.y, <span class=\"number\">0.1f</span>);<span class=\"comment\">//t为归一化进度系数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t所需要私有字段</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> SPEED_RUN = <span class=\"number\">200.0f</span>;  <span class=\"comment\">//最大奔跑速度</span></span><br><span class=\"line\">SDL_FPoint target_velocity = &#123; <span class=\"number\">0</span> &#125;; <span class=\"comment\">//目标速度</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> THRESHOLD = <span class=\"number\">15.0f</span>; <span class=\"comment\">//速度阈值，指接近这个数值直接跳转目标值 </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>​\t指数平滑 和 临界阻尼弹簧，这种基于指数衰减的算法，让2D角色获得了更自然、流畅且帧率无关的较好手感也比较符合我对游戏操作的直觉，所以给这两个小算法打满分！！，大家也快去试验一下吧！</p>"},{"title":"让SDL程序不使用控制台","date":"2025-02-11T16:00:00.000Z","updated":"2025-02-22T16:00:00.000Z","_content":"\n本文以[生化危鸡](https://space.bilibili.com/25864506/lists/4191853?type=season)项目为例，展示如何取消掉程序运行后的出现的控制台（通常以黑框的形式出现）。  \n需要工具：Visual Studio 2022，SDL2。\n\n***注意：本文以SDL2作为演示。关于SDL3，参见文末SDL3部分。***\n<!-- more -->\n\n## 原理\n当项目属性 -> 链接器 -> 系统 -> 子系统的值为控制台(/SUBSYSTEM:CONSOLE)时，操作系统为程序提供控制台。  \n将其修改为窗口(/SUBSYSTEM:WINDOWS)后（建议将预处理器定义的_CONSOLE也换为_WINDOWS），\n操作系统不再提供控制台，但是链接器默认会寻找WinMain函数作为入口（而非main函数）。  \n而SDL2main.lib中有WinMain函数的定义，将SDL2main.lib添加到附加依赖项，正常定义main函数即可，例：int main(int argc, char* argv[])。\n\n## 实践\n右键项目，点击属性  \n![项目属性](articles/YeMinglv/SDL_no_console/project_property.png)  \n将子系统的值切换为窗口(/SUBSYSTEM:WINDOWS)\n\n最好将预处理器定义的_CONSOLE也换为_WINDOWS\n![预处理器](articles/YeMinglv/SDL_no_console/preprocessor.png)\n\n添加依赖项，注意勾选从父级或项目默认设置继承\n![附加依赖项](articles/YeMinglv/SDL_no_console/additional_dependencies.png)\n\n运行程序，没有弹出控制台窗口\n![结果](articles/YeMinglv/SDL_no_console/result.png)\n\n## 常见错误\n![错误1](articles/YeMinglv/SDL_no_console/error_1.png)\n错因：没有添加依赖项SDL2main.lib，找不到入口函数WinMain。\n\n![错误2](articles/YeMinglv/SDL_no_console/error_2.png)\n错因：没有勾选从父级或项目默认设置继承，找不到CommandLineToArgvW函数所在的库shell32.lib。\n\n## SDL3\n在SDL3中，不再设置SDL2main.lib这个静态库，取而代之的是单头文件的库（single-header library）。\n这意味着，我们不需要设置附加依赖项，在某一源文件（通常是main.cpp）中包含<SDL3/SDL_main.h>即可。\n\n## 参考文献\n[SDL2 Windows FAQ](https://wiki.libsdl.org/SDL2/FAQWindows)（英文）  \n[/ENTRY（入口点符号）](https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170)(机翻)  \n[SDL3主函数](https://wiki.libsdl.org/SDL3/README/main-functions)（英文）\n","source":"_posts/YeMinglv/让SDL程序不使用控制台.md","raw":"---\ntitle: 让SDL程序不使用控制台\ndate: 2025-02-12\nupdated: 2025-02-23\npermalink: articles/YeMinglv/SDL_no_console/\ncategories: YeMinglv\ntags: [SDL2, 控制台]\n---\n\n本文以[生化危鸡](https://space.bilibili.com/25864506/lists/4191853?type=season)项目为例，展示如何取消掉程序运行后的出现的控制台（通常以黑框的形式出现）。  \n需要工具：Visual Studio 2022，SDL2。\n\n***注意：本文以SDL2作为演示。关于SDL3，参见文末SDL3部分。***\n<!-- more -->\n\n## 原理\n当项目属性 -> 链接器 -> 系统 -> 子系统的值为控制台(/SUBSYSTEM:CONSOLE)时，操作系统为程序提供控制台。  \n将其修改为窗口(/SUBSYSTEM:WINDOWS)后（建议将预处理器定义的_CONSOLE也换为_WINDOWS），\n操作系统不再提供控制台，但是链接器默认会寻找WinMain函数作为入口（而非main函数）。  \n而SDL2main.lib中有WinMain函数的定义，将SDL2main.lib添加到附加依赖项，正常定义main函数即可，例：int main(int argc, char* argv[])。\n\n## 实践\n右键项目，点击属性  \n![项目属性](articles/YeMinglv/SDL_no_console/project_property.png)  \n将子系统的值切换为窗口(/SUBSYSTEM:WINDOWS)\n\n最好将预处理器定义的_CONSOLE也换为_WINDOWS\n![预处理器](articles/YeMinglv/SDL_no_console/preprocessor.png)\n\n添加依赖项，注意勾选从父级或项目默认设置继承\n![附加依赖项](articles/YeMinglv/SDL_no_console/additional_dependencies.png)\n\n运行程序，没有弹出控制台窗口\n![结果](articles/YeMinglv/SDL_no_console/result.png)\n\n## 常见错误\n![错误1](articles/YeMinglv/SDL_no_console/error_1.png)\n错因：没有添加依赖项SDL2main.lib，找不到入口函数WinMain。\n\n![错误2](articles/YeMinglv/SDL_no_console/error_2.png)\n错因：没有勾选从父级或项目默认设置继承，找不到CommandLineToArgvW函数所在的库shell32.lib。\n\n## SDL3\n在SDL3中，不再设置SDL2main.lib这个静态库，取而代之的是单头文件的库（single-header library）。\n这意味着，我们不需要设置附加依赖项，在某一源文件（通常是main.cpp）中包含<SDL3/SDL_main.h>即可。\n\n## 参考文献\n[SDL2 Windows FAQ](https://wiki.libsdl.org/SDL2/FAQWindows)（英文）  \n[/ENTRY（入口点符号）](https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170)(机翻)  \n[SDL3主函数](https://wiki.libsdl.org/SDL3/README/main-functions)（英文）\n","slug":"YeMinglv/让SDL程序不使用控制台","published":1,"__permalink":"articles/YeMinglv/SDL_no_console/","comments":1,"layout":"post","photos":[],"link":"","_id":"cme5bvpfg0006nofwh7lxdgx6","content":"<p>本文以<a href=\"https://space.bilibili.com/25864506/lists/4191853?type=season\">生化危鸡</a>项目为例，展示如何取消掉程序运行后的出现的控制台（通常以黑框的形式出现）。<br>需要工具：Visual Studio 2022，SDL2。</p>\n<p><em><strong>注意：本文以SDL2作为演示。关于SDL3，参见文末SDL3部分。</strong></em></p>\n<span id=\"more\"></span>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>当项目属性 -&gt; 链接器 -&gt; 系统 -&gt; 子系统的值为控制台(&#x2F;SUBSYSTEM:CONSOLE)时，操作系统为程序提供控制台。<br>将其修改为窗口(&#x2F;SUBSYSTEM:WINDOWS)后（建议将预处理器定义的_CONSOLE也换为_WINDOWS），<br>操作系统不再提供控制台，但是链接器默认会寻找WinMain函数作为入口（而非main函数）。<br>而SDL2main.lib中有WinMain函数的定义，将SDL2main.lib添加到附加依赖项，正常定义main函数即可，例：int main(int argc, char* argv[])。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>右键项目，点击属性<br><img src=\"/articles/YeMinglv/SDL_no_console/project_property.png\" alt=\"项目属性\"><br>将子系统的值切换为窗口(&#x2F;SUBSYSTEM:WINDOWS)</p>\n<p>最好将预处理器定义的_CONSOLE也换为_WINDOWS<br><img src=\"/articles/YeMinglv/SDL_no_console/preprocessor.png\" alt=\"预处理器\"></p>\n<p>添加依赖项，注意勾选从父级或项目默认设置继承<br><img src=\"/articles/YeMinglv/SDL_no_console/additional_dependencies.png\" alt=\"附加依赖项\"></p>\n<p>运行程序，没有弹出控制台窗口<br><img src=\"/articles/YeMinglv/SDL_no_console/result.png\" alt=\"结果\"></p>\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p><img src=\"/articles/YeMinglv/SDL_no_console/error_1.png\" alt=\"错误1\"><br>错因：没有添加依赖项SDL2main.lib，找不到入口函数WinMain。</p>\n<p><img src=\"/articles/YeMinglv/SDL_no_console/error_2.png\" alt=\"错误2\"><br>错因：没有勾选从父级或项目默认设置继承，找不到CommandLineToArgvW函数所在的库shell32.lib。</p>\n<h2 id=\"SDL3\"><a href=\"#SDL3\" class=\"headerlink\" title=\"SDL3\"></a>SDL3</h2><p>在SDL3中，不再设置SDL2main.lib这个静态库，取而代之的是单头文件的库（single-header library）。<br>这意味着，我们不需要设置附加依赖项，在某一源文件（通常是main.cpp）中包含&lt;SDL3&#x2F;SDL_main.h&gt;即可。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://wiki.libsdl.org/SDL2/FAQWindows\">SDL2 Windows FAQ</a>（英文）<br><a href=\"https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170\">&#x2F;ENTRY（入口点符号）</a>(机翻)<br><a href=\"https://wiki.libsdl.org/SDL3/README/main-functions\">SDL3主函数</a>（英文）</p>\n","site":{"data":{}},"excerpt":"<p>本文以<a href=\"https://space.bilibili.com/25864506/lists/4191853?type=season\">生化危鸡</a>项目为例，展示如何取消掉程序运行后的出现的控制台（通常以黑框的形式出现）。<br>需要工具：Visual Studio 2022，SDL2。</p>\n<p><em><strong>注意：本文以SDL2作为演示。关于SDL3，参见文末SDL3部分。</strong></em></p>","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>当项目属性 -&gt; 链接器 -&gt; 系统 -&gt; 子系统的值为控制台(&#x2F;SUBSYSTEM:CONSOLE)时，操作系统为程序提供控制台。<br>将其修改为窗口(&#x2F;SUBSYSTEM:WINDOWS)后（建议将预处理器定义的_CONSOLE也换为_WINDOWS），<br>操作系统不再提供控制台，但是链接器默认会寻找WinMain函数作为入口（而非main函数）。<br>而SDL2main.lib中有WinMain函数的定义，将SDL2main.lib添加到附加依赖项，正常定义main函数即可，例：int main(int argc, char* argv[])。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>右键项目，点击属性<br><img src=\"/articles/YeMinglv/SDL_no_console/project_property.png\" alt=\"项目属性\"><br>将子系统的值切换为窗口(&#x2F;SUBSYSTEM:WINDOWS)</p>\n<p>最好将预处理器定义的_CONSOLE也换为_WINDOWS<br><img src=\"/articles/YeMinglv/SDL_no_console/preprocessor.png\" alt=\"预处理器\"></p>\n<p>添加依赖项，注意勾选从父级或项目默认设置继承<br><img src=\"/articles/YeMinglv/SDL_no_console/additional_dependencies.png\" alt=\"附加依赖项\"></p>\n<p>运行程序，没有弹出控制台窗口<br><img src=\"/articles/YeMinglv/SDL_no_console/result.png\" alt=\"结果\"></p>\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p><img src=\"/articles/YeMinglv/SDL_no_console/error_1.png\" alt=\"错误1\"><br>错因：没有添加依赖项SDL2main.lib，找不到入口函数WinMain。</p>\n<p><img src=\"/articles/YeMinglv/SDL_no_console/error_2.png\" alt=\"错误2\"><br>错因：没有勾选从父级或项目默认设置继承，找不到CommandLineToArgvW函数所在的库shell32.lib。</p>\n<h2 id=\"SDL3\"><a href=\"#SDL3\" class=\"headerlink\" title=\"SDL3\"></a>SDL3</h2><p>在SDL3中，不再设置SDL2main.lib这个静态库，取而代之的是单头文件的库（single-header library）。<br>这意味着，我们不需要设置附加依赖项，在某一源文件（通常是main.cpp）中包含&lt;SDL3&#x2F;SDL_main.h&gt;即可。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://wiki.libsdl.org/SDL2/FAQWindows\">SDL2 Windows FAQ</a>（英文）<br><a href=\"https://learn.microsoft.com/zh-cn/cpp/build/reference/entry-entry-point-symbol?view=msvc-170\">&#x2F;ENTRY（入口点符号）</a>(机翻)<br><a href=\"https://wiki.libsdl.org/SDL3/README/main-functions\">SDL3主函数</a>（英文）</p>"}],"PostAsset":[{"_id":"source/_posts/Demo/HelloWorld/avatar.png","slug":"avatar.png","post":"clx8n2hg20000o8yegq8i0076","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏设计知识分享笔记-依赖性/游戏设计知识分享-依赖性-1.png","slug":"游戏设计知识分享-依赖性-1.png","post":"clx8n2hg80005o8yea1488m2y","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Blue_Joker.webp","slug":"Blue_Joker.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Cavendish.webp","slug":"Cavendish.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Four_Fingers.webp","slug":"Four_Fingers.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Golden_Joker.webp","slug":"Golden_Joker.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Hanging_Chad.webp","slug":"Hanging_Chad.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Joker.webp","slug":"Joker.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Photograph.webp","slug":"Photograph.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/Smiley_Face.webp","slug":"Smiley_Face.webp","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/四指同花顺.png","slug":"四指同花顺.png","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/游戏评测-Balatro小丑牌/计分板.png","slug":"计分板.png","post":"clx8n2hg90009o8ye3b9e4vsg","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/OpenEasing/-1e69599c03b67f3a.jpg","slug":"-1e69599c03b67f3a.jpg","post":"clx8n2hgf000lo8ye6hli2vre","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/OpenEasing/OpenEasing.png","slug":"OpenEasing.png","post":"clx8n2hgf000lo8ye6hli2vre","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/Camera2D/1.gif","slug":"1.gif","post":"clx8n2hga000eo8ye55wzathg","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/Camera2D/2.png","slug":"2.png","post":"clx8n2hga000eo8ye55wzathg","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/1.png","slug":"1.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/10.png","slug":"10.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/11.png","slug":"11.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/12.png","slug":"12.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/123415231.png","slug":"123415231.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/13.png","slug":"13.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/14.png","slug":"14.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/15.png","slug":"15.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/16.png","slug":"16.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/17.png","slug":"17.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/18.png","slug":"18.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/19.png","slug":"19.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/2.png","slug":"2.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/20.png","slug":"20.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/21.png","slug":"21.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/22.png","slug":"22.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/23.png","slug":"23.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/24.png","slug":"24.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/25.png","slug":"25.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/26.png","slug":"26.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/27.png","slug":"27.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/28.png","slug":"28.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/3.png","slug":"3.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/4.png","slug":"4.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/5.png","slug":"5.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/6.png","slug":"6.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/7.png","slug":"7.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/8.png","slug":"8.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/CorrectlyReleased/9.png","slug":"9.png","post":"clx8n2hga000go8ye6epw1ygl","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/Iamme/1.jpg","slug":"1.jpg","post":"clx8n2hgf000ko8ye18hp6oh1","modified":0,"renderable":0},{"_id":"source/_posts/QiNuoTu/Iamme/2.png","slug":"2.png","post":"clx8n2hgf000ko8ye18hp6oh1","modified":0,"renderable":0},{"_id":"source/_posts/shuo-liu16/deploy-Hexo-2024-04-10/1.png","slug":"1.png","post":"clx8n2hgk0018o8yecnntceft","modified":0,"renderable":0},{"_id":"source/_posts/shuo-liu16/deploy-Hexo-2024-04-10/2.png","slug":"2.png","post":"clx8n2hgk0018o8yecnntceft","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/101894421252079.gif","slug":"101894421252079.gif","post":"clx8n2hgh000ro8ye7fyj2j4x","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/231573721246935.png","slug":"231573721246935.png","post":"clx8n2hgh000ro8ye7fyj2j4x","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/294884321256325.gif","slug":"294884321256325.gif","post":"clx8n2hgh000ro8ye7fyj2j4x","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/338824221259770.gif","slug":"338824221259770.gif","post":"clx8n2hgh000ro8ye7fyj2j4x","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/Boids集群算法浅析与实践/403754021267101.png","slug":"403754021267101.png","post":"clx8n2hgh000ro8ye7fyj2j4x","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/125364318267564.png","slug":"125364318267564.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/151655416259069.png","slug":"151655416259069.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/161600919246307.png","slug":"161600919246307.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/202434217267102.png","slug":"202434217267102.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/532531818252080.png","slug":"532531818252080.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/553721218256326.png","slug":"553721218256326.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/59555018265066.png","slug":"59555018265066.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/76072812230849.png","slug":"76072812230849.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/Voidmatrix/程序化游戏地图生成浅析（一）/87331419268747.png","slug":"87331419268747.png","post":"clx8n2hgi000yo8yedk2m781a","modified":0,"renderable":0},{"_id":"source/_posts/suang/Aboutme/suang.png","slug":"suang.png","post":"clx8n2hgl001do8yeeffv3tdm","modified":0,"renderable":0},{"_id":"source/_posts/suang/Aboutme/who_am_I.png","slug":"who_am_I.png","post":"clx8n2hgl001do8yeeffv3tdm","modified":0,"renderable":0},{"_id":"source/_posts/suang/publish_article/fork_img.png","slug":"fork_img.png","post":"clx8n2hgm001jo8ye2klu8hcu","modified":0,"renderable":0},{"_id":"source/_posts/suang/publish_article/image_pos.png","slug":"image_pos.png","post":"clx8n2hgm001jo8ye2klu8hcu","modified":0,"renderable":0},{"_id":"source/_posts/59/GAMES002_01/01.png","slug":"01.png","post":"cm2e5r84m0000lcut9rcohb1k","modified":0,"renderable":0},{"_id":"source/_posts/59/GAMES002_01/02.png","slug":"02.png","post":"cm2e5r84m0000lcut9rcohb1k","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/img_flipped.png","slug":"img_flipped.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/main.png","slug":"main.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/modify.png","slug":"modify.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/raw.png","slug":"raw.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/sun_bullet_ex.png","slug":"sun_bullet_ex.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/timer_spawn_pea_ex.png","slug":"timer_spawn_pea_ex.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/植物明星大乱斗系列视频——勘误/winner_bar.png","slug":"winner_bar.png","post":"cm2e5r8580007lcut8j9rbh60","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_client.png","slug":"hachimi_client.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server.png","slug":"hachimi_server.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/hachimi_server_data.png","slug":"hachimi_server_data.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client.png","slug":"jing_client.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_client_2.png","slug":"jing_client_2.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/jing_server.png","slug":"jing_server.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/FlyingfishFantasticfan/网络编程学习笔记-1/noooooooooooo.png","slug":"noooooooooooo.png","post":"cm2e5r8510004lcutf22j0obd","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/calculate-reflectivity.png","slug":"calculate-reflectivity.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/cook-torrance.png","slug":"cook-torrance.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/ct-brdf.png","slug":"ct-brdf.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/direct-remapping.png","slug":"direct-remapping.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/disney-principled-brdf.png","slug":"disney-principled-brdf.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/fresnel-schlick.png","slug":"fresnel-schlick.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/fresnel.png","slug":"fresnel.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/geometry-shadowing.png","slug":"geometry-shadowing.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/geometry.png","slug":"geometry.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/lambertian.png","slug":"lambertian.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/material-base-reflectivity.png","slug":"material-base-reflectivity.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/metallic.gif","slug":"metallic.gif","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/ndf.png","slug":"ndf.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/roughness.gif","slug":"roughness.gif","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/schlick-ggx.png","slug":"schlick-ggx.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/smith-method.png","slug":"smith-method.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/surface-reaction.png","slug":"surface-reaction.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/textures.png","slug":"textures.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/hszSoft/pbr-theory/trowbridge-reitz-ggx.png","slug":"trowbridge-reitz-ggx.png","post":"cm2e5r85c000flcuth70q0sln","modified":0,"renderable":0},{"_id":"source/_posts/Kritace/植物明星大乱斗血包道具/血包实例图.png","slug":"血包实例图.png","post":"cm2e5r8560006lcuthxc79ecm","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/bloom.png","slug":"bloom.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/cover.png","slug":"cover.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/equation1.svg","slug":"equation1.svg","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/equation2.svg","slug":"equation2.svg","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/equation3.svg","slug":"equation3.svg","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/equation4.svg","slug":"equation4.svg","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/light.png","slug":"light.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/normal_result.png","slug":"normal_result.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/normal_texture.png","slug":"normal_texture.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/Margoo/2d-light/pipeline.png","slug":"pipeline.png","post":"cm2e5r85b000clcut232yd8a2","modified":0,"renderable":0},{"_id":"source/_posts/suang/SDL_utils_2/rabbit_hole.png","slug":"rabbit_hole.png","post":"cm2e5r85i000mlcutdimbgh9a","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/Center.jpeg","slug":"Center.jpeg","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/image-20240622103232679.png","slug":"image-20240622103232679.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/image-20240622105847430.png","slug":"image-20240622105847430.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/image-20240713155355573.png","slug":"image-20240713155355573.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151655.png","slug":"屏幕截图 2024-07-13 151655.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151711.png","slug":"屏幕截图 2024-07-13 151711.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/c++输入与输出/屏幕截图 2024-07-13 151721.png","slug":"屏幕截图 2024-07-13 151721.png","post":"cm2e5r85j000plcut24uwdvz4","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/0902517424204b618b2d27075e4a3d37.png","slug":"0902517424204b618b2d27075e4a3d37.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/202d8acdd52f4509b9dbab88998ab4ef.png","slug":"202d8acdd52f4509b9dbab88998ab4ef.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/4506b0d4a9fb4c68a4f21af2e8f4b7b3.png","slug":"4506b0d4a9fb4c68a4f21af2e8f4b7b3.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/45d8c982a7bc4392b7cdc220c3147b22.png","slug":"45d8c982a7bc4392b7cdc220c3147b22.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/5e1c85cfceb84975951d63017b8bca37.png","slug":"5e1c85cfceb84975951d63017b8bca37.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/68bfe33fe1914bf5bfcc01ad7534cd5e.png","slug":"68bfe33fe1914bf5bfcc01ad7534cd5e.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/74bb10b1d0024d6aaee8e2036be019f1.png","slug":"74bb10b1d0024d6aaee8e2036be019f1.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/8c4bc7708c19453186b2bb91df9ed7e9.png","slug":"8c4bc7708c19453186b2bb91df9ed7e9.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/95b245ce93fc49bb85c42e0fbd166697.png","slug":"95b245ce93fc49bb85c42e0fbd166697.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/99abbcbff8fb414082511a66ece8f60a.png","slug":"99abbcbff8fb414082511a66ece8f60a.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/f3fc7b2dc87b4bc285059b5154d9292c.png","slug":"f3fc7b2dc87b4bc285059b5154d9292c.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/map&&unordered_map/image-20240630204341298.png","slug":"image-20240630204341298.png","post":"cm2e5r85m000wlcut1ncnd3ot","modified":0,"renderable":0},{"_id":"source/_posts/yang/C++继承/p1.png","slug":"p1.png","post":"cm2e5r85l000tlcut8e2ygji7","modified":0,"renderable":0},{"_id":"source/_posts/yang/C++继承/p2.png","slug":"p2.png","post":"cm2e5r85l000tlcut8e2ygji7","modified":0,"renderable":0},{"_id":"source/_posts/yang/C++继承/p3.png","slug":"p3.png","post":"cm2e5r85l000tlcut8e2ygji7","modified":0,"renderable":0},{"_id":"source/_posts/yang/计时器的分析/image-20240614140821676.png","slug":"image-20240614140821676.png","post":"cm2e5r85p0012lcut8mjb94fx","modified":0,"renderable":0},{"_id":"source/_posts/yang/计时器的分析/屏幕截图 2024-06-14 135834.png","slug":"屏幕截图 2024-06-14 135834.png","post":"cm2e5r85p0012lcut8mjb94fx","modified":0,"renderable":0},{"_id":"source/_posts/yang/单例模式/format,png-1719298517759-3.png","slug":"format,png-1719298517759-3.png","post":"cm69406jy000a1out9xjf7mm6","modified":0,"renderable":0},{"_id":"source/_posts/yang/单例模式/format,png-1719298652881-6.png","slug":"format,png-1719298652881-6.png","post":"cm69406jy000a1out9xjf7mm6","modified":0,"renderable":0},{"_id":"source/_posts/yang/单例模式/format,png.png","slug":"format,png.png","post":"cm69406jy000a1out9xjf7mm6","modified":0,"renderable":0},{"_id":"source/_posts/yang/单例模式/image-20240625125041783.png","slug":"image-20240625125041783.png","post":"cm69406jy000a1out9xjf7mm6","modified":0,"renderable":0},{"_id":"source/_posts/yang/单例模式/image-20240625135923590.png","slug":"image-20240625135923590.png","post":"cm69406jy000a1out9xjf7mm6","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/big-Oh.png","slug":"big-Oh.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/cover.png","slug":"cover.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/merge_sort.png","slug":"merge_sort.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/实验统计样例.png","slug":"实验统计样例.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树二次旋转.png","slug":"平衡二叉树二次旋转.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/zExNocs/笔记-ADE-算法数据结构和效率/平衡二叉树旋转.png","slug":"平衡二叉树旋转.png","post":"cm2e5r86h0022lcut6k8tgd9k","modified":0,"renderable":0},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/additional_dependencies.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"additional_dependencies.png","modified":1,"renderable":1},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/error_1.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"error_1.png","modified":1,"renderable":1},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/error_2.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"error_2.png","modified":1,"renderable":1},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/preprocessor.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"preprocessor.png","modified":1,"renderable":1},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/project_property.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"project_property.png","modified":1,"renderable":1},{"_id":"source/_posts/YeMinglv/让SDL程序不使用控制台/result.png","post":"cme5bvpfg0006nofwh7lxdgx6","slug":"result.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clx8n2hg20000o8yegq8i0076","category_id":"clx8n2hg50001o8yea90f4i5q","_id":"clx8n2hg9000bo8ye52lh0se6"},{"post_id":"clx8n2hg70004o8yeabnyg1ae","category_id":"clx8n2hg9000co8ye8gtq5k5g","_id":"clx8n2hgg000no8yeaqbp4fsd"},{"post_id":"clx8n2hg80005o8yea1488m2y","category_id":"clx8n2hg9000co8ye8gtq5k5g","_id":"clx8n2hgh000to8yeffay3msq"},{"post_id":"clx8n2hg90009o8ye3b9e4vsg","category_id":"clx8n2hg9000co8ye8gtq5k5g","_id":"clx8n2hgi000zo8yeb3vs9tms"},{"post_id":"clx8n2hga000eo8ye55wzathg","category_id":"clx8n2hgi0010o8ye3b0i5mnm","_id":"clx8n2hgl001fo8ye44la9x27"},{"post_id":"clx8n2hga000go8ye6epw1ygl","category_id":"clx8n2hgi0010o8ye3b0i5mnm","_id":"clx8n2hgm001lo8ye6gax14qv"},{"post_id":"clx8n2hgf000ko8ye18hp6oh1","category_id":"clx8n2hgi0010o8ye3b0i5mnm","_id":"clx8n2hgn001oo8ye2bntda6e"},{"post_id":"clx8n2hgf000lo8ye6hli2vre","category_id":"clx8n2hgi0010o8ye3b0i5mnm","_id":"clx8n2hgo001so8ye1qi61oq6"},{"post_id":"clx8n2hgg000po8ye0cbe7qrr","category_id":"clx8n2hgi0010o8ye3b0i5mnm","_id":"clx8n2hgo001wo8ye26rv121q"},{"post_id":"clx8n2hgh000ro8ye7fyj2j4x","category_id":"clx8n2hgo001ro8ye7h744ueg","_id":"clx8n2hgo0020o8ye3eqc39zg"},{"post_id":"clx8n2hgh000vo8ye3fv08lzg","category_id":"clx8n2hgo001xo8ye589taadj","_id":"clx8n2hgp0027o8ye8zkhhnaf"},{"post_id":"clx8n2hgi000yo8yedk2m781a","category_id":"clx8n2hgo001ro8ye7h744ueg","_id":"clx8n2hgp0029o8ye5gvj2u8i"},{"post_id":"clx8n2hgk0018o8yecnntceft","category_id":"clx8n2hgq002eo8yefriq959i","_id":"clx8n2hgr002jo8ye0wt238ha"},{"post_id":"clx8n2hgk001bo8yeemd78tcv","category_id":"clx8n2hgq002ho8ye2piw2uzd","_id":"clx8n2hgr002po8ye4z3l5xrm"},{"post_id":"clx8n2hgl001do8yeeffv3tdm","category_id":"clx8n2hgr002lo8ye42fa681j","_id":"clx8n2hgs002to8ye9snn90t9"},{"post_id":"clx8n2hgm001io8ye5rbnald2","category_id":"clx8n2hgr002lo8ye42fa681j","_id":"clx8n2hgs002vo8ye1mqv5rq2"},{"post_id":"clx8n2hgm001jo8ye2klu8hcu","category_id":"clx8n2hgr002lo8ye42fa681j","_id":"clx8n2hgs002yo8ye8aswftwx"},{"post_id":"clx8n2hgw003oo8yeh89ohgvt","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"clx8n2hgy003xo8ye5dkldh2w"},{"post_id":"clx8n2hgx003po8ye39c50tl1","category_id":"clx8n2hgy003uo8ye9xgm7r7i","_id":"clx8n2hgz0040o8ye1rht2vox"},{"post_id":"clx8n2hgx003so8ye8ozq9748","category_id":"clx8n2hgy003uo8ye9xgm7r7i","_id":"clx8n2hgz0042o8ye9hnv4ky4"},{"post_id":"cm2e5r84p0001lcut1uwq9f37","category_id":"clx8n2hg9000co8ye8gtq5k5g","_id":"cm2e5r8590008lcut5ft44d7u"},{"post_id":"cm2e5r8510004lcutf22j0obd","category_id":"clx8n2hg9000co8ye8gtq5k5g","_id":"cm2e5r85b000dlcut0mo0fo7g"},{"post_id":"cm2e5r84m0000lcut9rcohb1k","category_id":"cm2e5r84q0002lcutg0130egi","_id":"cm2e5r85d000glcutehue1p1j"},{"post_id":"cm2e5r85c000flcuth70q0sln","category_id":"clx8n2hgq002ho8ye2piw2uzd","_id":"cm2e5r85i000nlcutbneje5hz"},{"post_id":"cm2e5r8560006lcuthxc79ecm","category_id":"cm2e5r85a000alcutfbqb3rh6","_id":"cm2e5r85j000qlcutat2i5mnu"},{"post_id":"cm2e5r85e000ilcutan833u8n","category_id":"clx8n2hgq002eo8yefriq959i","_id":"cm2e5r85l000ulcutb2yc5rkv"},{"post_id":"cm2e5r85g000klcuta0w64lp2","category_id":"clx8n2hgr002lo8ye42fa681j","_id":"cm2e5r85m000xlcut6lix4gqx"},{"post_id":"cm2e5r8580007lcut8j9rbh60","category_id":"cm2e5r85f000jlcut6nh30y09","_id":"cm2e5r85o000zlcutg717gfim"},{"post_id":"cm2e5r85i000mlcutdimbgh9a","category_id":"clx8n2hgr002lo8ye42fa681j","_id":"cm2e5r85s0013lcut6j470zkm"},{"post_id":"cm2e5r85j000plcut24uwdvz4","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"cm2e5r85s0015lcut9o32eekf"},{"post_id":"cm2e5r85l000tlcut8e2ygji7","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"cm2e5r85w0018lcut8hhebbg9"},{"post_id":"cm2e5r85m000wlcut1ncnd3ot","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"cm2e5r85x001alcutfaee35cp"},{"post_id":"cm2e5r85p0012lcut8mjb94fx","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"cm2e5r85x001dlcut9yeagdws"},{"post_id":"cm2e5r86h0022lcut6k8tgd9k","category_id":"clx8n2hgy003uo8ye9xgm7r7i","_id":"cm2e5r86i0025lcut807ph8a7"},{"post_id":"cm2e5r85b000clcut232yd8a2","category_id":"cm693l0ac0000i0ut4suc9a47","_id":"cm693l0ag0001i0ut7d8ig7bk"},{"post_id":"cm693l0ag0002i0ut59c09cw0","category_id":"cm693l0ah0003i0ut8ayh18lo","_id":"cm693l0ai0007i0ut0bgo1vaw"},{"post_id":"cm693v2qg00001outbppqeask","category_id":"cm693vzej00051out07qwdu7t","_id":"cm693vzek00061outebecd491"},{"post_id":"cm69406jy000a1out9xjf7mm6","category_id":"clx8n2hgx003qo8yehj5hdmre","_id":"cm69406jz000d1outcotz5upy"},{"post_id":"cme5bvpej0000nofw8eiw0me0","category_id":"clx8n2hg80006o8yeewzpfvxv","_id":"cme5bvpff0005nofw2rw39mxy"},{"post_id":"cme5bvpfg0006nofwh7lxdgx6","category_id":"cm2e5r85f000jlcut6nh30y09","_id":"cme5bvpfn000dnofw589r0bs7"},{"post_id":"cme5bvpen0001nofwea6je2wz","category_id":"cme5bvpf90003nofw1cikbanf","_id":"cme5bvpfn000fnofwc96d63xm"},{"post_id":"cme5bvpfb0004nofwbkxuenog","category_id":"cme5bvpfk0009nofwfpbk4b2n","_id":"cme5bvpfo000inofwdwdmgvsd"}],"PostTag":[{"post_id":"clx8n2hg20000o8yegq8i0076","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"clx8n2hg80008o8ye1kh25241"},{"post_id":"clx8n2hgf000lo8ye6hli2vre","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"clx8n2hgh000qo8ye1ko42bec"},{"post_id":"clx8n2hgg000po8ye0cbe7qrr","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"clx8n2hgh000uo8ye9qp2cks7"},{"post_id":"clx8n2hg70004o8yeabnyg1ae","tag_id":"clx8n2hga000do8ye3w4gcr2g","_id":"clx8n2hgi000xo8ye1x2o55ds"},{"post_id":"clx8n2hg70004o8yeabnyg1ae","tag_id":"clx8n2hgb000jo8ye2n9z7mid","_id":"clx8n2hgi0011o8ye3xecgp5i"},{"post_id":"clx8n2hg70004o8yeabnyg1ae","tag_id":"clx8n2hgg000oo8ye5o9r7t0h","_id":"clx8n2hgj0014o8yed3qt8ck7"},{"post_id":"clx8n2hgh000vo8ye3fv08lzg","tag_id":"clx8n2hgg000oo8ye5o9r7t0h","_id":"clx8n2hgk0017o8yedqm08wd2"},{"post_id":"clx8n2hg80005o8yea1488m2y","tag_id":"clx8n2hgh000wo8ye068v8eo0","_id":"clx8n2hgl001co8ye2vtbbwf2"},{"post_id":"clx8n2hg80005o8yea1488m2y","tag_id":"clx8n2hgb000jo8ye2n9z7mid","_id":"clx8n2hgl001go8ye6sunf5sz"},{"post_id":"clx8n2hg90009o8ye3b9e4vsg","tag_id":"clx8n2hgk001ao8ye8y0w1grp","_id":"clx8n2hgn001qo8ye5zi4c9l7"},{"post_id":"clx8n2hg90009o8ye3b9e4vsg","tag_id":"clx8n2hgm001ho8ye2c8uh83h","_id":"clx8n2hgo001to8ye3nwmd8f5"},{"post_id":"clx8n2hg90009o8ye3b9e4vsg","tag_id":"clx8n2hgn001mo8yeg52885ta","_id":"clx8n2hgo001vo8yecn29cou5"},{"post_id":"clx8n2hga000eo8ye55wzathg","tag_id":"clx8n2hgo001uo8yec8jw5fcn","_id":"clx8n2hgp0021o8ye1fcs9t3x"},{"post_id":"clx8n2hga000eo8ye55wzathg","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"clx8n2hgp0023o8ye7zgc9fv0"},{"post_id":"clx8n2hga000go8ye6epw1ygl","tag_id":"clx8n2hgo001uo8yec8jw5fcn","_id":"clx8n2hgp0025o8ye4ymb8yau"},{"post_id":"clx8n2hgf000ko8ye18hp6oh1","tag_id":"clx8n2hgp0024o8ye04wq48e9","_id":"clx8n2hgp002ao8ye76ktf77k"},{"post_id":"clx8n2hgh000ro8ye7fyj2j4x","tag_id":"clx8n2hgp0028o8ye46rd8rdx","_id":"clx8n2hgr002ko8ye0l7c67o0"},{"post_id":"clx8n2hgh000ro8ye7fyj2j4x","tag_id":"clx8n2hgq002co8yeaqk85e5o","_id":"clx8n2hgr002mo8ye3pp86a29"},{"post_id":"clx8n2hgh000ro8ye7fyj2j4x","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"clx8n2hgr002oo8yedekv0m2w"},{"post_id":"clx8n2hgi000yo8yedk2m781a","tag_id":"clx8n2hgp0028o8ye46rd8rdx","_id":"clx8n2hgs002xo8ye13l8b0fq"},{"post_id":"clx8n2hgi000yo8yedk2m781a","tag_id":"clx8n2hgq002co8yeaqk85e5o","_id":"clx8n2hgs002zo8yecuh88k0b"},{"post_id":"clx8n2hgi000yo8yedk2m781a","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"clx8n2hgt0031o8ye3xzvb9w6"},{"post_id":"clx8n2hgi000yo8yedk2m781a","tag_id":"clx8n2hgs002uo8ye4e4qgpq9","_id":"clx8n2hgt0032o8ye43f28wr1"},{"post_id":"clx8n2hgk0018o8yecnntceft","tag_id":"clx8n2hgt0033o8ye2w9s28sa","_id":"clx8n2hgt0037o8yee7427g0y"},{"post_id":"clx8n2hgk001bo8yeemd78tcv","tag_id":"clx8n2hgt0036o8ye3no3fict","_id":"clx8n2hgt0039o8yediihday3"},{"post_id":"clx8n2hgl001do8yeeffv3tdm","tag_id":"clx8n2hgt0038o8ye8rzt893m","_id":"clx8n2hgu003bo8ye385h2cl0"},{"post_id":"clx8n2hgl001do8yeeffv3tdm","tag_id":"clx8n2hgg000oo8ye5o9r7t0h","_id":"clx8n2hgu003co8ye7dmf7a1w"},{"post_id":"clx8n2hgm001io8ye5rbnald2","tag_id":"clx8n2hgt003ao8yehu6o6rov","_id":"clx8n2hgu003go8ye8b7m7taj"},{"post_id":"clx8n2hgm001io8ye5rbnald2","tag_id":"clx8n2hgu003do8ye6tty88sz","_id":"clx8n2hgu003ho8yeapo6dzfg"},{"post_id":"clx8n2hgm001io8ye5rbnald2","tag_id":"clx8n2hgp0028o8ye46rd8rdx","_id":"clx8n2hgv003jo8ye6kl82l79"},{"post_id":"clx8n2hgm001jo8ye2klu8hcu","tag_id":"clx8n2hgt0038o8ye8rzt893m","_id":"clx8n2hgv003lo8yegsrebgvx"},{"post_id":"clx8n2hgm001jo8ye2klu8hcu","tag_id":"clx8n2hgo001uo8yec8jw5fcn","_id":"clx8n2hgv003mo8yedntdbxzs"},{"post_id":"clx8n2hgm001jo8ye2klu8hcu","tag_id":"clx8n2hgv003ko8ye5880dtom","_id":"clx8n2hgv003no8ye3ghqfs0m"},{"post_id":"clx8n2hgx003po8ye39c50tl1","tag_id":"clx8n2hgg000oo8ye5o9r7t0h","_id":"clx8n2hgy003to8ye8tnv6vf3"},{"post_id":"clx8n2hgw003oo8yeh89ohgvt","tag_id":"clx8n2hgx003ro8ye58o9akgw","_id":"clx8n2hgy003wo8yecrv45lx9"},{"post_id":"clx8n2hgx003so8ye8ozq9748","tag_id":"clx8n2hgy003vo8ye5dtb0ksq","_id":"clx8n2hgz0041o8ye8piugw7u"},{"post_id":"clx8n2hgx003so8ye8ozq9748","tag_id":"clx8n2hgy003zo8ye2t71gbff","_id":"clx8n2hgz0043o8yed52a92ov"},{"post_id":"clx8n2hgx003so8ye8ozq9748","tag_id":"clx8n2hga000do8ye3w4gcr2g","_id":"clx8n2hgz0044o8yehf2ihd66"},{"post_id":"cm2e5r84p0001lcut1uwq9f37","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"cm2e5r8540005lcut257l0izc"},{"post_id":"cm2e5r84m0000lcut9rcohb1k","tag_id":"cm2e5r84y0003lcut7ka73gxb","_id":"cm2e5r85a000blcut5a8tbnxw"},{"post_id":"cm2e5r8580007lcut8j9rbh60","tag_id":"clx8n2hgs002wo8ye0ffxgkml","_id":"cm2e5r85c000elcutgw9s25a2"},{"post_id":"cm2e5r8510004lcutf22j0obd","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"cm2e5r85i000olcutdk80a51d"},{"post_id":"cm2e5r8510004lcutf22j0obd","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"cm2e5r85k000rlcut3amng2is"},{"post_id":"cm2e5r8510004lcutf22j0obd","tag_id":"cm2e5r8590009lcutdy619jt9","_id":"cm2e5r85l000vlcut708f3lva"},{"post_id":"cm2e5r8510004lcutf22j0obd","tag_id":"cm2e5r85d000hlcutdt5x3m0q","_id":"cm2e5r85n000ylcut2zk8f3zs"},{"post_id":"cm2e5r85g000klcuta0w64lp2","tag_id":"clx8n2hgt003ao8yehu6o6rov","_id":"cm2e5r85o0011lcut8vus4q2q"},{"post_id":"cm2e5r85g000klcuta0w64lp2","tag_id":"cm2e5r8590009lcutdy619jt9","_id":"cm2e5r85s0014lcut1y5ceudj"},{"post_id":"cm2e5r85i000mlcutdimbgh9a","tag_id":"clx8n2hgt003ao8yehu6o6rov","_id":"cm2e5r85u0017lcutblid8kw7"},{"post_id":"cm2e5r85i000mlcutdimbgh9a","tag_id":"cm2e5r8590009lcutdy619jt9","_id":"cm2e5r85x0019lcutepfd6r6m"},{"post_id":"cm2e5r8560006lcuthxc79ecm","tag_id":"cm2e5r85h000llcuta11a4e51","_id":"cm2e5r85x001blcut9zy3572x"},{"post_id":"cm2e5r85b000clcut232yd8a2","tag_id":"cm2e5r85k000slcut10c24zny","_id":"cm2e5r85x001elcut35wv96f3"},{"post_id":"cm2e5r85b000clcut232yd8a2","tag_id":"cm2e5r85o0010lcutc4zqcmmo","_id":"cm2e5r85x001flcuteal1fl5u"},{"post_id":"cm2e5r85b000clcut232yd8a2","tag_id":"cm2e5r85u0016lcut9bvocf49","_id":"cm2e5r85y001hlcut1s2q4oae"},{"post_id":"cm2e5r85c000flcuth70q0sln","tag_id":"cm2e5r85x001clcutg1m3ad4o","_id":"cm2e5r85y001ilcut2aou5msq"},{"post_id":"cm2e5r85c000flcuth70q0sln","tag_id":"clx8n2hgt0036o8ye3no3fict","_id":"cm2e5r85z001klcuthxtch1x7"},{"post_id":"cm2e5r85e000ilcutan833u8n","tag_id":"cm2e5r85x001glcut7smibce1","_id":"cm2e5r861001mlcut69z0e9gh"},{"post_id":"cm2e5r85e000ilcutan833u8n","tag_id":"cm2e5r85y001jlcut26n2cij7","_id":"cm2e5r862001nlcutfkc18qav"},{"post_id":"cm2e5r85e000ilcutan833u8n","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"cm2e5r869001plcutan4xgi5t"},{"post_id":"cm2e5r85j000plcut24uwdvz4","tag_id":"cm2e5r85z001llcut6kducong","_id":"cm2e5r869001qlcut5tvah19r"},{"post_id":"cm2e5r85l000tlcut8e2ygji7","tag_id":"cm2e5r85z001llcut6kducong","_id":"cm2e5r86a001slcut9ye95amv"},{"post_id":"cm2e5r85m000wlcut1ncnd3ot","tag_id":"cm2e5r869001rlcute1k87psv","_id":"cm2e5r86c001wlcuthxw8dj6v"},{"post_id":"cm2e5r85m000wlcut1ncnd3ot","tag_id":"cm2e5r85x001glcut7smibce1","_id":"cm2e5r86c001xlcut4dns54gb"},{"post_id":"cm2e5r85m000wlcut1ncnd3ot","tag_id":"cm2e5r86b001ulcutc6kq5fab","_id":"cm2e5r86c001ylcut2ust9wd1"},{"post_id":"cm2e5r85p0012lcut8mjb94fx","tag_id":"cm2e5r86b001vlcut30f1drhg","_id":"cm2e5r86c001zlcut6rmqe3in"},{"post_id":"cm2e5r86h0022lcut6k8tgd9k","tag_id":"clx8n2hgq002co8yeaqk85e5o","_id":"cm2e5r86j0029lcutflyudtpn"},{"post_id":"cm2e5r86h0022lcut6k8tgd9k","tag_id":"cm2e5r85x001glcut7smibce1","_id":"cm2e5r86j002alcutcss82zbw"},{"post_id":"cm2e5r86h0022lcut6k8tgd9k","tag_id":"cm2e5r86i0026lcut4rz4f87c","_id":"cm2e5r86j002blcut6z48hrew"},{"post_id":"cm693l0ag0002i0ut59c09cw0","tag_id":"cm2e5r85x001glcut7smibce1","_id":"cm693l0ah0004i0ut50wd0gph"},{"post_id":"cm693l0ag0002i0ut59c09cw0","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"cm693l0ah0005i0ut817ufgxc"},{"post_id":"cm693l0ag0002i0ut59c09cw0","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"cm693l0ai0006i0utgyp11z4r"},{"post_id":"cm693v2qg00001outbppqeask","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"cm693vgp100021out07jm4lo0"},{"post_id":"cm693v2qg00001outbppqeask","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"cm693vgp100041out8h7pbtla"},{"post_id":"cm693v2qg00001outbppqeask","tag_id":"clx8n2hgp0028o8ye46rd8rdx","_id":"cm693y7q300071outauyoe5yf"},{"post_id":"cm69406jy000a1out9xjf7mm6","tag_id":"cm2e5r86g0021lcut3c4wf1m6","_id":"cm69406jz000b1outb0cp2yta"},{"post_id":"cm69406jy000a1out9xjf7mm6","tag_id":"cm2e5r86i0024lcutgp2z2vvv","_id":"cm69406jz000c1out38z8b58u"},{"post_id":"cme5bvpfb0004nofwbkxuenog","tag_id":"cm2e5r85h000llcuta11a4e51","_id":"cme5bvpfj0008nofw4u9d8mv5"},{"post_id":"cme5bvpej0000nofw8eiw0me0","tag_id":"cme5bvpeq0002nofw734b7ggl","_id":"cme5bvpfm000anofw6h0d9bkn"},{"post_id":"cme5bvpej0000nofw8eiw0me0","tag_id":"clx8n2hg60002o8yeerxpcugc","_id":"cme5bvpfn000cnofwflw2csyn"},{"post_id":"cme5bvpej0000nofw8eiw0me0","tag_id":"clx8n2hgq002fo8ye6nxkajhg","_id":"cme5bvpfn000enofwduyuf9il"},{"post_id":"cme5bvpen0001nofwea6je2wz","tag_id":"cme5bvpfh0007nofw2lwi04yv","_id":"cme5bvpfo000hnofwgngcbr80"},{"post_id":"cme5bvpfg0006nofwh7lxdgx6","tag_id":"cme5bvpfm000bnofwbq5zca84","_id":"cme5bvpfp000jnofwglwib5bv"},{"post_id":"cme5bvpfg0006nofwh7lxdgx6","tag_id":"cme5bvpfn000gnofwek0mfoyf","_id":"cme5bvpfp000knofw8uqlb6z3"}],"Tag":[{"name":"游戏开发","_id":"clx8n2hg60002o8yeerxpcugc"},{"name":"测试测试测试测试测试","_id":"clx8n2hg80007o8ye9mvlda35"},{"name":"Git","_id":"clx8n2hga000do8ye3w4gcr2g"},{"name":"学习","_id":"clx8n2hgb000jo8ye2n9z7mid"},{"name":"自我介绍","_id":"clx8n2hgg000oo8ye5o9r7t0h"},{"name":"游戏设计","_id":"clx8n2hgh000wo8ye068v8eo0"},{"name":"游戏评测","_id":"clx8n2hgk001ao8ye8y0w1grp"},{"name":"小丑牌","_id":"clx8n2hgm001ho8ye2c8uh83h"},{"name":"Balatro","_id":"clx8n2hgn001mo8yeg52885ta"},{"name":"测试","_id":"clx8n2hgn001po8yeazys4ju9"},{"name":"教程","_id":"clx8n2hgo001uo8yec8jw5fcn"},{"name":"闲聊","_id":"clx8n2hgp0024o8ye04wq48e9"},{"name":"EasyX","_id":"clx8n2hgp0028o8ye46rd8rdx"},{"name":"算法","_id":"clx8n2hgq002co8yeaqk85e5o"},{"name":"C++","_id":"clx8n2hgq002fo8ye6nxkajhg"},{"name":"PCG","_id":"clx8n2hgs002uo8ye4e4qgpq9"},{"name":"勘误","_id":"clx8n2hgs002wo8ye0ffxgkml"},{"name":"hexo","_id":"clx8n2hgt0033o8ye2w9s28sa"},{"name":"hszSoft","_id":"clx8n2hgt0036o8ye3no3fict"},{"name":"suang","_id":"clx8n2hgt0038o8ye8rzt893m"},{"name":"c++","_id":"clx8n2hgt003ao8yehu6o6rov"},{"name":"编码","_id":"clx8n2hgu003do8ye6tty88sz"},{"name":"发表文章","_id":"clx8n2hgv003ko8ye5880dtom"},{"name":"游戏心得","_id":"clx8n2hgx003ro8ye58o9akgw"},{"name":"VoidGameSpace","_id":"clx8n2hgy003vo8ye5dtb0ksq"},{"name":"Hexo","_id":"clx8n2hgy003zo8ye2t71gbff"},{"name":"Linux","_id":"cm2e5r84y0003lcut7ka73gxb"},{"name":"SDL","_id":"cm2e5r8590009lcutdy619jt9"},{"name":"网络编程","_id":"cm2e5r85d000hlcutdt5x3m0q"},{"name":"学习心得","_id":"cm2e5r85h000llcuta11a4e51"},{"name":"Math","_id":"cm2e5r85k000slcut10c24zny"},{"name":"Computer Graphics","_id":"cm2e5r85o0010lcutc4zqcmmo"},{"name":"Lighting","_id":"cm2e5r85u0016lcut9bvocf49"},{"name":"pbr","_id":"cm2e5r85x001clcutg1m3ad4o"},{"name":"数据结构","_id":"cm2e5r85x001glcut7smibce1"},{"name":"排序算法","_id":"cm2e5r85y001jlcut26n2cij7"},{"name":"c++语法","_id":"cm2e5r85z001llcut6kducong"},{"name":"STL","_id":"cm2e5r869001rlcute1k87psv"},{"name":"塔防课程","_id":"cm2e5r86b001ulcutc6kq5fab"},{"name":"植物明星大乱斗","_id":"cm2e5r86b001vlcut30f1drhg"},{"name":"设计模式","_id":"cm2e5r86g0021lcut3c4wf1m6"},{"name":"塔防课程，c++","_id":"cm2e5r86i0024lcutgp2z2vvv"},{"name":"Big-Oh","_id":"cm2e5r86i0026lcut4rz4f87c"},{"name":"ECS","_id":"cme5bvpeq0002nofw734b7ggl"},{"name":"面经","_id":"cme5bvpfh0007nofw2lwi04yv"},{"name":"SDL2","_id":"cme5bvpfm000bnofwbq5zca84"},{"name":"控制台","_id":"cme5bvpfn000gnofwek0mfoyf"}]}}